{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":1,"renderable":0},{"_id":"source/images/iframe.png","path":"images/iframe.png","modified":1,"renderable":0},{"_id":"source/images/Promise_Object.png","path":"images/Promise_Object.png","modified":1,"renderable":0},{"_id":"source/images/input_phone.jpg","path":"images/input_phone.jpg","modified":1,"renderable":0},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","path":"css/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/bg_body.jpg","path":"fancybox/bg_body.jpg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"source/images/triangles.png","path":"images/triangles.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"bda06d08875dec8e72035fb59940f2addbbdd218","modified":1515378897134},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1514432852498},{"_id":"themes/maupassant/LICENSE","hash":"019dc6a9aba02ae3aaabca45f39aecd6e8e7f1d8","modified":1514432852498},{"_id":"source/favicon.ico","hash":"7346009ac30c875e23c96d5a3fc4410b8e84f4ea","modified":1514432852470},{"_id":"themes/maupassant/README.md","hash":"0b219f558d18afa89cbc14448f3a139dc79644b9","modified":1514432852498},{"_id":"themes/maupassant/.DS_Store","hash":"9457f542cf2c3f2a50b9ecd64858fc6f50b0d0c4","modified":1530859897167},{"_id":"themes/maupassant/_config.yml","hash":"8cb336661255607839634101b15b35cb8475352b","modified":1514432852499},{"_id":"themes/maupassant/package.json","hash":"83573f7e992896e38117ccd370be6d79f4c51757","modified":1534156682582},{"_id":"source/apple-touch-icon.png","hash":"45e33af92dd42b3cf147ac82a6685d6067863775","modified":1514432852469},{"_id":"source/_posts/2016小结.md","hash":"e6fa0a234226e22fc52c6257dbce21011f6dd622","modified":1514432852452},{"_id":"source/_posts/Ajax以及跨域总结.md","hash":"610b1265a0cf1f60b735b7bf73e340e71aeeda15","modified":1514432852452},{"_id":"source/_posts/Angular文档划重点(1).md","hash":"95f9c617cafb340bac083dedb28f244b187c0982","modified":1516700917185},{"_id":"source/_posts/Angular文档划重点(2).md","hash":"3b818fba4437ef98f8346d4e3e9cb5425f393474","modified":1516699148820},{"_id":"source/_posts/Angular文档划重点(3).md","hash":"d12b096ab6c5142a8f39d37d5b60b371caa31e36","modified":1526365990307},{"_id":"source/_posts/CSS后处理PostCSS.md","hash":"04f4c0ec41c63eaf10d231991999c9e8d7f4069d","modified":1514432852452},{"_id":"source/_posts/ES6.md","hash":"6e5531ff8f816d272aa5c6c662d7b0fb151ea649","modified":1514432852453},{"_id":"source/_posts/Flutter正在加载的实现.md","hash":"a05319e9bc288da67210e5495a68d5059453b3f5","modified":1534146571862},{"_id":"source/_posts/H5页面.md","hash":"b26bc43d671588283294429eda128a1e2614259a","modified":1514432852453},{"_id":"source/_posts/Hexo进一步.md","hash":"0672e3e8c5cafaf95218c31c09fb8350646e4a0e","modified":1514432852453},{"_id":"source/_posts/LICENSE","hash":"c2b8384c44d2f6128c2280f3a9f57a400fbd2a70","modified":1514432852454},{"_id":"source/_posts/Promise总结.md","hash":"b57c79ef2aaff4938763809b9c554acecf3013bb","modified":1515060042248},{"_id":"source/_posts/React Docs(1).md","hash":"772d6ff86e35e96eb828468cfd9bf208e6bc368d","modified":1514432852454},{"_id":"source/_posts/React Docs(2).md","hash":"11496c1196bd910317f25fcb2f295643813f419f","modified":1514432852454},{"_id":"source/_posts/React Docs(3).md","hash":"f7abeaae2374f60ba95e88dcc05ccd94d27a1c4c","modified":1514432852455},{"_id":"source/_posts/React Router学习.md","hash":"24283768db4cd30d8474582f11fbf03e5ad378d4","modified":1514432852455},{"_id":"source/_posts/RxJS.md","hash":"eb26a031d4d54d434f3243303ff40dff48e5fde8","modified":1518330533616},{"_id":"source/_posts/RxJS文档划重点.md","hash":"d0be7e7da532d7b8ace0c0d5378339221368ff79","modified":1518330518234},{"_id":"source/_posts/Swagger学习.md","hash":"a17b597fc7d3edc2afd02897412b77e285427bd7","modified":1514432852455},{"_id":"source/_posts/dva中的handleAction.md","hash":"b93c5baafc7b00cac49b199869b2369884994aec","modified":1514432852456},{"_id":"source/_posts/fixed移动端解决.md","hash":"f67592d58de4b80b321a714fbb45e5352d42d3d6","modified":1514432852456},{"_id":"source/_posts/github大小写问题.md","hash":"60139bd1d7086baf499f27e67173b792194b9433","modified":1514432852456},{"_id":"source/_posts/gulp初次实践.md","hash":"f3e462d1b876f31b708bd65b307673a672480c40","modified":1514432852456},{"_id":"source/_posts/redux学习.md","hash":"9b99246025e5507fa01010a4d2cb0932d7d26013","modified":1514432852462},{"_id":"source/_posts/redux应用于React.md","hash":"60ee4f73b9b21652df66bb02f9b7717f1b52f06e","modified":1514432852463},{"_id":"source/_posts/redux简单分享.md","hash":"f321007693076ab4e6e2e9dd13191a123a2900d1","modified":1515060046841},{"_id":"source/_posts/一些关于git.md","hash":"fb17b32bc77335dd380e0882a67f699b296becf5","modified":1514432852463},{"_id":"source/_posts/一次H5页面.md","hash":"5013996406fbb29878b5a8eac7314865c7ee1833","modified":1514432852463},{"_id":"source/_posts/一次麻烦的投票.md","hash":"4f2d7a1ef7e18ade718a9175defe21147261ad5b","modified":1514432852463},{"_id":"source/_posts/为gulp添加更多.md","hash":"6649353ce414e0857757b83e2aa8baf734c6f6c4","modified":1514432852464},{"_id":"source/_posts/了解Flutter.md","hash":"432615a12acf76d6662f5b44f0614733343bf713","modified":1534146556980},{"_id":"source/_posts/今天的面试.md","hash":"d4da8d1d28c12cc05c57a5a403316513a0e51cee","modified":1514432852464},{"_id":"source/_posts/从零搭建React(1).md","hash":"a32ef29c001632185622fd7864b33af8bbbc8bae","modified":1514432852464},{"_id":"source/_posts/从零搭建React(2).md","hash":"8b0b61b32216007ff0338081587c68e710cc8073","modified":1514432852464},{"_id":"source/_posts/从零搭建React(3).md","hash":"ed338b3e44769f902b11df381a4639cd4b757c45","modified":1514432852465},{"_id":"source/_posts/函数节流.md","hash":"8baa0b7c3bb44d0be5199bfe2f692134e3dca830","modified":1514432852465},{"_id":"source/_posts/初次selenium.md","hash":"6b6333140e2af3a892e69424138f7afd8b3f5077","modified":1529562578915},{"_id":"source/_posts/利用Github+Hexo搭建博客过程.md","hash":"9b9642a654bf83cea5367879736f3c4170dbcd9b","modified":1514432852465},{"_id":"source/_posts/前端工具","hash":"49849622d286f6721059c41fe168e01b0238631d","modified":1514432852466},{"_id":"source/_posts/前端技术栈.md","hash":"304cbac21d6a14f3ab269e8479dd1f1e58878898","modified":1514432852466},{"_id":"source/_posts/小程序上线.md","hash":"b136773893f1bd66209437237e0ec77aae487a72","modified":1514432852466},{"_id":"source/_posts/微信分享绝对是个坑.md","hash":"b015d618562805a4fc024745ef519ccb149956fe","modified":1514432852467},{"_id":"source/_posts/微信小程序初体验.md","hash":"be2a5c80685ab0e8742fca3f4c672546e0a121f7","modified":1514432852467},{"_id":"source/_posts/我的首个Hexo博客.md","hash":"ee74aea797835aaa8bfbd787f492b673d920cd9c","modified":1514432852467},{"_id":"source/_posts/批量移动QQ邮箱文件夹.md","hash":"51209d5323df5486ac373c649a5e7725e2822ef0","modified":1515060037762},{"_id":"source/_posts/移动端input光标问题.md","hash":"682c7a95e646ee719873088040bf7bd05e6c61e9","modified":1515059991167},{"_id":"source/_posts/起点H5分析.md","hash":"519cdcd10e3f5d47bf3cc9d758e34994874c28a4","modified":1514432852468},{"_id":"source/_posts/面向对象的javascript(继承).md","hash":"d7490e332970438e8a0c87de1b8b96a81b6d08c9","modified":1514432852468},{"_id":"source/_posts/面向对象的javascript.md","hash":"2504f11a90625e504b4892961018d07280179c71","modified":1514432852468},{"_id":"source/images/iframe.png","hash":"ec3e99f41d9b82e2fc920ce4a0460893ad602b37","modified":1514432852457},{"_id":"source/images/Promise_Object.png","hash":"6df0592eba8d2fdb744cadc93b50f2846d4e427d","modified":1514432852457},{"_id":"source/images/input_phone.jpg","hash":"74f7e8d0823986f6111fd6412523906d7d73a599","modified":1515059149604},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1514432852499},{"_id":"themes/maupassant/languages/en.yml","hash":"e13ab1a2d2f1edbe67b4c035fd4667cb6a31db8e","modified":1514432852499},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1514432852499},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1514432852500},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1514432852501},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"ebacfa5d0c14d603e0d505757adb24c0bbe5dd13","modified":1514432852501},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"56b65995c60e99dcebbf00168447fd225d28e5b2","modified":1514432852501},{"_id":"themes/maupassant/layout/archive.jade","hash":"0050c883b4f202add71c8664d65e6072179e7190","modified":1514432852506},{"_id":"themes/maupassant/layout/base-without-sidebar.jade","hash":"779c736a61a999292156ed23625b46e4ad69af86","modified":1514432852506},{"_id":"themes/maupassant/layout/base.jade","hash":"1104e2c7c1fb5a7c1ef14e5554fa5badadd8806e","modified":1514432852507},{"_id":"themes/maupassant/layout/index.jade","hash":"f842164f6cba007c1dfcd7fe7bba24736bc886a9","modified":1514432852507},{"_id":"themes/maupassant/layout/page.jade","hash":"8d70fd3b93f2c9087a9ea7ec538dcc1d413bea01","modified":1514432852507},{"_id":"themes/maupassant/layout/post.jade","hash":"9cf29fb0daed95935154ce0fa2b154df5a9b11b1","modified":1514432852508},{"_id":"themes/maupassant/layout/single-column.jade","hash":"c35fff4d9b331a41af5bc10f4278ec3d9da503db","modified":1514432852508},{"_id":"themes/maupassant/layout/timeline.jade","hash":"f03d8df63a188543cfe4e85e76194abe081411a1","modified":1514432852508},{"_id":"themes/maupassant/layout/_partial/after_footer.jade","hash":"b5035337d98c66d6f039da261544aad5d524a525","modified":1514432852502},{"_id":"themes/maupassant/layout/_partial/comments.jade","hash":"6c7f63ba04a4d28323ba31e79a4927f3d3fcc56e","modified":1514432852502},{"_id":"themes/maupassant/layout/_partial/footer.jade","hash":"aa020b794e697e8e9612530c97c6295efde469fe","modified":1514432852502},{"_id":"themes/maupassant/layout/_partial/helpers.jade","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1514432852502},{"_id":"themes/maupassant/layout/_partial/mathjax.jade","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1514432852503},{"_id":"themes/maupassant/layout/_partial/mathjax2.jade","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1514432852503},{"_id":"themes/maupassant/layout/_partial/paginator.jade","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1514432852503},{"_id":"themes/maupassant/layout/_partial/post_nav.jade","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1514432852503},{"_id":"themes/maupassant/layout/_partial/tag.jade","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1514432852503},{"_id":"themes/maupassant/layout/_partial/totop.jade","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1514432852504},{"_id":"themes/maupassant/layout/_widget/category.jade","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1514432852504},{"_id":"themes/maupassant/layout/_widget/links.jade","hash":"f57a0c76d243882b2b77330132bdb43bc648948b","modified":1514432852504},{"_id":"themes/maupassant/layout/_widget/music.jade","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1514432852505},{"_id":"themes/maupassant/layout/_widget/recent_comments.jade","hash":"e119c5afa85abc60d139e2da99b0bfcd7a6530f8","modified":1514432852505},{"_id":"themes/maupassant/layout/_widget/recent_posts.jade","hash":"19431336d724d2118e46da43683bce9063176541","modified":1514432852505},{"_id":"themes/maupassant/layout/_widget/search.jade","hash":"193546282908e499813534f86d27ef6e0a1357b3","modified":1514432852505},{"_id":"themes/maupassant/layout/_widget/tag.jade","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1514432852506},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1514432852509},{"_id":"themes/maupassant/source/css/style.scss","hash":"3073d0da13aefd76956e818866cac2cb3c670560","modified":1530860479067},{"_id":"themes/maupassant/source/fancybox/bg_body.jpg","hash":"4fe576826b7f9364e554c7f2e5ac7fb11badfc04","modified":1530859875209},{"_id":"themes/maupassant/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1514432852510},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1514432852510},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1514432852510},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1514432852511},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1514432852511},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1514432852510},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1514432852511},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1514432852511},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1514432852512},{"_id":"themes/maupassant/source/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1514432852512},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1514432852512},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1514432852512},{"_id":"source/images/triangles.png","hash":"9ed6e83d13b3c1ff2ec693440234a7f60b1d65cf","modified":1514432852462}],"Category":[{"name":"杂记","_id":"cjks5i9hk0002vmtizhr4mt1u"},{"name":"JavaScript","_id":"cjks5i9hp0007vmtioj7jmzp9"},{"name":"CSS","_id":"cjks5i9i4000xvmtinx6vn9a4"},{"name":"移动端","_id":"cjks5i9i60016vmtifngpreo2"},{"name":"H5","_id":"cjks5i9i9001cvmtidbkw1ynr"},{"name":"React","_id":"cjks5i9ic001lvmtifpxve2mo"},{"name":"工具","_id":"cjks5i9il0026vmti0c73qk7t"},{"name":"git","_id":"cjks5i9ir002mvmti06np2yaz"}],"Data":[],"Page":[],"Post":[{"title":"2016小结","date":"2017-01-02T16:00:00.000Z","comments":1,"_content":"\n这一年经历还算丰富，总结起来两件大事：毕业、工作。\n\n毕业既令人期待，也让人伤感，大学生活也许不太充实，但是充满欢声。很佩服那些日子可以过得既能一直拼搏奋斗，又能充实有趣的人们。如果大学时光可以重来，我也不知道自己会选择怎样，也许选择那时候更努力的学习，希望可以改变现在的平庸；也许选择那时候更疯狂的玩耍，希望以此来珍惜那段无虑的时光；也许我能够在学习和玩耍之间能找到一个更好的平衡点；也许我根本就没认真地想过“如果重来”这个问题。\n\n工作虽然不怎么顺利，值得庆幸的是目前也算是入了前端的坑。现在想想，那时候的自己确实挺差劲的，学习PHP却连个页面都写不出来，实习半年，才开始对Web有一些理解，大学的课程真的和完全没学过一样。刚刚对Java的Web开发熟悉一些，了解了SSH三大框架就离职转前端也是有点作死的感觉。  \n","source":"_posts/2016小结.md","raw":"---\ntitle: 2016小结\ndate: 2017-01-03\ntags: \ncategories: \n- 杂记\ncomments: true\n---\n\n这一年经历还算丰富，总结起来两件大事：毕业、工作。\n\n毕业既令人期待，也让人伤感，大学生活也许不太充实，但是充满欢声。很佩服那些日子可以过得既能一直拼搏奋斗，又能充实有趣的人们。如果大学时光可以重来，我也不知道自己会选择怎样，也许选择那时候更努力的学习，希望可以改变现在的平庸；也许选择那时候更疯狂的玩耍，希望以此来珍惜那段无虑的时光；也许我能够在学习和玩耍之间能找到一个更好的平衡点；也许我根本就没认真地想过“如果重来”这个问题。\n\n工作虽然不怎么顺利，值得庆幸的是目前也算是入了前端的坑。现在想想，那时候的自己确实挺差劲的，学习PHP却连个页面都写不出来，实习半年，才开始对Web有一些理解，大学的课程真的和完全没学过一样。刚刚对Java的Web开发熟悉一些，了解了SSH三大框架就离职转前端也是有点作死的感觉。  \n","slug":"2016小结","published":1,"updated":"2017-12-28T03:47:32.452Z","layout":"post","photos":[],"link":"","_id":"cjks5i9hd0000vmti7cvflihs","content":"<p>这一年经历还算丰富，总结起来两件大事：毕业、工作。</p>\n<p>毕业既令人期待，也让人伤感，大学生活也许不太充实，但是充满欢声。很佩服那些日子可以过得既能一直拼搏奋斗，又能充实有趣的人们。如果大学时光可以重来，我也不知道自己会选择怎样，也许选择那时候更努力的学习，希望可以改变现在的平庸；也许选择那时候更疯狂的玩耍，希望以此来珍惜那段无虑的时光；也许我能够在学习和玩耍之间能找到一个更好的平衡点；也许我根本就没认真地想过“如果重来”这个问题。</p>\n<p>工作虽然不怎么顺利，值得庆幸的是目前也算是入了前端的坑。现在想想，那时候的自己确实挺差劲的，学习PHP却连个页面都写不出来，实习半年，才开始对Web有一些理解，大学的课程真的和完全没学过一样。刚刚对Java的Web开发熟悉一些，了解了SSH三大框架就离职转前端也是有点作死的感觉。  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>这一年经历还算丰富，总结起来两件大事：毕业、工作。</p>\n<p>毕业既令人期待，也让人伤感，大学生活也许不太充实，但是充满欢声。很佩服那些日子可以过得既能一直拼搏奋斗，又能充实有趣的人们。如果大学时光可以重来，我也不知道自己会选择怎样，也许选择那时候更努力的学习，希望可以改变现在的平庸；也许选择那时候更疯狂的玩耍，希望以此来珍惜那段无虑的时光；也许我能够在学习和玩耍之间能找到一个更好的平衡点；也许我根本就没认真地想过“如果重来”这个问题。</p>\n<p>工作虽然不怎么顺利，值得庆幸的是目前也算是入了前端的坑。现在想想，那时候的自己确实挺差劲的，学习PHP却连个页面都写不出来，实习半年，才开始对Web有一些理解，大学的课程真的和完全没学过一样。刚刚对Java的Web开发熟悉一些，了解了SSH三大框架就离职转前端也是有点作死的感觉。  </p>\n"},{"title":"Ajax以及跨域总结","date":"2017-08-15T16:00:00.000Z","comments":1,"_content":"\nAjax主要用来前端发送get或post请求，可以实现前端向后端的通信。  \nAjax是通过XMLHttpRequest实现的，只需要四步。  \n第一步创建XMLHttpRequest对象。(兼容IE的判断是可以不再考虑)  \n第二步监听readystatechange事件，在请求发送到服务器期间，会触发一系列的readystatechange事件，当readyState===4的时候，表示请求已经完成，响应已经处理完毕。  \n第三步定义请求，可以定义请求方式，请求地址，是否异步。  \n第四部发送请求。\n```JavaScript\nvar xhr = new XMLHttpRequest()\nxhr.onreadystatechange = function () {\n  if (xhr.readyState == 4 && xhr.status == 200) {\n    document.getElementById(\"myDiv\").innerHTML = xhr.responseText\n  }\n}\nxhr.open(\"GET\", \"test1.txt\", true)\nxhr.send()\n```\n\n什么是跨域？\n\n协议、域名、端口有任何一个不相同，则为跨域。  \n协议主要指http和https，域名需要注意包括二级域名，端口一般情况下线上环境都是80端口，不会存在不同情况。  \n限制跨域请求是浏览器的安全行为。\n\n实现跨域的方式\n\n第一种是JSONP\n\n虽然在jQuery中，JSONP的使用方式也是$.ajax，但是JSONP并不属于Ajax，因为其并不是通过XMLHttpRequest来实现的。  \n我们在使用script标签的时候可以引用各种域名下的资源，不会有跨域限制，并且script中引用的代码会在加载结束以后执行。\n```html\n// index.html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>JSONP</title>\n</head>\n<body>\n  <script type=\"text/javascript\">\n    var scriptElem = document.createElement('script')\n    scriptElem.src = './index.js'\n    document.head.append(scriptElem)\n  </script>\n</body>\n</html>\n\n// index.js\ncb = {\n  a: 'a'\n}\n```\n上面的代码会在全局引入变量cb，通过cb就可以拿到对象{a: 'a'}，这就是JSONP的原理了。 \n在实际使用中，一般情况是jsonp请求是在普通请求后面添加参数callback，服务器端根据是否包含callback决定返回json格式还是\"jsonp\"格式。前端在请求前定义与callback值同名的方法，服务器端返回\"jsonp\"为该方法的执行，参数就是我们需要的数据。  \n如果使用jQuery等库都会封装前端这些操作，只需要后端对callback进行判断。  \n\n\n第二种是跨域资源共享（CORS）\n\n这种方法更为简单，不需要前端做任何工作，其实现就是服务器端在返回结果的时候告诉浏览器这个资源是允许被跨域请求的。通过http的头信息中的`Access-Control-Allow-Origin`的值，可以实现资源的跨域，如果值设置为*表示允许所有的地址跨域请求该资源。\n\nps: 在实际开发中还遇到过css引用字体文件跨域问题，解决办法同样是使用CORS。如果字体使用不是特别多，也可以使用字蛛进一步压缩字体文件后，使用base64来解决跨域问题。\n\n\n更多关于跨域问题可以参考阮一峰老师的[这个](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)以及[这个](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n\n\n\n","source":"_posts/Ajax以及跨域总结.md","raw":"---\ntitle: Ajax以及跨域总结\ndate: 2017-8-16\ntags: [JavaScript, 项目经验]\ncategories:\n- JavaScript\ncomments: true\n---\n\nAjax主要用来前端发送get或post请求，可以实现前端向后端的通信。  \nAjax是通过XMLHttpRequest实现的，只需要四步。  \n第一步创建XMLHttpRequest对象。(兼容IE的判断是可以不再考虑)  \n第二步监听readystatechange事件，在请求发送到服务器期间，会触发一系列的readystatechange事件，当readyState===4的时候，表示请求已经完成，响应已经处理完毕。  \n第三步定义请求，可以定义请求方式，请求地址，是否异步。  \n第四部发送请求。\n```JavaScript\nvar xhr = new XMLHttpRequest()\nxhr.onreadystatechange = function () {\n  if (xhr.readyState == 4 && xhr.status == 200) {\n    document.getElementById(\"myDiv\").innerHTML = xhr.responseText\n  }\n}\nxhr.open(\"GET\", \"test1.txt\", true)\nxhr.send()\n```\n\n什么是跨域？\n\n协议、域名、端口有任何一个不相同，则为跨域。  \n协议主要指http和https，域名需要注意包括二级域名，端口一般情况下线上环境都是80端口，不会存在不同情况。  \n限制跨域请求是浏览器的安全行为。\n\n实现跨域的方式\n\n第一种是JSONP\n\n虽然在jQuery中，JSONP的使用方式也是$.ajax，但是JSONP并不属于Ajax，因为其并不是通过XMLHttpRequest来实现的。  \n我们在使用script标签的时候可以引用各种域名下的资源，不会有跨域限制，并且script中引用的代码会在加载结束以后执行。\n```html\n// index.html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>JSONP</title>\n</head>\n<body>\n  <script type=\"text/javascript\">\n    var scriptElem = document.createElement('script')\n    scriptElem.src = './index.js'\n    document.head.append(scriptElem)\n  </script>\n</body>\n</html>\n\n// index.js\ncb = {\n  a: 'a'\n}\n```\n上面的代码会在全局引入变量cb，通过cb就可以拿到对象{a: 'a'}，这就是JSONP的原理了。 \n在实际使用中，一般情况是jsonp请求是在普通请求后面添加参数callback，服务器端根据是否包含callback决定返回json格式还是\"jsonp\"格式。前端在请求前定义与callback值同名的方法，服务器端返回\"jsonp\"为该方法的执行，参数就是我们需要的数据。  \n如果使用jQuery等库都会封装前端这些操作，只需要后端对callback进行判断。  \n\n\n第二种是跨域资源共享（CORS）\n\n这种方法更为简单，不需要前端做任何工作，其实现就是服务器端在返回结果的时候告诉浏览器这个资源是允许被跨域请求的。通过http的头信息中的`Access-Control-Allow-Origin`的值，可以实现资源的跨域，如果值设置为*表示允许所有的地址跨域请求该资源。\n\nps: 在实际开发中还遇到过css引用字体文件跨域问题，解决办法同样是使用CORS。如果字体使用不是特别多，也可以使用字蛛进一步压缩字体文件后，使用base64来解决跨域问题。\n\n\n更多关于跨域问题可以参考阮一峰老师的[这个](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)以及[这个](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n\n\n\n","slug":"Ajax以及跨域总结","published":1,"updated":"2017-12-28T03:47:32.452Z","layout":"post","photos":[],"link":"","_id":"cjks5i9hh0001vmti17xzr3xu","content":"<p>Ajax主要用来前端发送get或post请求，可以实现前端向后端的通信。<br>Ajax是通过XMLHttpRequest实现的，只需要四步。<br>第一步创建XMLHttpRequest对象。(兼容IE的判断是可以不再考虑)<br>第二步监听readystatechange事件，在请求发送到服务器期间，会触发一系列的readystatechange事件，当readyState===4的时候，表示请求已经完成，响应已经处理完毕。<br>第三步定义请求，可以定义请求方式，请求地址，是否异步。<br>第四部发送请求。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest()</span><br><span class=\"line\">xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (xhr.readyState == <span class=\"number\">4</span> &amp;&amp; xhr.status == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myDiv\"</span>).innerHTML = xhr.responseText</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">xhr.open(<span class=\"string\">\"GET\"</span>, <span class=\"string\">\"test1.txt\"</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">xhr.send()</span><br></pre></td></tr></table></figure></p>\n<p>什么是跨域？</p>\n<p>协议、域名、端口有任何一个不相同，则为跨域。<br>协议主要指http和https，域名需要注意包括二级域名，端口一般情况下线上环境都是80端口，不会存在不同情况。<br>限制跨域请求是浏览器的安全行为。</p>\n<p>实现跨域的方式</p>\n<p>第一种是JSONP</p>\n<p>虽然在jQuery中，JSONP的使用方式也是$.ajax，但是JSONP并不属于Ajax，因为其并不是通过XMLHttpRequest来实现的。<br>我们在使用script标签的时候可以引用各种域名下的资源，不会有跨域限制，并且script中引用的代码会在加载结束以后执行。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.html</span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>JSONP<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> scriptElem = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">    scriptElem.src = <span class=\"string\">'./index.js'</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">document</span>.head.append(scriptElem)</span></span><br><span class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">// index.js</span><br><span class=\"line\">cb = &#123;</span><br><span class=\"line\">  a: 'a'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码会在全局引入变量cb，通过cb就可以拿到对象{a: ‘a’}，这就是JSONP的原理了。<br>在实际使用中，一般情况是jsonp请求是在普通请求后面添加参数callback，服务器端根据是否包含callback决定返回json格式还是”jsonp”格式。前端在请求前定义与callback值同名的方法，服务器端返回”jsonp”为该方法的执行，参数就是我们需要的数据。<br>如果使用jQuery等库都会封装前端这些操作，只需要后端对callback进行判断。  </p>\n<p>第二种是跨域资源共享（CORS）</p>\n<p>这种方法更为简单，不需要前端做任何工作，其实现就是服务器端在返回结果的时候告诉浏览器这个资源是允许被跨域请求的。通过http的头信息中的<code>Access-Control-Allow-Origin</code>的值，可以实现资源的跨域，如果值设置为*表示允许所有的地址跨域请求该资源。</p>\n<p>ps: 在实际开发中还遇到过css引用字体文件跨域问题，解决办法同样是使用CORS。如果字体使用不是特别多，也可以使用字蛛进一步压缩字体文件后，使用base64来解决跨域问题。</p>\n<p>更多关于跨域问题可以参考阮一峰老师的<a href=\"http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html\" target=\"_blank\" rel=\"noopener\">这个</a>以及<a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">这个</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Ajax主要用来前端发送get或post请求，可以实现前端向后端的通信。<br>Ajax是通过XMLHttpRequest实现的，只需要四步。<br>第一步创建XMLHttpRequest对象。(兼容IE的判断是可以不再考虑)<br>第二步监听readystatechange事件，在请求发送到服务器期间，会触发一系列的readystatechange事件，当readyState===4的时候，表示请求已经完成，响应已经处理完毕。<br>第三步定义请求，可以定义请求方式，请求地址，是否异步。<br>第四部发送请求。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest()</span><br><span class=\"line\">xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (xhr.readyState == <span class=\"number\">4</span> &amp;&amp; xhr.status == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myDiv\"</span>).innerHTML = xhr.responseText</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">xhr.open(<span class=\"string\">\"GET\"</span>, <span class=\"string\">\"test1.txt\"</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">xhr.send()</span><br></pre></td></tr></table></figure></p>\n<p>什么是跨域？</p>\n<p>协议、域名、端口有任何一个不相同，则为跨域。<br>协议主要指http和https，域名需要注意包括二级域名，端口一般情况下线上环境都是80端口，不会存在不同情况。<br>限制跨域请求是浏览器的安全行为。</p>\n<p>实现跨域的方式</p>\n<p>第一种是JSONP</p>\n<p>虽然在jQuery中，JSONP的使用方式也是$.ajax，但是JSONP并不属于Ajax，因为其并不是通过XMLHttpRequest来实现的。<br>我们在使用script标签的时候可以引用各种域名下的资源，不会有跨域限制，并且script中引用的代码会在加载结束以后执行。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.html</span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>JSONP<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> scriptElem = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">    scriptElem.src = <span class=\"string\">'./index.js'</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">document</span>.head.append(scriptElem)</span></span><br><span class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">// index.js</span><br><span class=\"line\">cb = &#123;</span><br><span class=\"line\">  a: 'a'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码会在全局引入变量cb，通过cb就可以拿到对象{a: ‘a’}，这就是JSONP的原理了。<br>在实际使用中，一般情况是jsonp请求是在普通请求后面添加参数callback，服务器端根据是否包含callback决定返回json格式还是”jsonp”格式。前端在请求前定义与callback值同名的方法，服务器端返回”jsonp”为该方法的执行，参数就是我们需要的数据。<br>如果使用jQuery等库都会封装前端这些操作，只需要后端对callback进行判断。  </p>\n<p>第二种是跨域资源共享（CORS）</p>\n<p>这种方法更为简单，不需要前端做任何工作，其实现就是服务器端在返回结果的时候告诉浏览器这个资源是允许被跨域请求的。通过http的头信息中的<code>Access-Control-Allow-Origin</code>的值，可以实现资源的跨域，如果值设置为*表示允许所有的地址跨域请求该资源。</p>\n<p>ps: 在实际开发中还遇到过css引用字体文件跨域问题，解决办法同样是使用CORS。如果字体使用不是特别多，也可以使用字蛛进一步压缩字体文件后，使用base64来解决跨域问题。</p>\n<p>更多关于跨域问题可以参考阮一峰老师的<a href=\"http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html\" target=\"_blank\" rel=\"noopener\">这个</a>以及<a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">这个</a></p>\n"},{"title":"Angular文档划重点(1)","date":"2018-01-22T16:00:00.000Z","comments":1,"_content":"\n### 模板与数据绑定\n\n#### 模板语法\n\n* 模板中的HTML： 禁用了script、HTML、body、base等标签\n\n* 插值表达式：{% raw %}{{}}{% endraw %}，括号中的素材是一个模板表达式，对其中内容求值，并转换为string\n\n* 模板表达式：可能引起副作用的表达式被禁用：赋值（=, +=, -=, ...），new 运算符，使用;或,的链式表达式，自增或自减操作符 (++和--)。并且不支持位运算|和&。\n\n* 表达式上下文：包括所在组件的对象，模板输入变量（比如：ngFor中的let item）和模板引用变量（#input）。不能引用全局变量（window.*,document.*等）。\n\n* 模板语句：主要用于触发事件（(event)=\"statement\"），和模板表达式不同的是支持基本赋值（=）和表达式链（;和,）。\n\n* 语句上下文：包括所在组件的对象，模板输入变量（比如：ngFor中的let item）和模板引用变量（#input）。不能引用全局变量（window.*,document.*等）。\n\n* 属性绑定：[]=\n\n* attribute绑定：当元素没有属性可绑定的时候，需要使用[attr.*]=\"\"进行绑定\n\n* CSS类绑定：<div class=\"bad curly\" [class]=\"badCurly\"></div>会计算badCurly的值，赋值并覆盖之前的class。可以使用[class.*]=\"\"来添加新的class\n\n* 样式绑定：[style.color]=\"\"\n\n* 绑定事件：(click)=\"func()\"和on-click=\"func()\" $event原生event对象\n\n* 使用EventEmitter实现自定义事件：new EventEmitter().emit(参数)\n\n* 双向数据绑定：[()]双向数据绑定实际上是属性绑定和事件绑定的语法糖\n\n* 内置结构指令：NgIf,NgFor,NgSwitch等等\n\n* 模板引用变量：(#var) 作用域为整个模板\n\n* 输入和输出：@Input和@Output，或者通过@Component中的元数据inputs:[]和outputs:[]\n\n* 模板表达式操作符：管道(|)，安全导航操作符(?.)，非空断言(!)。非空断言和安全导航操作符不同的是，非空断言只是“断言”来避免TypeScript的检查，但是允许返回null和undefined\n\n#### 生命周期钩子\n\n|钩子|目的和时机|\n|---|--------|\n|ngOnChanges()|当Angular（重新）设置数据绑定输入属性时响应。 该方法接受当前和上一属性值的SimpleChanges对象当被绑定的输入属性的值发生变化时调用，首次调用一定会发生在ngOnInit()之前。|\n|ngOnInit()|在Angular第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件。在第一轮ngOnChanges()完成之后调用，只调用一次。|\n|ngDoCheck()|检测，并在发生Angular无法或不愿意自己检测的变化时作出反应。在每个Angular变更检测周期中调用，ngOnChanges()和ngOnInit()之后。|\n|ngAfterContentInit()|当把内容投影进组件之后调用。第一次ngDoCheck()之后调用，只调用一次。只适用于组件。|\n|ngAfterContentChecked()|每次完成被投影组件内容的变更检测之后调用。ngAfterContentInit()和每次ngDoCheck()之后调用只适合组件。|\n|ngAfterViewInit()|初始化完组件视图及其子视图之后调用。第一次ngAfterContentChecked()之后调用，只调用一次。只适合组件。|\n|ngAfterViewChecked()|每次做完组件视图和子视图的变更检测之后调用。ngAfterViewInit()和每次ngAfterContentChecked()之后调用。只适合组件。|\n|ngOnDestroy()|当Angular每次销毁指令/组件之前调用并清扫。 在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。在Angular销毁指令/组件之前调用。|\n\n#### 组件交互\n\n* 通过输入型绑定把数据从父组件传到子组件：@Input\n\n* 通过setter截听输入属性值的变化\n\n* 通过ngOnChanges()来截听输入属性值的变化\n\n* 父组件监听子组件的事件： 通过@Output一个EventEmitter对象\n\n* 父子组件通过本地变量交互： #var\n\n* 父组件调用@ViewChild()： AfterViewInit钩子中\n\n* 通过服务通讯\n\n#### 组件样式\n\n* 组件的样式有三种封装模式：原生(Native)、仿真(Emulated)、无(none)。原生会通过Shadow DOM保证样式不影响组件外其他元素，仿真会通过改名等特殊处理实现不影响外面其他元素。\n\n#### 动态组件\n\n* 通过componentFactoryResolver下的方法(如：resolveComponentFactory)解析出一个ComponentFactory对象。\n\n* 通过ViewContainerRef可以获取对容器视图的访问权(包括clear、createComponent等方法)。\n\n* 将ComponentFactory传递给ViewContainerRef的createComponent即可将组件动态添加到ViewContainerRef中。\n\n#### 属性型指令\n\n* Directive提供@Directive装饰器功能。\n\n* 通过ElementRef可以访问DOM元素。\n\n* 通过@Input传入参数\n\n* 通过@HostListener添加响应事件\n\n#### 结构型指令\n\n* *号是一个微语法，解开会变成<ng-template>标签。\n\n* <ng-template>会被转换成注释，不会显示出来。\n\n* <ng-container>不会被渲染的容器。\n\n* 通过TemplateRef取得<ng-template>的内容，通过VeiwContainerRef来访问视图容器\n\n#### 管道\n\n* 自定义管道需要实现PipeTransform接口的transform方法，接受一个输入值和参数\n\n* 纯管道：只有发生纯变更（原始类型变更，或引用地址的变更）的时候才会执行纯管道。\n\n* 非纯管道：元数据中添加pure: false。\n\n* 非纯异步管道：接受一个Promise或Observable作为输入，最终返回给出的值。\n\n#### 动画\n\n* 元数据中定义animations\n\n* 定义不同状态下的样式，定义状态砖厂动画效果。\n\n* *为任意状态，void状态为未进场或移除状态。\n","source":"_posts/Angular文档划重点(1).md","raw":"---\ntitle: Angular文档划重点(1)\ndate: 2018-01-23\ntags: [Angular]\ncategories:\n- JavaScript\ncomments: true\n---\n\n### 模板与数据绑定\n\n#### 模板语法\n\n* 模板中的HTML： 禁用了script、HTML、body、base等标签\n\n* 插值表达式：{% raw %}{{}}{% endraw %}，括号中的素材是一个模板表达式，对其中内容求值，并转换为string\n\n* 模板表达式：可能引起副作用的表达式被禁用：赋值（=, +=, -=, ...），new 运算符，使用;或,的链式表达式，自增或自减操作符 (++和--)。并且不支持位运算|和&。\n\n* 表达式上下文：包括所在组件的对象，模板输入变量（比如：ngFor中的let item）和模板引用变量（#input）。不能引用全局变量（window.*,document.*等）。\n\n* 模板语句：主要用于触发事件（(event)=\"statement\"），和模板表达式不同的是支持基本赋值（=）和表达式链（;和,）。\n\n* 语句上下文：包括所在组件的对象，模板输入变量（比如：ngFor中的let item）和模板引用变量（#input）。不能引用全局变量（window.*,document.*等）。\n\n* 属性绑定：[]=\n\n* attribute绑定：当元素没有属性可绑定的时候，需要使用[attr.*]=\"\"进行绑定\n\n* CSS类绑定：<div class=\"bad curly\" [class]=\"badCurly\"></div>会计算badCurly的值，赋值并覆盖之前的class。可以使用[class.*]=\"\"来添加新的class\n\n* 样式绑定：[style.color]=\"\"\n\n* 绑定事件：(click)=\"func()\"和on-click=\"func()\" $event原生event对象\n\n* 使用EventEmitter实现自定义事件：new EventEmitter().emit(参数)\n\n* 双向数据绑定：[()]双向数据绑定实际上是属性绑定和事件绑定的语法糖\n\n* 内置结构指令：NgIf,NgFor,NgSwitch等等\n\n* 模板引用变量：(#var) 作用域为整个模板\n\n* 输入和输出：@Input和@Output，或者通过@Component中的元数据inputs:[]和outputs:[]\n\n* 模板表达式操作符：管道(|)，安全导航操作符(?.)，非空断言(!)。非空断言和安全导航操作符不同的是，非空断言只是“断言”来避免TypeScript的检查，但是允许返回null和undefined\n\n#### 生命周期钩子\n\n|钩子|目的和时机|\n|---|--------|\n|ngOnChanges()|当Angular（重新）设置数据绑定输入属性时响应。 该方法接受当前和上一属性值的SimpleChanges对象当被绑定的输入属性的值发生变化时调用，首次调用一定会发生在ngOnInit()之前。|\n|ngOnInit()|在Angular第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件。在第一轮ngOnChanges()完成之后调用，只调用一次。|\n|ngDoCheck()|检测，并在发生Angular无法或不愿意自己检测的变化时作出反应。在每个Angular变更检测周期中调用，ngOnChanges()和ngOnInit()之后。|\n|ngAfterContentInit()|当把内容投影进组件之后调用。第一次ngDoCheck()之后调用，只调用一次。只适用于组件。|\n|ngAfterContentChecked()|每次完成被投影组件内容的变更检测之后调用。ngAfterContentInit()和每次ngDoCheck()之后调用只适合组件。|\n|ngAfterViewInit()|初始化完组件视图及其子视图之后调用。第一次ngAfterContentChecked()之后调用，只调用一次。只适合组件。|\n|ngAfterViewChecked()|每次做完组件视图和子视图的变更检测之后调用。ngAfterViewInit()和每次ngAfterContentChecked()之后调用。只适合组件。|\n|ngOnDestroy()|当Angular每次销毁指令/组件之前调用并清扫。 在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。在Angular销毁指令/组件之前调用。|\n\n#### 组件交互\n\n* 通过输入型绑定把数据从父组件传到子组件：@Input\n\n* 通过setter截听输入属性值的变化\n\n* 通过ngOnChanges()来截听输入属性值的变化\n\n* 父组件监听子组件的事件： 通过@Output一个EventEmitter对象\n\n* 父子组件通过本地变量交互： #var\n\n* 父组件调用@ViewChild()： AfterViewInit钩子中\n\n* 通过服务通讯\n\n#### 组件样式\n\n* 组件的样式有三种封装模式：原生(Native)、仿真(Emulated)、无(none)。原生会通过Shadow DOM保证样式不影响组件外其他元素，仿真会通过改名等特殊处理实现不影响外面其他元素。\n\n#### 动态组件\n\n* 通过componentFactoryResolver下的方法(如：resolveComponentFactory)解析出一个ComponentFactory对象。\n\n* 通过ViewContainerRef可以获取对容器视图的访问权(包括clear、createComponent等方法)。\n\n* 将ComponentFactory传递给ViewContainerRef的createComponent即可将组件动态添加到ViewContainerRef中。\n\n#### 属性型指令\n\n* Directive提供@Directive装饰器功能。\n\n* 通过ElementRef可以访问DOM元素。\n\n* 通过@Input传入参数\n\n* 通过@HostListener添加响应事件\n\n#### 结构型指令\n\n* *号是一个微语法，解开会变成<ng-template>标签。\n\n* <ng-template>会被转换成注释，不会显示出来。\n\n* <ng-container>不会被渲染的容器。\n\n* 通过TemplateRef取得<ng-template>的内容，通过VeiwContainerRef来访问视图容器\n\n#### 管道\n\n* 自定义管道需要实现PipeTransform接口的transform方法，接受一个输入值和参数\n\n* 纯管道：只有发生纯变更（原始类型变更，或引用地址的变更）的时候才会执行纯管道。\n\n* 非纯管道：元数据中添加pure: false。\n\n* 非纯异步管道：接受一个Promise或Observable作为输入，最终返回给出的值。\n\n#### 动画\n\n* 元数据中定义animations\n\n* 定义不同状态下的样式，定义状态砖厂动画效果。\n\n* *为任意状态，void状态为未进场或移除状态。\n","slug":"Angular文档划重点(1)","published":1,"updated":"2018-01-23T09:48:37.185Z","layout":"post","photos":[],"link":"","_id":"cjks5i9hl0003vmtid1h25a54","content":"<h3 id=\"模板与数据绑定\"><a href=\"#模板与数据绑定\" class=\"headerlink\" title=\"模板与数据绑定\"></a>模板与数据绑定</h3><h4 id=\"模板语法\"><a href=\"#模板语法\" class=\"headerlink\" title=\"模板语法\"></a>模板语法</h4><ul>\n<li><p>模板中的HTML： 禁用了script、HTML、body、base等标签</p>\n</li>\n<li><p>插值表达式：{{}}，括号中的素材是一个模板表达式，对其中内容求值，并转换为string</p>\n</li>\n<li><p>模板表达式：可能引起副作用的表达式被禁用：赋值（=, +=, -=, …），new 运算符，使用;或,的链式表达式，自增或自减操作符 (++和–)。并且不支持位运算|和&amp;。</p>\n</li>\n<li><p>表达式上下文：包括所在组件的对象，模板输入变量（比如：ngFor中的let item）和模板引用变量（#input）。不能引用全局变量（window.<em>,document.</em>等）。</p>\n</li>\n<li><p>模板语句：主要用于触发事件（(event)=”statement”），和模板表达式不同的是支持基本赋值（=）和表达式链（;和,）。</p>\n</li>\n<li><p>语句上下文：包括所在组件的对象，模板输入变量（比如：ngFor中的let item）和模板引用变量（#input）。不能引用全局变量（window.<em>,document.</em>等）。</p>\n</li>\n<li><p>属性绑定：[]=</p>\n</li>\n<li><p>attribute绑定：当元素没有属性可绑定的时候，需要使用[attr.*]=””进行绑定</p>\n</li>\n<li><p>CSS类绑定：<div class=\"bad curly\" [class]=\"badCurly\"></div>会计算badCurly的值，赋值并覆盖之前的class。可以使用[class.*]=””来添加新的class</p>\n</li>\n<li><p>样式绑定：[style.color]=””</p>\n</li>\n<li><p>绑定事件：(click)=”func()”和on-click=”func()” $event原生event对象</p>\n</li>\n<li><p>使用EventEmitter实现自定义事件：new EventEmitter().emit(参数)</p>\n</li>\n<li><p>双向数据绑定：[()]双向数据绑定实际上是属性绑定和事件绑定的语法糖</p>\n</li>\n<li><p>内置结构指令：NgIf,NgFor,NgSwitch等等</p>\n</li>\n<li><p>模板引用变量：(#var) 作用域为整个模板</p>\n</li>\n<li><p>输入和输出：@Input和@Output，或者通过@Component中的元数据inputs:[]和outputs:[]</p>\n</li>\n<li><p>模板表达式操作符：管道(|)，安全导航操作符(?.)，非空断言(!)。非空断言和安全导航操作符不同的是，非空断言只是“断言”来避免TypeScript的检查，但是允许返回null和undefined</p>\n</li>\n</ul>\n<h4 id=\"生命周期钩子\"><a href=\"#生命周期钩子\" class=\"headerlink\" title=\"生命周期钩子\"></a>生命周期钩子</h4><table>\n<thead>\n<tr>\n<th>钩子</th>\n<th>目的和时机</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ngOnChanges()</td>\n<td>当Angular（重新）设置数据绑定输入属性时响应。 该方法接受当前和上一属性值的SimpleChanges对象当被绑定的输入属性的值发生变化时调用，首次调用一定会发生在ngOnInit()之前。</td>\n</tr>\n<tr>\n<td>ngOnInit()</td>\n<td>在Angular第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件。在第一轮ngOnChanges()完成之后调用，只调用一次。</td>\n</tr>\n<tr>\n<td>ngDoCheck()</td>\n<td>检测，并在发生Angular无法或不愿意自己检测的变化时作出反应。在每个Angular变更检测周期中调用，ngOnChanges()和ngOnInit()之后。</td>\n</tr>\n<tr>\n<td>ngAfterContentInit()</td>\n<td>当把内容投影进组件之后调用。第一次ngDoCheck()之后调用，只调用一次。只适用于组件。</td>\n</tr>\n<tr>\n<td>ngAfterContentChecked()</td>\n<td>每次完成被投影组件内容的变更检测之后调用。ngAfterContentInit()和每次ngDoCheck()之后调用只适合组件。</td>\n</tr>\n<tr>\n<td>ngAfterViewInit()</td>\n<td>初始化完组件视图及其子视图之后调用。第一次ngAfterContentChecked()之后调用，只调用一次。只适合组件。</td>\n</tr>\n<tr>\n<td>ngAfterViewChecked()</td>\n<td>每次做完组件视图和子视图的变更检测之后调用。ngAfterViewInit()和每次ngAfterContentChecked()之后调用。只适合组件。</td>\n</tr>\n<tr>\n<td>ngOnDestroy()</td>\n<td>当Angular每次销毁指令/组件之前调用并清扫。 在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。在Angular销毁指令/组件之前调用。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"组件交互\"><a href=\"#组件交互\" class=\"headerlink\" title=\"组件交互\"></a>组件交互</h4><ul>\n<li><p>通过输入型绑定把数据从父组件传到子组件：@Input</p>\n</li>\n<li><p>通过setter截听输入属性值的变化</p>\n</li>\n<li><p>通过ngOnChanges()来截听输入属性值的变化</p>\n</li>\n<li><p>父组件监听子组件的事件： 通过@Output一个EventEmitter对象</p>\n</li>\n<li><p>父子组件通过本地变量交互： #var</p>\n</li>\n<li><p>父组件调用@ViewChild()： AfterViewInit钩子中</p>\n</li>\n<li><p>通过服务通讯</p>\n</li>\n</ul>\n<h4 id=\"组件样式\"><a href=\"#组件样式\" class=\"headerlink\" title=\"组件样式\"></a>组件样式</h4><ul>\n<li>组件的样式有三种封装模式：原生(Native)、仿真(Emulated)、无(none)。原生会通过Shadow DOM保证样式不影响组件外其他元素，仿真会通过改名等特殊处理实现不影响外面其他元素。</li>\n</ul>\n<h4 id=\"动态组件\"><a href=\"#动态组件\" class=\"headerlink\" title=\"动态组件\"></a>动态组件</h4><ul>\n<li><p>通过componentFactoryResolver下的方法(如：resolveComponentFactory)解析出一个ComponentFactory对象。</p>\n</li>\n<li><p>通过ViewContainerRef可以获取对容器视图的访问权(包括clear、createComponent等方法)。</p>\n</li>\n<li><p>将ComponentFactory传递给ViewContainerRef的createComponent即可将组件动态添加到ViewContainerRef中。</p>\n</li>\n</ul>\n<h4 id=\"属性型指令\"><a href=\"#属性型指令\" class=\"headerlink\" title=\"属性型指令\"></a>属性型指令</h4><ul>\n<li><p>Directive提供@Directive装饰器功能。</p>\n</li>\n<li><p>通过ElementRef可以访问DOM元素。</p>\n</li>\n<li><p>通过@Input传入参数</p>\n</li>\n<li><p>通过@HostListener添加响应事件</p>\n</li>\n</ul>\n<h4 id=\"结构型指令\"><a href=\"#结构型指令\" class=\"headerlink\" title=\"结构型指令\"></a>结构型指令</h4><ul>\n<li><p>*号是一个微语法，解开会变成<ng-template>标签。</ng-template></p>\n</li>\n<li><p><ng-template>会被转换成注释，不会显示出来。</ng-template></p>\n</li>\n<li><p><ng-container>不会被渲染的容器。</ng-container></p>\n</li>\n<li><p>通过TemplateRef取得<ng-template>的内容，通过VeiwContainerRef来访问视图容器</ng-template></p>\n</li>\n</ul>\n<h4 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h4><ul>\n<li><p>自定义管道需要实现PipeTransform接口的transform方法，接受一个输入值和参数</p>\n</li>\n<li><p>纯管道：只有发生纯变更（原始类型变更，或引用地址的变更）的时候才会执行纯管道。</p>\n</li>\n<li><p>非纯管道：元数据中添加pure: false。</p>\n</li>\n<li><p>非纯异步管道：接受一个Promise或Observable作为输入，最终返回给出的值。</p>\n</li>\n</ul>\n<h4 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h4><ul>\n<li><p>元数据中定义animations</p>\n</li>\n<li><p>定义不同状态下的样式，定义状态砖厂动画效果。</p>\n</li>\n<li><p>*为任意状态，void状态为未进场或移除状态。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"模板与数据绑定\"><a href=\"#模板与数据绑定\" class=\"headerlink\" title=\"模板与数据绑定\"></a>模板与数据绑定</h3><h4 id=\"模板语法\"><a href=\"#模板语法\" class=\"headerlink\" title=\"模板语法\"></a>模板语法</h4><ul>\n<li><p>模板中的HTML： 禁用了script、HTML、body、base等标签</p>\n</li>\n<li><p>插值表达式：{{}}，括号中的素材是一个模板表达式，对其中内容求值，并转换为string</p>\n</li>\n<li><p>模板表达式：可能引起副作用的表达式被禁用：赋值（=, +=, -=, …），new 运算符，使用;或,的链式表达式，自增或自减操作符 (++和–)。并且不支持位运算|和&amp;。</p>\n</li>\n<li><p>表达式上下文：包括所在组件的对象，模板输入变量（比如：ngFor中的let item）和模板引用变量（#input）。不能引用全局变量（window.<em>,document.</em>等）。</p>\n</li>\n<li><p>模板语句：主要用于触发事件（(event)=”statement”），和模板表达式不同的是支持基本赋值（=）和表达式链（;和,）。</p>\n</li>\n<li><p>语句上下文：包括所在组件的对象，模板输入变量（比如：ngFor中的let item）和模板引用变量（#input）。不能引用全局变量（window.<em>,document.</em>等）。</p>\n</li>\n<li><p>属性绑定：[]=</p>\n</li>\n<li><p>attribute绑定：当元素没有属性可绑定的时候，需要使用[attr.*]=””进行绑定</p>\n</li>\n<li><p>CSS类绑定：<div class=\"bad curly\" [class]=\"badCurly\"></div>会计算badCurly的值，赋值并覆盖之前的class。可以使用[class.*]=””来添加新的class</p>\n</li>\n<li><p>样式绑定：[style.color]=””</p>\n</li>\n<li><p>绑定事件：(click)=”func()”和on-click=”func()” $event原生event对象</p>\n</li>\n<li><p>使用EventEmitter实现自定义事件：new EventEmitter().emit(参数)</p>\n</li>\n<li><p>双向数据绑定：[()]双向数据绑定实际上是属性绑定和事件绑定的语法糖</p>\n</li>\n<li><p>内置结构指令：NgIf,NgFor,NgSwitch等等</p>\n</li>\n<li><p>模板引用变量：(#var) 作用域为整个模板</p>\n</li>\n<li><p>输入和输出：@Input和@Output，或者通过@Component中的元数据inputs:[]和outputs:[]</p>\n</li>\n<li><p>模板表达式操作符：管道(|)，安全导航操作符(?.)，非空断言(!)。非空断言和安全导航操作符不同的是，非空断言只是“断言”来避免TypeScript的检查，但是允许返回null和undefined</p>\n</li>\n</ul>\n<h4 id=\"生命周期钩子\"><a href=\"#生命周期钩子\" class=\"headerlink\" title=\"生命周期钩子\"></a>生命周期钩子</h4><table>\n<thead>\n<tr>\n<th>钩子</th>\n<th>目的和时机</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ngOnChanges()</td>\n<td>当Angular（重新）设置数据绑定输入属性时响应。 该方法接受当前和上一属性值的SimpleChanges对象当被绑定的输入属性的值发生变化时调用，首次调用一定会发生在ngOnInit()之前。</td>\n</tr>\n<tr>\n<td>ngOnInit()</td>\n<td>在Angular第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件。在第一轮ngOnChanges()完成之后调用，只调用一次。</td>\n</tr>\n<tr>\n<td>ngDoCheck()</td>\n<td>检测，并在发生Angular无法或不愿意自己检测的变化时作出反应。在每个Angular变更检测周期中调用，ngOnChanges()和ngOnInit()之后。</td>\n</tr>\n<tr>\n<td>ngAfterContentInit()</td>\n<td>当把内容投影进组件之后调用。第一次ngDoCheck()之后调用，只调用一次。只适用于组件。</td>\n</tr>\n<tr>\n<td>ngAfterContentChecked()</td>\n<td>每次完成被投影组件内容的变更检测之后调用。ngAfterContentInit()和每次ngDoCheck()之后调用只适合组件。</td>\n</tr>\n<tr>\n<td>ngAfterViewInit()</td>\n<td>初始化完组件视图及其子视图之后调用。第一次ngAfterContentChecked()之后调用，只调用一次。只适合组件。</td>\n</tr>\n<tr>\n<td>ngAfterViewChecked()</td>\n<td>每次做完组件视图和子视图的变更检测之后调用。ngAfterViewInit()和每次ngAfterContentChecked()之后调用。只适合组件。</td>\n</tr>\n<tr>\n<td>ngOnDestroy()</td>\n<td>当Angular每次销毁指令/组件之前调用并清扫。 在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。在Angular销毁指令/组件之前调用。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"组件交互\"><a href=\"#组件交互\" class=\"headerlink\" title=\"组件交互\"></a>组件交互</h4><ul>\n<li><p>通过输入型绑定把数据从父组件传到子组件：@Input</p>\n</li>\n<li><p>通过setter截听输入属性值的变化</p>\n</li>\n<li><p>通过ngOnChanges()来截听输入属性值的变化</p>\n</li>\n<li><p>父组件监听子组件的事件： 通过@Output一个EventEmitter对象</p>\n</li>\n<li><p>父子组件通过本地变量交互： #var</p>\n</li>\n<li><p>父组件调用@ViewChild()： AfterViewInit钩子中</p>\n</li>\n<li><p>通过服务通讯</p>\n</li>\n</ul>\n<h4 id=\"组件样式\"><a href=\"#组件样式\" class=\"headerlink\" title=\"组件样式\"></a>组件样式</h4><ul>\n<li>组件的样式有三种封装模式：原生(Native)、仿真(Emulated)、无(none)。原生会通过Shadow DOM保证样式不影响组件外其他元素，仿真会通过改名等特殊处理实现不影响外面其他元素。</li>\n</ul>\n<h4 id=\"动态组件\"><a href=\"#动态组件\" class=\"headerlink\" title=\"动态组件\"></a>动态组件</h4><ul>\n<li><p>通过componentFactoryResolver下的方法(如：resolveComponentFactory)解析出一个ComponentFactory对象。</p>\n</li>\n<li><p>通过ViewContainerRef可以获取对容器视图的访问权(包括clear、createComponent等方法)。</p>\n</li>\n<li><p>将ComponentFactory传递给ViewContainerRef的createComponent即可将组件动态添加到ViewContainerRef中。</p>\n</li>\n</ul>\n<h4 id=\"属性型指令\"><a href=\"#属性型指令\" class=\"headerlink\" title=\"属性型指令\"></a>属性型指令</h4><ul>\n<li><p>Directive提供@Directive装饰器功能。</p>\n</li>\n<li><p>通过ElementRef可以访问DOM元素。</p>\n</li>\n<li><p>通过@Input传入参数</p>\n</li>\n<li><p>通过@HostListener添加响应事件</p>\n</li>\n</ul>\n<h4 id=\"结构型指令\"><a href=\"#结构型指令\" class=\"headerlink\" title=\"结构型指令\"></a>结构型指令</h4><ul>\n<li><p>*号是一个微语法，解开会变成<ng-template>标签。</ng-template></p>\n</li>\n<li><p><ng-template>会被转换成注释，不会显示出来。</ng-template></p>\n</li>\n<li><p><ng-container>不会被渲染的容器。</ng-container></p>\n</li>\n<li><p>通过TemplateRef取得<ng-template>的内容，通过VeiwContainerRef来访问视图容器</ng-template></p>\n</li>\n</ul>\n<h4 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h4><ul>\n<li><p>自定义管道需要实现PipeTransform接口的transform方法，接受一个输入值和参数</p>\n</li>\n<li><p>纯管道：只有发生纯变更（原始类型变更，或引用地址的变更）的时候才会执行纯管道。</p>\n</li>\n<li><p>非纯管道：元数据中添加pure: false。</p>\n</li>\n<li><p>非纯异步管道：接受一个Promise或Observable作为输入，最终返回给出的值。</p>\n</li>\n</ul>\n<h4 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h4><ul>\n<li><p>元数据中定义animations</p>\n</li>\n<li><p>定义不同状态下的样式，定义状态砖厂动画效果。</p>\n</li>\n<li><p>*为任意状态，void状态为未进场或移除状态。</p>\n</li>\n</ul>\n"},{"title":"Angular文档划重点(2)","date":"2018-01-22T16:00:00.000Z","comments":1,"_content":"\n### 表单\n\n#### 用户输入\n\n* 绑定用户输入事件：(click) => \"toClick()\"\n\n* 通过$event获取事件，尽量传递值，而不是事件\n\n* 从模板引用变量获取用户输入的值： #var 必须绑定事件（即使是空事件(keyup)=\"0\"）\n\n#### 模板驱动表单\n\n* 使用绑定语法[(ngModel)]=\"\"，并且必须有name属性\n\n* 通过在form标签上添加#var=\"ngForm\"，可以引用form表单，提供var.from.valid等属性\n\n* 需要引入FormsModule模块\n\n* ngModel会跟踪修改状态与有效性验证，包括添加类名ng-touched与ng-untouched、ng-dirty与ng-pristine、ng-valid与ng-invalid\n\n* 通过#var=\"ngModel\"可以获得元素，并且可以访问touched、untouched、dirty等属性\n\n* 使用ngSubmit提交表单\n\n#### 模型驱动表单（响应式表单）\n\n* 属性关联到模板： 模板中[formControl]=\"var\"，类中var = new FormControl()\n\n* 导入ReactiveFormsModule\n\n* AbstractControl是三个具体表单类的抽象基类。并为它们提供了一些共同的行为和属性，其中有些是可观察对象\n\n* FormControl用于跟踪一个单独的表单控件的值和有效性状态。它对应于一个HTML表单控件，比如输入框和下拉框\n\n* FormGroup用于跟踪一组AbstractControl的实例的值和有效性状态。该组的属性中包含了它的子控件。\n\n* FormArray用于跟踪AbstractControl实例组成的有序数组的值和有效性状态\n\n* FormGroup使用： 模板中[formGroup]=\"heroForm\",[formControl]=\"name\"需要修改为formControlName=\"name\",类中heroForm = new FormGroup({name: new FormControl()})。novalidate可以阻止浏览器默认表单校验\n\n* FormBuilder可以减少FormControl的编写： 明确类型var: FormGroup；构造函数中传入FormBuilder: constructor(private fb: FormBuilder)；创建表单this.var = this.fb.group({name: '', // <--- the FormControl called \"name\"})\n\n* Validators验证器：上例中this.var = this.fb.group({name: ['', Validators.required]})\n\n* 多级FormGroup： 同样将[formGroup]=\"var\"改为formGroupName=\"var\"\n\n* 通过formGroup.get('var')可以获得单个formControl状态：主要包括value、status、pristine、untouched等\n\n#### 表单验证\n\n* 模板驱动表单中，通过#var=\"ngModel\"可以将NgModel导出为变量var。\n\n* 响应式表单中，实例化FormControl时第二个参数可以传入同步验证器，第三个参数可以传入异步验证器。\n","source":"_posts/Angular文档划重点(2).md","raw":"---\ntitle: Angular文档划重点(2)\ndate: 2018-01-23\ntags: [Angular]\ncategories:\n- JavaScript\ncomments: true\n---\n\n### 表单\n\n#### 用户输入\n\n* 绑定用户输入事件：(click) => \"toClick()\"\n\n* 通过$event获取事件，尽量传递值，而不是事件\n\n* 从模板引用变量获取用户输入的值： #var 必须绑定事件（即使是空事件(keyup)=\"0\"）\n\n#### 模板驱动表单\n\n* 使用绑定语法[(ngModel)]=\"\"，并且必须有name属性\n\n* 通过在form标签上添加#var=\"ngForm\"，可以引用form表单，提供var.from.valid等属性\n\n* 需要引入FormsModule模块\n\n* ngModel会跟踪修改状态与有效性验证，包括添加类名ng-touched与ng-untouched、ng-dirty与ng-pristine、ng-valid与ng-invalid\n\n* 通过#var=\"ngModel\"可以获得元素，并且可以访问touched、untouched、dirty等属性\n\n* 使用ngSubmit提交表单\n\n#### 模型驱动表单（响应式表单）\n\n* 属性关联到模板： 模板中[formControl]=\"var\"，类中var = new FormControl()\n\n* 导入ReactiveFormsModule\n\n* AbstractControl是三个具体表单类的抽象基类。并为它们提供了一些共同的行为和属性，其中有些是可观察对象\n\n* FormControl用于跟踪一个单独的表单控件的值和有效性状态。它对应于一个HTML表单控件，比如输入框和下拉框\n\n* FormGroup用于跟踪一组AbstractControl的实例的值和有效性状态。该组的属性中包含了它的子控件。\n\n* FormArray用于跟踪AbstractControl实例组成的有序数组的值和有效性状态\n\n* FormGroup使用： 模板中[formGroup]=\"heroForm\",[formControl]=\"name\"需要修改为formControlName=\"name\",类中heroForm = new FormGroup({name: new FormControl()})。novalidate可以阻止浏览器默认表单校验\n\n* FormBuilder可以减少FormControl的编写： 明确类型var: FormGroup；构造函数中传入FormBuilder: constructor(private fb: FormBuilder)；创建表单this.var = this.fb.group({name: '', // <--- the FormControl called \"name\"})\n\n* Validators验证器：上例中this.var = this.fb.group({name: ['', Validators.required]})\n\n* 多级FormGroup： 同样将[formGroup]=\"var\"改为formGroupName=\"var\"\n\n* 通过formGroup.get('var')可以获得单个formControl状态：主要包括value、status、pristine、untouched等\n\n#### 表单验证\n\n* 模板驱动表单中，通过#var=\"ngModel\"可以将NgModel导出为变量var。\n\n* 响应式表单中，实例化FormControl时第二个参数可以传入同步验证器，第三个参数可以传入异步验证器。\n","slug":"Angular文档划重点(2)","published":1,"updated":"2018-01-23T09:19:08.820Z","layout":"post","photos":[],"link":"","_id":"cjks5i9hn0005vmtiztmf87ha","content":"<h3 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h3><h4 id=\"用户输入\"><a href=\"#用户输入\" class=\"headerlink\" title=\"用户输入\"></a>用户输入</h4><ul>\n<li><p>绑定用户输入事件：(click) =&gt; “toClick()”</p>\n</li>\n<li><p>通过$event获取事件，尽量传递值，而不是事件</p>\n</li>\n<li><p>从模板引用变量获取用户输入的值： #var 必须绑定事件（即使是空事件(keyup)=”0”）</p>\n</li>\n</ul>\n<h4 id=\"模板驱动表单\"><a href=\"#模板驱动表单\" class=\"headerlink\" title=\"模板驱动表单\"></a>模板驱动表单</h4><ul>\n<li><p>使用绑定语法[(ngModel)]=””，并且必须有name属性</p>\n</li>\n<li><p>通过在form标签上添加#var=”ngForm”，可以引用form表单，提供var.from.valid等属性</p>\n</li>\n<li><p>需要引入FormsModule模块</p>\n</li>\n<li><p>ngModel会跟踪修改状态与有效性验证，包括添加类名ng-touched与ng-untouched、ng-dirty与ng-pristine、ng-valid与ng-invalid</p>\n</li>\n<li><p>通过#var=”ngModel”可以获得元素，并且可以访问touched、untouched、dirty等属性</p>\n</li>\n<li><p>使用ngSubmit提交表单</p>\n</li>\n</ul>\n<h4 id=\"模型驱动表单（响应式表单）\"><a href=\"#模型驱动表单（响应式表单）\" class=\"headerlink\" title=\"模型驱动表单（响应式表单）\"></a>模型驱动表单（响应式表单）</h4><ul>\n<li><p>属性关联到模板： 模板中[formControl]=”var”，类中var = new FormControl()</p>\n</li>\n<li><p>导入ReactiveFormsModule</p>\n</li>\n<li><p>AbstractControl是三个具体表单类的抽象基类。并为它们提供了一些共同的行为和属性，其中有些是可观察对象</p>\n</li>\n<li><p>FormControl用于跟踪一个单独的表单控件的值和有效性状态。它对应于一个HTML表单控件，比如输入框和下拉框</p>\n</li>\n<li><p>FormGroup用于跟踪一组AbstractControl的实例的值和有效性状态。该组的属性中包含了它的子控件。</p>\n</li>\n<li><p>FormArray用于跟踪AbstractControl实例组成的有序数组的值和有效性状态</p>\n</li>\n<li><p>FormGroup使用： 模板中[formGroup]=”heroForm”,[formControl]=”name”需要修改为formControlName=”name”,类中heroForm = new FormGroup({name: new FormControl()})。novalidate可以阻止浏览器默认表单校验</p>\n</li>\n<li><p>FormBuilder可以减少FormControl的编写： 明确类型var: FormGroup；构造函数中传入FormBuilder: constructor(private fb: FormBuilder)；创建表单this.var = this.fb.group({name: ‘’, // &lt;— the FormControl called “name”})</p>\n</li>\n<li><p>Validators验证器：上例中this.var = this.fb.group({name: [‘’, Validators.required]})</p>\n</li>\n<li><p>多级FormGroup： 同样将[formGroup]=”var”改为formGroupName=”var”</p>\n</li>\n<li><p>通过formGroup.get(‘var’)可以获得单个formControl状态：主要包括value、status、pristine、untouched等</p>\n</li>\n</ul>\n<h4 id=\"表单验证\"><a href=\"#表单验证\" class=\"headerlink\" title=\"表单验证\"></a>表单验证</h4><ul>\n<li><p>模板驱动表单中，通过#var=”ngModel”可以将NgModel导出为变量var。</p>\n</li>\n<li><p>响应式表单中，实例化FormControl时第二个参数可以传入同步验证器，第三个参数可以传入异步验证器。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h3><h4 id=\"用户输入\"><a href=\"#用户输入\" class=\"headerlink\" title=\"用户输入\"></a>用户输入</h4><ul>\n<li><p>绑定用户输入事件：(click) =&gt; “toClick()”</p>\n</li>\n<li><p>通过$event获取事件，尽量传递值，而不是事件</p>\n</li>\n<li><p>从模板引用变量获取用户输入的值： #var 必须绑定事件（即使是空事件(keyup)=”0”）</p>\n</li>\n</ul>\n<h4 id=\"模板驱动表单\"><a href=\"#模板驱动表单\" class=\"headerlink\" title=\"模板驱动表单\"></a>模板驱动表单</h4><ul>\n<li><p>使用绑定语法[(ngModel)]=””，并且必须有name属性</p>\n</li>\n<li><p>通过在form标签上添加#var=”ngForm”，可以引用form表单，提供var.from.valid等属性</p>\n</li>\n<li><p>需要引入FormsModule模块</p>\n</li>\n<li><p>ngModel会跟踪修改状态与有效性验证，包括添加类名ng-touched与ng-untouched、ng-dirty与ng-pristine、ng-valid与ng-invalid</p>\n</li>\n<li><p>通过#var=”ngModel”可以获得元素，并且可以访问touched、untouched、dirty等属性</p>\n</li>\n<li><p>使用ngSubmit提交表单</p>\n</li>\n</ul>\n<h4 id=\"模型驱动表单（响应式表单）\"><a href=\"#模型驱动表单（响应式表单）\" class=\"headerlink\" title=\"模型驱动表单（响应式表单）\"></a>模型驱动表单（响应式表单）</h4><ul>\n<li><p>属性关联到模板： 模板中[formControl]=”var”，类中var = new FormControl()</p>\n</li>\n<li><p>导入ReactiveFormsModule</p>\n</li>\n<li><p>AbstractControl是三个具体表单类的抽象基类。并为它们提供了一些共同的行为和属性，其中有些是可观察对象</p>\n</li>\n<li><p>FormControl用于跟踪一个单独的表单控件的值和有效性状态。它对应于一个HTML表单控件，比如输入框和下拉框</p>\n</li>\n<li><p>FormGroup用于跟踪一组AbstractControl的实例的值和有效性状态。该组的属性中包含了它的子控件。</p>\n</li>\n<li><p>FormArray用于跟踪AbstractControl实例组成的有序数组的值和有效性状态</p>\n</li>\n<li><p>FormGroup使用： 模板中[formGroup]=”heroForm”,[formControl]=”name”需要修改为formControlName=”name”,类中heroForm = new FormGroup({name: new FormControl()})。novalidate可以阻止浏览器默认表单校验</p>\n</li>\n<li><p>FormBuilder可以减少FormControl的编写： 明确类型var: FormGroup；构造函数中传入FormBuilder: constructor(private fb: FormBuilder)；创建表单this.var = this.fb.group({name: ‘’, // &lt;— the FormControl called “name”})</p>\n</li>\n<li><p>Validators验证器：上例中this.var = this.fb.group({name: [‘’, Validators.required]})</p>\n</li>\n<li><p>多级FormGroup： 同样将[formGroup]=”var”改为formGroupName=”var”</p>\n</li>\n<li><p>通过formGroup.get(‘var’)可以获得单个formControl状态：主要包括value、status、pristine、untouched等</p>\n</li>\n</ul>\n<h4 id=\"表单验证\"><a href=\"#表单验证\" class=\"headerlink\" title=\"表单验证\"></a>表单验证</h4><ul>\n<li><p>模板驱动表单中，通过#var=”ngModel”可以将NgModel导出为变量var。</p>\n</li>\n<li><p>响应式表单中，实例化FormControl时第二个参数可以传入同步验证器，第三个参数可以传入异步验证器。</p>\n</li>\n</ul>\n"},{"title":"Angular文档划重点(3)","date":"2018-01-22T16:00:00.000Z","comments":1,"_content":"\n### 启动过程\n\n* @NgModule接受一个元数据对象，告诉Angular如何编译和启动应用。\n\n* imports模块，declarations组件，providers服务。\n\n* 引导AppModule有多种方式，浏览器平台主要有即时(JiT)编译和预编译器(AoT-Ahead-Of-Time)静态引导。\n\n* 预编译器静态引导生成更小、启动更快的应用，一般用于线上环境。\n\n* 根模块中的imports与特性模块的imports互不相干。特性模块中应该用CommonModule替换BrowserModule。\n\n* 惰性加载：在根模块中不导入，路由中通过loadChildren:'path#ComponentName'\n\n* 根模块调用RouterModule.forRoot，特性模块调用RouterModule.forChild\n\n### 依赖注入\n\n* 通过注册provider来配置注入器\n\n* 创建服务时是用@Injectable()\n\n* 在需要服务的构造函数中引入\n\n### HttpClient\n\n* 从@angular/common/http导入HttpClientModule，注入HttpClient\n\n* 通过observe: 'response'可以获取完整的响应体\n\n* 错误信息的类型为HttpErrorResponse，主要包括status、error、message等属性\n\n* 通过retry()可以在发生错误时重新发送请求\n\n* 通过参数responseType: 'text'可以获取非JSON数据\n\n* 拦截器继承HttpInterceptor，包含intercept一个方法，参数为req: HttpRequest<any>和next: HttpHandler\n\n* 通过providers: [{provide: HTTP_INTERCEPTORS,useClass: ClassName,multi: true}]来使用自定义的ClassName拦截器\n\n* 拦截器处理的是比HttpClient请求更底层的事件，拦截器必须透传自己不理解的和不打算修改的事件\n\n* HttpRequest和HttpResponse类是不可变的，需要通过clone()传递参数修改\n\n* 通过{setHeaders: {Authorization: authHeader}设置请求头\n\n* 通过设置reportProgress: true可以监听进度事件，主要包括event.loaded和event.total\n\n### 路由\n\n* 在导航时的每个生命周期成功完成时，路由器会构建出一个`ActivatedRoute`组成的树，它表示路由器的当前状态\n\n* 需要根据参数，同一组件切换不同数据，可以使用`ParamMap`，返回`Observable`；当不需要`Observable`时，可以使用`snapshot`\n\n* 用CanActivate来处理导航到某路由的情况；用CanActivateChild来处理导航到某子路由的情况；用CanDeactivate来处理从当前路由离开的情况；用Resolve在路由激活之前获取路由数据；用CanLoad来处理异步导航到某特性模块的情况。\n","source":"_posts/Angular文档划重点(3).md","raw":"---\ntitle: Angular文档划重点(3)\ndate: 2018-01-23\ntags: [Angular]\ncategories:\n- JavaScript\ncomments: true\n---\n\n### 启动过程\n\n* @NgModule接受一个元数据对象，告诉Angular如何编译和启动应用。\n\n* imports模块，declarations组件，providers服务。\n\n* 引导AppModule有多种方式，浏览器平台主要有即时(JiT)编译和预编译器(AoT-Ahead-Of-Time)静态引导。\n\n* 预编译器静态引导生成更小、启动更快的应用，一般用于线上环境。\n\n* 根模块中的imports与特性模块的imports互不相干。特性模块中应该用CommonModule替换BrowserModule。\n\n* 惰性加载：在根模块中不导入，路由中通过loadChildren:'path#ComponentName'\n\n* 根模块调用RouterModule.forRoot，特性模块调用RouterModule.forChild\n\n### 依赖注入\n\n* 通过注册provider来配置注入器\n\n* 创建服务时是用@Injectable()\n\n* 在需要服务的构造函数中引入\n\n### HttpClient\n\n* 从@angular/common/http导入HttpClientModule，注入HttpClient\n\n* 通过observe: 'response'可以获取完整的响应体\n\n* 错误信息的类型为HttpErrorResponse，主要包括status、error、message等属性\n\n* 通过retry()可以在发生错误时重新发送请求\n\n* 通过参数responseType: 'text'可以获取非JSON数据\n\n* 拦截器继承HttpInterceptor，包含intercept一个方法，参数为req: HttpRequest<any>和next: HttpHandler\n\n* 通过providers: [{provide: HTTP_INTERCEPTORS,useClass: ClassName,multi: true}]来使用自定义的ClassName拦截器\n\n* 拦截器处理的是比HttpClient请求更底层的事件，拦截器必须透传自己不理解的和不打算修改的事件\n\n* HttpRequest和HttpResponse类是不可变的，需要通过clone()传递参数修改\n\n* 通过{setHeaders: {Authorization: authHeader}设置请求头\n\n* 通过设置reportProgress: true可以监听进度事件，主要包括event.loaded和event.total\n\n### 路由\n\n* 在导航时的每个生命周期成功完成时，路由器会构建出一个`ActivatedRoute`组成的树，它表示路由器的当前状态\n\n* 需要根据参数，同一组件切换不同数据，可以使用`ParamMap`，返回`Observable`；当不需要`Observable`时，可以使用`snapshot`\n\n* 用CanActivate来处理导航到某路由的情况；用CanActivateChild来处理导航到某子路由的情况；用CanDeactivate来处理从当前路由离开的情况；用Resolve在路由激活之前获取路由数据；用CanLoad来处理异步导航到某特性模块的情况。\n","slug":"Angular文档划重点(3)","published":1,"updated":"2018-05-15T06:33:10.307Z","layout":"post","photos":[],"link":"","_id":"cjks5i9ho0006vmtiw1174lpj","content":"<h3 id=\"启动过程\"><a href=\"#启动过程\" class=\"headerlink\" title=\"启动过程\"></a>启动过程</h3><ul>\n<li><p>@NgModule接受一个元数据对象，告诉Angular如何编译和启动应用。</p>\n</li>\n<li><p>imports模块，declarations组件，providers服务。</p>\n</li>\n<li><p>引导AppModule有多种方式，浏览器平台主要有即时(JiT)编译和预编译器(AoT-Ahead-Of-Time)静态引导。</p>\n</li>\n<li><p>预编译器静态引导生成更小、启动更快的应用，一般用于线上环境。</p>\n</li>\n<li><p>根模块中的imports与特性模块的imports互不相干。特性模块中应该用CommonModule替换BrowserModule。</p>\n</li>\n<li><p>惰性加载：在根模块中不导入，路由中通过loadChildren:’path#ComponentName’</p>\n</li>\n<li><p>根模块调用RouterModule.forRoot，特性模块调用RouterModule.forChild</p>\n</li>\n</ul>\n<h3 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h3><ul>\n<li><p>通过注册provider来配置注入器</p>\n</li>\n<li><p>创建服务时是用@Injectable()</p>\n</li>\n<li><p>在需要服务的构造函数中引入</p>\n</li>\n</ul>\n<h3 id=\"HttpClient\"><a href=\"#HttpClient\" class=\"headerlink\" title=\"HttpClient\"></a>HttpClient</h3><ul>\n<li><p>从@angular/common/http导入HttpClientModule，注入HttpClient</p>\n</li>\n<li><p>通过observe: ‘response’可以获取完整的响应体</p>\n</li>\n<li><p>错误信息的类型为HttpErrorResponse，主要包括status、error、message等属性</p>\n</li>\n<li><p>通过retry()可以在发生错误时重新发送请求</p>\n</li>\n<li><p>通过参数responseType: ‘text’可以获取非JSON数据</p>\n</li>\n<li><p>拦截器继承HttpInterceptor，包含intercept一个方法，参数为req: HttpRequest<any>和next: HttpHandler</any></p>\n</li>\n<li><p>通过providers: [{provide: HTTP_INTERCEPTORS,useClass: ClassName,multi: true}]来使用自定义的ClassName拦截器</p>\n</li>\n<li><p>拦截器处理的是比HttpClient请求更底层的事件，拦截器必须透传自己不理解的和不打算修改的事件</p>\n</li>\n<li><p>HttpRequest和HttpResponse类是不可变的，需要通过clone()传递参数修改</p>\n</li>\n<li><p>通过{setHeaders: {Authorization: authHeader}设置请求头</p>\n</li>\n<li><p>通过设置reportProgress: true可以监听进度事件，主要包括event.loaded和event.total</p>\n</li>\n</ul>\n<h3 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h3><ul>\n<li><p>在导航时的每个生命周期成功完成时，路由器会构建出一个<code>ActivatedRoute</code>组成的树，它表示路由器的当前状态</p>\n</li>\n<li><p>需要根据参数，同一组件切换不同数据，可以使用<code>ParamMap</code>，返回<code>Observable</code>；当不需要<code>Observable</code>时，可以使用<code>snapshot</code></p>\n</li>\n<li><p>用CanActivate来处理导航到某路由的情况；用CanActivateChild来处理导航到某子路由的情况；用CanDeactivate来处理从当前路由离开的情况；用Resolve在路由激活之前获取路由数据；用CanLoad来处理异步导航到某特性模块的情况。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"启动过程\"><a href=\"#启动过程\" class=\"headerlink\" title=\"启动过程\"></a>启动过程</h3><ul>\n<li><p>@NgModule接受一个元数据对象，告诉Angular如何编译和启动应用。</p>\n</li>\n<li><p>imports模块，declarations组件，providers服务。</p>\n</li>\n<li><p>引导AppModule有多种方式，浏览器平台主要有即时(JiT)编译和预编译器(AoT-Ahead-Of-Time)静态引导。</p>\n</li>\n<li><p>预编译器静态引导生成更小、启动更快的应用，一般用于线上环境。</p>\n</li>\n<li><p>根模块中的imports与特性模块的imports互不相干。特性模块中应该用CommonModule替换BrowserModule。</p>\n</li>\n<li><p>惰性加载：在根模块中不导入，路由中通过loadChildren:’path#ComponentName’</p>\n</li>\n<li><p>根模块调用RouterModule.forRoot，特性模块调用RouterModule.forChild</p>\n</li>\n</ul>\n<h3 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h3><ul>\n<li><p>通过注册provider来配置注入器</p>\n</li>\n<li><p>创建服务时是用@Injectable()</p>\n</li>\n<li><p>在需要服务的构造函数中引入</p>\n</li>\n</ul>\n<h3 id=\"HttpClient\"><a href=\"#HttpClient\" class=\"headerlink\" title=\"HttpClient\"></a>HttpClient</h3><ul>\n<li><p>从@angular/common/http导入HttpClientModule，注入HttpClient</p>\n</li>\n<li><p>通过observe: ‘response’可以获取完整的响应体</p>\n</li>\n<li><p>错误信息的类型为HttpErrorResponse，主要包括status、error、message等属性</p>\n</li>\n<li><p>通过retry()可以在发生错误时重新发送请求</p>\n</li>\n<li><p>通过参数responseType: ‘text’可以获取非JSON数据</p>\n</li>\n<li><p>拦截器继承HttpInterceptor，包含intercept一个方法，参数为req: HttpRequest<any>和next: HttpHandler</any></p>\n</li>\n<li><p>通过providers: [{provide: HTTP_INTERCEPTORS,useClass: ClassName,multi: true}]来使用自定义的ClassName拦截器</p>\n</li>\n<li><p>拦截器处理的是比HttpClient请求更底层的事件，拦截器必须透传自己不理解的和不打算修改的事件</p>\n</li>\n<li><p>HttpRequest和HttpResponse类是不可变的，需要通过clone()传递参数修改</p>\n</li>\n<li><p>通过{setHeaders: {Authorization: authHeader}设置请求头</p>\n</li>\n<li><p>通过设置reportProgress: true可以监听进度事件，主要包括event.loaded和event.total</p>\n</li>\n</ul>\n<h3 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h3><ul>\n<li><p>在导航时的每个生命周期成功完成时，路由器会构建出一个<code>ActivatedRoute</code>组成的树，它表示路由器的当前状态</p>\n</li>\n<li><p>需要根据参数，同一组件切换不同数据，可以使用<code>ParamMap</code>，返回<code>Observable</code>；当不需要<code>Observable</code>时，可以使用<code>snapshot</code></p>\n</li>\n<li><p>用CanActivate来处理导航到某路由的情况；用CanActivateChild来处理导航到某子路由的情况；用CanDeactivate来处理从当前路由离开的情况；用Resolve在路由激活之前获取路由数据；用CanLoad来处理异步导航到某特性模块的情况。</p>\n</li>\n</ul>\n"},{"title":"CSS后处理PostCSS","date":"2017-08-13T16:00:00.000Z","comments":1,"_content":"\nLess、Sass是比较常用的CSS预处理器，使用预处理器可以帮助我们实现在CSS中，像编程一样使用变量、条件控制、循环等等功能，我们需要做的就是学习一套Less或者Sass的语法，并用该语法来编写样式表，最后通过Less或Sass将其转换为CSS样式表。  \nPostCSS则不同，PostCSS对于使用者不需要学习其他语法，只需要正常编写CSS，最后PostCSS会根据配置功能对该CSS样式表进行修改。比如，最常用的AutoPrefixer就是通过PostCSS实现的，我们在使用的时候，不需要写额外的内容，只需要编写一些配置使用AutoPrefixer即可。\n\n在PostCSS的官网上，我们可以看到对PostCSS的描述，A tool for transforming CSS with JavaScript。PostCSS只是一个用于提供使用JavaScript去转换CSS的工具，本身并没有实现对CSS的任何修改。PostCSS可以分析CSS文件，将所有的CSS规则转换成AST（抽象语法树），并提供了一系列的API对其可以进行遍历、修改，最终重新生成CSS文件。\n\n首先根据官网的教程，我们可以发现一个简单的插件架子是这样的。\n```JavaScript\nconst postcss = require('postcss')\n\nmodule.exports = postcss.plugin('myplugin', function myplugin(options) {\n  return function(css) {\n    options = options || {}\n    // 这里是对CSS的处理\n  }\n})\n```\n首先是将整个文件转换成了AST对象（可以通过[这里](http://astexplorer.net/#/2uBU1BLuJ1)查看抽象语法树结构），存储在css变量中。这个对象（Root对象）是这样子的，在子节点中包含所有规则\n```JavaScript\nRoot {\n  raws: { semicolon: false, after: '\\n\\n\\n' },    // 是否包含分号，结尾内容\n  type: 'root',                                   // 节点类型\n  nodes: [\n    Rule {                                  // 子节点\n      raws: [Object],\n      type: 'rule',\n      nodes: [Object],\n      parent: [Circular],\n      source: [Object],\n      selector: 'body'\n    }\n  ],\n  source: {\n    input: Input {\n      css: '\\nbody {\\n  margin: 0;\\n}\\n\\n\\n',\n      file: '/Users/huanqiu/Desktop/Fanz/postCssDemo/index.css'\n    },\n    start: { line: 1, column: 1 }\n  }\n}\n```\n之后，通过Root的walkRules可以遍历每一个子节点，也就是Rule对象，这里就是一条规则，在子节点中包含所有声明\n```JavaScript\nRule {\n  raws: { before: '\\n', between: ' ', semicolon: true, after: '\\n' },\n  type: 'rule',\n  nodes: [Declaration {\n    raws: [Object],\n    type: 'decl',\n    parent: [Circular],\n    source: [Object],\n    prop: 'margin',\n    value: '0'\n  }],\n  parent: Root {\n    raws: { semicolon: false, after: '\\n\\n\\n' },\n    type: 'root',\n    nodes: [\n      [Circular]\n    ],\n    source: { input: [Object], start: [Object] },\n    lastEach: 1,\n    indexes: { '1': 0 }\n  },\n  source: {\n    start: { line: 2, column: 1 },\n    input: Input {\n      css: '\\nbody {\\n  margin: 0;\\n}\\n\\n\\n',\n      file: '/Users/huanqiu/Desktop/Fanz/postCssDemo/index.css'\n    },\n    end: { line: 4, column: 1 }\n  },\n  selector: 'body'\n}\n```\n再之后，可以通过Rule对象的walkDecls拿到每一条声明。（通过Root直接使用walkDecls也可以直接拿到声明）\n```JavaScript\nDeclaration {\n  raws: { before: '\\n  ', between: ': ' },\n  type: 'decl',\n  parent: \n    Rule {\n     raws: { before: '\\n', between: ' ', semicolon: true, after: '\\n' },\n     type: 'rule',\n     nodes: [ [Circular] ],\n     parent: \n      Root {\n        raws: [Object],\n        type: 'root',\n        nodes: [Object],\n        source: [Object],\n        lastEach: 1,\n        indexes: [Object] },\n     source: { start: [Object], input: [Object], end: [Object] },\n     selector: 'body',\n     lastEach: 1,\n     indexes: { '1': 0 } \n    },\n  source: { \n    start: { line: 3, column: 3 },\n    input: \n      Input {\n        css: '\\nbody {\\n  margin: 0;\\n}\\n\\n\\n',\n        file: '/Users/huanqiu/Desktop/Fanz/postCssDemo/index.css' },\n     end: { line: 3, column: 12 } },\n  prop: 'margin',\n  value: '0' \n}\n```\n在任何对象上，我们都可以通过PostCSS提供的API对CSS进行修改。比如实现一个简单的为transform添加-webkit-前缀功能，在walkDecls方法中传入下面方法作为参数\n```JavaScript\nfunction (decl, i) {\n  if (decl.prop === 'transform') {\n    decl.before('-webkit-transform: ' + decl.value)\n  }\n}\n```\n更多API可以参考[这里](http://api.postcss.org)\n\n在CSS中，有注释、CSS规则、规则中的声明以及媒体查询规则，分别对应PostCSS中的Comment、Rule、Declaration、AtRule对象。除此之外，还有Root对象可以用来表示整个CSS文件；Node对象是所有节点类型对象的祖先对象；Container对象是Root、Rule、AtRule的祖先对象；Result对象是PostCSS转换结果的对象，包含css、map等内容；Warning、CssSyntaxError等等。\n","source":"_posts/CSS后处理PostCSS.md","raw":"---\ntitle: CSS后处理PostCSS\ndate: 2017-08-14\ntags: [CSS]\ncategories: \n- CSS\ncomments: true\n---\n\nLess、Sass是比较常用的CSS预处理器，使用预处理器可以帮助我们实现在CSS中，像编程一样使用变量、条件控制、循环等等功能，我们需要做的就是学习一套Less或者Sass的语法，并用该语法来编写样式表，最后通过Less或Sass将其转换为CSS样式表。  \nPostCSS则不同，PostCSS对于使用者不需要学习其他语法，只需要正常编写CSS，最后PostCSS会根据配置功能对该CSS样式表进行修改。比如，最常用的AutoPrefixer就是通过PostCSS实现的，我们在使用的时候，不需要写额外的内容，只需要编写一些配置使用AutoPrefixer即可。\n\n在PostCSS的官网上，我们可以看到对PostCSS的描述，A tool for transforming CSS with JavaScript。PostCSS只是一个用于提供使用JavaScript去转换CSS的工具，本身并没有实现对CSS的任何修改。PostCSS可以分析CSS文件，将所有的CSS规则转换成AST（抽象语法树），并提供了一系列的API对其可以进行遍历、修改，最终重新生成CSS文件。\n\n首先根据官网的教程，我们可以发现一个简单的插件架子是这样的。\n```JavaScript\nconst postcss = require('postcss')\n\nmodule.exports = postcss.plugin('myplugin', function myplugin(options) {\n  return function(css) {\n    options = options || {}\n    // 这里是对CSS的处理\n  }\n})\n```\n首先是将整个文件转换成了AST对象（可以通过[这里](http://astexplorer.net/#/2uBU1BLuJ1)查看抽象语法树结构），存储在css变量中。这个对象（Root对象）是这样子的，在子节点中包含所有规则\n```JavaScript\nRoot {\n  raws: { semicolon: false, after: '\\n\\n\\n' },    // 是否包含分号，结尾内容\n  type: 'root',                                   // 节点类型\n  nodes: [\n    Rule {                                  // 子节点\n      raws: [Object],\n      type: 'rule',\n      nodes: [Object],\n      parent: [Circular],\n      source: [Object],\n      selector: 'body'\n    }\n  ],\n  source: {\n    input: Input {\n      css: '\\nbody {\\n  margin: 0;\\n}\\n\\n\\n',\n      file: '/Users/huanqiu/Desktop/Fanz/postCssDemo/index.css'\n    },\n    start: { line: 1, column: 1 }\n  }\n}\n```\n之后，通过Root的walkRules可以遍历每一个子节点，也就是Rule对象，这里就是一条规则，在子节点中包含所有声明\n```JavaScript\nRule {\n  raws: { before: '\\n', between: ' ', semicolon: true, after: '\\n' },\n  type: 'rule',\n  nodes: [Declaration {\n    raws: [Object],\n    type: 'decl',\n    parent: [Circular],\n    source: [Object],\n    prop: 'margin',\n    value: '0'\n  }],\n  parent: Root {\n    raws: { semicolon: false, after: '\\n\\n\\n' },\n    type: 'root',\n    nodes: [\n      [Circular]\n    ],\n    source: { input: [Object], start: [Object] },\n    lastEach: 1,\n    indexes: { '1': 0 }\n  },\n  source: {\n    start: { line: 2, column: 1 },\n    input: Input {\n      css: '\\nbody {\\n  margin: 0;\\n}\\n\\n\\n',\n      file: '/Users/huanqiu/Desktop/Fanz/postCssDemo/index.css'\n    },\n    end: { line: 4, column: 1 }\n  },\n  selector: 'body'\n}\n```\n再之后，可以通过Rule对象的walkDecls拿到每一条声明。（通过Root直接使用walkDecls也可以直接拿到声明）\n```JavaScript\nDeclaration {\n  raws: { before: '\\n  ', between: ': ' },\n  type: 'decl',\n  parent: \n    Rule {\n     raws: { before: '\\n', between: ' ', semicolon: true, after: '\\n' },\n     type: 'rule',\n     nodes: [ [Circular] ],\n     parent: \n      Root {\n        raws: [Object],\n        type: 'root',\n        nodes: [Object],\n        source: [Object],\n        lastEach: 1,\n        indexes: [Object] },\n     source: { start: [Object], input: [Object], end: [Object] },\n     selector: 'body',\n     lastEach: 1,\n     indexes: { '1': 0 } \n    },\n  source: { \n    start: { line: 3, column: 3 },\n    input: \n      Input {\n        css: '\\nbody {\\n  margin: 0;\\n}\\n\\n\\n',\n        file: '/Users/huanqiu/Desktop/Fanz/postCssDemo/index.css' },\n     end: { line: 3, column: 12 } },\n  prop: 'margin',\n  value: '0' \n}\n```\n在任何对象上，我们都可以通过PostCSS提供的API对CSS进行修改。比如实现一个简单的为transform添加-webkit-前缀功能，在walkDecls方法中传入下面方法作为参数\n```JavaScript\nfunction (decl, i) {\n  if (decl.prop === 'transform') {\n    decl.before('-webkit-transform: ' + decl.value)\n  }\n}\n```\n更多API可以参考[这里](http://api.postcss.org)\n\n在CSS中，有注释、CSS规则、规则中的声明以及媒体查询规则，分别对应PostCSS中的Comment、Rule、Declaration、AtRule对象。除此之外，还有Root对象可以用来表示整个CSS文件；Node对象是所有节点类型对象的祖先对象；Container对象是Root、Rule、AtRule的祖先对象；Result对象是PostCSS转换结果的对象，包含css、map等内容；Warning、CssSyntaxError等等。\n","slug":"CSS后处理PostCSS","published":1,"updated":"2017-12-28T03:47:32.452Z","layout":"post","photos":[],"link":"","_id":"cjks5i9hp0008vmtidnmnppyi","content":"<p>Less、Sass是比较常用的CSS预处理器，使用预处理器可以帮助我们实现在CSS中，像编程一样使用变量、条件控制、循环等等功能，我们需要做的就是学习一套Less或者Sass的语法，并用该语法来编写样式表，最后通过Less或Sass将其转换为CSS样式表。<br>PostCSS则不同，PostCSS对于使用者不需要学习其他语法，只需要正常编写CSS，最后PostCSS会根据配置功能对该CSS样式表进行修改。比如，最常用的AutoPrefixer就是通过PostCSS实现的，我们在使用的时候，不需要写额外的内容，只需要编写一些配置使用AutoPrefixer即可。</p>\n<p>在PostCSS的官网上，我们可以看到对PostCSS的描述，A tool for transforming CSS with JavaScript。PostCSS只是一个用于提供使用JavaScript去转换CSS的工具，本身并没有实现对CSS的任何修改。PostCSS可以分析CSS文件，将所有的CSS规则转换成AST（抽象语法树），并提供了一系列的API对其可以进行遍历、修改，最终重新生成CSS文件。</p>\n<p>首先根据官网的教程，我们可以发现一个简单的插件架子是这样的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> postcss = <span class=\"built_in\">require</span>(<span class=\"string\">'postcss'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = postcss.plugin(<span class=\"string\">'myplugin'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myplugin</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">css</span>) </span>&#123;</span><br><span class=\"line\">    options = options || &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这里是对CSS的处理</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>首先是将整个文件转换成了AST对象（可以通过<a href=\"http://astexplorer.net/#/2uBU1BLuJ1\" target=\"_blank\" rel=\"noopener\">这里</a>查看抽象语法树结构），存储在css变量中。这个对象（Root对象）是这样子的，在子节点中包含所有规则<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Root &#123;</span><br><span class=\"line\">  raws: &#123; <span class=\"attr\">semicolon</span>: <span class=\"literal\">false</span>, <span class=\"attr\">after</span>: <span class=\"string\">'\\n\\n\\n'</span> &#125;,    <span class=\"comment\">// 是否包含分号，结尾内容</span></span><br><span class=\"line\">  type: <span class=\"string\">'root'</span>,                                   <span class=\"comment\">// 节点类型</span></span><br><span class=\"line\">  nodes: [</span><br><span class=\"line\">    Rule &#123;                                  <span class=\"comment\">// 子节点</span></span><br><span class=\"line\">      raws: [<span class=\"built_in\">Object</span>],</span><br><span class=\"line\">      type: <span class=\"string\">'rule'</span>,</span><br><span class=\"line\">      nodes: [<span class=\"built_in\">Object</span>],</span><br><span class=\"line\">      parent: [Circular],</span><br><span class=\"line\">      source: [<span class=\"built_in\">Object</span>],</span><br><span class=\"line\">      selector: <span class=\"string\">'body'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  source: &#123;</span><br><span class=\"line\">    input: Input &#123;</span><br><span class=\"line\">      css: <span class=\"string\">'\\nbody &#123;\\n  margin: 0;\\n&#125;\\n\\n\\n'</span>,</span><br><span class=\"line\">      file: <span class=\"string\">'/Users/huanqiu/Desktop/Fanz/postCssDemo/index.css'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    start: &#123; <span class=\"attr\">line</span>: <span class=\"number\">1</span>, <span class=\"attr\">column</span>: <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>之后，通过Root的walkRules可以遍历每一个子节点，也就是Rule对象，这里就是一条规则，在子节点中包含所有声明<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rule &#123;</span><br><span class=\"line\">  raws: &#123; <span class=\"attr\">before</span>: <span class=\"string\">'\\n'</span>, <span class=\"attr\">between</span>: <span class=\"string\">' '</span>, <span class=\"attr\">semicolon</span>: <span class=\"literal\">true</span>, <span class=\"attr\">after</span>: <span class=\"string\">'\\n'</span> &#125;,</span><br><span class=\"line\">  type: <span class=\"string\">'rule'</span>,</span><br><span class=\"line\">  nodes: [Declaration &#123;</span><br><span class=\"line\">    raws: [<span class=\"built_in\">Object</span>],</span><br><span class=\"line\">    type: <span class=\"string\">'decl'</span>,</span><br><span class=\"line\">    parent: [Circular],</span><br><span class=\"line\">    source: [<span class=\"built_in\">Object</span>],</span><br><span class=\"line\">    prop: <span class=\"string\">'margin'</span>,</span><br><span class=\"line\">    value: <span class=\"string\">'0'</span></span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\">  parent: Root &#123;</span><br><span class=\"line\">    raws: &#123; <span class=\"attr\">semicolon</span>: <span class=\"literal\">false</span>, <span class=\"attr\">after</span>: <span class=\"string\">'\\n\\n\\n'</span> &#125;,</span><br><span class=\"line\">    type: <span class=\"string\">'root'</span>,</span><br><span class=\"line\">    nodes: [</span><br><span class=\"line\">      [Circular]</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    source: &#123; <span class=\"attr\">input</span>: [<span class=\"built_in\">Object</span>], <span class=\"attr\">start</span>: [<span class=\"built_in\">Object</span>] &#125;,</span><br><span class=\"line\">    lastEach: <span class=\"number\">1</span>,</span><br><span class=\"line\">    indexes: &#123; <span class=\"string\">'1'</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  source: &#123;</span><br><span class=\"line\">    start: &#123; <span class=\"attr\">line</span>: <span class=\"number\">2</span>, <span class=\"attr\">column</span>: <span class=\"number\">1</span> &#125;,</span><br><span class=\"line\">    input: Input &#123;</span><br><span class=\"line\">      css: <span class=\"string\">'\\nbody &#123;\\n  margin: 0;\\n&#125;\\n\\n\\n'</span>,</span><br><span class=\"line\">      file: <span class=\"string\">'/Users/huanqiu/Desktop/Fanz/postCssDemo/index.css'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    end: &#123; <span class=\"attr\">line</span>: <span class=\"number\">4</span>, <span class=\"attr\">column</span>: <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  selector: <span class=\"string\">'body'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再之后，可以通过Rule对象的walkDecls拿到每一条声明。（通过Root直接使用walkDecls也可以直接拿到声明）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Declaration &#123;</span><br><span class=\"line\">  raws: &#123; <span class=\"attr\">before</span>: <span class=\"string\">'\\n  '</span>, <span class=\"attr\">between</span>: <span class=\"string\">': '</span> &#125;,</span><br><span class=\"line\">  type: <span class=\"string\">'decl'</span>,</span><br><span class=\"line\">  parent: </span><br><span class=\"line\">    Rule &#123;</span><br><span class=\"line\">     raws: &#123; <span class=\"attr\">before</span>: <span class=\"string\">'\\n'</span>, <span class=\"attr\">between</span>: <span class=\"string\">' '</span>, <span class=\"attr\">semicolon</span>: <span class=\"literal\">true</span>, <span class=\"attr\">after</span>: <span class=\"string\">'\\n'</span> &#125;,</span><br><span class=\"line\">     type: <span class=\"string\">'rule'</span>,</span><br><span class=\"line\">     nodes: [ [Circular] ],</span><br><span class=\"line\">     parent: </span><br><span class=\"line\">      Root &#123;</span><br><span class=\"line\">        raws: [<span class=\"built_in\">Object</span>],</span><br><span class=\"line\">        type: <span class=\"string\">'root'</span>,</span><br><span class=\"line\">        nodes: [<span class=\"built_in\">Object</span>],</span><br><span class=\"line\">        source: [<span class=\"built_in\">Object</span>],</span><br><span class=\"line\">        lastEach: <span class=\"number\">1</span>,</span><br><span class=\"line\">        indexes: [<span class=\"built_in\">Object</span>] &#125;,</span><br><span class=\"line\">     source: &#123; <span class=\"attr\">start</span>: [<span class=\"built_in\">Object</span>], <span class=\"attr\">input</span>: [<span class=\"built_in\">Object</span>], <span class=\"attr\">end</span>: [<span class=\"built_in\">Object</span>] &#125;,</span><br><span class=\"line\">     selector: <span class=\"string\">'body'</span>,</span><br><span class=\"line\">     lastEach: <span class=\"number\">1</span>,</span><br><span class=\"line\">     indexes: &#123; <span class=\"string\">'1'</span>: <span class=\"number\">0</span> &#125; </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  source: &#123; </span><br><span class=\"line\">    start: &#123; <span class=\"attr\">line</span>: <span class=\"number\">3</span>, <span class=\"attr\">column</span>: <span class=\"number\">3</span> &#125;,</span><br><span class=\"line\">    input: </span><br><span class=\"line\">      Input &#123;</span><br><span class=\"line\">        css: <span class=\"string\">'\\nbody &#123;\\n  margin: 0;\\n&#125;\\n\\n\\n'</span>,</span><br><span class=\"line\">        file: <span class=\"string\">'/Users/huanqiu/Desktop/Fanz/postCssDemo/index.css'</span> &#125;,</span><br><span class=\"line\">     end: &#123; <span class=\"attr\">line</span>: <span class=\"number\">3</span>, <span class=\"attr\">column</span>: <span class=\"number\">12</span> &#125; &#125;,</span><br><span class=\"line\">  prop: <span class=\"string\">'margin'</span>,</span><br><span class=\"line\">  value: <span class=\"string\">'0'</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在任何对象上，我们都可以通过PostCSS提供的API对CSS进行修改。比如实现一个简单的为transform添加-webkit-前缀功能，在walkDecls方法中传入下面方法作为参数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">decl, i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (decl.prop === <span class=\"string\">'transform'</span>) &#123;</span><br><span class=\"line\">    decl.before(<span class=\"string\">'-webkit-transform: '</span> + decl.value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>更多API可以参考<a href=\"http://api.postcss.org\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<p>在CSS中，有注释、CSS规则、规则中的声明以及媒体查询规则，分别对应PostCSS中的Comment、Rule、Declaration、AtRule对象。除此之外，还有Root对象可以用来表示整个CSS文件；Node对象是所有节点类型对象的祖先对象；Container对象是Root、Rule、AtRule的祖先对象；Result对象是PostCSS转换结果的对象，包含css、map等内容；Warning、CssSyntaxError等等。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Less、Sass是比较常用的CSS预处理器，使用预处理器可以帮助我们实现在CSS中，像编程一样使用变量、条件控制、循环等等功能，我们需要做的就是学习一套Less或者Sass的语法，并用该语法来编写样式表，最后通过Less或Sass将其转换为CSS样式表。<br>PostCSS则不同，PostCSS对于使用者不需要学习其他语法，只需要正常编写CSS，最后PostCSS会根据配置功能对该CSS样式表进行修改。比如，最常用的AutoPrefixer就是通过PostCSS实现的，我们在使用的时候，不需要写额外的内容，只需要编写一些配置使用AutoPrefixer即可。</p>\n<p>在PostCSS的官网上，我们可以看到对PostCSS的描述，A tool for transforming CSS with JavaScript。PostCSS只是一个用于提供使用JavaScript去转换CSS的工具，本身并没有实现对CSS的任何修改。PostCSS可以分析CSS文件，将所有的CSS规则转换成AST（抽象语法树），并提供了一系列的API对其可以进行遍历、修改，最终重新生成CSS文件。</p>\n<p>首先根据官网的教程，我们可以发现一个简单的插件架子是这样的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> postcss = <span class=\"built_in\">require</span>(<span class=\"string\">'postcss'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = postcss.plugin(<span class=\"string\">'myplugin'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myplugin</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">css</span>) </span>&#123;</span><br><span class=\"line\">    options = options || &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这里是对CSS的处理</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>首先是将整个文件转换成了AST对象（可以通过<a href=\"http://astexplorer.net/#/2uBU1BLuJ1\" target=\"_blank\" rel=\"noopener\">这里</a>查看抽象语法树结构），存储在css变量中。这个对象（Root对象）是这样子的，在子节点中包含所有规则<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Root &#123;</span><br><span class=\"line\">  raws: &#123; <span class=\"attr\">semicolon</span>: <span class=\"literal\">false</span>, <span class=\"attr\">after</span>: <span class=\"string\">'\\n\\n\\n'</span> &#125;,    <span class=\"comment\">// 是否包含分号，结尾内容</span></span><br><span class=\"line\">  type: <span class=\"string\">'root'</span>,                                   <span class=\"comment\">// 节点类型</span></span><br><span class=\"line\">  nodes: [</span><br><span class=\"line\">    Rule &#123;                                  <span class=\"comment\">// 子节点</span></span><br><span class=\"line\">      raws: [<span class=\"built_in\">Object</span>],</span><br><span class=\"line\">      type: <span class=\"string\">'rule'</span>,</span><br><span class=\"line\">      nodes: [<span class=\"built_in\">Object</span>],</span><br><span class=\"line\">      parent: [Circular],</span><br><span class=\"line\">      source: [<span class=\"built_in\">Object</span>],</span><br><span class=\"line\">      selector: <span class=\"string\">'body'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  source: &#123;</span><br><span class=\"line\">    input: Input &#123;</span><br><span class=\"line\">      css: <span class=\"string\">'\\nbody &#123;\\n  margin: 0;\\n&#125;\\n\\n\\n'</span>,</span><br><span class=\"line\">      file: <span class=\"string\">'/Users/huanqiu/Desktop/Fanz/postCssDemo/index.css'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    start: &#123; <span class=\"attr\">line</span>: <span class=\"number\">1</span>, <span class=\"attr\">column</span>: <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>之后，通过Root的walkRules可以遍历每一个子节点，也就是Rule对象，这里就是一条规则，在子节点中包含所有声明<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rule &#123;</span><br><span class=\"line\">  raws: &#123; <span class=\"attr\">before</span>: <span class=\"string\">'\\n'</span>, <span class=\"attr\">between</span>: <span class=\"string\">' '</span>, <span class=\"attr\">semicolon</span>: <span class=\"literal\">true</span>, <span class=\"attr\">after</span>: <span class=\"string\">'\\n'</span> &#125;,</span><br><span class=\"line\">  type: <span class=\"string\">'rule'</span>,</span><br><span class=\"line\">  nodes: [Declaration &#123;</span><br><span class=\"line\">    raws: [<span class=\"built_in\">Object</span>],</span><br><span class=\"line\">    type: <span class=\"string\">'decl'</span>,</span><br><span class=\"line\">    parent: [Circular],</span><br><span class=\"line\">    source: [<span class=\"built_in\">Object</span>],</span><br><span class=\"line\">    prop: <span class=\"string\">'margin'</span>,</span><br><span class=\"line\">    value: <span class=\"string\">'0'</span></span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\">  parent: Root &#123;</span><br><span class=\"line\">    raws: &#123; <span class=\"attr\">semicolon</span>: <span class=\"literal\">false</span>, <span class=\"attr\">after</span>: <span class=\"string\">'\\n\\n\\n'</span> &#125;,</span><br><span class=\"line\">    type: <span class=\"string\">'root'</span>,</span><br><span class=\"line\">    nodes: [</span><br><span class=\"line\">      [Circular]</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    source: &#123; <span class=\"attr\">input</span>: [<span class=\"built_in\">Object</span>], <span class=\"attr\">start</span>: [<span class=\"built_in\">Object</span>] &#125;,</span><br><span class=\"line\">    lastEach: <span class=\"number\">1</span>,</span><br><span class=\"line\">    indexes: &#123; <span class=\"string\">'1'</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  source: &#123;</span><br><span class=\"line\">    start: &#123; <span class=\"attr\">line</span>: <span class=\"number\">2</span>, <span class=\"attr\">column</span>: <span class=\"number\">1</span> &#125;,</span><br><span class=\"line\">    input: Input &#123;</span><br><span class=\"line\">      css: <span class=\"string\">'\\nbody &#123;\\n  margin: 0;\\n&#125;\\n\\n\\n'</span>,</span><br><span class=\"line\">      file: <span class=\"string\">'/Users/huanqiu/Desktop/Fanz/postCssDemo/index.css'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    end: &#123; <span class=\"attr\">line</span>: <span class=\"number\">4</span>, <span class=\"attr\">column</span>: <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  selector: <span class=\"string\">'body'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再之后，可以通过Rule对象的walkDecls拿到每一条声明。（通过Root直接使用walkDecls也可以直接拿到声明）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Declaration &#123;</span><br><span class=\"line\">  raws: &#123; <span class=\"attr\">before</span>: <span class=\"string\">'\\n  '</span>, <span class=\"attr\">between</span>: <span class=\"string\">': '</span> &#125;,</span><br><span class=\"line\">  type: <span class=\"string\">'decl'</span>,</span><br><span class=\"line\">  parent: </span><br><span class=\"line\">    Rule &#123;</span><br><span class=\"line\">     raws: &#123; <span class=\"attr\">before</span>: <span class=\"string\">'\\n'</span>, <span class=\"attr\">between</span>: <span class=\"string\">' '</span>, <span class=\"attr\">semicolon</span>: <span class=\"literal\">true</span>, <span class=\"attr\">after</span>: <span class=\"string\">'\\n'</span> &#125;,</span><br><span class=\"line\">     type: <span class=\"string\">'rule'</span>,</span><br><span class=\"line\">     nodes: [ [Circular] ],</span><br><span class=\"line\">     parent: </span><br><span class=\"line\">      Root &#123;</span><br><span class=\"line\">        raws: [<span class=\"built_in\">Object</span>],</span><br><span class=\"line\">        type: <span class=\"string\">'root'</span>,</span><br><span class=\"line\">        nodes: [<span class=\"built_in\">Object</span>],</span><br><span class=\"line\">        source: [<span class=\"built_in\">Object</span>],</span><br><span class=\"line\">        lastEach: <span class=\"number\">1</span>,</span><br><span class=\"line\">        indexes: [<span class=\"built_in\">Object</span>] &#125;,</span><br><span class=\"line\">     source: &#123; <span class=\"attr\">start</span>: [<span class=\"built_in\">Object</span>], <span class=\"attr\">input</span>: [<span class=\"built_in\">Object</span>], <span class=\"attr\">end</span>: [<span class=\"built_in\">Object</span>] &#125;,</span><br><span class=\"line\">     selector: <span class=\"string\">'body'</span>,</span><br><span class=\"line\">     lastEach: <span class=\"number\">1</span>,</span><br><span class=\"line\">     indexes: &#123; <span class=\"string\">'1'</span>: <span class=\"number\">0</span> &#125; </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  source: &#123; </span><br><span class=\"line\">    start: &#123; <span class=\"attr\">line</span>: <span class=\"number\">3</span>, <span class=\"attr\">column</span>: <span class=\"number\">3</span> &#125;,</span><br><span class=\"line\">    input: </span><br><span class=\"line\">      Input &#123;</span><br><span class=\"line\">        css: <span class=\"string\">'\\nbody &#123;\\n  margin: 0;\\n&#125;\\n\\n\\n'</span>,</span><br><span class=\"line\">        file: <span class=\"string\">'/Users/huanqiu/Desktop/Fanz/postCssDemo/index.css'</span> &#125;,</span><br><span class=\"line\">     end: &#123; <span class=\"attr\">line</span>: <span class=\"number\">3</span>, <span class=\"attr\">column</span>: <span class=\"number\">12</span> &#125; &#125;,</span><br><span class=\"line\">  prop: <span class=\"string\">'margin'</span>,</span><br><span class=\"line\">  value: <span class=\"string\">'0'</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在任何对象上，我们都可以通过PostCSS提供的API对CSS进行修改。比如实现一个简单的为transform添加-webkit-前缀功能，在walkDecls方法中传入下面方法作为参数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">decl, i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (decl.prop === <span class=\"string\">'transform'</span>) &#123;</span><br><span class=\"line\">    decl.before(<span class=\"string\">'-webkit-transform: '</span> + decl.value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>更多API可以参考<a href=\"http://api.postcss.org\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<p>在CSS中，有注释、CSS规则、规则中的声明以及媒体查询规则，分别对应PostCSS中的Comment、Rule、Declaration、AtRule对象。除此之外，还有Root对象可以用来表示整个CSS文件；Node对象是所有节点类型对象的祖先对象；Container对象是Root、Rule、AtRule的祖先对象；Result对象是PostCSS转换结果的对象，包含css、map等内容；Warning、CssSyntaxError等等。</p>\n"},{"title":"ES6初探","date":"2016-07-08T16:00:00.000Z","comments":1,"_content":"\nFrom [点击这里](http://mp.weixin.qq.com/s?__biz=MzAxMjA5ODQwMQ==&mid=2455058700&idx=1&sn=9361036ef5dc0c27cafb0612d495a85c)\n## ES6\n### 定义变量：let、const\n* let、const声明变量为块级作用域，var声明为函数作用域\n* let声明不具备变量提升，const声明具备\n* const用于声明常量，必须声明时赋值\n* let、const声明变量不能再次声明覆盖\n### 函数声明：箭头函数\n缘由\n\nps:\n```\n// 六种语言中的简单函数示例\nfunction (a) { return a > 0; } // JS\n[](int a) { return a > 0; }  // C++\n(lambda (a) (> a 0))  ;; Lisp\nlambda a: a > 0  # Python\na => a > 0  // C#\na -> a > 0  // Java\n```\n1. 情况一 a => a > 0   相当于 function(a) { return a > 0 }  tag:单个参数、直接返回\n2. 情况二 (a, b) => a + b  相当于 function(a, b) { return a + b }  tag:多个参数、直接返回\n3. 情况三 （a, b）=> { a + b ... }  相当于 function(a, b) { a + b ... } tag:函数体，返回需要自己写return语句\n4. 情况四  (a, b) => ({a: 'a'}) 相当于 function(a, b) { return {a: 'a'} } tab:直接返回对象，因为=>后面的{}会被理解为函数体，添加()才会被理解为对象\n\n* 箭头函数相当于匿名函数的简写\n* 箭头函数的this总是和外层函数的this指向相同。\n\teg.\n```javascript\n// ES5\nfunction Person() {\n  var self = this;\n  self.age = 0;\n\n  setInterval(function growUp() {\n  \t// this会指向windows\n  \t// 所以用self保存了this\n    self.age++;\n  }, 1000);\n}\n// ES6\nfunction Person(){\n  this.age = 0;\n\n  setInterval(() => {\n    // |this| 指向 person 对象\n    this.age++;\n  }, 1000);\n}\n\nvar person = new Person();\n```\n### for...of \n1. for...of  遍历数组,遍历字符串,对象没有该方法\n```javascript\nlet nicknames = ['di', 'boo', 'punkeye'];\nfor (let nickname of nicknames) {\n  console.log(nickname);\n}\nResult: di, boo, punkeye\n```\n2. for...in  遍历对象，数组也能够使用该方法\n```javascript\nlet nicknames = ['di', 'boo', 'punkeye'];\nnicknames.size = 3;\nfor (let nickname in nicknames) {\n  console.log(nickname); // 0 1 2 size\n}\n```\n### 类Class\n```javascript\n// ES5 定义类\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n// 相当于 ES6中\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  // 不需要添加function，方法和方法之间不能用逗号隔开\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\ntyof Point // function  说明Class只是一个语法糖\nPoint === Point.prototype.constructor // true\n```\n* new className()会自动调用constructor()\n* class定义的类只能通过new操作符，不能直接调用\n* 通过class只能定义在construtor中的共有属性，不能定义私有属性，定义的方法也都是相当于定义在prototype上的共有方法\n* 与ES5中定义在prototype不同在于不可枚举\n* 与ES5相同，所有实例共享原型。所以通过实例的__proto__属性可以为Class添加方法\n* 不存在变量提升，Class定义与ES5不同\n\n### 继承extends\n在使用extends继承时，子类的constructor中必须先调用super()方法，也就是父类的构造方法。\n\n### 对象超类\n```javascript\nvar parent = {\n  foo() {\n    console.log(\"Hello from the Parent\");\n  }\n}\n\nvar child = {\n  foo() {\n    super.foo();\n    console.log(\"Hello from the Child\");\n  }\n}\n\nObject.setPrototypeOf(child, parent); // ES6设置对象原型的方法\nchild.foo(); // Hello from the Parent\n             // Hello from the Child\n```\n### Promise\nPromise对象有三种状态：Pending、Resolved，Rejected，外界无法改变状态，状态一旦改变就不会再变。\n```javascript\nvar promise = new Promise(function(resolve, reject) {\n\t// ... some code\n\n\tif(/* 异步操作成功 */) {\n\t\tresolve(value);  // 将promise状态变为Resolved\n\t} else {\n\t\treject(error);\n\t}\n});\n\npromise.then(function(value) {\n\t// success\n}, function(error) {\n\t// failure\n})\n```\nps:\n\n一个用Promise实现Ajax操作的例子\n```javascript\nvar getJSON = function(url) {\n\tvar promise = new Promise(function(resolve, reject) {\n\t\tvar client = new XMLHttpRequest();\n\t\tclient.open('GET', url);\n\t\tclient.onreadystatechange = handler;\n\t\tclient.responseType = 'json';\n\t\tclient.setRequestHeader('Accept', 'application/json');\n\t\tclient.send();\n\n\t\tfunction handler() {\n\t\t\tif(this.readyState !== 4) {\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tif(this.status === 200) {\n\t\t\t\tresolve(this.response);\n\t\t\t} else {\n\t\t\t\treject(new Error(this.statusText));\n\t\t\t}\n\t\t};\n\t});\n\n\treturn promise;\n}\n```\n### 模板语法和分隔符\n```javascript\nlet user = 'Barret';\nconsole.log(`Hi ${user}!`); // Hi Barret\n```\n\n### 对象扩展\n```javascript\nfunction getCar(make, model, value) {\n  return {\n    // 简写变量\n    make,  // 等同于 make: make\n    model, // 等同于 model: model\n    value, // 等同于 value: value\n\n    // 属性可以使用表达式计算值\n    ['make' + make]: true,\n\n    // 忽略 `function` 关键词简写对象函数\n    depreciate() {\n      this.value -= 2500;\n    }\n  };\n}\n```\n### 对象和数组解构\n```javascript\nfunction foo() {\n  return [1,2,3];\n}\nlet arr = foo(); // [1,2,3]\n\nlet [a, b, c] = foo();\nconsole.log(a, b, c); // 1 2 3\n\nfunction bar() {\n  return {\n    x: 4,\n    y: 5,\n    z: 6\n  };\n}\nlet {x: x, y: y, z: z} = bar();\nconsole.log(x, y, z); // 4 5 6\n```\n### 迭代器\n通过[Symbol.iterator]()定义一个对象的迭代器\n```javascript\nvar arr = [11,12,13];\nvar itr = arr[Symbol.iterator]();\n\nitr.next(); // { value: 11, done: false }\nitr.next(); // { value: 12, done: false }\nitr.next(); // { value: 13, done: false }\n\nitr.next(); // { value: undefined, done: true }\n```\n\n### 扩展操作符...\n貌似只能用于参数传递\n1. 情况一 \n```javascript\nfunction foo(x,y,z) {\n  console.log(x,y,z);\n}\n\nlet arr = [1,2,3];\nfoo(...arr); // 1 2 3\n```\n2. 情况二\n```javascript\nfunction foo(...args) {\n  console.log(args);\n}\nfoo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]\n```","source":"_posts/ES6.md","raw":"---\ntitle: ES6初探\ndate: 2016-07-09\ntags: [JavaScript]\ncategories: \n- JavaScript\ncomments: true\n---\n\nFrom [点击这里](http://mp.weixin.qq.com/s?__biz=MzAxMjA5ODQwMQ==&mid=2455058700&idx=1&sn=9361036ef5dc0c27cafb0612d495a85c)\n## ES6\n### 定义变量：let、const\n* let、const声明变量为块级作用域，var声明为函数作用域\n* let声明不具备变量提升，const声明具备\n* const用于声明常量，必须声明时赋值\n* let、const声明变量不能再次声明覆盖\n### 函数声明：箭头函数\n缘由\n\nps:\n```\n// 六种语言中的简单函数示例\nfunction (a) { return a > 0; } // JS\n[](int a) { return a > 0; }  // C++\n(lambda (a) (> a 0))  ;; Lisp\nlambda a: a > 0  # Python\na => a > 0  // C#\na -> a > 0  // Java\n```\n1. 情况一 a => a > 0   相当于 function(a) { return a > 0 }  tag:单个参数、直接返回\n2. 情况二 (a, b) => a + b  相当于 function(a, b) { return a + b }  tag:多个参数、直接返回\n3. 情况三 （a, b）=> { a + b ... }  相当于 function(a, b) { a + b ... } tag:函数体，返回需要自己写return语句\n4. 情况四  (a, b) => ({a: 'a'}) 相当于 function(a, b) { return {a: 'a'} } tab:直接返回对象，因为=>后面的{}会被理解为函数体，添加()才会被理解为对象\n\n* 箭头函数相当于匿名函数的简写\n* 箭头函数的this总是和外层函数的this指向相同。\n\teg.\n```javascript\n// ES5\nfunction Person() {\n  var self = this;\n  self.age = 0;\n\n  setInterval(function growUp() {\n  \t// this会指向windows\n  \t// 所以用self保存了this\n    self.age++;\n  }, 1000);\n}\n// ES6\nfunction Person(){\n  this.age = 0;\n\n  setInterval(() => {\n    // |this| 指向 person 对象\n    this.age++;\n  }, 1000);\n}\n\nvar person = new Person();\n```\n### for...of \n1. for...of  遍历数组,遍历字符串,对象没有该方法\n```javascript\nlet nicknames = ['di', 'boo', 'punkeye'];\nfor (let nickname of nicknames) {\n  console.log(nickname);\n}\nResult: di, boo, punkeye\n```\n2. for...in  遍历对象，数组也能够使用该方法\n```javascript\nlet nicknames = ['di', 'boo', 'punkeye'];\nnicknames.size = 3;\nfor (let nickname in nicknames) {\n  console.log(nickname); // 0 1 2 size\n}\n```\n### 类Class\n```javascript\n// ES5 定义类\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n// 相当于 ES6中\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  // 不需要添加function，方法和方法之间不能用逗号隔开\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\ntyof Point // function  说明Class只是一个语法糖\nPoint === Point.prototype.constructor // true\n```\n* new className()会自动调用constructor()\n* class定义的类只能通过new操作符，不能直接调用\n* 通过class只能定义在construtor中的共有属性，不能定义私有属性，定义的方法也都是相当于定义在prototype上的共有方法\n* 与ES5中定义在prototype不同在于不可枚举\n* 与ES5相同，所有实例共享原型。所以通过实例的__proto__属性可以为Class添加方法\n* 不存在变量提升，Class定义与ES5不同\n\n### 继承extends\n在使用extends继承时，子类的constructor中必须先调用super()方法，也就是父类的构造方法。\n\n### 对象超类\n```javascript\nvar parent = {\n  foo() {\n    console.log(\"Hello from the Parent\");\n  }\n}\n\nvar child = {\n  foo() {\n    super.foo();\n    console.log(\"Hello from the Child\");\n  }\n}\n\nObject.setPrototypeOf(child, parent); // ES6设置对象原型的方法\nchild.foo(); // Hello from the Parent\n             // Hello from the Child\n```\n### Promise\nPromise对象有三种状态：Pending、Resolved，Rejected，外界无法改变状态，状态一旦改变就不会再变。\n```javascript\nvar promise = new Promise(function(resolve, reject) {\n\t// ... some code\n\n\tif(/* 异步操作成功 */) {\n\t\tresolve(value);  // 将promise状态变为Resolved\n\t} else {\n\t\treject(error);\n\t}\n});\n\npromise.then(function(value) {\n\t// success\n}, function(error) {\n\t// failure\n})\n```\nps:\n\n一个用Promise实现Ajax操作的例子\n```javascript\nvar getJSON = function(url) {\n\tvar promise = new Promise(function(resolve, reject) {\n\t\tvar client = new XMLHttpRequest();\n\t\tclient.open('GET', url);\n\t\tclient.onreadystatechange = handler;\n\t\tclient.responseType = 'json';\n\t\tclient.setRequestHeader('Accept', 'application/json');\n\t\tclient.send();\n\n\t\tfunction handler() {\n\t\t\tif(this.readyState !== 4) {\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tif(this.status === 200) {\n\t\t\t\tresolve(this.response);\n\t\t\t} else {\n\t\t\t\treject(new Error(this.statusText));\n\t\t\t}\n\t\t};\n\t});\n\n\treturn promise;\n}\n```\n### 模板语法和分隔符\n```javascript\nlet user = 'Barret';\nconsole.log(`Hi ${user}!`); // Hi Barret\n```\n\n### 对象扩展\n```javascript\nfunction getCar(make, model, value) {\n  return {\n    // 简写变量\n    make,  // 等同于 make: make\n    model, // 等同于 model: model\n    value, // 等同于 value: value\n\n    // 属性可以使用表达式计算值\n    ['make' + make]: true,\n\n    // 忽略 `function` 关键词简写对象函数\n    depreciate() {\n      this.value -= 2500;\n    }\n  };\n}\n```\n### 对象和数组解构\n```javascript\nfunction foo() {\n  return [1,2,3];\n}\nlet arr = foo(); // [1,2,3]\n\nlet [a, b, c] = foo();\nconsole.log(a, b, c); // 1 2 3\n\nfunction bar() {\n  return {\n    x: 4,\n    y: 5,\n    z: 6\n  };\n}\nlet {x: x, y: y, z: z} = bar();\nconsole.log(x, y, z); // 4 5 6\n```\n### 迭代器\n通过[Symbol.iterator]()定义一个对象的迭代器\n```javascript\nvar arr = [11,12,13];\nvar itr = arr[Symbol.iterator]();\n\nitr.next(); // { value: 11, done: false }\nitr.next(); // { value: 12, done: false }\nitr.next(); // { value: 13, done: false }\n\nitr.next(); // { value: undefined, done: true }\n```\n\n### 扩展操作符...\n貌似只能用于参数传递\n1. 情况一 \n```javascript\nfunction foo(x,y,z) {\n  console.log(x,y,z);\n}\n\nlet arr = [1,2,3];\nfoo(...arr); // 1 2 3\n```\n2. 情况二\n```javascript\nfunction foo(...args) {\n  console.log(args);\n}\nfoo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]\n```","slug":"ES6","published":1,"updated":"2017-12-28T03:47:32.453Z","layout":"post","photos":[],"link":"","_id":"cjks5i9hq000avmtieybk5n95","content":"<p>From <a href=\"http://mp.weixin.qq.com/s?__biz=MzAxMjA5ODQwMQ==&amp;mid=2455058700&amp;idx=1&amp;sn=9361036ef5dc0c27cafb0612d495a85c\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n<h2 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h2><h3 id=\"定义变量：let、const\"><a href=\"#定义变量：let、const\" class=\"headerlink\" title=\"定义变量：let、const\"></a>定义变量：let、const</h3><ul>\n<li>let、const声明变量为块级作用域，var声明为函数作用域</li>\n<li>let声明不具备变量提升，const声明具备</li>\n<li>const用于声明常量，必须声明时赋值</li>\n<li>let、const声明变量不能再次声明覆盖<h3 id=\"函数声明：箭头函数\"><a href=\"#函数声明：箭头函数\" class=\"headerlink\" title=\"函数声明：箭头函数\"></a>函数声明：箭头函数</h3>缘由</li>\n</ul>\n<p>ps:<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 六种语言中的简单函数示例</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(a)</span> <span class=\"comment\">&#123; return a &gt; 0; &#125;</span> <span class=\"comment\">// JS</span></span></span><br><span class=\"line\"><span class=\"function\">[]<span class=\"params\">(int a)</span> <span class=\"comment\">&#123; return a &gt; 0; &#125;</span>  <span class=\"comment\">// C++</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(lambda (a)</span> <span class=\"params\">(&gt; a 0)</span>)  ;</span>; Lisp</span><br><span class=\"line\">lambda a: a &gt; <span class=\"number\">0</span>  # Python</span><br><span class=\"line\">a =&gt; a &gt; <span class=\"number\">0</span>  <span class=\"comment\">// C#</span></span><br><span class=\"line\">a -&gt; a &gt; <span class=\"number\">0</span>  <span class=\"comment\">// Java</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>情况一 a =&gt; a &gt; 0   相当于 function(a) { return a &gt; 0 }  tag:单个参数、直接返回</li>\n<li>情况二 (a, b) =&gt; a + b  相当于 function(a, b) { return a + b }  tag:多个参数、直接返回</li>\n<li>情况三 （a, b）=&gt; { a + b … }  相当于 function(a, b) { a + b … } tag:函数体，返回需要自己写return语句</li>\n<li>情况四  (a, b) =&gt; ({a: ‘a’}) 相当于 function(a, b) { return {a: ‘a’} } tab:直接返回对象，因为=&gt;后面的{}会被理解为函数体，添加()才会被理解为对象</li>\n</ol>\n<ul>\n<li>箭头函数相当于匿名函数的简写</li>\n<li>箭头函数的this总是和外层函数的this指向相同。<br>  eg.<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  self.age = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  setInterval(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">growUp</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// this会指向windows</span></span><br><span class=\"line\">  \t<span class=\"comment\">// 所以用self保存了this</span></span><br><span class=\"line\">    self.age++;</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  setInterval(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// |this| 指向 person 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age++;</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"for…of\"><a href=\"#for…of\" class=\"headerlink\" title=\"for…of\"></a>for…of</h3><ol>\n<li><p>for…of  遍历数组,遍历字符串,对象没有该方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nicknames = [<span class=\"string\">'di'</span>, <span class=\"string\">'boo'</span>, <span class=\"string\">'punkeye'</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> nickname <span class=\"keyword\">of</span> nicknames) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(nickname);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Result: di, boo, punkeye</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>for…in  遍历对象，数组也能够使用该方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nicknames = [<span class=\"string\">'di'</span>, <span class=\"string\">'boo'</span>, <span class=\"string\">'punkeye'</span>];</span><br><span class=\"line\">nicknames.size = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> nickname <span class=\"keyword\">in</span> nicknames) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(nickname); <span class=\"comment\">// 0 1 2 size</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"类Class\"><a href=\"#类Class\" class=\"headerlink\" title=\"类Class\"></a>类Class</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5 定义类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 相当于 ES6中</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 不需要添加function，方法和方法之间不能用逗号隔开</span></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">tyof Point <span class=\"comment\">// function  说明Class只是一个语法糖</span></span><br><span class=\"line\">Point === Point.prototype.constructor <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>new className()会自动调用constructor()</li>\n<li>class定义的类只能通过new操作符，不能直接调用</li>\n<li>通过class只能定义在construtor中的共有属性，不能定义私有属性，定义的方法也都是相当于定义在prototype上的共有方法</li>\n<li>与ES5中定义在prototype不同在于不可枚举</li>\n<li>与ES5相同，所有实例共享原型。所以通过实例的<strong>proto</strong>属性可以为Class添加方法</li>\n<li>不存在变量提升，Class定义与ES5不同</li>\n</ul>\n<h3 id=\"继承extends\"><a href=\"#继承extends\" class=\"headerlink\" title=\"继承extends\"></a>继承extends</h3><p>在使用extends继承时，子类的constructor中必须先调用super()方法，也就是父类的构造方法。</p>\n<h3 id=\"对象超类\"><a href=\"#对象超类\" class=\"headerlink\" title=\"对象超类\"></a>对象超类</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parent = &#123;</span><br><span class=\"line\">  foo() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello from the Parent\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> child = &#123;</span><br><span class=\"line\">  foo() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.foo();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello from the Child\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(child, parent); <span class=\"comment\">// ES6设置对象原型的方法</span></span><br><span class=\"line\">child.foo(); <span class=\"comment\">// Hello from the Parent</span></span><br><span class=\"line\">             <span class=\"comment\">// Hello from the Child</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>Promise对象有三种状态：Pending、Resolved，Rejected，外界无法改变状态，状态一旦改变就不会再变。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ... some code</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"comment\">/* 异步操作成功 */</span>) &#123;</span><br><span class=\"line\">\t\tresolve(value);  <span class=\"comment\">// 将promise状态变为Resolved</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\treject(error);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>ps:</p>\n<p>一个用Promise实现Ajax操作的例子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getJSON = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> client = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">\t\tclient.open(<span class=\"string\">'GET'</span>, url);</span><br><span class=\"line\">\t\tclient.onreadystatechange = handler;</span><br><span class=\"line\">\t\tclient.responseType = <span class=\"string\">'json'</span>;</span><br><span class=\"line\">\t\tclient.setRequestHeader(<span class=\"string\">'Accept'</span>, <span class=\"string\">'application/json'</span>);</span><br><span class=\"line\">\t\tclient.send();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.readyState !== <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">\t\t\t\tresolve(<span class=\"keyword\">this</span>.response);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\treject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"keyword\">this</span>.statusText));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"模板语法和分隔符\"><a href=\"#模板语法和分隔符\" class=\"headerlink\" title=\"模板语法和分隔符\"></a>模板语法和分隔符</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"string\">'Barret'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi <span class=\"subst\">$&#123;user&#125;</span>!`</span>); <span class=\"comment\">// Hi Barret</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"对象扩展\"><a href=\"#对象扩展\" class=\"headerlink\" title=\"对象扩展\"></a>对象扩展</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCar</span>(<span class=\"params\">make, model, value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 简写变量</span></span><br><span class=\"line\">    make,  <span class=\"comment\">// 等同于 make: make</span></span><br><span class=\"line\">    model, <span class=\"comment\">// 等同于 model: model</span></span><br><span class=\"line\">    value, <span class=\"comment\">// 等同于 value: value</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 属性可以使用表达式计算值</span></span><br><span class=\"line\">    [<span class=\"string\">'make'</span> + make]: <span class=\"literal\">true</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 忽略 `function` 关键词简写对象函数</span></span><br><span class=\"line\">    depreciate() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.value -= <span class=\"number\">2500</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象和数组解构\"><a href=\"#对象和数组解构\" class=\"headerlink\" title=\"对象和数组解构\"></a>对象和数组解构</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = foo(); <span class=\"comment\">// [1,2,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c] = foo();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b, c); <span class=\"comment\">// 1 2 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    x: <span class=\"number\">4</span>,</span><br><span class=\"line\">    y: <span class=\"number\">5</span>,</span><br><span class=\"line\">    z: <span class=\"number\">6</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">x</span>: x, <span class=\"attr\">y</span>: y, <span class=\"attr\">z</span>: z&#125; = bar();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x, y, z); <span class=\"comment\">// 4 5 6</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>通过<a href=\"\">Symbol.iterator</a>定义一个对象的迭代器<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">13</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> itr = arr[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\"></span><br><span class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: 11, done: false &#125;</span></span><br><span class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: 12, done: false &#125;</span></span><br><span class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: 13, done: false &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"扩展操作符…\"><a href=\"#扩展操作符…\" class=\"headerlink\" title=\"扩展操作符…\"></a>扩展操作符…</h3><p>貌似只能用于参数传递</p>\n<ol>\n<li><p>情况一 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x,y,z</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x,y,z);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">foo(...arr); <span class=\"comment\">// 1 2 3</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>情况二</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo( <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>); <span class=\"comment\">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>From <a href=\"http://mp.weixin.qq.com/s?__biz=MzAxMjA5ODQwMQ==&amp;mid=2455058700&amp;idx=1&amp;sn=9361036ef5dc0c27cafb0612d495a85c\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n<h2 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h2><h3 id=\"定义变量：let、const\"><a href=\"#定义变量：let、const\" class=\"headerlink\" title=\"定义变量：let、const\"></a>定义变量：let、const</h3><ul>\n<li>let、const声明变量为块级作用域，var声明为函数作用域</li>\n<li>let声明不具备变量提升，const声明具备</li>\n<li>const用于声明常量，必须声明时赋值</li>\n<li>let、const声明变量不能再次声明覆盖<h3 id=\"函数声明：箭头函数\"><a href=\"#函数声明：箭头函数\" class=\"headerlink\" title=\"函数声明：箭头函数\"></a>函数声明：箭头函数</h3>缘由</li>\n</ul>\n<p>ps:<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 六种语言中的简单函数示例</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(a)</span> <span class=\"comment\">&#123; return a &gt; 0; &#125;</span> <span class=\"comment\">// JS</span></span></span><br><span class=\"line\"><span class=\"function\">[]<span class=\"params\">(int a)</span> <span class=\"comment\">&#123; return a &gt; 0; &#125;</span>  <span class=\"comment\">// C++</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(lambda (a)</span> <span class=\"params\">(&gt; a 0)</span>)  ;</span>; Lisp</span><br><span class=\"line\">lambda a: a &gt; <span class=\"number\">0</span>  # Python</span><br><span class=\"line\">a =&gt; a &gt; <span class=\"number\">0</span>  <span class=\"comment\">// C#</span></span><br><span class=\"line\">a -&gt; a &gt; <span class=\"number\">0</span>  <span class=\"comment\">// Java</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>情况一 a =&gt; a &gt; 0   相当于 function(a) { return a &gt; 0 }  tag:单个参数、直接返回</li>\n<li>情况二 (a, b) =&gt; a + b  相当于 function(a, b) { return a + b }  tag:多个参数、直接返回</li>\n<li>情况三 （a, b）=&gt; { a + b … }  相当于 function(a, b) { a + b … } tag:函数体，返回需要自己写return语句</li>\n<li>情况四  (a, b) =&gt; ({a: ‘a’}) 相当于 function(a, b) { return {a: ‘a’} } tab:直接返回对象，因为=&gt;后面的{}会被理解为函数体，添加()才会被理解为对象</li>\n</ol>\n<ul>\n<li>箭头函数相当于匿名函数的简写</li>\n<li>箭头函数的this总是和外层函数的this指向相同。<br>  eg.<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  self.age = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  setInterval(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">growUp</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// this会指向windows</span></span><br><span class=\"line\">  \t<span class=\"comment\">// 所以用self保存了this</span></span><br><span class=\"line\">    self.age++;</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  setInterval(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// |this| 指向 person 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age++;</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"for…of\"><a href=\"#for…of\" class=\"headerlink\" title=\"for…of\"></a>for…of</h3><ol>\n<li><p>for…of  遍历数组,遍历字符串,对象没有该方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nicknames = [<span class=\"string\">'di'</span>, <span class=\"string\">'boo'</span>, <span class=\"string\">'punkeye'</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> nickname <span class=\"keyword\">of</span> nicknames) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(nickname);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Result: di, boo, punkeye</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>for…in  遍历对象，数组也能够使用该方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nicknames = [<span class=\"string\">'di'</span>, <span class=\"string\">'boo'</span>, <span class=\"string\">'punkeye'</span>];</span><br><span class=\"line\">nicknames.size = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> nickname <span class=\"keyword\">in</span> nicknames) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(nickname); <span class=\"comment\">// 0 1 2 size</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"类Class\"><a href=\"#类Class\" class=\"headerlink\" title=\"类Class\"></a>类Class</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5 定义类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 相当于 ES6中</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 不需要添加function，方法和方法之间不能用逗号隔开</span></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">tyof Point <span class=\"comment\">// function  说明Class只是一个语法糖</span></span><br><span class=\"line\">Point === Point.prototype.constructor <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>new className()会自动调用constructor()</li>\n<li>class定义的类只能通过new操作符，不能直接调用</li>\n<li>通过class只能定义在construtor中的共有属性，不能定义私有属性，定义的方法也都是相当于定义在prototype上的共有方法</li>\n<li>与ES5中定义在prototype不同在于不可枚举</li>\n<li>与ES5相同，所有实例共享原型。所以通过实例的<strong>proto</strong>属性可以为Class添加方法</li>\n<li>不存在变量提升，Class定义与ES5不同</li>\n</ul>\n<h3 id=\"继承extends\"><a href=\"#继承extends\" class=\"headerlink\" title=\"继承extends\"></a>继承extends</h3><p>在使用extends继承时，子类的constructor中必须先调用super()方法，也就是父类的构造方法。</p>\n<h3 id=\"对象超类\"><a href=\"#对象超类\" class=\"headerlink\" title=\"对象超类\"></a>对象超类</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parent = &#123;</span><br><span class=\"line\">  foo() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello from the Parent\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> child = &#123;</span><br><span class=\"line\">  foo() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.foo();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello from the Child\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(child, parent); <span class=\"comment\">// ES6设置对象原型的方法</span></span><br><span class=\"line\">child.foo(); <span class=\"comment\">// Hello from the Parent</span></span><br><span class=\"line\">             <span class=\"comment\">// Hello from the Child</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>Promise对象有三种状态：Pending、Resolved，Rejected，外界无法改变状态，状态一旦改变就不会再变。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ... some code</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"comment\">/* 异步操作成功 */</span>) &#123;</span><br><span class=\"line\">\t\tresolve(value);  <span class=\"comment\">// 将promise状态变为Resolved</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\treject(error);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>ps:</p>\n<p>一个用Promise实现Ajax操作的例子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getJSON = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> client = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">\t\tclient.open(<span class=\"string\">'GET'</span>, url);</span><br><span class=\"line\">\t\tclient.onreadystatechange = handler;</span><br><span class=\"line\">\t\tclient.responseType = <span class=\"string\">'json'</span>;</span><br><span class=\"line\">\t\tclient.setRequestHeader(<span class=\"string\">'Accept'</span>, <span class=\"string\">'application/json'</span>);</span><br><span class=\"line\">\t\tclient.send();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.readyState !== <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">\t\t\t\tresolve(<span class=\"keyword\">this</span>.response);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\treject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"keyword\">this</span>.statusText));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"模板语法和分隔符\"><a href=\"#模板语法和分隔符\" class=\"headerlink\" title=\"模板语法和分隔符\"></a>模板语法和分隔符</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"string\">'Barret'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi <span class=\"subst\">$&#123;user&#125;</span>!`</span>); <span class=\"comment\">// Hi Barret</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"对象扩展\"><a href=\"#对象扩展\" class=\"headerlink\" title=\"对象扩展\"></a>对象扩展</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCar</span>(<span class=\"params\">make, model, value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 简写变量</span></span><br><span class=\"line\">    make,  <span class=\"comment\">// 等同于 make: make</span></span><br><span class=\"line\">    model, <span class=\"comment\">// 等同于 model: model</span></span><br><span class=\"line\">    value, <span class=\"comment\">// 等同于 value: value</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 属性可以使用表达式计算值</span></span><br><span class=\"line\">    [<span class=\"string\">'make'</span> + make]: <span class=\"literal\">true</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 忽略 `function` 关键词简写对象函数</span></span><br><span class=\"line\">    depreciate() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.value -= <span class=\"number\">2500</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象和数组解构\"><a href=\"#对象和数组解构\" class=\"headerlink\" title=\"对象和数组解构\"></a>对象和数组解构</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = foo(); <span class=\"comment\">// [1,2,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c] = foo();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, b, c); <span class=\"comment\">// 1 2 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    x: <span class=\"number\">4</span>,</span><br><span class=\"line\">    y: <span class=\"number\">5</span>,</span><br><span class=\"line\">    z: <span class=\"number\">6</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">x</span>: x, <span class=\"attr\">y</span>: y, <span class=\"attr\">z</span>: z&#125; = bar();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x, y, z); <span class=\"comment\">// 4 5 6</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>通过<a href=\"\">Symbol.iterator</a>定义一个对象的迭代器<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">13</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> itr = arr[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\"></span><br><span class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: 11, done: false &#125;</span></span><br><span class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: 12, done: false &#125;</span></span><br><span class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: 13, done: false &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"扩展操作符…\"><a href=\"#扩展操作符…\" class=\"headerlink\" title=\"扩展操作符…\"></a>扩展操作符…</h3><p>貌似只能用于参数传递</p>\n<ol>\n<li><p>情况一 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x,y,z</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x,y,z);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">foo(...arr); <span class=\"comment\">// 1 2 3</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>情况二</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo( <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>); <span class=\"comment\">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"Flutter正在加载的实现","date":"2018-08-12T16:00:00.000Z","comments":1,"_content":"\n\n以登录页面跳转为例，实现接口请求以及正在加载页面效果。\n\n因为web大家都比较熟悉，就以最简单的方式简单描述一下。\n\nflutter可能比较多的点是需要注意的。\n\n### web中的实现\n\n界面的实现主要通过`position`来将正在加载页面显示在登录表单前面。代码大致如下：\n```css\n.wrap-loading {\n    /* 遮盖整页，并添加背景色 */\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background: rgba(255, 255, 255, .5);\n    \n    /* 居中 */\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n```\n逻辑主要是就显示加载页面-请求完成-隐藏加载页面。代码大致如下：\n```javascript\nfunction toLogin () {\n    $('.wrap.loading').show()\n    $.ajax({\n        url: url,\n        success: function (data) {\n            $('.warp.loading').hide()\n            if (success) {\n                enterHome()\n            } else {\n                showError()\n            }\n        }\n    })\n}\n```\n\n### flutter中的实现\n\n首先还是界面的实现。\n\n实现正在加载页肯定是有许多种方式的，其中最佳的方式应该就是通过`FutureBuilder`（初学dart和flutter，组件是最佳实践，代码是个人目前的能力）。\n\n`FutureBuilder`的官方文档在[这里](https://docs.flutter.io/flutter/widgets/FutureBuilder-class.html)，简单来说的话，就是他可以通过`Future`的状态，显示不同的组件，主要用的构造属性也就是`future`和`builder`。\n\n考虑页面的状态，应该包括还未发送请求状态、请求已发送还未返回的状态、以及请求成功的状态。\n\n在`FutureBuilder`中的`builder`回调函数中，参数为`context`和`AsyncSnapshot`，其中`AsyncSnapshot`包含属性`connectionState`可以用于判断链接的当前状态。\n\n代码大致如下：\n```dart\n// FutureBuilder中的future需要点击登录之后赋值，所以需要StatefulWidget\n\nclass LoginScreen extends StatefulWidget {\n  @override\n    State<StatefulWidget> createState() {\n      return LoginScreenState();\n    }\n}\n\nclass LoginScreenState extends State<LoginScreen> {\n\n  Future<Response> _loginFuture;\n\n  _toHomeScreen (context) {\n    Navigator.of(context).pushAndRemoveUntil(\n      MaterialPageRoute(\n        builder: (context) => HomeScreen()\n      ), (route) => false);\n  }\n\n  _fetchLogin (username, password) {\n    // 发送请求，调用setState，使得重新渲染\n    setState(() {\n      _loginFuture = http.post(\n        baseUrl + loginUrl,\n        body: {\n          username: username,\n          password: password\n        }\n      );\n    });\n    return _loginFuture;\n  }\n\n  // 返回加载，或什么也不显示\n  _showLoading (isShow) {\n    if (isShow) {\n      return Center(\n        child: FullScreenLoading(),\n      );\n    } else {\n      return Center();\n    }\n  }\n\n  @override\n    Widget build(BuildContext context) {\n      return FutureBuilder(\n        // _loginFuture状态改变，就会重新渲染\n        future: _loginFuture,\n        builder: (context, snapshot) {\n          print(snapshot.connectionState);\n          // Stack叠加组件，这里相当于上面web代码中position: absolute的作用\n          return Stack(\n            children: <Widget>[\n              Scaffold(\n                body: Container(\n                  padding: const EdgeInsets.all(20.0),\n                  child: Column(\n                    mainAxisAlignment: MainAxisAlignment.center,\n                    children: <Widget>[\n                      LoginForm(_fetchLogin, success: _toHomeScreen),\n                    ],\n                  )\n                ),\n                bottomNavigationBar: Container(\n                  margin: const EdgeInsets.only(bottom: 20.0),\n                  child: BottomLinksBar(),\n                )\n              ),\n              // 根据状态不同，显示不同\n              _showLoading(snapshot.connectionState == ConnectionState.waiting)\n            ],\n          );\n        },\n      );\n    }\n\n}\n\n```\n\n 在dart中，异步编程主要是在`dart:async`中，包括`Future`和`Stream`等类，这次主要用到的是`Future`，`Futrue`是一个很类似于JavaScript中的`Promise`的存在。\n ","source":"_posts/Flutter正在加载的实现.md","raw":"---\ntitle: Flutter正在加载的实现\ndate: 2018-08-13\ntags: [移动端, Flutter]\ncategories: \n- 移动端\ncomments: true\n---\n\n\n以登录页面跳转为例，实现接口请求以及正在加载页面效果。\n\n因为web大家都比较熟悉，就以最简单的方式简单描述一下。\n\nflutter可能比较多的点是需要注意的。\n\n### web中的实现\n\n界面的实现主要通过`position`来将正在加载页面显示在登录表单前面。代码大致如下：\n```css\n.wrap-loading {\n    /* 遮盖整页，并添加背景色 */\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background: rgba(255, 255, 255, .5);\n    \n    /* 居中 */\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n```\n逻辑主要是就显示加载页面-请求完成-隐藏加载页面。代码大致如下：\n```javascript\nfunction toLogin () {\n    $('.wrap.loading').show()\n    $.ajax({\n        url: url,\n        success: function (data) {\n            $('.warp.loading').hide()\n            if (success) {\n                enterHome()\n            } else {\n                showError()\n            }\n        }\n    })\n}\n```\n\n### flutter中的实现\n\n首先还是界面的实现。\n\n实现正在加载页肯定是有许多种方式的，其中最佳的方式应该就是通过`FutureBuilder`（初学dart和flutter，组件是最佳实践，代码是个人目前的能力）。\n\n`FutureBuilder`的官方文档在[这里](https://docs.flutter.io/flutter/widgets/FutureBuilder-class.html)，简单来说的话，就是他可以通过`Future`的状态，显示不同的组件，主要用的构造属性也就是`future`和`builder`。\n\n考虑页面的状态，应该包括还未发送请求状态、请求已发送还未返回的状态、以及请求成功的状态。\n\n在`FutureBuilder`中的`builder`回调函数中，参数为`context`和`AsyncSnapshot`，其中`AsyncSnapshot`包含属性`connectionState`可以用于判断链接的当前状态。\n\n代码大致如下：\n```dart\n// FutureBuilder中的future需要点击登录之后赋值，所以需要StatefulWidget\n\nclass LoginScreen extends StatefulWidget {\n  @override\n    State<StatefulWidget> createState() {\n      return LoginScreenState();\n    }\n}\n\nclass LoginScreenState extends State<LoginScreen> {\n\n  Future<Response> _loginFuture;\n\n  _toHomeScreen (context) {\n    Navigator.of(context).pushAndRemoveUntil(\n      MaterialPageRoute(\n        builder: (context) => HomeScreen()\n      ), (route) => false);\n  }\n\n  _fetchLogin (username, password) {\n    // 发送请求，调用setState，使得重新渲染\n    setState(() {\n      _loginFuture = http.post(\n        baseUrl + loginUrl,\n        body: {\n          username: username,\n          password: password\n        }\n      );\n    });\n    return _loginFuture;\n  }\n\n  // 返回加载，或什么也不显示\n  _showLoading (isShow) {\n    if (isShow) {\n      return Center(\n        child: FullScreenLoading(),\n      );\n    } else {\n      return Center();\n    }\n  }\n\n  @override\n    Widget build(BuildContext context) {\n      return FutureBuilder(\n        // _loginFuture状态改变，就会重新渲染\n        future: _loginFuture,\n        builder: (context, snapshot) {\n          print(snapshot.connectionState);\n          // Stack叠加组件，这里相当于上面web代码中position: absolute的作用\n          return Stack(\n            children: <Widget>[\n              Scaffold(\n                body: Container(\n                  padding: const EdgeInsets.all(20.0),\n                  child: Column(\n                    mainAxisAlignment: MainAxisAlignment.center,\n                    children: <Widget>[\n                      LoginForm(_fetchLogin, success: _toHomeScreen),\n                    ],\n                  )\n                ),\n                bottomNavigationBar: Container(\n                  margin: const EdgeInsets.only(bottom: 20.0),\n                  child: BottomLinksBar(),\n                )\n              ),\n              // 根据状态不同，显示不同\n              _showLoading(snapshot.connectionState == ConnectionState.waiting)\n            ],\n          );\n        },\n      );\n    }\n\n}\n\n```\n\n 在dart中，异步编程主要是在`dart:async`中，包括`Future`和`Stream`等类，这次主要用到的是`Future`，`Futrue`是一个很类似于JavaScript中的`Promise`的存在。\n ","slug":"Flutter正在加载的实现","published":1,"updated":"2018-08-13T07:49:31.862Z","layout":"post","photos":[],"link":"","_id":"cjks5i9ht000dvmtievn4mtvx","content":"<p>以登录页面跳转为例，实现接口请求以及正在加载页面效果。</p>\n<p>因为web大家都比较熟悉，就以最简单的方式简单描述一下。</p>\n<p>flutter可能比较多的点是需要注意的。</p>\n<h3 id=\"web中的实现\"><a href=\"#web中的实现\" class=\"headerlink\" title=\"web中的实现\"></a>web中的实现</h3><p>界面的实现主要通过<code>position</code>来将正在加载页面显示在登录表单前面。代码大致如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.wrap-loading</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 遮盖整页，并添加背景色 */</span></span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">rgba</span>(255, 255, 255, .5);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* 居中 */</span></span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>逻辑主要是就显示加载页面-请求完成-隐藏加载页面。代码大致如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toLogin</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    $(<span class=\"string\">'.wrap.loading'</span>).show()</span><br><span class=\"line\">    $.ajax(&#123;</span><br><span class=\"line\">        url: url,</span><br><span class=\"line\">        success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            $(<span class=\"string\">'.warp.loading'</span>).hide()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (success) &#123;</span><br><span class=\"line\">                enterHome()</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                showError()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"flutter中的实现\"><a href=\"#flutter中的实现\" class=\"headerlink\" title=\"flutter中的实现\"></a>flutter中的实现</h3><p>首先还是界面的实现。</p>\n<p>实现正在加载页肯定是有许多种方式的，其中最佳的方式应该就是通过<code>FutureBuilder</code>（初学dart和flutter，组件是最佳实践，代码是个人目前的能力）。</p>\n<p><code>FutureBuilder</code>的官方文档在<a href=\"https://docs.flutter.io/flutter/widgets/FutureBuilder-class.html\" target=\"_blank\" rel=\"noopener\">这里</a>，简单来说的话，就是他可以通过<code>Future</code>的状态，显示不同的组件，主要用的构造属性也就是<code>future</code>和<code>builder</code>。</p>\n<p>考虑页面的状态，应该包括还未发送请求状态、请求已发送还未返回的状态、以及请求成功的状态。</p>\n<p>在<code>FutureBuilder</code>中的<code>builder</code>回调函数中，参数为<code>context</code>和<code>AsyncSnapshot</code>，其中<code>AsyncSnapshot</code>包含属性<code>connectionState</code>可以用于判断链接的当前状态。</p>\n<p>代码大致如下：<br><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// FutureBuilder中的future需要点击登录之后赋值，所以需要StatefulWidget</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginScreen</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">    State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> LoginScreenState();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginScreenState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">LoginScreen</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  Future&lt;Response&gt; _loginFuture;</span><br><span class=\"line\"></span><br><span class=\"line\">  _toHomeScreen (context) &#123;</span><br><span class=\"line\">    Navigator.of(context).pushAndRemoveUntil(</span><br><span class=\"line\">      MaterialPageRoute(</span><br><span class=\"line\">        builder: (context) =&gt; HomeScreen()</span><br><span class=\"line\">      ), (route) =&gt; <span class=\"keyword\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  _fetchLogin (username, password) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发送请求，调用setState，使得重新渲染</span></span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      _loginFuture = http.post(</span><br><span class=\"line\">        baseUrl + loginUrl,</span><br><span class=\"line\">        body: &#123;</span><br><span class=\"line\">          username: username,</span><br><span class=\"line\">          password: password</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _loginFuture;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 返回加载，或什么也不显示</span></span><br><span class=\"line\">  _showLoading (isShow) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isShow) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Center(</span><br><span class=\"line\">        child: FullScreenLoading(),</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Center();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">    Widget build(BuildContext context) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> FutureBuilder(</span><br><span class=\"line\">        <span class=\"comment\">// _loginFuture状态改变，就会重新渲染</span></span><br><span class=\"line\">        future: _loginFuture,</span><br><span class=\"line\">        builder: (context, snapshot) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">print</span>(snapshot.connectionState);</span><br><span class=\"line\">          <span class=\"comment\">// Stack叠加组件，这里相当于上面web代码中position: absolute的作用</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> Stack(</span><br><span class=\"line\">            children: &lt;Widget&gt;[</span><br><span class=\"line\">              Scaffold(</span><br><span class=\"line\">                body: Container(</span><br><span class=\"line\">                  padding: <span class=\"keyword\">const</span> EdgeInsets.all(<span class=\"number\">20.0</span>),</span><br><span class=\"line\">                  child: Column(</span><br><span class=\"line\">                    mainAxisAlignment: MainAxisAlignment.center,</span><br><span class=\"line\">                    children: &lt;Widget&gt;[</span><br><span class=\"line\">                      LoginForm(_fetchLogin, success: _toHomeScreen),</span><br><span class=\"line\">                    ],</span><br><span class=\"line\">                  )</span><br><span class=\"line\">                ),</span><br><span class=\"line\">                bottomNavigationBar: Container(</span><br><span class=\"line\">                  margin: <span class=\"keyword\">const</span> EdgeInsets.only(bottom: <span class=\"number\">20.0</span>),</span><br><span class=\"line\">                  child: BottomLinksBar(),</span><br><span class=\"line\">                )</span><br><span class=\"line\">              ),</span><br><span class=\"line\">              <span class=\"comment\">// 根据状态不同，显示不同</span></span><br><span class=\"line\">              _showLoading(snapshot.connectionState == ConnectionState.waiting)</span><br><span class=\"line\">            ],</span><br><span class=\"line\">          );</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> 在dart中，异步编程主要是在<code>dart:async</code>中，包括<code>Future</code>和<code>Stream</code>等类，这次主要用到的是<code>Future</code>，<code>Futrue</code>是一个很类似于JavaScript中的<code>Promise</code>的存在。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>以登录页面跳转为例，实现接口请求以及正在加载页面效果。</p>\n<p>因为web大家都比较熟悉，就以最简单的方式简单描述一下。</p>\n<p>flutter可能比较多的点是需要注意的。</p>\n<h3 id=\"web中的实现\"><a href=\"#web中的实现\" class=\"headerlink\" title=\"web中的实现\"></a>web中的实现</h3><p>界面的实现主要通过<code>position</code>来将正在加载页面显示在登录表单前面。代码大致如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.wrap-loading</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 遮盖整页，并添加背景色 */</span></span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">rgba</span>(255, 255, 255, .5);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* 居中 */</span></span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>逻辑主要是就显示加载页面-请求完成-隐藏加载页面。代码大致如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toLogin</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    $(<span class=\"string\">'.wrap.loading'</span>).show()</span><br><span class=\"line\">    $.ajax(&#123;</span><br><span class=\"line\">        url: url,</span><br><span class=\"line\">        success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            $(<span class=\"string\">'.warp.loading'</span>).hide()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (success) &#123;</span><br><span class=\"line\">                enterHome()</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                showError()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"flutter中的实现\"><a href=\"#flutter中的实现\" class=\"headerlink\" title=\"flutter中的实现\"></a>flutter中的实现</h3><p>首先还是界面的实现。</p>\n<p>实现正在加载页肯定是有许多种方式的，其中最佳的方式应该就是通过<code>FutureBuilder</code>（初学dart和flutter，组件是最佳实践，代码是个人目前的能力）。</p>\n<p><code>FutureBuilder</code>的官方文档在<a href=\"https://docs.flutter.io/flutter/widgets/FutureBuilder-class.html\" target=\"_blank\" rel=\"noopener\">这里</a>，简单来说的话，就是他可以通过<code>Future</code>的状态，显示不同的组件，主要用的构造属性也就是<code>future</code>和<code>builder</code>。</p>\n<p>考虑页面的状态，应该包括还未发送请求状态、请求已发送还未返回的状态、以及请求成功的状态。</p>\n<p>在<code>FutureBuilder</code>中的<code>builder</code>回调函数中，参数为<code>context</code>和<code>AsyncSnapshot</code>，其中<code>AsyncSnapshot</code>包含属性<code>connectionState</code>可以用于判断链接的当前状态。</p>\n<p>代码大致如下：<br><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// FutureBuilder中的future需要点击登录之后赋值，所以需要StatefulWidget</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginScreen</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">    State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> LoginScreenState();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginScreenState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">LoginScreen</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  Future&lt;Response&gt; _loginFuture;</span><br><span class=\"line\"></span><br><span class=\"line\">  _toHomeScreen (context) &#123;</span><br><span class=\"line\">    Navigator.of(context).pushAndRemoveUntil(</span><br><span class=\"line\">      MaterialPageRoute(</span><br><span class=\"line\">        builder: (context) =&gt; HomeScreen()</span><br><span class=\"line\">      ), (route) =&gt; <span class=\"keyword\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  _fetchLogin (username, password) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发送请求，调用setState，使得重新渲染</span></span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      _loginFuture = http.post(</span><br><span class=\"line\">        baseUrl + loginUrl,</span><br><span class=\"line\">        body: &#123;</span><br><span class=\"line\">          username: username,</span><br><span class=\"line\">          password: password</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _loginFuture;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 返回加载，或什么也不显示</span></span><br><span class=\"line\">  _showLoading (isShow) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isShow) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Center(</span><br><span class=\"line\">        child: FullScreenLoading(),</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Center();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">    Widget build(BuildContext context) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> FutureBuilder(</span><br><span class=\"line\">        <span class=\"comment\">// _loginFuture状态改变，就会重新渲染</span></span><br><span class=\"line\">        future: _loginFuture,</span><br><span class=\"line\">        builder: (context, snapshot) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">print</span>(snapshot.connectionState);</span><br><span class=\"line\">          <span class=\"comment\">// Stack叠加组件，这里相当于上面web代码中position: absolute的作用</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> Stack(</span><br><span class=\"line\">            children: &lt;Widget&gt;[</span><br><span class=\"line\">              Scaffold(</span><br><span class=\"line\">                body: Container(</span><br><span class=\"line\">                  padding: <span class=\"keyword\">const</span> EdgeInsets.all(<span class=\"number\">20.0</span>),</span><br><span class=\"line\">                  child: Column(</span><br><span class=\"line\">                    mainAxisAlignment: MainAxisAlignment.center,</span><br><span class=\"line\">                    children: &lt;Widget&gt;[</span><br><span class=\"line\">                      LoginForm(_fetchLogin, success: _toHomeScreen),</span><br><span class=\"line\">                    ],</span><br><span class=\"line\">                  )</span><br><span class=\"line\">                ),</span><br><span class=\"line\">                bottomNavigationBar: Container(</span><br><span class=\"line\">                  margin: <span class=\"keyword\">const</span> EdgeInsets.only(bottom: <span class=\"number\">20.0</span>),</span><br><span class=\"line\">                  child: BottomLinksBar(),</span><br><span class=\"line\">                )</span><br><span class=\"line\">              ),</span><br><span class=\"line\">              <span class=\"comment\">// 根据状态不同，显示不同</span></span><br><span class=\"line\">              _showLoading(snapshot.connectionState == ConnectionState.waiting)</span><br><span class=\"line\">            ],</span><br><span class=\"line\">          );</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> 在dart中，异步编程主要是在<code>dart:async</code>中，包括<code>Future</code>和<code>Stream</code>等类，这次主要用到的是<code>Future</code>，<code>Futrue</code>是一个很类似于JavaScript中的<code>Promise</code>的存在。</p>\n"},{"title":"Hexo进一步","date":"2017-04-25T16:00:00.000Z","comments":1,"_content":"\nHexo搭建博客完成后，通过hexo的配置，可以定制我们博客的标题、副标题、描述等等内容，另外主题的配置文件中，也会为我们提供许多页面上的配置，通过这些配置，可以实现一些个性化定制，一般都有比较详细的配置注释（一定是因为json没有注释，所以配置才不用json的）。\n\n#### 添加评论\n第一种情况，在主题配置中有相关配置，比如多说、disqus等。因为多说最近关闭，选择了使用disqus，只是需要翻墙才能够正常使用。（以下操作可能都需要翻墙）  \n首先是注册帐号，之后在个人的首页中，settings中有Add Disqus To site，之后在最下面是Get Start。之后就是一些选择和配置。完成这些以后将disqus的shortname配置到主题的配置文件中就可以了。  \n第二种情况是主题没有相关配置，这时候需要我们自己去将disqus提供的代码添加到页面中，具体做法参考添加网易云音乐中。\n\n#### 添加网易云音乐\n网易云因为支持外链，一种是iframe模式，一种flash模式，只需要将代码加入我们页面中，就可以生成网易云音乐的简易播放器。进入网易云音乐的网页版，搜索我们要的歌曲，或者是歌单，会有个生成外链的链接。在这里就可以得到我们要的网易云音乐的外链。  \n下一步就需要我们研究主题的源码了，在`themes`文件夹下找到自己使用的主题，其中`layout`文件夹中存放的就是主题的模板文件，静态文件的生成就是按照这些模板文件来生成的。Hexo支持很多模板引擎，如果是我们自己设计自己的主题，可以选择其中一种来深入学习。如果我们仅仅是想在现有主题中添加修改一些内容，比如这里我们要添加网易云音乐的外链，我们只需要照着样子添加进去就可以了。比如我使用的这个主题模板使用的是jade，通过比较几个文件，其实就是`标签名(标签属性)`，通过缩进来控制层级。将我们找到的网易云音乐外链改成模板引擎解构，添加到相应位置。可以添加一个class、id属性，在source文件夹中自定义css或js。\n\n我们了解了模板引擎，也就大致明白我们的页面是怎么回事了。查看[Hexo变量](https://hexo.io/zh-cn/docs/variables.html)可以了解到在模板引擎中可以使用的变量，通过这些变量以及对模板引擎的熟练使用，应该就可以完全自定义我们的博客了，比如还可以添加统计分析系统等等。\n\n#### 网站收录\n使用site:[blogname].github.io可以检测自己的博客是非被搜索引擎收录。这里以谷歌为例，如果搜索不到，谷歌会提示使用`Search Console`。在这里，我们可以点击添加属性来添加我们的网站，之后需要验证此域名是否属于你。验证中，我是用的是最简单的HTML标记，只需要修改模板引擎就可以实现。谷歌验证之后，应该是很快就能被收录，我们也可以添加站点地图，使得搜索更准确。  \n站点地图使用了另一个插件`hexo-generator-sitemap`，然后在Hexo配置中添加配置\n```\nsitemap:\n  path: sitemap.xml\n```\n部署之后在谷歌Search Console中添加站点地图即可。\n\n百度的收录过程和谷歌收录过程大同小异。收录地址可以百度搜索百度站长。提交网站后验证和谷歌一样。只是github禁止百度抓取，可以采用的解决办法是将Hexo同时部署都coding中，通过Hexo配置，可以同时部署到github和coding中。\n```bash\ndeploy:\n  type: git\n  repo: \n    github: https://github.com/PFanz/Fanz.github.io.git\n    coding: https://git.coding.net/PFanz/PFanz.git\n  branch: master\n```\nsitemap可以使用`hexo-generator-baidu-sitemap`生成。另外百度的收录需要较长的时间，也有可能是我的方式不对，至今还未被收录。\n\n#### 之后\n熟悉了模板引擎，可以尝试实现自己的Hexo主题。","source":"_posts/Hexo进一步.md","raw":"---\ntitle: Hexo进一步\ndate: 2017-04-26\ntags: Hexo\ncategories: \n- 杂记\ncomments: true\n---\n\nHexo搭建博客完成后，通过hexo的配置，可以定制我们博客的标题、副标题、描述等等内容，另外主题的配置文件中，也会为我们提供许多页面上的配置，通过这些配置，可以实现一些个性化定制，一般都有比较详细的配置注释（一定是因为json没有注释，所以配置才不用json的）。\n\n#### 添加评论\n第一种情况，在主题配置中有相关配置，比如多说、disqus等。因为多说最近关闭，选择了使用disqus，只是需要翻墙才能够正常使用。（以下操作可能都需要翻墙）  \n首先是注册帐号，之后在个人的首页中，settings中有Add Disqus To site，之后在最下面是Get Start。之后就是一些选择和配置。完成这些以后将disqus的shortname配置到主题的配置文件中就可以了。  \n第二种情况是主题没有相关配置，这时候需要我们自己去将disqus提供的代码添加到页面中，具体做法参考添加网易云音乐中。\n\n#### 添加网易云音乐\n网易云因为支持外链，一种是iframe模式，一种flash模式，只需要将代码加入我们页面中，就可以生成网易云音乐的简易播放器。进入网易云音乐的网页版，搜索我们要的歌曲，或者是歌单，会有个生成外链的链接。在这里就可以得到我们要的网易云音乐的外链。  \n下一步就需要我们研究主题的源码了，在`themes`文件夹下找到自己使用的主题，其中`layout`文件夹中存放的就是主题的模板文件，静态文件的生成就是按照这些模板文件来生成的。Hexo支持很多模板引擎，如果是我们自己设计自己的主题，可以选择其中一种来深入学习。如果我们仅仅是想在现有主题中添加修改一些内容，比如这里我们要添加网易云音乐的外链，我们只需要照着样子添加进去就可以了。比如我使用的这个主题模板使用的是jade，通过比较几个文件，其实就是`标签名(标签属性)`，通过缩进来控制层级。将我们找到的网易云音乐外链改成模板引擎解构，添加到相应位置。可以添加一个class、id属性，在source文件夹中自定义css或js。\n\n我们了解了模板引擎，也就大致明白我们的页面是怎么回事了。查看[Hexo变量](https://hexo.io/zh-cn/docs/variables.html)可以了解到在模板引擎中可以使用的变量，通过这些变量以及对模板引擎的熟练使用，应该就可以完全自定义我们的博客了，比如还可以添加统计分析系统等等。\n\n#### 网站收录\n使用site:[blogname].github.io可以检测自己的博客是非被搜索引擎收录。这里以谷歌为例，如果搜索不到，谷歌会提示使用`Search Console`。在这里，我们可以点击添加属性来添加我们的网站，之后需要验证此域名是否属于你。验证中，我是用的是最简单的HTML标记，只需要修改模板引擎就可以实现。谷歌验证之后，应该是很快就能被收录，我们也可以添加站点地图，使得搜索更准确。  \n站点地图使用了另一个插件`hexo-generator-sitemap`，然后在Hexo配置中添加配置\n```\nsitemap:\n  path: sitemap.xml\n```\n部署之后在谷歌Search Console中添加站点地图即可。\n\n百度的收录过程和谷歌收录过程大同小异。收录地址可以百度搜索百度站长。提交网站后验证和谷歌一样。只是github禁止百度抓取，可以采用的解决办法是将Hexo同时部署都coding中，通过Hexo配置，可以同时部署到github和coding中。\n```bash\ndeploy:\n  type: git\n  repo: \n    github: https://github.com/PFanz/Fanz.github.io.git\n    coding: https://git.coding.net/PFanz/PFanz.git\n  branch: master\n```\nsitemap可以使用`hexo-generator-baidu-sitemap`生成。另外百度的收录需要较长的时间，也有可能是我的方式不对，至今还未被收录。\n\n#### 之后\n熟悉了模板引擎，可以尝试实现自己的Hexo主题。","slug":"Hexo进一步","published":1,"updated":"2017-12-28T03:47:32.453Z","layout":"post","photos":[],"link":"","_id":"cjks5i9hv000gvmtim4vzb4ih","content":"<p>Hexo搭建博客完成后，通过hexo的配置，可以定制我们博客的标题、副标题、描述等等内容，另外主题的配置文件中，也会为我们提供许多页面上的配置，通过这些配置，可以实现一些个性化定制，一般都有比较详细的配置注释（一定是因为json没有注释，所以配置才不用json的）。</p>\n<h4 id=\"添加评论\"><a href=\"#添加评论\" class=\"headerlink\" title=\"添加评论\"></a>添加评论</h4><p>第一种情况，在主题配置中有相关配置，比如多说、disqus等。因为多说最近关闭，选择了使用disqus，只是需要翻墙才能够正常使用。（以下操作可能都需要翻墙）<br>首先是注册帐号，之后在个人的首页中，settings中有Add Disqus To site，之后在最下面是Get Start。之后就是一些选择和配置。完成这些以后将disqus的shortname配置到主题的配置文件中就可以了。<br>第二种情况是主题没有相关配置，这时候需要我们自己去将disqus提供的代码添加到页面中，具体做法参考添加网易云音乐中。</p>\n<h4 id=\"添加网易云音乐\"><a href=\"#添加网易云音乐\" class=\"headerlink\" title=\"添加网易云音乐\"></a>添加网易云音乐</h4><p>网易云因为支持外链，一种是iframe模式，一种flash模式，只需要将代码加入我们页面中，就可以生成网易云音乐的简易播放器。进入网易云音乐的网页版，搜索我们要的歌曲，或者是歌单，会有个生成外链的链接。在这里就可以得到我们要的网易云音乐的外链。<br>下一步就需要我们研究主题的源码了，在<code>themes</code>文件夹下找到自己使用的主题，其中<code>layout</code>文件夹中存放的就是主题的模板文件，静态文件的生成就是按照这些模板文件来生成的。Hexo支持很多模板引擎，如果是我们自己设计自己的主题，可以选择其中一种来深入学习。如果我们仅仅是想在现有主题中添加修改一些内容，比如这里我们要添加网易云音乐的外链，我们只需要照着样子添加进去就可以了。比如我使用的这个主题模板使用的是jade，通过比较几个文件，其实就是<code>标签名(标签属性)</code>，通过缩进来控制层级。将我们找到的网易云音乐外链改成模板引擎解构，添加到相应位置。可以添加一个class、id属性，在source文件夹中自定义css或js。</p>\n<p>我们了解了模板引擎，也就大致明白我们的页面是怎么回事了。查看<a href=\"https://hexo.io/zh-cn/docs/variables.html\" target=\"_blank\" rel=\"noopener\">Hexo变量</a>可以了解到在模板引擎中可以使用的变量，通过这些变量以及对模板引擎的熟练使用，应该就可以完全自定义我们的博客了，比如还可以添加统计分析系统等等。</p>\n<h4 id=\"网站收录\"><a href=\"#网站收录\" class=\"headerlink\" title=\"网站收录\"></a>网站收录</h4><p>使用site:[blogname].github.io可以检测自己的博客是非被搜索引擎收录。这里以谷歌为例，如果搜索不到，谷歌会提示使用<code>Search Console</code>。在这里，我们可以点击添加属性来添加我们的网站，之后需要验证此域名是否属于你。验证中，我是用的是最简单的HTML标记，只需要修改模板引擎就可以实现。谷歌验证之后，应该是很快就能被收录，我们也可以添加站点地图，使得搜索更准确。<br>站点地图使用了另一个插件<code>hexo-generator-sitemap</code>，然后在Hexo配置中添加配置<br><figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">sitemap:</span></span><br><span class=\"line\"><span class=\"symbol\">  path:</span> sitemap.xml</span><br></pre></td></tr></table></figure></p>\n<p>部署之后在谷歌Search Console中添加站点地图即可。</p>\n<p>百度的收录过程和谷歌收录过程大同小异。收录地址可以百度搜索百度站长。提交网站后验证和谷歌一样。只是github禁止百度抓取，可以采用的解决办法是将Hexo同时部署都coding中，通过Hexo配置，可以同时部署到github和coding中。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repo: </span><br><span class=\"line\">    github: https://github.com/PFanz/Fanz.github.io.git</span><br><span class=\"line\">    coding: https://git.coding.net/PFanz/PFanz.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure></p>\n<p>sitemap可以使用<code>hexo-generator-baidu-sitemap</code>生成。另外百度的收录需要较长的时间，也有可能是我的方式不对，至今还未被收录。</p>\n<h4 id=\"之后\"><a href=\"#之后\" class=\"headerlink\" title=\"之后\"></a>之后</h4><p>熟悉了模板引擎，可以尝试实现自己的Hexo主题。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Hexo搭建博客完成后，通过hexo的配置，可以定制我们博客的标题、副标题、描述等等内容，另外主题的配置文件中，也会为我们提供许多页面上的配置，通过这些配置，可以实现一些个性化定制，一般都有比较详细的配置注释（一定是因为json没有注释，所以配置才不用json的）。</p>\n<h4 id=\"添加评论\"><a href=\"#添加评论\" class=\"headerlink\" title=\"添加评论\"></a>添加评论</h4><p>第一种情况，在主题配置中有相关配置，比如多说、disqus等。因为多说最近关闭，选择了使用disqus，只是需要翻墙才能够正常使用。（以下操作可能都需要翻墙）<br>首先是注册帐号，之后在个人的首页中，settings中有Add Disqus To site，之后在最下面是Get Start。之后就是一些选择和配置。完成这些以后将disqus的shortname配置到主题的配置文件中就可以了。<br>第二种情况是主题没有相关配置，这时候需要我们自己去将disqus提供的代码添加到页面中，具体做法参考添加网易云音乐中。</p>\n<h4 id=\"添加网易云音乐\"><a href=\"#添加网易云音乐\" class=\"headerlink\" title=\"添加网易云音乐\"></a>添加网易云音乐</h4><p>网易云因为支持外链，一种是iframe模式，一种flash模式，只需要将代码加入我们页面中，就可以生成网易云音乐的简易播放器。进入网易云音乐的网页版，搜索我们要的歌曲，或者是歌单，会有个生成外链的链接。在这里就可以得到我们要的网易云音乐的外链。<br>下一步就需要我们研究主题的源码了，在<code>themes</code>文件夹下找到自己使用的主题，其中<code>layout</code>文件夹中存放的就是主题的模板文件，静态文件的生成就是按照这些模板文件来生成的。Hexo支持很多模板引擎，如果是我们自己设计自己的主题，可以选择其中一种来深入学习。如果我们仅仅是想在现有主题中添加修改一些内容，比如这里我们要添加网易云音乐的外链，我们只需要照着样子添加进去就可以了。比如我使用的这个主题模板使用的是jade，通过比较几个文件，其实就是<code>标签名(标签属性)</code>，通过缩进来控制层级。将我们找到的网易云音乐外链改成模板引擎解构，添加到相应位置。可以添加一个class、id属性，在source文件夹中自定义css或js。</p>\n<p>我们了解了模板引擎，也就大致明白我们的页面是怎么回事了。查看<a href=\"https://hexo.io/zh-cn/docs/variables.html\" target=\"_blank\" rel=\"noopener\">Hexo变量</a>可以了解到在模板引擎中可以使用的变量，通过这些变量以及对模板引擎的熟练使用，应该就可以完全自定义我们的博客了，比如还可以添加统计分析系统等等。</p>\n<h4 id=\"网站收录\"><a href=\"#网站收录\" class=\"headerlink\" title=\"网站收录\"></a>网站收录</h4><p>使用site:[blogname].github.io可以检测自己的博客是非被搜索引擎收录。这里以谷歌为例，如果搜索不到，谷歌会提示使用<code>Search Console</code>。在这里，我们可以点击添加属性来添加我们的网站，之后需要验证此域名是否属于你。验证中，我是用的是最简单的HTML标记，只需要修改模板引擎就可以实现。谷歌验证之后，应该是很快就能被收录，我们也可以添加站点地图，使得搜索更准确。<br>站点地图使用了另一个插件<code>hexo-generator-sitemap</code>，然后在Hexo配置中添加配置<br><figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">sitemap:</span></span><br><span class=\"line\"><span class=\"symbol\">  path:</span> sitemap.xml</span><br></pre></td></tr></table></figure></p>\n<p>部署之后在谷歌Search Console中添加站点地图即可。</p>\n<p>百度的收录过程和谷歌收录过程大同小异。收录地址可以百度搜索百度站长。提交网站后验证和谷歌一样。只是github禁止百度抓取，可以采用的解决办法是将Hexo同时部署都coding中，通过Hexo配置，可以同时部署到github和coding中。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repo: </span><br><span class=\"line\">    github: https://github.com/PFanz/Fanz.github.io.git</span><br><span class=\"line\">    coding: https://git.coding.net/PFanz/PFanz.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure></p>\n<p>sitemap可以使用<code>hexo-generator-baidu-sitemap</code>生成。另外百度的收录需要较长的时间，也有可能是我的方式不对，至今还未被收录。</p>\n<h4 id=\"之后\"><a href=\"#之后\" class=\"headerlink\" title=\"之后\"></a>之后</h4><p>熟悉了模板引擎，可以尝试实现自己的Hexo主题。</p>\n"},{"title":"H5页面","date":"2016-08-02T16:00:00.000Z","comments":1,"_content":"\n任务：环球网-2016七夕H5页面  \n环境：swiper插件，gulp及相关常用工具。\n\n---\n\n### 适配\n使用的还是lib-flexible那套解决方案，需要查看的可以点击[这里](https://github.com/amfe/lib-flexible)  \n### 使用swiper\n使用swiper页面的控制以及滑动功能就变得非常容易，可以参见[Swiper中文网](http://www.swiper.com.cn/)，其中添加给类名添加`swiper-slide`即可表示一页。  \n在Swiper实例化中，属性`direction`可以定义横向/竖向滑动，`nextButton`可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在`onSlideChangeStart`中不能够出发`slideTo()`方法。  \nSwiper还有许多其他功能，可以参见[Swiper中文网](http://www.swiper.com.cn/)中API。\n\n### ES6的使用\nES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是`gulp-babel`。\n\n### 目录、git以及gulp相关\n目录和之前的项目目录基本相同。\n```\n.\n├── .eslintrc.json\n├── .gitignore\n├── dist\n│   ├── css\n│   ├── imgs\n│   ├── js\n│   └── libs\n├── gulpfile.js\n├── index.html\n├── node_modules\n├── package.json\n├── psd\n└── src\n    ├── ES6\n    ├── css\n    ├── imgs\n    ├── js\n    ├── libs\n    └── sass\n```\ndist目录存放合并、压缩的代码，用于上线使用。(自动生成)  \nsrc目录存放源文件。  \nnode_modules目录存放用到的node工具。(自动生成)  \npsd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。  \n相比之前增加的文件：\n\n*  .eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看[这里](https://segmentfault.com/a/1190000004468428)。\n*  .gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。\n```\n/node_modules/\n/psd/\n```\n* src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。\n\ngit开始学习使用分支处理bug、添加尝试性功能等。\n\n### 坑是用来爬的\n#### 最经典的坑——this\n在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过`fn.bind(this)`来指向想要的this，在旧版本浏览器下需要使用兼容写法。\n\n#### 省事也被坑——autoprefixer\nautoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是`remove`，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。  \nandriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。\n\n#### 没想到的坑——微信分享\n关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。  \n问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中`mqq.data.setShareInfo`可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。\n\n### 其他\n#### 自定义单选框\n自定义单选框并没有想象中的那么难，除了`<input type=\"radio\">`外，还有个label标签和after伪类。  \n设置css`[type=radio]: display: none;`，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)\n\n#### 文字居中\n要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。\n\n#### 横屏问题\n我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。\n\n### 改进\n需要改进的东西就太多太多了。 \n \n* 最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。\n* 图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。\n* 动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。","source":"_posts/H5页面.md","raw":"---\ntitle: H5页面\ndate: 2016-08-03\ntags: [JavaScript, H5]\ncategories: \n- H5\ncomments: true\n---\n\n任务：环球网-2016七夕H5页面  \n环境：swiper插件，gulp及相关常用工具。\n\n---\n\n### 适配\n使用的还是lib-flexible那套解决方案，需要查看的可以点击[这里](https://github.com/amfe/lib-flexible)  \n### 使用swiper\n使用swiper页面的控制以及滑动功能就变得非常容易，可以参见[Swiper中文网](http://www.swiper.com.cn/)，其中添加给类名添加`swiper-slide`即可表示一页。  \n在Swiper实例化中，属性`direction`可以定义横向/竖向滑动，`nextButton`可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在`onSlideChangeStart`中不能够出发`slideTo()`方法。  \nSwiper还有许多其他功能，可以参见[Swiper中文网](http://www.swiper.com.cn/)中API。\n\n### ES6的使用\nES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是`gulp-babel`。\n\n### 目录、git以及gulp相关\n目录和之前的项目目录基本相同。\n```\n.\n├── .eslintrc.json\n├── .gitignore\n├── dist\n│   ├── css\n│   ├── imgs\n│   ├── js\n│   └── libs\n├── gulpfile.js\n├── index.html\n├── node_modules\n├── package.json\n├── psd\n└── src\n    ├── ES6\n    ├── css\n    ├── imgs\n    ├── js\n    ├── libs\n    └── sass\n```\ndist目录存放合并、压缩的代码，用于上线使用。(自动生成)  \nsrc目录存放源文件。  \nnode_modules目录存放用到的node工具。(自动生成)  \npsd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。  \n相比之前增加的文件：\n\n*  .eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看[这里](https://segmentfault.com/a/1190000004468428)。\n*  .gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。\n```\n/node_modules/\n/psd/\n```\n* src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。\n\ngit开始学习使用分支处理bug、添加尝试性功能等。\n\n### 坑是用来爬的\n#### 最经典的坑——this\n在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过`fn.bind(this)`来指向想要的this，在旧版本浏览器下需要使用兼容写法。\n\n#### 省事也被坑——autoprefixer\nautoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是`remove`，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。  \nandriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。\n\n#### 没想到的坑——微信分享\n关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。  \n问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中`mqq.data.setShareInfo`可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。\n\n### 其他\n#### 自定义单选框\n自定义单选框并没有想象中的那么难，除了`<input type=\"radio\">`外，还有个label标签和after伪类。  \n设置css`[type=radio]: display: none;`，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)\n\n#### 文字居中\n要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。\n\n#### 横屏问题\n我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。\n\n### 改进\n需要改进的东西就太多太多了。 \n \n* 最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。\n* 图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。\n* 动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。","slug":"H5页面","published":1,"updated":"2017-12-28T03:47:32.453Z","layout":"post","photos":[],"link":"","_id":"cjks5i9hx000kvmtigi1hjwol","content":"<p>任务：环球网-2016七夕H5页面<br>环境：swiper插件，gulp及相关常用工具。</p>\n<hr>\n<h3 id=\"适配\"><a href=\"#适配\" class=\"headerlink\" title=\"适配\"></a>适配</h3><p>使用的还是lib-flexible那套解决方案，需要查看的可以点击<a href=\"https://github.com/amfe/lib-flexible\" target=\"_blank\" rel=\"noopener\">这里</a>  </p>\n<h3 id=\"使用swiper\"><a href=\"#使用swiper\" class=\"headerlink\" title=\"使用swiper\"></a>使用swiper</h3><p>使用swiper页面的控制以及滑动功能就变得非常容易，可以参见<a href=\"http://www.swiper.com.cn/\" target=\"_blank\" rel=\"noopener\">Swiper中文网</a>，其中添加给类名添加<code>swiper-slide</code>即可表示一页。<br>在Swiper实例化中，属性<code>direction</code>可以定义横向/竖向滑动，<code>nextButton</code>可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在<code>onSlideChangeStart</code>中不能够出发<code>slideTo()</code>方法。<br>Swiper还有许多其他功能，可以参见<a href=\"http://www.swiper.com.cn/\" target=\"_blank\" rel=\"noopener\">Swiper中文网</a>中API。</p>\n<h3 id=\"ES6的使用\"><a href=\"#ES6的使用\" class=\"headerlink\" title=\"ES6的使用\"></a>ES6的使用</h3><p>ES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是<code>gulp-babel</code>。</p>\n<h3 id=\"目录、git以及gulp相关\"><a href=\"#目录、git以及gulp相关\" class=\"headerlink\" title=\"目录、git以及gulp相关\"></a>目录、git以及gulp相关</h3><p>目录和之前的项目目录基本相同。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── <span class=\"selector-class\">.eslintrc</span><span class=\"selector-class\">.json</span></span><br><span class=\"line\">├── .gitignore</span><br><span class=\"line\">├── dist</span><br><span class=\"line\">│   ├── css</span><br><span class=\"line\">│   ├── imgs</span><br><span class=\"line\">│   ├── js</span><br><span class=\"line\">│   └── libs</span><br><span class=\"line\">├── gulpfile.js</span><br><span class=\"line\">├── index.html</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── psd</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── ES6</span><br><span class=\"line\">    ├── css</span><br><span class=\"line\">    ├── imgs</span><br><span class=\"line\">    ├── js</span><br><span class=\"line\">    ├── libs</span><br><span class=\"line\">    └── sass</span><br></pre></td></tr></table></figure></p>\n<p>dist目录存放合并、压缩的代码，用于上线使用。(自动生成)<br>src目录存放源文件。<br>node_modules目录存放用到的node工具。(自动生成)<br>psd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。<br>相比之前增加的文件：</p>\n<ul>\n<li>.eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看<a href=\"https://segmentfault.com/a/1190000004468428\" target=\"_blank\" rel=\"noopener\">这里</a>。</li>\n<li><p>.gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">/node_modules/</span></span><br><span class=\"line\"><span class=\"regexp\">/psd/</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。</p>\n</li>\n</ul>\n<p>git开始学习使用分支处理bug、添加尝试性功能等。</p>\n<h3 id=\"坑是用来爬的\"><a href=\"#坑是用来爬的\" class=\"headerlink\" title=\"坑是用来爬的\"></a>坑是用来爬的</h3><h4 id=\"最经典的坑——this\"><a href=\"#最经典的坑——this\" class=\"headerlink\" title=\"最经典的坑——this\"></a>最经典的坑——this</h4><p>在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过<code>fn.bind(this)</code>来指向想要的this，在旧版本浏览器下需要使用兼容写法。</p>\n<h4 id=\"省事也被坑——autoprefixer\"><a href=\"#省事也被坑——autoprefixer\" class=\"headerlink\" title=\"省事也被坑——autoprefixer\"></a>省事也被坑——autoprefixer</h4><p>autoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是<code>remove</code>，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。<br>andriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。</p>\n<h4 id=\"没想到的坑——微信分享\"><a href=\"#没想到的坑——微信分享\" class=\"headerlink\" title=\"没想到的坑——微信分享\"></a>没想到的坑——微信分享</h4><p>关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。<br>问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中<code>mqq.data.setShareInfo</code>可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"自定义单选框\"><a href=\"#自定义单选框\" class=\"headerlink\" title=\"自定义单选框\"></a>自定义单选框</h4><p>自定义单选框并没有想象中的那么难，除了<code>&lt;input type=&quot;radio&quot;&gt;</code>外，还有个label标签和after伪类。<br>设置css<code>[type=radio]: display: none;</code>，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)</p>\n<h4 id=\"文字居中\"><a href=\"#文字居中\" class=\"headerlink\" title=\"文字居中\"></a>文字居中</h4><p>要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。</p>\n<h4 id=\"横屏问题\"><a href=\"#横屏问题\" class=\"headerlink\" title=\"横屏问题\"></a>横屏问题</h4><p>我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。</p>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>需要改进的东西就太多太多了。 </p>\n<ul>\n<li>最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。</li>\n<li>图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。</li>\n<li>动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>任务：环球网-2016七夕H5页面<br>环境：swiper插件，gulp及相关常用工具。</p>\n<hr>\n<h3 id=\"适配\"><a href=\"#适配\" class=\"headerlink\" title=\"适配\"></a>适配</h3><p>使用的还是lib-flexible那套解决方案，需要查看的可以点击<a href=\"https://github.com/amfe/lib-flexible\" target=\"_blank\" rel=\"noopener\">这里</a>  </p>\n<h3 id=\"使用swiper\"><a href=\"#使用swiper\" class=\"headerlink\" title=\"使用swiper\"></a>使用swiper</h3><p>使用swiper页面的控制以及滑动功能就变得非常容易，可以参见<a href=\"http://www.swiper.com.cn/\" target=\"_blank\" rel=\"noopener\">Swiper中文网</a>，其中添加给类名添加<code>swiper-slide</code>即可表示一页。<br>在Swiper实例化中，属性<code>direction</code>可以定义横向/竖向滑动，<code>nextButton</code>可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在<code>onSlideChangeStart</code>中不能够出发<code>slideTo()</code>方法。<br>Swiper还有许多其他功能，可以参见<a href=\"http://www.swiper.com.cn/\" target=\"_blank\" rel=\"noopener\">Swiper中文网</a>中API。</p>\n<h3 id=\"ES6的使用\"><a href=\"#ES6的使用\" class=\"headerlink\" title=\"ES6的使用\"></a>ES6的使用</h3><p>ES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是<code>gulp-babel</code>。</p>\n<h3 id=\"目录、git以及gulp相关\"><a href=\"#目录、git以及gulp相关\" class=\"headerlink\" title=\"目录、git以及gulp相关\"></a>目录、git以及gulp相关</h3><p>目录和之前的项目目录基本相同。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── <span class=\"selector-class\">.eslintrc</span><span class=\"selector-class\">.json</span></span><br><span class=\"line\">├── .gitignore</span><br><span class=\"line\">├── dist</span><br><span class=\"line\">│   ├── css</span><br><span class=\"line\">│   ├── imgs</span><br><span class=\"line\">│   ├── js</span><br><span class=\"line\">│   └── libs</span><br><span class=\"line\">├── gulpfile.js</span><br><span class=\"line\">├── index.html</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── psd</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── ES6</span><br><span class=\"line\">    ├── css</span><br><span class=\"line\">    ├── imgs</span><br><span class=\"line\">    ├── js</span><br><span class=\"line\">    ├── libs</span><br><span class=\"line\">    └── sass</span><br></pre></td></tr></table></figure></p>\n<p>dist目录存放合并、压缩的代码，用于上线使用。(自动生成)<br>src目录存放源文件。<br>node_modules目录存放用到的node工具。(自动生成)<br>psd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。<br>相比之前增加的文件：</p>\n<ul>\n<li>.eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看<a href=\"https://segmentfault.com/a/1190000004468428\" target=\"_blank\" rel=\"noopener\">这里</a>。</li>\n<li><p>.gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">/node_modules/</span></span><br><span class=\"line\"><span class=\"regexp\">/psd/</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。</p>\n</li>\n</ul>\n<p>git开始学习使用分支处理bug、添加尝试性功能等。</p>\n<h3 id=\"坑是用来爬的\"><a href=\"#坑是用来爬的\" class=\"headerlink\" title=\"坑是用来爬的\"></a>坑是用来爬的</h3><h4 id=\"最经典的坑——this\"><a href=\"#最经典的坑——this\" class=\"headerlink\" title=\"最经典的坑——this\"></a>最经典的坑——this</h4><p>在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过<code>fn.bind(this)</code>来指向想要的this，在旧版本浏览器下需要使用兼容写法。</p>\n<h4 id=\"省事也被坑——autoprefixer\"><a href=\"#省事也被坑——autoprefixer\" class=\"headerlink\" title=\"省事也被坑——autoprefixer\"></a>省事也被坑——autoprefixer</h4><p>autoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是<code>remove</code>，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。<br>andriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。</p>\n<h4 id=\"没想到的坑——微信分享\"><a href=\"#没想到的坑——微信分享\" class=\"headerlink\" title=\"没想到的坑——微信分享\"></a>没想到的坑——微信分享</h4><p>关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。<br>问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中<code>mqq.data.setShareInfo</code>可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"自定义单选框\"><a href=\"#自定义单选框\" class=\"headerlink\" title=\"自定义单选框\"></a>自定义单选框</h4><p>自定义单选框并没有想象中的那么难，除了<code>&lt;input type=&quot;radio&quot;&gt;</code>外，还有个label标签和after伪类。<br>设置css<code>[type=radio]: display: none;</code>，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)</p>\n<h4 id=\"文字居中\"><a href=\"#文字居中\" class=\"headerlink\" title=\"文字居中\"></a>文字居中</h4><p>要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。</p>\n<h4 id=\"横屏问题\"><a href=\"#横屏问题\" class=\"headerlink\" title=\"横屏问题\"></a>横屏问题</h4><p>我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。</p>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>需要改进的东西就太多太多了。 </p>\n<ul>\n<li>最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。</li>\n<li>图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。</li>\n<li>动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。</li>\n</ul>\n"},{"title":"Promise总结","date":"2016-11-24T16:00:00.000Z","comments":1,"_content":"\n因为最近项目中用到了ajax，想尝试下Promise，所以看了下ES6中的[Promise](http://es6.ruanyifeng.com/#docs/promise)。\n\n一般用法：\n```javascript\n// promise表示一个Promise对象\npromise\n  .then(function (data) {\n    // success\n  })\n  .catch(function (err) {\n    // error\n  })\n```\n所以如果使用jQuery或者zepto，可以这样：\n```javascript\nvar ajaxBack = $.ajax({\n  url: '*****'\n})\n\najaxBack\n  .then(data => {\n    // 处理数据\n  })\n  .catch(error => {\n    // 处理报错\n  })\n```\n\n### 什么是Promise对象？\n\nPromise是异步编程的一种解决方案。  \n首先，我们通过chrome浏览器控制台来看一下Promise对象的样子。  \n在控制台输入`Promise`然后回车，会看到输出`function Promise() { [native code] }`。然后我们new一个Promise出来看一下，`var promise = new Promise(function(){})`，在创建Promise对象时候，必须传递一个函数，否则会报错。  \n看一下promise：  \n![Promise对象](/images/Promise_Object.png)  \n包括\\_\\_proto\\_\\_，[[PromiseStatus]]，[[PromiseValue]]三个属性，其中\\_\\_proto\\_\\_主要包括catch、then、constructor方法。所以我们对Promise的学习主要就是[[PromiseStatus]]，[[PromiseValue]]属性和catch，then方法。\n\n### Promise的三种状态\n通过[资料](http://es6.ruanyifeng.com/#docs/promise)，我们会知道Promise对象有三种状态：Pending、Resolved和Rejected。  \nPromise构造函数接受一个函数作为参数，该函数有两个参数分别为resolve和reject，我们的创建方法应该是这样`new Promise(function (resolve, reject) {})`。  \n这两个参数resolve和reject也是函数，resolve是将Promise对象的状态从Pending变成Resolved，reject是将Promise对象的状态从Pending变成Rejected。  \n如果我们执行`var promise = new Promise(function(resolve, reject){resolve()})`，会发现promise中的[[PromiseStatus]]变成了`\"resolved\"`。如果我们执行`var promise = new Promise(function(resolve, reject){resolve('执行成功')})`，会发现不仅[[PromiseStatus]]变了，[[PromiseValue]]的值变成了`“执行成功”`。(reject函数同理)\n\n    需要注意：\n      只有函数中的构造函数参数中的resolve和reject可以改变Promise对象的状态。\n      一旦Promise对象的状态改变，就会一直保持这个状态，不能再改变。\n\n### Promise的then函数和catch函数\n\nthen函数和catch函数可以理解成对Promise状态的监听函数，不同点在于监听函数需要在事件发生之前创建，而因为Promise中的状态在改变后是不能再次改变的，所以then函数和catch函数可以在Promise对象改变状态之后创建，这样的话，该函数会立即执行。  \nthen函数接受两个函数作为参数，分别是Promise状态为`Resolved`时执行和状态为`Rejected`时执行。\n```javascript\n// promise是一个Promise对象\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\nthen函数中的函数参数是[[PromiseValue]]中的值，即是Promise构造中的resolve()、reject()中的参数。\n\n另外，then函数中的方法是异步的，即使resolve立即执行，then中的函数也在同步函数执行结束之后执行：\n```javascript\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise');\n  resolve();\n});\n\npromise.then(function() {\n  console.log('Resolved.');\n});\n\nconsole.log('Hi!');\n\n// Promise\n// Hi!\n// Resolved\n```\n\ncatch函数相当于.then(null, function () {})，是在发生错误时的回调函数，reject()执行时也算是一种错误发生，所以在执行reject()时，catch中的函数也会被执行。  \n所以，最好的方式是reject()发生时候需要执行的函数定义在catch中，而不是在then的第二个参数中，这样无论是reject()还是其他错误都能够被捕获。\n```javascript\n// bad\npromise\n  .then(function(data) {\n    // success\n  }, function(err) {\n    // error\n  });\n\n// good\npromise\n  .then(function(data) { //cb\n    // success\n  })\n  .catch(function(err) {\n    // error\n  });\n```\n\n### Promise对象的嵌套\n在resolve()和reject()中传递的可以是另一个Promise对象，例如\n```javascript\nvar p1 = new Promise(function (resolve, reject) {\n  setTimeout(() => reject(new Error('fail')), 3000)\n})\n\nvar p2 = new Promise(function (resolve, reject) {\n  setTimeout(() => resolve(p1), 1000)\n})\n\np2\n  .then(result => console.log(result))\n  .catch(error => console.log(error))\n// Error: fail\n```\np1是一个Promise，3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。此时，由于p2返回的是另一个Promise，所以后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。\n\n### 其他函数\n\n#### Promise.all()\nPromise.all()将多个Promise包装成一个Promise对象，只有在包装的多个Promise都转变成`Resolved`状态，此Promise.all()才会转变成`Resolved`状态，返回值是多个Promise返回值组成的数组；如果有其中一个转变成了`Rejected`状态，则此Promise.all()变成`Rejected`状态，返回值是第一个被reject的返回值。\n\n#### Promise.race()\nPromise.race()可以理解成Promise.all()的“否命题”。  \n将多个Promise包装成一个，只要有其中一个状态变成`Resolved`，则此Promise.race()变成`Resolved`，返回值是第一个状态变成`Resolved`的值。\n\n#### Promise.resolve()\nPromise.resolve()用于将对象转换成Promise对象。\n\n    1. 参数为Promise对象，方法什么也不做，直接返回。\n    2. 参数为一个有then方法的对象，方法将对象转换成Promise对象，并立即执行then方法。例如：Promise.resolve(Object)相当于new Promise(Object.then)\n    3. 参数不是具有then方法的对象，或者不是对象，则返回一个状态为`Resolved`的Promise对象，并将此参数传递给then中的第一个参数函数。\n    4. 不带任何参数，直接返回`Resolved`的Promise对象。\n\n#### Promise.reject()\nPromise.reject()和Promise.resolve()行为一致，只是返回的默认是`Rejected`的Promise对象。\n\n#### done()\n\n#### finally()\n","source":"_posts/Promise总结.md","raw":"---\ntitle: Promise总结\ndate: 2016-11-25\ntags: JavaScript\ncategories:\n- JavaScript\ncomments: true\n---\n\n因为最近项目中用到了ajax，想尝试下Promise，所以看了下ES6中的[Promise](http://es6.ruanyifeng.com/#docs/promise)。\n\n一般用法：\n```javascript\n// promise表示一个Promise对象\npromise\n  .then(function (data) {\n    // success\n  })\n  .catch(function (err) {\n    // error\n  })\n```\n所以如果使用jQuery或者zepto，可以这样：\n```javascript\nvar ajaxBack = $.ajax({\n  url: '*****'\n})\n\najaxBack\n  .then(data => {\n    // 处理数据\n  })\n  .catch(error => {\n    // 处理报错\n  })\n```\n\n### 什么是Promise对象？\n\nPromise是异步编程的一种解决方案。  \n首先，我们通过chrome浏览器控制台来看一下Promise对象的样子。  \n在控制台输入`Promise`然后回车，会看到输出`function Promise() { [native code] }`。然后我们new一个Promise出来看一下，`var promise = new Promise(function(){})`，在创建Promise对象时候，必须传递一个函数，否则会报错。  \n看一下promise：  \n![Promise对象](/images/Promise_Object.png)  \n包括\\_\\_proto\\_\\_，[[PromiseStatus]]，[[PromiseValue]]三个属性，其中\\_\\_proto\\_\\_主要包括catch、then、constructor方法。所以我们对Promise的学习主要就是[[PromiseStatus]]，[[PromiseValue]]属性和catch，then方法。\n\n### Promise的三种状态\n通过[资料](http://es6.ruanyifeng.com/#docs/promise)，我们会知道Promise对象有三种状态：Pending、Resolved和Rejected。  \nPromise构造函数接受一个函数作为参数，该函数有两个参数分别为resolve和reject，我们的创建方法应该是这样`new Promise(function (resolve, reject) {})`。  \n这两个参数resolve和reject也是函数，resolve是将Promise对象的状态从Pending变成Resolved，reject是将Promise对象的状态从Pending变成Rejected。  \n如果我们执行`var promise = new Promise(function(resolve, reject){resolve()})`，会发现promise中的[[PromiseStatus]]变成了`\"resolved\"`。如果我们执行`var promise = new Promise(function(resolve, reject){resolve('执行成功')})`，会发现不仅[[PromiseStatus]]变了，[[PromiseValue]]的值变成了`“执行成功”`。(reject函数同理)\n\n    需要注意：\n      只有函数中的构造函数参数中的resolve和reject可以改变Promise对象的状态。\n      一旦Promise对象的状态改变，就会一直保持这个状态，不能再改变。\n\n### Promise的then函数和catch函数\n\nthen函数和catch函数可以理解成对Promise状态的监听函数，不同点在于监听函数需要在事件发生之前创建，而因为Promise中的状态在改变后是不能再次改变的，所以then函数和catch函数可以在Promise对象改变状态之后创建，这样的话，该函数会立即执行。  \nthen函数接受两个函数作为参数，分别是Promise状态为`Resolved`时执行和状态为`Rejected`时执行。\n```javascript\n// promise是一个Promise对象\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\nthen函数中的函数参数是[[PromiseValue]]中的值，即是Promise构造中的resolve()、reject()中的参数。\n\n另外，then函数中的方法是异步的，即使resolve立即执行，then中的函数也在同步函数执行结束之后执行：\n```javascript\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise');\n  resolve();\n});\n\npromise.then(function() {\n  console.log('Resolved.');\n});\n\nconsole.log('Hi!');\n\n// Promise\n// Hi!\n// Resolved\n```\n\ncatch函数相当于.then(null, function () {})，是在发生错误时的回调函数，reject()执行时也算是一种错误发生，所以在执行reject()时，catch中的函数也会被执行。  \n所以，最好的方式是reject()发生时候需要执行的函数定义在catch中，而不是在then的第二个参数中，这样无论是reject()还是其他错误都能够被捕获。\n```javascript\n// bad\npromise\n  .then(function(data) {\n    // success\n  }, function(err) {\n    // error\n  });\n\n// good\npromise\n  .then(function(data) { //cb\n    // success\n  })\n  .catch(function(err) {\n    // error\n  });\n```\n\n### Promise对象的嵌套\n在resolve()和reject()中传递的可以是另一个Promise对象，例如\n```javascript\nvar p1 = new Promise(function (resolve, reject) {\n  setTimeout(() => reject(new Error('fail')), 3000)\n})\n\nvar p2 = new Promise(function (resolve, reject) {\n  setTimeout(() => resolve(p1), 1000)\n})\n\np2\n  .then(result => console.log(result))\n  .catch(error => console.log(error))\n// Error: fail\n```\np1是一个Promise，3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。此时，由于p2返回的是另一个Promise，所以后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。\n\n### 其他函数\n\n#### Promise.all()\nPromise.all()将多个Promise包装成一个Promise对象，只有在包装的多个Promise都转变成`Resolved`状态，此Promise.all()才会转变成`Resolved`状态，返回值是多个Promise返回值组成的数组；如果有其中一个转变成了`Rejected`状态，则此Promise.all()变成`Rejected`状态，返回值是第一个被reject的返回值。\n\n#### Promise.race()\nPromise.race()可以理解成Promise.all()的“否命题”。  \n将多个Promise包装成一个，只要有其中一个状态变成`Resolved`，则此Promise.race()变成`Resolved`，返回值是第一个状态变成`Resolved`的值。\n\n#### Promise.resolve()\nPromise.resolve()用于将对象转换成Promise对象。\n\n    1. 参数为Promise对象，方法什么也不做，直接返回。\n    2. 参数为一个有then方法的对象，方法将对象转换成Promise对象，并立即执行then方法。例如：Promise.resolve(Object)相当于new Promise(Object.then)\n    3. 参数不是具有then方法的对象，或者不是对象，则返回一个状态为`Resolved`的Promise对象，并将此参数传递给then中的第一个参数函数。\n    4. 不带任何参数，直接返回`Resolved`的Promise对象。\n\n#### Promise.reject()\nPromise.reject()和Promise.resolve()行为一致，只是返回的默认是`Rejected`的Promise对象。\n\n#### done()\n\n#### finally()\n","slug":"Promise总结","published":1,"updated":"2018-01-04T10:00:42.248Z","layout":"post","photos":[],"link":"","_id":"cjks5i9i0000ovmtidgwgevt7","content":"<p>因为最近项目中用到了ajax，想尝试下Promise，所以看了下ES6中的<a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"noopener\">Promise</a>。</p>\n<p>一般用法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// promise表示一个Promise对象</span></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>所以如果使用jQuery或者zepto，可以这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ajaxBack = $.ajax(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">'*****'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">ajaxBack</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理数据</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理报错</span></span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"什么是Promise对象？\"><a href=\"#什么是Promise对象？\" class=\"headerlink\" title=\"什么是Promise对象？\"></a>什么是Promise对象？</h3><p>Promise是异步编程的一种解决方案。<br>首先，我们通过chrome浏览器控制台来看一下Promise对象的样子。<br>在控制台输入<code>Promise</code>然后回车，会看到输出<code>function Promise() { [native code] }</code>。然后我们new一个Promise出来看一下，<code>var promise = new Promise(function(){})</code>，在创建Promise对象时候，必须传递一个函数，否则会报错。<br>看一下promise：<br><img src=\"/images/Promise_Object.png\" alt=\"Promise对象\"><br>包括__proto__，[[PromiseStatus]]，[[PromiseValue]]三个属性，其中__proto__主要包括catch、then、constructor方法。所以我们对Promise的学习主要就是[[PromiseStatus]]，[[PromiseValue]]属性和catch，then方法。</p>\n<h3 id=\"Promise的三种状态\"><a href=\"#Promise的三种状态\" class=\"headerlink\" title=\"Promise的三种状态\"></a>Promise的三种状态</h3><p>通过<a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"noopener\">资料</a>，我们会知道Promise对象有三种状态：Pending、Resolved和Rejected。<br>Promise构造函数接受一个函数作为参数，该函数有两个参数分别为resolve和reject，我们的创建方法应该是这样<code>new Promise(function (resolve, reject) {})</code>。<br>这两个参数resolve和reject也是函数，resolve是将Promise对象的状态从Pending变成Resolved，reject是将Promise对象的状态从Pending变成Rejected。<br>如果我们执行<code>var promise = new Promise(function(resolve, reject){resolve()})</code>，会发现promise中的[[PromiseStatus]]变成了<code>&quot;resolved&quot;</code>。如果我们执行<code>var promise = new Promise(function(resolve, reject){resolve(&#39;执行成功&#39;)})</code>，会发现不仅[[PromiseStatus]]变了，[[PromiseValue]]的值变成了<code>“执行成功”</code>。(reject函数同理)</p>\n<pre><code>需要注意：\n  只有函数中的构造函数参数中的resolve和reject可以改变Promise对象的状态。\n  一旦Promise对象的状态改变，就会一直保持这个状态，不能再改变。\n</code></pre><h3 id=\"Promise的then函数和catch函数\"><a href=\"#Promise的then函数和catch函数\" class=\"headerlink\" title=\"Promise的then函数和catch函数\"></a>Promise的then函数和catch函数</h3><p>then函数和catch函数可以理解成对Promise状态的监听函数，不同点在于监听函数需要在事件发生之前创建，而因为Promise中的状态在改变后是不能再次改变的，所以then函数和catch函数可以在Promise对象改变状态之后创建，这样的话，该函数会立即执行。<br>then函数接受两个函数作为参数，分别是Promise状态为<code>Resolved</code>时执行和状态为<code>Rejected</code>时执行。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// promise是一个Promise对象</span></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>then函数中的函数参数是[[PromiseValue]]中的值，即是Promise构造中的resolve()、reject()中的参数。</p>\n<p>另外，then函数中的方法是异步的，即使resolve立即执行，then中的函数也在同步函数执行结束之后执行：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Promise'</span>);</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved.'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Promise</span></span><br><span class=\"line\"><span class=\"comment\">// Hi!</span></span><br><span class=\"line\"><span class=\"comment\">// Resolved</span></span><br></pre></td></tr></table></figure></p>\n<p>catch函数相当于.then(null, function () {})，是在发生错误时的回调函数，reject()执行时也算是一种错误发生，所以在执行reject()时，catch中的函数也会被执行。<br>所以，最好的方式是reject()发生时候需要执行的函数定义在catch中，而不是在then的第二个参数中，这样无论是reject()还是其他错误都能够被捕获。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bad</span></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// good</span></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123; <span class=\"comment\">//cb</span></span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Promise对象的嵌套\"><a href=\"#Promise对象的嵌套\" class=\"headerlink\" title=\"Promise对象的嵌套\"></a>Promise对象的嵌套</h3><p>在resolve()和reject()中传递的可以是另一个Promise对象，例如<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'fail'</span>)), <span class=\"number\">3000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(p1), <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">p2</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> <span class=\"built_in\">console</span>.log(result))</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(error))</span><br><span class=\"line\"><span class=\"comment\">// Error: fail</span></span><br></pre></td></tr></table></figure></p>\n<p>p1是一个Promise，3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。此时，由于p2返回的是另一个Promise，所以后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。</p>\n<h3 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h3><h4 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h4><p>Promise.all()将多个Promise包装成一个Promise对象，只有在包装的多个Promise都转变成<code>Resolved</code>状态，此Promise.all()才会转变成<code>Resolved</code>状态，返回值是多个Promise返回值组成的数组；如果有其中一个转变成了<code>Rejected</code>状态，则此Promise.all()变成<code>Rejected</code>状态，返回值是第一个被reject的返回值。</p>\n<h4 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h4><p>Promise.race()可以理解成Promise.all()的“否命题”。<br>将多个Promise包装成一个，只要有其中一个状态变成<code>Resolved</code>，则此Promise.race()变成<code>Resolved</code>，返回值是第一个状态变成<code>Resolved</code>的值。</p>\n<h4 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h4><p>Promise.resolve()用于将对象转换成Promise对象。</p>\n<pre><code>1. 参数为Promise对象，方法什么也不做，直接返回。\n2. 参数为一个有then方法的对象，方法将对象转换成Promise对象，并立即执行then方法。例如：Promise.resolve(Object)相当于new Promise(Object.then)\n3. 参数不是具有then方法的对象，或者不是对象，则返回一个状态为`Resolved`的Promise对象，并将此参数传递给then中的第一个参数函数。\n4. 不带任何参数，直接返回`Resolved`的Promise对象。\n</code></pre><h4 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h4><p>Promise.reject()和Promise.resolve()行为一致，只是返回的默认是<code>Rejected</code>的Promise对象。</p>\n<h4 id=\"done\"><a href=\"#done\" class=\"headerlink\" title=\"done()\"></a>done()</h4><h4 id=\"finally\"><a href=\"#finally\" class=\"headerlink\" title=\"finally()\"></a>finally()</h4>","site":{"data":{}},"excerpt":"","more":"<p>因为最近项目中用到了ajax，想尝试下Promise，所以看了下ES6中的<a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"noopener\">Promise</a>。</p>\n<p>一般用法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// promise表示一个Promise对象</span></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>所以如果使用jQuery或者zepto，可以这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ajaxBack = $.ajax(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">'*****'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">ajaxBack</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理数据</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理报错</span></span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"什么是Promise对象？\"><a href=\"#什么是Promise对象？\" class=\"headerlink\" title=\"什么是Promise对象？\"></a>什么是Promise对象？</h3><p>Promise是异步编程的一种解决方案。<br>首先，我们通过chrome浏览器控制台来看一下Promise对象的样子。<br>在控制台输入<code>Promise</code>然后回车，会看到输出<code>function Promise() { [native code] }</code>。然后我们new一个Promise出来看一下，<code>var promise = new Promise(function(){})</code>，在创建Promise对象时候，必须传递一个函数，否则会报错。<br>看一下promise：<br><img src=\"/images/Promise_Object.png\" alt=\"Promise对象\"><br>包括__proto__，[[PromiseStatus]]，[[PromiseValue]]三个属性，其中__proto__主要包括catch、then、constructor方法。所以我们对Promise的学习主要就是[[PromiseStatus]]，[[PromiseValue]]属性和catch，then方法。</p>\n<h3 id=\"Promise的三种状态\"><a href=\"#Promise的三种状态\" class=\"headerlink\" title=\"Promise的三种状态\"></a>Promise的三种状态</h3><p>通过<a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"noopener\">资料</a>，我们会知道Promise对象有三种状态：Pending、Resolved和Rejected。<br>Promise构造函数接受一个函数作为参数，该函数有两个参数分别为resolve和reject，我们的创建方法应该是这样<code>new Promise(function (resolve, reject) {})</code>。<br>这两个参数resolve和reject也是函数，resolve是将Promise对象的状态从Pending变成Resolved，reject是将Promise对象的状态从Pending变成Rejected。<br>如果我们执行<code>var promise = new Promise(function(resolve, reject){resolve()})</code>，会发现promise中的[[PromiseStatus]]变成了<code>&quot;resolved&quot;</code>。如果我们执行<code>var promise = new Promise(function(resolve, reject){resolve(&#39;执行成功&#39;)})</code>，会发现不仅[[PromiseStatus]]变了，[[PromiseValue]]的值变成了<code>“执行成功”</code>。(reject函数同理)</p>\n<pre><code>需要注意：\n  只有函数中的构造函数参数中的resolve和reject可以改变Promise对象的状态。\n  一旦Promise对象的状态改变，就会一直保持这个状态，不能再改变。\n</code></pre><h3 id=\"Promise的then函数和catch函数\"><a href=\"#Promise的then函数和catch函数\" class=\"headerlink\" title=\"Promise的then函数和catch函数\"></a>Promise的then函数和catch函数</h3><p>then函数和catch函数可以理解成对Promise状态的监听函数，不同点在于监听函数需要在事件发生之前创建，而因为Promise中的状态在改变后是不能再次改变的，所以then函数和catch函数可以在Promise对象改变状态之后创建，这样的话，该函数会立即执行。<br>then函数接受两个函数作为参数，分别是Promise状态为<code>Resolved</code>时执行和状态为<code>Rejected</code>时执行。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// promise是一个Promise对象</span></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>then函数中的函数参数是[[PromiseValue]]中的值，即是Promise构造中的resolve()、reject()中的参数。</p>\n<p>另外，then函数中的方法是异步的，即使resolve立即执行，then中的函数也在同步函数执行结束之后执行：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Promise'</span>);</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved.'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Promise</span></span><br><span class=\"line\"><span class=\"comment\">// Hi!</span></span><br><span class=\"line\"><span class=\"comment\">// Resolved</span></span><br></pre></td></tr></table></figure></p>\n<p>catch函数相当于.then(null, function () {})，是在发生错误时的回调函数，reject()执行时也算是一种错误发生，所以在执行reject()时，catch中的函数也会被执行。<br>所以，最好的方式是reject()发生时候需要执行的函数定义在catch中，而不是在then的第二个参数中，这样无论是reject()还是其他错误都能够被捕获。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bad</span></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// good</span></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123; <span class=\"comment\">//cb</span></span><br><span class=\"line\">    <span class=\"comment\">// success</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Promise对象的嵌套\"><a href=\"#Promise对象的嵌套\" class=\"headerlink\" title=\"Promise对象的嵌套\"></a>Promise对象的嵌套</h3><p>在resolve()和reject()中传递的可以是另一个Promise对象，例如<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'fail'</span>)), <span class=\"number\">3000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(p1), <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">p2</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> <span class=\"built_in\">console</span>.log(result))</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(error))</span><br><span class=\"line\"><span class=\"comment\">// Error: fail</span></span><br></pre></td></tr></table></figure></p>\n<p>p1是一个Promise，3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。此时，由于p2返回的是另一个Promise，所以后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。</p>\n<h3 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h3><h4 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h4><p>Promise.all()将多个Promise包装成一个Promise对象，只有在包装的多个Promise都转变成<code>Resolved</code>状态，此Promise.all()才会转变成<code>Resolved</code>状态，返回值是多个Promise返回值组成的数组；如果有其中一个转变成了<code>Rejected</code>状态，则此Promise.all()变成<code>Rejected</code>状态，返回值是第一个被reject的返回值。</p>\n<h4 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h4><p>Promise.race()可以理解成Promise.all()的“否命题”。<br>将多个Promise包装成一个，只要有其中一个状态变成<code>Resolved</code>，则此Promise.race()变成<code>Resolved</code>，返回值是第一个状态变成<code>Resolved</code>的值。</p>\n<h4 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h4><p>Promise.resolve()用于将对象转换成Promise对象。</p>\n<pre><code>1. 参数为Promise对象，方法什么也不做，直接返回。\n2. 参数为一个有then方法的对象，方法将对象转换成Promise对象，并立即执行then方法。例如：Promise.resolve(Object)相当于new Promise(Object.then)\n3. 参数不是具有then方法的对象，或者不是对象，则返回一个状态为`Resolved`的Promise对象，并将此参数传递给then中的第一个参数函数。\n4. 不带任何参数，直接返回`Resolved`的Promise对象。\n</code></pre><h4 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h4><p>Promise.reject()和Promise.resolve()行为一致，只是返回的默认是<code>Rejected</code>的Promise对象。</p>\n<h4 id=\"done\"><a href=\"#done\" class=\"headerlink\" title=\"done()\"></a>done()</h4><h4 id=\"finally\"><a href=\"#finally\" class=\"headerlink\" title=\"finally()\"></a>finally()</h4>"},{"title":"React Docs（1）","date":"2016-12-08T16:00:00.000Z","comments":1,"_content":"\n### 安装\nReact在codepen上提供了一个Hello，World项目事例，只需打开[网站](http://codepen.io/gaearon/pen/rrpgNB?editors=0010)，即可尝试React。  \n另外还提供了一个[html文件](https://facebook.github.io/react/downloads/single-file-example.html)的Hello，World项目，项目中引用CDN的react.js、react-dom.js以及用于编译babel的babel.min.js，运行比较缓慢，只适合学习语法使用。\n\n### 创建单页面应用\n创建React应用的最好方法是单页面应用，这里是最好方法，也是可以创建多页面应用的。可以通过官方方法去创建你的应用：\n```shell\nnpm install -g create-react-app\ncreate-create-app hello-world\ncd hello-world\nnpm start\n```\n这里不涉及任何后端逻辑和数据库，可以使用任何你想用的后端。create-react-app中使用了Webpack，Babel和ESLint，但是你可以自己去配置他们。\n\n#### 将React加入一个现有的应用\n使用`npm install --save react react-dom`安装React。  \n将其导入你的代码中，如：\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nReactDOM.render(\n  <h1>Hello, world!</h1>,\n  document.getElementById('root')\n)\n```\n这段代码应该被包含在一个拥有id为root的HTML元素，所以你的HTML文件需要`<div id=\"root\"></div>`  \n当你使用上面方法使用React的时候，需要使用预设为es2015和react的Babel进行转化代码。使用React在生产环境的时候，设置NODE_ENV为\"production\"。\n\n#### 使用ES6和JSX\n建议是用Babel将你的ES6和JSX代码转换为JavaScript代码，Babel可以有很多不同的配置，但是确保里面包含`babel-preset-react`和`babel-preset-es2015`。\n\n#### 使用CDN\n如果不想使用npm，可以使用CDN\n```html\n<script src=\"https://unpkg.com/react@15/dist/react.js\"></script>\n<script src=\"https://unpkg.com/react-dom@15/dist/react-dom.js\"></script>\n```\n@后面数字可以指定版本\n```html\n<script src=\"https://unpkg.com/react@15/dist/react.min.js\"></script>\n<script src=\"https://unpkg.com/react-dom@15/dist/react-dom.min.js\"></script>\n```\n\n### JSX\n在JSX中，可以在任意地方插入JavaScript代码，只需要将JavaScript放在大括号中即可。下面的代码都是合法的：\n```jsx\nfunction formatName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\nconst user = {\n  firstName: 'Harper',\n  lastName: 'Perez'\n};\n\nconst element = (\n  <h1>\n    Hello, {formatName(user)}!\n  </h1>\n);\n\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);\n```\n将JSX代码放在小括号中，像HTML代码一样换行，可以方便阅读。\n\n##### JSX也是表达式\nJSX最后也被编译成JavaScript代码，这就以为着JSX可以赋值给一个JavaScript变量，可以作为方法的参数，可以被方法返回。\n\n##### JSX添加HTML属性\n可以用字符串设置属性，也可以通过使用{}将JavaScript表达式赋值给属性。\n\n##### 闭合JSX\n如果JSX是空的可以使用`/>`来闭合标签，如果包含其他标签，也可以使用</***>闭合。  \n虽然JSX很接近HTML，但是还是有些不同，比如属性使用小驼峰法命名，class使用className，for使用forHtml等。\n\n##### JSX防止注入攻击\n默认情况下，React DOM在渲染JSX之前会对其进行编码。\n\n##### JSX描述对象\nBabel会将JSX转化为React.createElement()形式，比如下面这样：\n```jsx\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n)\n```\n转化为\n```javascript\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n```\nReact.createElement会对你的代码进行一些检查，但是本质上就是将其转化成一个对象：\n```javascript\nconst element = {\n  type: 'h1',\n  props: {\n    className: 'greeting',\n    children: 'Hello, world'\n  }\n}\n```\n\n### 组件\n将你的页面分成一个个组件，每个组件都是独立的、可以重复使用的。组件就像JavaScript中的方法，可以接受一些输入参数，返回React元素\n\n##### Funtional 和 Class 组件\n定义组件最简单的方式是使用JavaScript方法：\n```javascript\nfunction Welcome (props) {\n  return <h1>Hello, {props.name}</h1>\n}\n这个方法就是个有效的React组件，因为它接受props作为参数，并且返回了一个React元素。\n\n另外也可以使用ES6中的类(class)来定义组件：\n```javascript\nclass Welcome extends React.Component {\n  render () {\n    return <h1>Hello, {this.props.name}</h1>\n  }\n}\n```\n上面两种定义组件的方法是等价的。  \n但是Class组件能够添加一些额外的功能，我们将在下面讨论。在不需要这些额外的方法，可以使用Functional组件。\n\n##### 渲染组件\n渲染如下：\n```javascript\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n\nconst element = <Welcome name=\"Sara\" />;\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);\n```\n过程：\n  1. 调用ReactDOM.render()方法，参数为自定义组件<Welcome name=\"Sara\" />。\n  2. React调用组件Welcome，传递`{name=\"Sara\"}`作为参数。\n  3. Welcome组件返回`<h1>Hello, Sara</h1>`。\n  4. React将`<h1>Hello, Sara</h1>`更新到页面。\n\n##### 组件组合\n组件可以任意组合。  \n通常情况，React应用中在最顶端是一个`App`组件。组件必须有一个根元素，也就是所有元素都得包裹起来。\n\n##### 提取组件\n不要担心组件被拆分的太小。下面是一个对组件进行拆分的例子。  \nComment组件：  \n```javascript\nfunction Comment(props) {\n  return (\n    <div className=\"Comment\">\n      <div className=\"UserInfo\">\n        <img className=\"Avatar\"\n          src={props.author.avatarUrl}\n          alt={props.author.name}\n        />\n        <div className=\"UserInfo-name\">\n          {props.author.name}\n        </div>\n      </div>\n      <div className=\"Comment-text\">\n        {props.text}\n      </div>\n      <div className=\"Comment-date\">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n```\n在Comment组件中，使用了`author (object)`，`text (string)`，`date (date)`来描述这个对象。这样的组件因为组合的原因是很难复用的。\n\n第一步，提取出一个`Avatar`组件：\n```javascript\nfunction Avatar(props) {\n  return (\n    <img className=\"Avatar\"\n      src={props.user.avatarUrl}\n      alt={props.user.name}\n    />\n  );\n}\n```\n这里的`Avatar`组件我们系统他更通用，所以说用了`user`而不是`author`。  \n根据组件去命名参数，而不是根据使用上下文。\n\n下一步是提取`UserInfo`组件，这里使用了上面提取的`Avatar`组件：\n```javascript\nfunction UserInfo(props) {\n  return (\n    <div className=\"UserInfo\">\n      <Avatar user={props.user} />\n      <div className=\"UserInfo-name\">\n        {props.user.name}\n      </div>\n    </div>\n  );\n}\n```\n这样，我们的`Comment`组件就成了下面的样子：\n```javascript\nfunction Comment(props) {\n  return (\n    <div className=\"Comment\">\n      <UserInfo user={props.author} />\n      <div className=\"Comment-text\">\n        {props.text}\n      </div>\n      <div className=\"Comment-date\">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n```\n\n##### Props是只读的\n无论是Funcional还是Class组件，都是不能够修改props的。\n```javascript\n// 下面这个是纯函数，因为它没有试图改变自己的输入，并且对相同的输入会有相同的输出。\nfunction sum(a, b) {\n  return a + b;\n}\n// 下面这个不是纯函数，因为他改变了输入的值\nfunction withdraw(account, amount) {\n  account.total -= amount;\n}\n```\n通过官方这个例子，可以明白纯函数有两点，一是相同的输入就会有相同的输出，第二点是不会更改输入的参数。\n\n所有的React组件对于props参数必须像纯函数一样，也就是不会试图去修改props，并且对于相同的props会有相同的输出。  \n当然，React也提供了随时间动态变化组件的方法，state允许根据用户行为、网络反馈等改变React组件的输出形式，这并不违背React纯函数原则。\n\n### state 和 生命周期\n请看下面一段代码：\n```javascript\nconst Clock = (\n  <div>\n    <h1>Hello, world!</h1>\n    <h2>It is {new Date().toLocaleTimeString()}.</h2>\n  </div>\n);\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n```\n这段代码只能够显示一个Hello,world!与一个生成页面的时间。如果想要时间不停的更新，就需要使用setInterval()不停的去执行。\n```javascript\n// 这样\nfunction tick() {\n  const Clock = (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {new Date().toLocaleTimeString()}.</h2>\n    </div>\n  );\n  ReactDOM.render(\n    <Clock />,\n    document.getElementById('root')\n  );\n}\nsetInterval(tick, 1000);\n\n// 或者这样\nfunction Clock(props) {\n  return (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {props.date.toLocaleTimeString()}.</h2>\n    </div>\n  );\n}\n\nfunction tick() {\n  ReactDOM.render(\n    <Clock date={new Date()} />,\n    document.getElementById('root')\n  );\n}\nsetInterval(tick, 1000);\n\n// 但是下面这种就是不可行的，原因在于Clock组件定义被转化成了一个对象，在之后没有发生过变化。\nconst Clock = (\n  <div>\n    <h1>Hello, world!</h1>\n    <h2>It is {new Date().toLocaleTimeString()}.</h2>\n  </div>\n);\nsetInterval(\nfunction(){\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n)}, 1000)\n```\n这样的代码的问题在于时间的变化应该是`Clock`组件的行为，而不应该定义在全局。  \n`state`可以帮助我们解决这个问题，state与props类似，但是更私有且被组件所控制，而不是传递过来的。\n\n##### 将Functional组件转换为Class组件\nFunctional组件是无状态组件，不能使用state，所以首先需要将Functional转化为Class组件：\n  1. 创建一个和Functional组件名相同的ES6 class继承`React.Component`\n  2. 添加空的方法`render()`\n  3. 将Functional组件中的函数主体移动`render()`方法中\n  4. 将`render()`中的`props`替换成`this.props`\n  5. 删除原来的Functional组件声明\nClass组件不仅可以使用state还可以使用生命周期函数。  \n拿上面的`Clock`组件作为事例，经过上面的转换，现在的Clock组件应该是这个样子：\n```jsx\nclass Clock extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.props.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\n\n##### 为Class组件添加本地state\n还是上面的`Clock`组件：\n  1. 将`render()`中的`this.props`替换成`this.state`\n  2. 添加class构造函数(constructor)初始化this.state (Class组件总是应该将props传递给父类)\n  3. 移除`date`从组件调用的props中\n```javascript\nclass Clock extends React.Component {\n  // 这里是步骤2\n  constructor(props) {\n    // 将props传递给父类\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n```\n这样只是初始化了state，后面会设置定时器。\n","source":"_posts/React Docs(1).md","raw":"---\ntitle: React Docs（1）\ndate: 2016-12-09\ntags: [JavaScript, React]\ncategories: \n- React\ncomments: true\n---\n\n### 安装\nReact在codepen上提供了一个Hello，World项目事例，只需打开[网站](http://codepen.io/gaearon/pen/rrpgNB?editors=0010)，即可尝试React。  \n另外还提供了一个[html文件](https://facebook.github.io/react/downloads/single-file-example.html)的Hello，World项目，项目中引用CDN的react.js、react-dom.js以及用于编译babel的babel.min.js，运行比较缓慢，只适合学习语法使用。\n\n### 创建单页面应用\n创建React应用的最好方法是单页面应用，这里是最好方法，也是可以创建多页面应用的。可以通过官方方法去创建你的应用：\n```shell\nnpm install -g create-react-app\ncreate-create-app hello-world\ncd hello-world\nnpm start\n```\n这里不涉及任何后端逻辑和数据库，可以使用任何你想用的后端。create-react-app中使用了Webpack，Babel和ESLint，但是你可以自己去配置他们。\n\n#### 将React加入一个现有的应用\n使用`npm install --save react react-dom`安装React。  \n将其导入你的代码中，如：\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nReactDOM.render(\n  <h1>Hello, world!</h1>,\n  document.getElementById('root')\n)\n```\n这段代码应该被包含在一个拥有id为root的HTML元素，所以你的HTML文件需要`<div id=\"root\"></div>`  \n当你使用上面方法使用React的时候，需要使用预设为es2015和react的Babel进行转化代码。使用React在生产环境的时候，设置NODE_ENV为\"production\"。\n\n#### 使用ES6和JSX\n建议是用Babel将你的ES6和JSX代码转换为JavaScript代码，Babel可以有很多不同的配置，但是确保里面包含`babel-preset-react`和`babel-preset-es2015`。\n\n#### 使用CDN\n如果不想使用npm，可以使用CDN\n```html\n<script src=\"https://unpkg.com/react@15/dist/react.js\"></script>\n<script src=\"https://unpkg.com/react-dom@15/dist/react-dom.js\"></script>\n```\n@后面数字可以指定版本\n```html\n<script src=\"https://unpkg.com/react@15/dist/react.min.js\"></script>\n<script src=\"https://unpkg.com/react-dom@15/dist/react-dom.min.js\"></script>\n```\n\n### JSX\n在JSX中，可以在任意地方插入JavaScript代码，只需要将JavaScript放在大括号中即可。下面的代码都是合法的：\n```jsx\nfunction formatName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\nconst user = {\n  firstName: 'Harper',\n  lastName: 'Perez'\n};\n\nconst element = (\n  <h1>\n    Hello, {formatName(user)}!\n  </h1>\n);\n\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);\n```\n将JSX代码放在小括号中，像HTML代码一样换行，可以方便阅读。\n\n##### JSX也是表达式\nJSX最后也被编译成JavaScript代码，这就以为着JSX可以赋值给一个JavaScript变量，可以作为方法的参数，可以被方法返回。\n\n##### JSX添加HTML属性\n可以用字符串设置属性，也可以通过使用{}将JavaScript表达式赋值给属性。\n\n##### 闭合JSX\n如果JSX是空的可以使用`/>`来闭合标签，如果包含其他标签，也可以使用</***>闭合。  \n虽然JSX很接近HTML，但是还是有些不同，比如属性使用小驼峰法命名，class使用className，for使用forHtml等。\n\n##### JSX防止注入攻击\n默认情况下，React DOM在渲染JSX之前会对其进行编码。\n\n##### JSX描述对象\nBabel会将JSX转化为React.createElement()形式，比如下面这样：\n```jsx\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n)\n```\n转化为\n```javascript\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n```\nReact.createElement会对你的代码进行一些检查，但是本质上就是将其转化成一个对象：\n```javascript\nconst element = {\n  type: 'h1',\n  props: {\n    className: 'greeting',\n    children: 'Hello, world'\n  }\n}\n```\n\n### 组件\n将你的页面分成一个个组件，每个组件都是独立的、可以重复使用的。组件就像JavaScript中的方法，可以接受一些输入参数，返回React元素\n\n##### Funtional 和 Class 组件\n定义组件最简单的方式是使用JavaScript方法：\n```javascript\nfunction Welcome (props) {\n  return <h1>Hello, {props.name}</h1>\n}\n这个方法就是个有效的React组件，因为它接受props作为参数，并且返回了一个React元素。\n\n另外也可以使用ES6中的类(class)来定义组件：\n```javascript\nclass Welcome extends React.Component {\n  render () {\n    return <h1>Hello, {this.props.name}</h1>\n  }\n}\n```\n上面两种定义组件的方法是等价的。  \n但是Class组件能够添加一些额外的功能，我们将在下面讨论。在不需要这些额外的方法，可以使用Functional组件。\n\n##### 渲染组件\n渲染如下：\n```javascript\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n\nconst element = <Welcome name=\"Sara\" />;\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);\n```\n过程：\n  1. 调用ReactDOM.render()方法，参数为自定义组件<Welcome name=\"Sara\" />。\n  2. React调用组件Welcome，传递`{name=\"Sara\"}`作为参数。\n  3. Welcome组件返回`<h1>Hello, Sara</h1>`。\n  4. React将`<h1>Hello, Sara</h1>`更新到页面。\n\n##### 组件组合\n组件可以任意组合。  \n通常情况，React应用中在最顶端是一个`App`组件。组件必须有一个根元素，也就是所有元素都得包裹起来。\n\n##### 提取组件\n不要担心组件被拆分的太小。下面是一个对组件进行拆分的例子。  \nComment组件：  \n```javascript\nfunction Comment(props) {\n  return (\n    <div className=\"Comment\">\n      <div className=\"UserInfo\">\n        <img className=\"Avatar\"\n          src={props.author.avatarUrl}\n          alt={props.author.name}\n        />\n        <div className=\"UserInfo-name\">\n          {props.author.name}\n        </div>\n      </div>\n      <div className=\"Comment-text\">\n        {props.text}\n      </div>\n      <div className=\"Comment-date\">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n```\n在Comment组件中，使用了`author (object)`，`text (string)`，`date (date)`来描述这个对象。这样的组件因为组合的原因是很难复用的。\n\n第一步，提取出一个`Avatar`组件：\n```javascript\nfunction Avatar(props) {\n  return (\n    <img className=\"Avatar\"\n      src={props.user.avatarUrl}\n      alt={props.user.name}\n    />\n  );\n}\n```\n这里的`Avatar`组件我们系统他更通用，所以说用了`user`而不是`author`。  \n根据组件去命名参数，而不是根据使用上下文。\n\n下一步是提取`UserInfo`组件，这里使用了上面提取的`Avatar`组件：\n```javascript\nfunction UserInfo(props) {\n  return (\n    <div className=\"UserInfo\">\n      <Avatar user={props.user} />\n      <div className=\"UserInfo-name\">\n        {props.user.name}\n      </div>\n    </div>\n  );\n}\n```\n这样，我们的`Comment`组件就成了下面的样子：\n```javascript\nfunction Comment(props) {\n  return (\n    <div className=\"Comment\">\n      <UserInfo user={props.author} />\n      <div className=\"Comment-text\">\n        {props.text}\n      </div>\n      <div className=\"Comment-date\">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n```\n\n##### Props是只读的\n无论是Funcional还是Class组件，都是不能够修改props的。\n```javascript\n// 下面这个是纯函数，因为它没有试图改变自己的输入，并且对相同的输入会有相同的输出。\nfunction sum(a, b) {\n  return a + b;\n}\n// 下面这个不是纯函数，因为他改变了输入的值\nfunction withdraw(account, amount) {\n  account.total -= amount;\n}\n```\n通过官方这个例子，可以明白纯函数有两点，一是相同的输入就会有相同的输出，第二点是不会更改输入的参数。\n\n所有的React组件对于props参数必须像纯函数一样，也就是不会试图去修改props，并且对于相同的props会有相同的输出。  \n当然，React也提供了随时间动态变化组件的方法，state允许根据用户行为、网络反馈等改变React组件的输出形式，这并不违背React纯函数原则。\n\n### state 和 生命周期\n请看下面一段代码：\n```javascript\nconst Clock = (\n  <div>\n    <h1>Hello, world!</h1>\n    <h2>It is {new Date().toLocaleTimeString()}.</h2>\n  </div>\n);\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n```\n这段代码只能够显示一个Hello,world!与一个生成页面的时间。如果想要时间不停的更新，就需要使用setInterval()不停的去执行。\n```javascript\n// 这样\nfunction tick() {\n  const Clock = (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {new Date().toLocaleTimeString()}.</h2>\n    </div>\n  );\n  ReactDOM.render(\n    <Clock />,\n    document.getElementById('root')\n  );\n}\nsetInterval(tick, 1000);\n\n// 或者这样\nfunction Clock(props) {\n  return (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {props.date.toLocaleTimeString()}.</h2>\n    </div>\n  );\n}\n\nfunction tick() {\n  ReactDOM.render(\n    <Clock date={new Date()} />,\n    document.getElementById('root')\n  );\n}\nsetInterval(tick, 1000);\n\n// 但是下面这种就是不可行的，原因在于Clock组件定义被转化成了一个对象，在之后没有发生过变化。\nconst Clock = (\n  <div>\n    <h1>Hello, world!</h1>\n    <h2>It is {new Date().toLocaleTimeString()}.</h2>\n  </div>\n);\nsetInterval(\nfunction(){\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n)}, 1000)\n```\n这样的代码的问题在于时间的变化应该是`Clock`组件的行为，而不应该定义在全局。  \n`state`可以帮助我们解决这个问题，state与props类似，但是更私有且被组件所控制，而不是传递过来的。\n\n##### 将Functional组件转换为Class组件\nFunctional组件是无状态组件，不能使用state，所以首先需要将Functional转化为Class组件：\n  1. 创建一个和Functional组件名相同的ES6 class继承`React.Component`\n  2. 添加空的方法`render()`\n  3. 将Functional组件中的函数主体移动`render()`方法中\n  4. 将`render()`中的`props`替换成`this.props`\n  5. 删除原来的Functional组件声明\nClass组件不仅可以使用state还可以使用生命周期函数。  \n拿上面的`Clock`组件作为事例，经过上面的转换，现在的Clock组件应该是这个样子：\n```jsx\nclass Clock extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.props.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\n\n##### 为Class组件添加本地state\n还是上面的`Clock`组件：\n  1. 将`render()`中的`this.props`替换成`this.state`\n  2. 添加class构造函数(constructor)初始化this.state (Class组件总是应该将props传递给父类)\n  3. 移除`date`从组件调用的props中\n```javascript\nclass Clock extends React.Component {\n  // 这里是步骤2\n  constructor(props) {\n    // 将props传递给父类\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n```\n这样只是初始化了state，后面会设置定时器。\n","slug":"React Docs(1)","published":1,"updated":"2017-12-28T03:47:32.454Z","layout":"post","photos":[],"link":"","_id":"cjks5i9i1000svmti7mquq51q","content":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>React在codepen上提供了一个Hello，World项目事例，只需打开<a href=\"http://codepen.io/gaearon/pen/rrpgNB?editors=0010\" target=\"_blank\" rel=\"noopener\">网站</a>，即可尝试React。<br>另外还提供了一个<a href=\"https://facebook.github.io/react/downloads/single-file-example.html\" target=\"_blank\" rel=\"noopener\">html文件</a>的Hello，World项目，项目中引用CDN的react.js、react-dom.js以及用于编译babel的babel.min.js，运行比较缓慢，只适合学习语法使用。</p>\n<h3 id=\"创建单页面应用\"><a href=\"#创建单页面应用\" class=\"headerlink\" title=\"创建单页面应用\"></a>创建单页面应用</h3><p>创建React应用的最好方法是单页面应用，这里是最好方法，也是可以创建多页面应用的。可以通过官方方法去创建你的应用：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g create-react-app</span><br><span class=\"line\">create-create-app hello-world</span><br><span class=\"line\">cd hello-world</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure></p>\n<p>这里不涉及任何后端逻辑和数据库，可以使用任何你想用的后端。create-react-app中使用了Webpack，Babel和ESLint，但是你可以自己去配置他们。</p>\n<h4 id=\"将React加入一个现有的应用\"><a href=\"#将React加入一个现有的应用\" class=\"headerlink\" title=\"将React加入一个现有的应用\"></a>将React加入一个现有的应用</h4><p>使用<code>npm install --save react react-dom</code>安装React。<br>将其导入你的代码中，如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>这段代码应该被包含在一个拥有id为root的HTML元素，所以你的HTML文件需要<code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code><br>当你使用上面方法使用React的时候，需要使用预设为es2015和react的Babel进行转化代码。使用React在生产环境的时候，设置NODE_ENV为”production”。</p>\n<h4 id=\"使用ES6和JSX\"><a href=\"#使用ES6和JSX\" class=\"headerlink\" title=\"使用ES6和JSX\"></a>使用ES6和JSX</h4><p>建议是用Babel将你的ES6和JSX代码转换为JavaScript代码，Babel可以有很多不同的配置，但是确保里面包含<code>babel-preset-react</code>和<code>babel-preset-es2015</code>。</p>\n<h4 id=\"使用CDN\"><a href=\"#使用CDN\" class=\"headerlink\" title=\"使用CDN\"></a>使用CDN</h4><p>如果不想使用npm，可以使用CDN<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react@15/dist/react.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react-dom@15/dist/react-dom.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>@后面数字可以指定版本<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react@15/dist/react.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react-dom@15/dist/react-dom.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h3><p>在JSX中，可以在任意地方插入JavaScript代码，只需要将JavaScript放在大括号中即可。下面的代码都是合法的：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatName</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> user.firstName + <span class=\"string\">' '</span> + user.lastName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;</span><br><span class=\"line\">  firstName: <span class=\"string\">'Harper'</span>,</span><br><span class=\"line\">  lastName: <span class=\"string\">'Perez'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  &lt;h1&gt;</span><br><span class=\"line\">    Hello, &#123;formatName(user)&#125;!</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">  element,</span></span><br><span class=\"line\"><span class=\"regexp\">  document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure></p>\n<p>将JSX代码放在小括号中，像HTML代码一样换行，可以方便阅读。</p>\n<h5 id=\"JSX也是表达式\"><a href=\"#JSX也是表达式\" class=\"headerlink\" title=\"JSX也是表达式\"></a>JSX也是表达式</h5><p>JSX最后也被编译成JavaScript代码，这就以为着JSX可以赋值给一个JavaScript变量，可以作为方法的参数，可以被方法返回。</p>\n<h5 id=\"JSX添加HTML属性\"><a href=\"#JSX添加HTML属性\" class=\"headerlink\" title=\"JSX添加HTML属性\"></a>JSX添加HTML属性</h5><p>可以用字符串设置属性，也可以通过使用{}将JavaScript表达式赋值给属性。</p>\n<h5 id=\"闭合JSX\"><a href=\"#闭合JSX\" class=\"headerlink\" title=\"闭合JSX\"></a>闭合JSX</h5><p>如果JSX是空的可以使用<code>/&gt;</code>来闭合标签，如果包含其他标签，也可以使用&lt;/***&gt;闭合。<br>虽然JSX很接近HTML，但是还是有些不同，比如属性使用小驼峰法命名，class使用className，for使用forHtml等。</p>\n<h5 id=\"JSX防止注入攻击\"><a href=\"#JSX防止注入攻击\" class=\"headerlink\" title=\"JSX防止注入攻击\"></a>JSX防止注入攻击</h5><p>默认情况下，React DOM在渲染JSX之前会对其进行编码。</p>\n<h5 id=\"JSX描述对象\"><a href=\"#JSX描述对象\" class=\"headerlink\" title=\"JSX描述对象\"></a>JSX描述对象</h5><p>Babel会将JSX转化为React.createElement()形式，比如下面这样：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  &lt;h1 className=<span class=\"string\">\"greeting\"</span>&gt;</span><br><span class=\"line\">    Hello, world!</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br></pre></td></tr></table></figure></p>\n<p>转化为<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = React.createElement(</span><br><span class=\"line\">  <span class=\"string\">'h1'</span>,</span><br><span class=\"line\">  &#123;<span class=\"attr\">className</span>: <span class=\"string\">'greeting'</span>&#125;,</span><br><span class=\"line\">  <span class=\"string\">'Hello, world!'</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>React.createElement会对你的代码进行一些检查，但是本质上就是将其转化成一个对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = &#123;</span><br><span class=\"line\">  type: <span class=\"string\">'h1'</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    className: <span class=\"string\">'greeting'</span>,</span><br><span class=\"line\">    children: <span class=\"string\">'Hello, world'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h3><p>将你的页面分成一个个组件，每个组件都是独立的、可以重复使用的。组件就像JavaScript中的方法，可以接受一些输入参数，返回React元素</p>\n<h5 id=\"Funtional-和-Class-组件\"><a href=\"#Funtional-和-Class-组件\" class=\"headerlink\" title=\"Funtional 和 Class 组件\"></a>Funtional 和 Class 组件</h5><p>定义组件最简单的方式是使用JavaScript方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span> (<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">这个方法就是个有效的React组件，因为它接受props作为参数，并且返回了一个React元素。</span><br><span class=\"line\"></span><br><span class=\"line\">另外也可以使用ES6中的类(<span class=\"class\"><span class=\"keyword\">class</span>)来定义组件：</span></span><br><span class=\"line\"><span class=\"class\">```<span class=\"title\">javascript</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Welcome</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面两种定义组件的方法是等价的。<br>但是Class组件能够添加一些额外的功能，我们将在下面讨论。在不需要这些额外的方法，可以使用Functional组件。</p>\n<h5 id=\"渲染组件\"><a href=\"#渲染组件\" class=\"headerlink\" title=\"渲染组件\"></a>渲染组件</h5><p>渲染如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Welcome</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Sara\"</span> /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"xml\">  element,</span></span><br><span class=\"line\"><span class=\"xml\">  document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"xml\">);</span></span><br></pre></td></tr></table></figure></p>\n<p>过程：</p>\n<ol>\n<li>调用ReactDOM.render()方法，参数为自定义组件<welcome name=\"Sara\">。</welcome></li>\n<li>React调用组件Welcome，传递<code>{name=&quot;Sara&quot;}</code>作为参数。</li>\n<li>Welcome组件返回<code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>。</li>\n<li>React将<code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>更新到页面。</li>\n</ol>\n<h5 id=\"组件组合\"><a href=\"#组件组合\" class=\"headerlink\" title=\"组件组合\"></a>组件组合</h5><p>组件可以任意组合。<br>通常情况，React应用中在最顶端是一个<code>App</code>组件。组件必须有一个根元素，也就是所有元素都得包裹起来。</p>\n<h5 id=\"提取组件\"><a href=\"#提取组件\" class=\"headerlink\" title=\"提取组件\"></a>提取组件</h5><p>不要担心组件被拆分的太小。下面是一个对组件进行拆分的例子。<br>Comment组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Comment</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div className=<span class=\"string\">\"Comment\"</span>&gt;</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"UserInfo\"</span>&gt;</span><br><span class=\"line\">        &lt;img className=<span class=\"string\">\"Avatar\"</span></span><br><span class=\"line\">          src=&#123;props.author.avatarUrl&#125;</span><br><span class=\"line\">          alt=&#123;props.author.name&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">        &lt;div className=<span class=\"string\">\"UserInfo-name\"</span>&gt;</span><br><span class=\"line\">          &#123;props.author.name&#125;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"Comment-text\"</span>&gt;</span><br><span class=\"line\">        &#123;props.text&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div className=\"Comment-date\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;formatDate(props.date)&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>在Comment组件中，使用了<code>author (object)</code>，<code>text (string)</code>，<code>date (date)</code>来描述这个对象。这样的组件因为组合的原因是很难复用的。</p>\n<p>第一步，提取出一个<code>Avatar</code>组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Avatar</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;img className=<span class=\"string\">\"Avatar\"</span></span><br><span class=\"line\">      src=&#123;props.user.avatarUrl&#125;</span><br><span class=\"line\">      alt=&#123;props.user.name&#125;</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的<code>Avatar</code>组件我们系统他更通用，所以说用了<code>user</code>而不是<code>author</code>。<br>根据组件去命名参数，而不是根据使用上下文。</p>\n<p>下一步是提取<code>UserInfo</code>组件，这里使用了上面提取的<code>Avatar</code>组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserInfo</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div className=<span class=\"string\">\"UserInfo\"</span>&gt;</span><br><span class=\"line\">      &lt;Avatar user=&#123;props.user&#125; /&gt;</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"UserInfo-name\"</span>&gt;</span><br><span class=\"line\">        &#123;props.user.name&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，我们的<code>Comment</code>组件就成了下面的样子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Comment</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div className=<span class=\"string\">\"Comment\"</span>&gt;</span><br><span class=\"line\">      &lt;UserInfo user=&#123;props.author&#125; /&gt;</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"Comment-text\"</span>&gt;</span><br><span class=\"line\">        &#123;props.text&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div className=\"Comment-date\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;formatDate(props.date)&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Props是只读的\"><a href=\"#Props是只读的\" class=\"headerlink\" title=\"Props是只读的\"></a>Props是只读的</h5><p>无论是Funcional还是Class组件，都是不能够修改props的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面这个是纯函数，因为它没有试图改变自己的输入，并且对相同的输入会有相同的输出。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 下面这个不是纯函数，因为他改变了输入的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withdraw</span>(<span class=\"params\">account, amount</span>) </span>&#123;</span><br><span class=\"line\">  account.total -= amount;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过官方这个例子，可以明白纯函数有两点，一是相同的输入就会有相同的输出，第二点是不会更改输入的参数。</p>\n<p>所有的React组件对于props参数必须像纯函数一样，也就是不会试图去修改props，并且对于相同的props会有相同的输出。<br>当然，React也提供了随时间动态变化组件的方法，state允许根据用户行为、网络反馈等改变React组件的输出形式，这并不违背React纯函数原则。</p>\n<h3 id=\"state-和-生命周期\"><a href=\"#state-和-生命周期\" class=\"headerlink\" title=\"state 和 生命周期\"></a>state 和 生命周期</h3><p>请看下面一段代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Clock = (</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">    &lt;h2&gt;It is &#123;<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>div&gt;</span><br><span class=\"line\">);</span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Clock /&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>这段代码只能够显示一个Hello,world!与一个生成页面的时间。如果想要时间不停的更新，就需要使用setInterval()不停的去执行。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这样</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> Clock = (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">      &lt;h2&gt;It is &#123;<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">  ReactDOM.render(</span><br><span class=\"line\">    &lt;Clock /&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setInterval(tick, <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者这样</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Clock</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">      &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  ReactDOM.render(</span><br><span class=\"line\">    &lt;Clock date=&#123;<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125; /&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setInterval(tick, <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 但是下面这种就是不可行的，原因在于Clock组件定义被转化成了一个对象，在之后没有发生过变化。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Clock = (</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">    &lt;h2&gt;It is &#123;<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>div&gt;</span><br><span class=\"line\">);</span><br><span class=\"line\">setInterval(</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Clock /&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">)&#125;, <span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure></p>\n<p>这样的代码的问题在于时间的变化应该是<code>Clock</code>组件的行为，而不应该定义在全局。<br><code>state</code>可以帮助我们解决这个问题，state与props类似，但是更私有且被组件所控制，而不是传递过来的。</p>\n<h5 id=\"将Functional组件转换为Class组件\"><a href=\"#将Functional组件转换为Class组件\" class=\"headerlink\" title=\"将Functional组件转换为Class组件\"></a>将Functional组件转换为Class组件</h5><p>Functional组件是无状态组件，不能使用state，所以首先需要将Functional转化为Class组件：</p>\n<ol>\n<li>创建一个和Functional组件名相同的ES6 class继承<code>React.Component</code></li>\n<li>添加空的方法<code>render()</code></li>\n<li>将Functional组件中的函数主体移动<code>render()</code>方法中</li>\n<li>将<code>render()</code>中的<code>props</code>替换成<code>this.props</code></li>\n<li>删除原来的Functional组件声明<br>Class组件不仅可以使用state还可以使用生命周期函数。<br>拿上面的<code>Clock</code>组件作为事例，经过上面的转换，现在的Clock组件应该是这个样子：<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.props.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"为Class组件添加本地state\"><a href=\"#为Class组件添加本地state\" class=\"headerlink\" title=\"为Class组件添加本地state\"></a>为Class组件添加本地state</h5><p>还是上面的<code>Clock</code>组件：</p>\n<ol>\n<li>将<code>render()</code>中的<code>this.props</code>替换成<code>this.state</code></li>\n<li>添加class构造函数(constructor)初始化this.state (Class组件总是应该将props传递给父类)</li>\n<li>移除<code>date</code>从组件调用的props中<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里是步骤2</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将props传递给父类</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">date</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Clock /&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这样只是初始化了state，后面会设置定时器。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>React在codepen上提供了一个Hello，World项目事例，只需打开<a href=\"http://codepen.io/gaearon/pen/rrpgNB?editors=0010\" target=\"_blank\" rel=\"noopener\">网站</a>，即可尝试React。<br>另外还提供了一个<a href=\"https://facebook.github.io/react/downloads/single-file-example.html\" target=\"_blank\" rel=\"noopener\">html文件</a>的Hello，World项目，项目中引用CDN的react.js、react-dom.js以及用于编译babel的babel.min.js，运行比较缓慢，只适合学习语法使用。</p>\n<h3 id=\"创建单页面应用\"><a href=\"#创建单页面应用\" class=\"headerlink\" title=\"创建单页面应用\"></a>创建单页面应用</h3><p>创建React应用的最好方法是单页面应用，这里是最好方法，也是可以创建多页面应用的。可以通过官方方法去创建你的应用：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g create-react-app</span><br><span class=\"line\">create-create-app hello-world</span><br><span class=\"line\">cd hello-world</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure></p>\n<p>这里不涉及任何后端逻辑和数据库，可以使用任何你想用的后端。create-react-app中使用了Webpack，Babel和ESLint，但是你可以自己去配置他们。</p>\n<h4 id=\"将React加入一个现有的应用\"><a href=\"#将React加入一个现有的应用\" class=\"headerlink\" title=\"将React加入一个现有的应用\"></a>将React加入一个现有的应用</h4><p>使用<code>npm install --save react react-dom</code>安装React。<br>将其导入你的代码中，如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>这段代码应该被包含在一个拥有id为root的HTML元素，所以你的HTML文件需要<code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code><br>当你使用上面方法使用React的时候，需要使用预设为es2015和react的Babel进行转化代码。使用React在生产环境的时候，设置NODE_ENV为”production”。</p>\n<h4 id=\"使用ES6和JSX\"><a href=\"#使用ES6和JSX\" class=\"headerlink\" title=\"使用ES6和JSX\"></a>使用ES6和JSX</h4><p>建议是用Babel将你的ES6和JSX代码转换为JavaScript代码，Babel可以有很多不同的配置，但是确保里面包含<code>babel-preset-react</code>和<code>babel-preset-es2015</code>。</p>\n<h4 id=\"使用CDN\"><a href=\"#使用CDN\" class=\"headerlink\" title=\"使用CDN\"></a>使用CDN</h4><p>如果不想使用npm，可以使用CDN<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react@15/dist/react.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react-dom@15/dist/react-dom.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>@后面数字可以指定版本<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react@15/dist/react.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react-dom@15/dist/react-dom.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h3><p>在JSX中，可以在任意地方插入JavaScript代码，只需要将JavaScript放在大括号中即可。下面的代码都是合法的：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatName</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> user.firstName + <span class=\"string\">' '</span> + user.lastName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;</span><br><span class=\"line\">  firstName: <span class=\"string\">'Harper'</span>,</span><br><span class=\"line\">  lastName: <span class=\"string\">'Perez'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  &lt;h1&gt;</span><br><span class=\"line\">    Hello, &#123;formatName(user)&#125;!</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">  element,</span></span><br><span class=\"line\"><span class=\"regexp\">  document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure></p>\n<p>将JSX代码放在小括号中，像HTML代码一样换行，可以方便阅读。</p>\n<h5 id=\"JSX也是表达式\"><a href=\"#JSX也是表达式\" class=\"headerlink\" title=\"JSX也是表达式\"></a>JSX也是表达式</h5><p>JSX最后也被编译成JavaScript代码，这就以为着JSX可以赋值给一个JavaScript变量，可以作为方法的参数，可以被方法返回。</p>\n<h5 id=\"JSX添加HTML属性\"><a href=\"#JSX添加HTML属性\" class=\"headerlink\" title=\"JSX添加HTML属性\"></a>JSX添加HTML属性</h5><p>可以用字符串设置属性，也可以通过使用{}将JavaScript表达式赋值给属性。</p>\n<h5 id=\"闭合JSX\"><a href=\"#闭合JSX\" class=\"headerlink\" title=\"闭合JSX\"></a>闭合JSX</h5><p>如果JSX是空的可以使用<code>/&gt;</code>来闭合标签，如果包含其他标签，也可以使用&lt;/***&gt;闭合。<br>虽然JSX很接近HTML，但是还是有些不同，比如属性使用小驼峰法命名，class使用className，for使用forHtml等。</p>\n<h5 id=\"JSX防止注入攻击\"><a href=\"#JSX防止注入攻击\" class=\"headerlink\" title=\"JSX防止注入攻击\"></a>JSX防止注入攻击</h5><p>默认情况下，React DOM在渲染JSX之前会对其进行编码。</p>\n<h5 id=\"JSX描述对象\"><a href=\"#JSX描述对象\" class=\"headerlink\" title=\"JSX描述对象\"></a>JSX描述对象</h5><p>Babel会将JSX转化为React.createElement()形式，比如下面这样：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  &lt;h1 className=<span class=\"string\">\"greeting\"</span>&gt;</span><br><span class=\"line\">    Hello, world!</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br></pre></td></tr></table></figure></p>\n<p>转化为<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = React.createElement(</span><br><span class=\"line\">  <span class=\"string\">'h1'</span>,</span><br><span class=\"line\">  &#123;<span class=\"attr\">className</span>: <span class=\"string\">'greeting'</span>&#125;,</span><br><span class=\"line\">  <span class=\"string\">'Hello, world!'</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>React.createElement会对你的代码进行一些检查，但是本质上就是将其转化成一个对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = &#123;</span><br><span class=\"line\">  type: <span class=\"string\">'h1'</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    className: <span class=\"string\">'greeting'</span>,</span><br><span class=\"line\">    children: <span class=\"string\">'Hello, world'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h3><p>将你的页面分成一个个组件，每个组件都是独立的、可以重复使用的。组件就像JavaScript中的方法，可以接受一些输入参数，返回React元素</p>\n<h5 id=\"Funtional-和-Class-组件\"><a href=\"#Funtional-和-Class-组件\" class=\"headerlink\" title=\"Funtional 和 Class 组件\"></a>Funtional 和 Class 组件</h5><p>定义组件最简单的方式是使用JavaScript方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span> (<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">这个方法就是个有效的React组件，因为它接受props作为参数，并且返回了一个React元素。</span><br><span class=\"line\"></span><br><span class=\"line\">另外也可以使用ES6中的类(<span class=\"class\"><span class=\"keyword\">class</span>)来定义组件：</span></span><br><span class=\"line\"><span class=\"class\">```<span class=\"title\">javascript</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Welcome</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面两种定义组件的方法是等价的。<br>但是Class组件能够添加一些额外的功能，我们将在下面讨论。在不需要这些额外的方法，可以使用Functional组件。</p>\n<h5 id=\"渲染组件\"><a href=\"#渲染组件\" class=\"headerlink\" title=\"渲染组件\"></a>渲染组件</h5><p>渲染如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Welcome</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Sara\"</span> /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"xml\">  element,</span></span><br><span class=\"line\"><span class=\"xml\">  document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"xml\">);</span></span><br></pre></td></tr></table></figure></p>\n<p>过程：</p>\n<ol>\n<li>调用ReactDOM.render()方法，参数为自定义组件<welcome name=\"Sara\">。</welcome></li>\n<li>React调用组件Welcome，传递<code>{name=&quot;Sara&quot;}</code>作为参数。</li>\n<li>Welcome组件返回<code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>。</li>\n<li>React将<code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>更新到页面。</li>\n</ol>\n<h5 id=\"组件组合\"><a href=\"#组件组合\" class=\"headerlink\" title=\"组件组合\"></a>组件组合</h5><p>组件可以任意组合。<br>通常情况，React应用中在最顶端是一个<code>App</code>组件。组件必须有一个根元素，也就是所有元素都得包裹起来。</p>\n<h5 id=\"提取组件\"><a href=\"#提取组件\" class=\"headerlink\" title=\"提取组件\"></a>提取组件</h5><p>不要担心组件被拆分的太小。下面是一个对组件进行拆分的例子。<br>Comment组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Comment</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div className=<span class=\"string\">\"Comment\"</span>&gt;</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"UserInfo\"</span>&gt;</span><br><span class=\"line\">        &lt;img className=<span class=\"string\">\"Avatar\"</span></span><br><span class=\"line\">          src=&#123;props.author.avatarUrl&#125;</span><br><span class=\"line\">          alt=&#123;props.author.name&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">        &lt;div className=<span class=\"string\">\"UserInfo-name\"</span>&gt;</span><br><span class=\"line\">          &#123;props.author.name&#125;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"Comment-text\"</span>&gt;</span><br><span class=\"line\">        &#123;props.text&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div className=\"Comment-date\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;formatDate(props.date)&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>在Comment组件中，使用了<code>author (object)</code>，<code>text (string)</code>，<code>date (date)</code>来描述这个对象。这样的组件因为组合的原因是很难复用的。</p>\n<p>第一步，提取出一个<code>Avatar</code>组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Avatar</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;img className=<span class=\"string\">\"Avatar\"</span></span><br><span class=\"line\">      src=&#123;props.user.avatarUrl&#125;</span><br><span class=\"line\">      alt=&#123;props.user.name&#125;</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的<code>Avatar</code>组件我们系统他更通用，所以说用了<code>user</code>而不是<code>author</code>。<br>根据组件去命名参数，而不是根据使用上下文。</p>\n<p>下一步是提取<code>UserInfo</code>组件，这里使用了上面提取的<code>Avatar</code>组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserInfo</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div className=<span class=\"string\">\"UserInfo\"</span>&gt;</span><br><span class=\"line\">      &lt;Avatar user=&#123;props.user&#125; /&gt;</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"UserInfo-name\"</span>&gt;</span><br><span class=\"line\">        &#123;props.user.name&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，我们的<code>Comment</code>组件就成了下面的样子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Comment</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div className=<span class=\"string\">\"Comment\"</span>&gt;</span><br><span class=\"line\">      &lt;UserInfo user=&#123;props.author&#125; /&gt;</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"Comment-text\"</span>&gt;</span><br><span class=\"line\">        &#123;props.text&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div className=\"Comment-date\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;formatDate(props.date)&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Props是只读的\"><a href=\"#Props是只读的\" class=\"headerlink\" title=\"Props是只读的\"></a>Props是只读的</h5><p>无论是Funcional还是Class组件，都是不能够修改props的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面这个是纯函数，因为它没有试图改变自己的输入，并且对相同的输入会有相同的输出。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 下面这个不是纯函数，因为他改变了输入的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withdraw</span>(<span class=\"params\">account, amount</span>) </span>&#123;</span><br><span class=\"line\">  account.total -= amount;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过官方这个例子，可以明白纯函数有两点，一是相同的输入就会有相同的输出，第二点是不会更改输入的参数。</p>\n<p>所有的React组件对于props参数必须像纯函数一样，也就是不会试图去修改props，并且对于相同的props会有相同的输出。<br>当然，React也提供了随时间动态变化组件的方法，state允许根据用户行为、网络反馈等改变React组件的输出形式，这并不违背React纯函数原则。</p>\n<h3 id=\"state-和-生命周期\"><a href=\"#state-和-生命周期\" class=\"headerlink\" title=\"state 和 生命周期\"></a>state 和 生命周期</h3><p>请看下面一段代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Clock = (</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">    &lt;h2&gt;It is &#123;<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>div&gt;</span><br><span class=\"line\">);</span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Clock /&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>这段代码只能够显示一个Hello,world!与一个生成页面的时间。如果想要时间不停的更新，就需要使用setInterval()不停的去执行。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这样</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> Clock = (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">      &lt;h2&gt;It is &#123;<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">  ReactDOM.render(</span><br><span class=\"line\">    &lt;Clock /&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setInterval(tick, <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者这样</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Clock</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">      &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  ReactDOM.render(</span><br><span class=\"line\">    &lt;Clock date=&#123;<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125; /&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setInterval(tick, <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 但是下面这种就是不可行的，原因在于Clock组件定义被转化成了一个对象，在之后没有发生过变化。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Clock = (</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">    &lt;h2&gt;It is &#123;<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>div&gt;</span><br><span class=\"line\">);</span><br><span class=\"line\">setInterval(</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Clock /&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">)&#125;, <span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure></p>\n<p>这样的代码的问题在于时间的变化应该是<code>Clock</code>组件的行为，而不应该定义在全局。<br><code>state</code>可以帮助我们解决这个问题，state与props类似，但是更私有且被组件所控制，而不是传递过来的。</p>\n<h5 id=\"将Functional组件转换为Class组件\"><a href=\"#将Functional组件转换为Class组件\" class=\"headerlink\" title=\"将Functional组件转换为Class组件\"></a>将Functional组件转换为Class组件</h5><p>Functional组件是无状态组件，不能使用state，所以首先需要将Functional转化为Class组件：</p>\n<ol>\n<li>创建一个和Functional组件名相同的ES6 class继承<code>React.Component</code></li>\n<li>添加空的方法<code>render()</code></li>\n<li>将Functional组件中的函数主体移动<code>render()</code>方法中</li>\n<li>将<code>render()</code>中的<code>props</code>替换成<code>this.props</code></li>\n<li>删除原来的Functional组件声明<br>Class组件不仅可以使用state还可以使用生命周期函数。<br>拿上面的<code>Clock</code>组件作为事例，经过上面的转换，现在的Clock组件应该是这个样子：<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.props.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"为Class组件添加本地state\"><a href=\"#为Class组件添加本地state\" class=\"headerlink\" title=\"为Class组件添加本地state\"></a>为Class组件添加本地state</h5><p>还是上面的<code>Clock</code>组件：</p>\n<ol>\n<li>将<code>render()</code>中的<code>this.props</code>替换成<code>this.state</code></li>\n<li>添加class构造函数(constructor)初始化this.state (Class组件总是应该将props传递给父类)</li>\n<li>移除<code>date</code>从组件调用的props中<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里是步骤2</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将props传递给父类</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">date</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Clock /&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这样只是初始化了state，后面会设置定时器。</p>\n"},{"title":"React Docs（2）","date":"2017-01-14T16:00:00.000Z","comments":1,"_content":"\n### 事件\nReact对事件的处理和在DOM元素上添加事件属性绑定事件的方式几乎一样，不同点在于React使用驼峰命名，而不是全小写；React中传递的是一个函数，不是一个字符串。\n另一个区别是，不能使用return false来阻止事件默认行为。  \nHTML中：\n```HTML\n<button onclick=\"activateLasers()\">\n  Activate Lasers\n</button>\n```\nReact中：\n```JSX\n<button onClick={activeteLasers}>\n  Activate Lasers\n</button>\n```\n在React中，event是合成事件，不需要考虑跨浏览器兼容问题。  \n在使用React中，一般不应该使用addEventListener在DOM元素创建以后去绑定事件，而应该在渲染初始化的时候就提供一个监听器。  \n在使用ES6语法Class创建组件时候，常见的模式是绑定事件是类中的一个方法：\n```javascript\nclass Toggle extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {isToggleOn: true};\n\n    // 这里的绑定this是必要的，这样可以使函数上下文环境为这个组件\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    this.setState(prevState => ({\n      isToggleOn: !prevState.isToggleOn\n    }));\n  }\n\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        {this.state.isToggleOn ? 'ON' : 'OFF'}\n      </button>\n    );\n  }\n}\n\nReactDOM.render(\n  <Toggle />,\n  document.getElementById('root')\n);\n```\n必须小心在事件回调函数中的this，在javascript中，Class中的方法默认是不绑定this的。如果忘记绑定，函调函数中的this指向的将是undefined。  \n如果不想使用bind函数，可以使用箭头函数这种语法来绑定this，下面函数中handleClick属性初始化时，里面的this就被绑定到了LoggingButton中:\n```javascript\nclass LoggingButton extends React.Component {\n  // 箭头函数可以绑定this\n  handleClick = () => {\n    console.log('this is:', this);\n  }\n\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        Click me\n      </button>\n    );\n  }\n}\n```\n另一种方式是在定义回调的时候用箭头函数绑定this：\n```javascript\nlass LoggingButton extends React.Component {\n  handleClick() {\n    console.log('this is:', this);\n  }\n\n  render() {\n    // 在onClick中，用箭头函数绑定了this\n    return (\n      <button onClick={(e) => this.handleClick(e)}>\n        Click me\n      </button>\n    );\n  }\n}\n```\n这种方法的问题在于每一次渲染该组件都会创建不同的回调函数。大多数情况下这是没有问题的，但是如果函调函数中传递一个prop给一个低阶组件，这些低阶组件会做额外的重复渲染。所以，一般建议使用第一种构造函数中bind绑定this或者是属性初始化中用箭头函数绑定this。\n\n### 条件渲染\n有时候需要根据组件的不同状态，渲染不同的组件。  \nReact中的条件渲染与JavaScript中的条件语句工作方式相同，可以使用if或者条件操作符来创建一个表示当前状态的元素，让React更新UI以配合组件状态。  \n下面是根据用户的登陆状态显示不同的问候语：\n```javascript\nfunction UserGreeting(props) {\n  return <h1>Welcome back!</h1>;\n}\n\nfunction GuestGreeting(props) {\n  return <h1>Please sign up.</h1>;\n}\n\nfunction Greeting(props) {\n  const isLoggedIn = props.isLoggedIn;\n  if (isLoggedIn) {\n    return <UserGreeting />;\n  }\n  return <GuestGreeting />;\n}\n\nReactDOM.render(\n  // Try changing to isLoggedIn={true}:\n  <Greeting isLoggedIn={false} />,\n  document.getElementById('root')\n);\n```\n#### 元素变量\n可以使用变量来存储元素，其余都不变。\n```javascript\n// 一个登陆按钮，一个注销按钮\nfunction LoginButton(props) {\n  return (\n    <button onClick={props.onClick}>\n      Login\n    </button>\n  );\n}\n\nfunction LogoutButton(props) {\n  return (\n    <button onClick={props.onClick}>\n      Logout\n    </button>\n  );\n}\n```\n下面创建一个有状态的组件LoginControl\n```javascript\nclass LoginControl extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleLoginClick = this.handleLoginClick.bind(this);\n    this.handleLogoutClick = this.handleLogoutClick.bind(this);\n    this.state = {isLoggedIn: false};\n  }\n\n  handleLoginClick() {\n    this.setState({isLoggedIn: true});\n  }\n\n  handleLogoutClick() {\n    this.setState({isLoggedIn: false});\n  }\n\n  render() {\n    const isLoggedIn = this.state.isLoggedIn;\n\n    let button = null;\n    if (isLoggedIn) {\n      button = <LogoutButton onClick={this.handleLogoutClick} />;\n    } else {\n      button = <LoginButton onClick={this.handleLoginClick} />;\n    }\n\n    return (\n      <div>\n        <Greeting isLoggedIn={isLoggedIn} />\n        {button}\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <LoginControl />,\n  document.getElementById('root')\n);\n```\n除了if语句，你也可以使用更短的逻辑语句，比如&&运算符，三目运算符等。\n\n#### 防止组件呈现\n极少数的情况下才需要这么做，通过return null可以使组件不被渲染。","source":"_posts/React Docs(2).md","raw":"---\ntitle: React Docs（2）\ndate: 2017-01-15\ntags: [JavaScript, React]\ncategories: \n- React\ncomments: true\n---\n\n### 事件\nReact对事件的处理和在DOM元素上添加事件属性绑定事件的方式几乎一样，不同点在于React使用驼峰命名，而不是全小写；React中传递的是一个函数，不是一个字符串。\n另一个区别是，不能使用return false来阻止事件默认行为。  \nHTML中：\n```HTML\n<button onclick=\"activateLasers()\">\n  Activate Lasers\n</button>\n```\nReact中：\n```JSX\n<button onClick={activeteLasers}>\n  Activate Lasers\n</button>\n```\n在React中，event是合成事件，不需要考虑跨浏览器兼容问题。  \n在使用React中，一般不应该使用addEventListener在DOM元素创建以后去绑定事件，而应该在渲染初始化的时候就提供一个监听器。  \n在使用ES6语法Class创建组件时候，常见的模式是绑定事件是类中的一个方法：\n```javascript\nclass Toggle extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {isToggleOn: true};\n\n    // 这里的绑定this是必要的，这样可以使函数上下文环境为这个组件\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    this.setState(prevState => ({\n      isToggleOn: !prevState.isToggleOn\n    }));\n  }\n\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        {this.state.isToggleOn ? 'ON' : 'OFF'}\n      </button>\n    );\n  }\n}\n\nReactDOM.render(\n  <Toggle />,\n  document.getElementById('root')\n);\n```\n必须小心在事件回调函数中的this，在javascript中，Class中的方法默认是不绑定this的。如果忘记绑定，函调函数中的this指向的将是undefined。  \n如果不想使用bind函数，可以使用箭头函数这种语法来绑定this，下面函数中handleClick属性初始化时，里面的this就被绑定到了LoggingButton中:\n```javascript\nclass LoggingButton extends React.Component {\n  // 箭头函数可以绑定this\n  handleClick = () => {\n    console.log('this is:', this);\n  }\n\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        Click me\n      </button>\n    );\n  }\n}\n```\n另一种方式是在定义回调的时候用箭头函数绑定this：\n```javascript\nlass LoggingButton extends React.Component {\n  handleClick() {\n    console.log('this is:', this);\n  }\n\n  render() {\n    // 在onClick中，用箭头函数绑定了this\n    return (\n      <button onClick={(e) => this.handleClick(e)}>\n        Click me\n      </button>\n    );\n  }\n}\n```\n这种方法的问题在于每一次渲染该组件都会创建不同的回调函数。大多数情况下这是没有问题的，但是如果函调函数中传递一个prop给一个低阶组件，这些低阶组件会做额外的重复渲染。所以，一般建议使用第一种构造函数中bind绑定this或者是属性初始化中用箭头函数绑定this。\n\n### 条件渲染\n有时候需要根据组件的不同状态，渲染不同的组件。  \nReact中的条件渲染与JavaScript中的条件语句工作方式相同，可以使用if或者条件操作符来创建一个表示当前状态的元素，让React更新UI以配合组件状态。  \n下面是根据用户的登陆状态显示不同的问候语：\n```javascript\nfunction UserGreeting(props) {\n  return <h1>Welcome back!</h1>;\n}\n\nfunction GuestGreeting(props) {\n  return <h1>Please sign up.</h1>;\n}\n\nfunction Greeting(props) {\n  const isLoggedIn = props.isLoggedIn;\n  if (isLoggedIn) {\n    return <UserGreeting />;\n  }\n  return <GuestGreeting />;\n}\n\nReactDOM.render(\n  // Try changing to isLoggedIn={true}:\n  <Greeting isLoggedIn={false} />,\n  document.getElementById('root')\n);\n```\n#### 元素变量\n可以使用变量来存储元素，其余都不变。\n```javascript\n// 一个登陆按钮，一个注销按钮\nfunction LoginButton(props) {\n  return (\n    <button onClick={props.onClick}>\n      Login\n    </button>\n  );\n}\n\nfunction LogoutButton(props) {\n  return (\n    <button onClick={props.onClick}>\n      Logout\n    </button>\n  );\n}\n```\n下面创建一个有状态的组件LoginControl\n```javascript\nclass LoginControl extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleLoginClick = this.handleLoginClick.bind(this);\n    this.handleLogoutClick = this.handleLogoutClick.bind(this);\n    this.state = {isLoggedIn: false};\n  }\n\n  handleLoginClick() {\n    this.setState({isLoggedIn: true});\n  }\n\n  handleLogoutClick() {\n    this.setState({isLoggedIn: false});\n  }\n\n  render() {\n    const isLoggedIn = this.state.isLoggedIn;\n\n    let button = null;\n    if (isLoggedIn) {\n      button = <LogoutButton onClick={this.handleLogoutClick} />;\n    } else {\n      button = <LoginButton onClick={this.handleLoginClick} />;\n    }\n\n    return (\n      <div>\n        <Greeting isLoggedIn={isLoggedIn} />\n        {button}\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <LoginControl />,\n  document.getElementById('root')\n);\n```\n除了if语句，你也可以使用更短的逻辑语句，比如&&运算符，三目运算符等。\n\n#### 防止组件呈现\n极少数的情况下才需要这么做，通过return null可以使组件不被渲染。","slug":"React Docs(2)","published":1,"updated":"2017-12-28T03:47:32.454Z","layout":"post","photos":[],"link":"","_id":"cjks5i9i3000wvmti80eo3itz","content":"<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3><p>React对事件的处理和在DOM元素上添加事件属性绑定事件的方式几乎一样，不同点在于React使用驼峰命名，而不是全小写；React中传递的是一个函数，不是一个字符串。<br>另一个区别是，不能使用return false来阻止事件默认行为。<br>HTML中：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"activateLasers()\"</span>&gt;</span></span><br><span class=\"line\">  Activate Lasers</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>React中：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button onClick=&#123;activeteLasers&#125;&gt;</span><br><span class=\"line\">  Activate Lasers</span><br><span class=\"line\">&lt;<span class=\"regexp\">/button&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>在React中，event是合成事件，不需要考虑跨浏览器兼容问题。<br>在使用React中，一般不应该使用addEventListener在DOM元素创建以后去绑定事件，而应该在渲染初始化的时候就提供一个监听器。<br>在使用ES6语法Class创建组件时候，常见的模式是绑定事件是类中的一个方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Toggle</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">isToggleOn</span>: <span class=\"literal\">true</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里的绑定this是必要的，这样可以使函数上下文环境为这个组件</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(<span class=\"function\"><span class=\"params\">prevState</span> =&gt;</span> (&#123;</span><br><span class=\"line\">      isToggleOn: !prevState.isToggleOn</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;button onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;</span><br><span class=\"line\">        &#123;<span class=\"keyword\">this</span>.state.isToggleOn ? <span class=\"string\">'ON'</span> : <span class=\"string\">'OFF'</span>&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;Toggle /</span>&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>必须小心在事件回调函数中的this，在javascript中，Class中的方法默认是不绑定this的。如果忘记绑定，函调函数中的this指向的将是undefined。<br>如果不想使用bind函数，可以使用箭头函数这种语法来绑定this，下面函数中handleClick属性初始化时，里面的this就被绑定到了LoggingButton中:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoggingButton</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 箭头函数可以绑定this</span></span><br><span class=\"line\">  handleClick = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'this is:'</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;button onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;</span><br><span class=\"line\">        Click me</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>另一种方式是在定义回调的时候用箭头函数绑定this：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lass LoggingButton extends React.Component &#123;</span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'this is:'</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在onClick中，用箭头函数绑定了this</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;button onClick=&#123;(e) =&gt; <span class=\"keyword\">this</span>.handleClick(e)&#125;&gt;</span><br><span class=\"line\">        Click me</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>这种方法的问题在于每一次渲染该组件都会创建不同的回调函数。大多数情况下这是没有问题的，但是如果函调函数中传递一个prop给一个低阶组件，这些低阶组件会做额外的重复渲染。所以，一般建议使用第一种构造函数中bind绑定this或者是属性初始化中用箭头函数绑定this。</p>\n<h3 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h3><p>有时候需要根据组件的不同状态，渲染不同的组件。<br>React中的条件渲染与JavaScript中的条件语句工作方式相同，可以使用if或者条件操作符来创建一个表示当前状态的元素，让React更新UI以配合组件状态。<br>下面是根据用户的登陆状态显示不同的问候语：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserGreeting</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Welcome back!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GuestGreeting</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Please sign up.<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Greeting</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> isLoggedIn = props.isLoggedIn;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isLoggedIn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">UserGreeting</span> /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">  return <span class=\"tag\">&lt;<span class=\"name\">GuestGreeting</span> /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"xml\">  // Try changing to isLoggedIn=&#123;true&#125;:</span></span><br><span class=\"line\">  &lt;Greeting isLoggedIn=&#123;false&#125; /&gt;,</span><br><span class=\"line\">  document.getElementById('root')</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"元素变量\"><a href=\"#元素变量\" class=\"headerlink\" title=\"元素变量\"></a>元素变量</h4><p>可以使用变量来存储元素，其余都不变。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个登陆按钮，一个注销按钮</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LoginButton</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;button onClick=&#123;props.onClick&#125;&gt;</span><br><span class=\"line\">      Login</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function LogoutButton(props) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;button onClick=&#123;props.onClick&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      Logout</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>button&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面创建一个有状态的组件LoginControl<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginControl</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleLoginClick = <span class=\"keyword\">this</span>.handleLoginClick.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleLogoutClick = <span class=\"keyword\">this</span>.handleLogoutClick.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">isLoggedIn</span>: <span class=\"literal\">false</span>&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleLoginClick() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">isLoggedIn</span>: <span class=\"literal\">true</span>&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleLogoutClick() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">isLoggedIn</span>: <span class=\"literal\">false</span>&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> isLoggedIn = <span class=\"keyword\">this</span>.state.isLoggedIn;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> button = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLoggedIn) &#123;</span><br><span class=\"line\">      button = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">LogoutButton</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handleLogoutClick&#125;</span> /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125; else &#123;</span></span><br><span class=\"line\">      button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;</span><br><span class=\"line\">        &#123;button&#125;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;LoginControl /&gt;,</span><br><span class=\"line\">  document.getElementById('root')</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>除了if语句，你也可以使用更短的逻辑语句，比如&amp;&amp;运算符，三目运算符等。</p>\n<h4 id=\"防止组件呈现\"><a href=\"#防止组件呈现\" class=\"headerlink\" title=\"防止组件呈现\"></a>防止组件呈现</h4><p>极少数的情况下才需要这么做，通过return null可以使组件不被渲染。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3><p>React对事件的处理和在DOM元素上添加事件属性绑定事件的方式几乎一样，不同点在于React使用驼峰命名，而不是全小写；React中传递的是一个函数，不是一个字符串。<br>另一个区别是，不能使用return false来阻止事件默认行为。<br>HTML中：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"activateLasers()\"</span>&gt;</span></span><br><span class=\"line\">  Activate Lasers</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>React中：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button onClick=&#123;activeteLasers&#125;&gt;</span><br><span class=\"line\">  Activate Lasers</span><br><span class=\"line\">&lt;<span class=\"regexp\">/button&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>在React中，event是合成事件，不需要考虑跨浏览器兼容问题。<br>在使用React中，一般不应该使用addEventListener在DOM元素创建以后去绑定事件，而应该在渲染初始化的时候就提供一个监听器。<br>在使用ES6语法Class创建组件时候，常见的模式是绑定事件是类中的一个方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Toggle</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">isToggleOn</span>: <span class=\"literal\">true</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里的绑定this是必要的，这样可以使函数上下文环境为这个组件</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(<span class=\"function\"><span class=\"params\">prevState</span> =&gt;</span> (&#123;</span><br><span class=\"line\">      isToggleOn: !prevState.isToggleOn</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;button onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;</span><br><span class=\"line\">        &#123;<span class=\"keyword\">this</span>.state.isToggleOn ? <span class=\"string\">'ON'</span> : <span class=\"string\">'OFF'</span>&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;Toggle /</span>&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>必须小心在事件回调函数中的this，在javascript中，Class中的方法默认是不绑定this的。如果忘记绑定，函调函数中的this指向的将是undefined。<br>如果不想使用bind函数，可以使用箭头函数这种语法来绑定this，下面函数中handleClick属性初始化时，里面的this就被绑定到了LoggingButton中:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoggingButton</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 箭头函数可以绑定this</span></span><br><span class=\"line\">  handleClick = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'this is:'</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;button onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;</span><br><span class=\"line\">        Click me</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>另一种方式是在定义回调的时候用箭头函数绑定this：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lass LoggingButton extends React.Component &#123;</span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'this is:'</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在onClick中，用箭头函数绑定了this</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;button onClick=&#123;(e) =&gt; <span class=\"keyword\">this</span>.handleClick(e)&#125;&gt;</span><br><span class=\"line\">        Click me</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>这种方法的问题在于每一次渲染该组件都会创建不同的回调函数。大多数情况下这是没有问题的，但是如果函调函数中传递一个prop给一个低阶组件，这些低阶组件会做额外的重复渲染。所以，一般建议使用第一种构造函数中bind绑定this或者是属性初始化中用箭头函数绑定this。</p>\n<h3 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h3><p>有时候需要根据组件的不同状态，渲染不同的组件。<br>React中的条件渲染与JavaScript中的条件语句工作方式相同，可以使用if或者条件操作符来创建一个表示当前状态的元素，让React更新UI以配合组件状态。<br>下面是根据用户的登陆状态显示不同的问候语：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserGreeting</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Welcome back!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GuestGreeting</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Please sign up.<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Greeting</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> isLoggedIn = props.isLoggedIn;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isLoggedIn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">UserGreeting</span> /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">  return <span class=\"tag\">&lt;<span class=\"name\">GuestGreeting</span> /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"xml\">  // Try changing to isLoggedIn=&#123;true&#125;:</span></span><br><span class=\"line\">  &lt;Greeting isLoggedIn=&#123;false&#125; /&gt;,</span><br><span class=\"line\">  document.getElementById('root')</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"元素变量\"><a href=\"#元素变量\" class=\"headerlink\" title=\"元素变量\"></a>元素变量</h4><p>可以使用变量来存储元素，其余都不变。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个登陆按钮，一个注销按钮</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LoginButton</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;button onClick=&#123;props.onClick&#125;&gt;</span><br><span class=\"line\">      Login</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function LogoutButton(props) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;button onClick=&#123;props.onClick&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      Logout</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>button&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面创建一个有状态的组件LoginControl<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginControl</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleLoginClick = <span class=\"keyword\">this</span>.handleLoginClick.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleLogoutClick = <span class=\"keyword\">this</span>.handleLogoutClick.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">isLoggedIn</span>: <span class=\"literal\">false</span>&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleLoginClick() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">isLoggedIn</span>: <span class=\"literal\">true</span>&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleLogoutClick() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">isLoggedIn</span>: <span class=\"literal\">false</span>&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> isLoggedIn = <span class=\"keyword\">this</span>.state.isLoggedIn;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> button = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isLoggedIn) &#123;</span><br><span class=\"line\">      button = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">LogoutButton</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handleLogoutClick&#125;</span> /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125; else &#123;</span></span><br><span class=\"line\">      button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;</span><br><span class=\"line\">        &#123;button&#125;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;LoginControl /&gt;,</span><br><span class=\"line\">  document.getElementById('root')</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>除了if语句，你也可以使用更短的逻辑语句，比如&amp;&amp;运算符，三目运算符等。</p>\n<h4 id=\"防止组件呈现\"><a href=\"#防止组件呈现\" class=\"headerlink\" title=\"防止组件呈现\"></a>防止组件呈现</h4><p>极少数的情况下才需要这么做，通过return null可以使组件不被渲染。</p>\n"},{"title":"React Docs（3）","date":"2017-01-15T16:00:00.000Z","comments":1,"_content":"\n### 列表和键（key）\n在React中转换数组和在JavaScript中几乎相同，可以通过数组的map方法渲染多个组件：\n```javascript\n// 显示内容为1到5的列表\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    <li>{number}</li>\n  );\n  return (\n    <ul>{listItems}</ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  <NumberList numbers={numbers} />,\n  document.getElementById('root')\n);\n```\n在运行此代码的时候，会收到一条警告，警告指出需要为每一项提供一个key，这个是很重要的。\n```javascript\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    <li key={number.toString()}>\n      {number}\n    </li>\n  );\n  return (\n    <ul>{listItems}</ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  <NumberList numbers={numbers} />,\n  document.getElementById('root')\n);\n```\n#### 键（key）\nkey可以帮助确定哪些项发生了变化，或者添加、删除了哪些项，通常使用数据的id作为key，这样在整个列表中key的值是唯一的。\nkey只有在周围环境是数据的情况下才有意义，如下：\n```javascript\n// 错误的做法\nfunction ListItem(props) {\n  const value = props.value;\n  return (\n    // 这里不必要使用key，使用\n    <li key={value.toString()}>\n      {value}\n    </li>\n  );\n}\n\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    // key属性应该添加在这里\n    <ListItem value={number} />\n  );\n  return (\n    <ul>\n      {listItems}\n    </ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  <NumberList numbers={numbers} />,\n  document.getElementById('root')\n);\n```\n其实只需要记得在map函数中使用key就可以了。\n\n#### key在兄弟节点间是唯一的\n数组中使用key需要是唯一的，但是在全局不需要是唯一的。当生成两个不同的数组，我们可以使用相同的键。  \nkey作为组件的标识，但是不会将值传递给组件，如果需要使用key中的值，需要另外传给组件的一个属性。  \nJSX中可以嵌套map函数。这种形式有时候会使代码更加清晰，有时候也会被滥用，这就需要你来决定是否需要提取出来，以提高可读性。\n\n## 表单\n表单元素自身本来就拥有一些属性（比如name等），表单在用户提交时，会执行默认的表单行为，提交到一个新的页面。但是在多数情况下，我们使用JavaScript函数处理表单的提交，处理用户提交的数据。实现这种方法的组件我们称为“受控组件”。\n\n#### 受控组件\n在HTML中，表单元素如`<input>`，`<textarea>`和`<select>`通常保持自己的状态，并根据用户的输入进行更新。而在React中，状态一般保存都state属性中，并且state属性只能通过`setState()`更新。  \n我们可以将React的state设置成HTML的输入将两者结合，然后React组件还需要控制用户的输入，这样的组件被称为“受控组件”。\n```javascript\nclass NameForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {value: ''};\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {\n    this.setState({value: event.target.value});\n  }\n\n  handleSubmit(event) {\n    alert('A name was submitted: ' + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Name:\n          <input type=\"text\" value={this.state.value} onChange={this.handleChange} />\n        </label>\n        <input type=\"submit\" value=\"Submit\" />\n      </form>\n    );\n  }\n}\n```\n其中将input元素的value值交给React组件的state，通过handleChange函数响应每次输入来更新state。使用受控组件，每个输入都会关联到处理函数，这使得可以直接修改或验证用户输入。\n\n#### textarea标签\n在React中，textarea标签也使用了value属性来代替在元素中的显示值。\n\n#### select标签\n在HTML中使用`<select>`标签时候，可以使用option中selected属性表示当前选择的选项。而在React中，将当前选项保存在select中的value，当select中的value与option的Value相同时，该选项被选择。\n\n#### 受控组件的代码\n使用受控组件有时候是很复杂的，因为你需要为更改数据的所有方式编写事件处理函数，并通过React组件管理所有输入状态。这时候可能需要不受控组件。\n\n## 提升state属性\n通常，几个组件需要反映相同的数据变化，这时候可以将共享的state提升到最接近的共同的父组件中。\n\n下面这个组件BoilingVerdict接受一个celsius温度参数，并打印是否能把水烧开\n```javascript\nfunction BoilingVerdict(props) {\n  if (props.celsius >= 100) {\n    return <p>The water would boil.</p>;\n  }\n  return <p>The water would not boil.</p>;\n}\n```\n下面这个组件Calculator，输入一个celsius摄氏温度，保存到this.state.value中，并作为BoilingVerdict输入。\n```javascript\nclass Calculator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {value: ''};\n  }\n\n  handleChange(e) {\n    this.setState({value: e.target.value});\n  }\n\n  render() {\n    const value = this.state.value;\n    return (\n      <fieldset>\n        <legend>Enter temperature in Celsius:</legend>\n        <input\n          value={value}\n          onChange={this.handleChange} />\n        <BoilingVerdict\n          celsius={parseFloat(value)} />\n      </fieldset>\n    );\n  }\n}\n```\n\n#### 添加第二个输入\n输入一个华氏温度，能够和摄氏度相互转换。  \n首先定义两个函数实现华氏度和摄氏度转换，再定义一个函数实现将值转换为字符串：\n```javascript\nfunction toCelsius(fahrenheit) {\n  return (fahrenheit - 32) * 5 / 9;\n}\n\nfunction toFahrenheit(celsius) {\n  return (celsius * 9 / 5) + 32;\n}\n\nfunction tryConvert(value, convert) {\n  const input = parseFloat(value);\n  if (Number.isNaN(input)) {\n    return '';\n  }\n  const output = convert(input);\n  const rounded = Math.round(output * 1000) / 1000;\n  return rounded.toString();\n}\n```\n下面是温度输入组件\n```javascript\nclass TemperatureInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n  }\n\n  handleChange(e) {\n    this.props.onChange(e.target.value);\n  }\n\n  render() {\n    const value = this.props.value;\n    const scale = this.props.scale;\n    return (\n      <fieldset>\n        <legend>Enter temperature in {scaleNames[scale]}:</legend>\n        <input value={value}\n               onChange={this.handleChange} />\n      </fieldset>\n    );\n  }\n}\n```\n下面是温度转换，以及显示沸水情况组件\n```javascript\nclass Calculator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleCelsiusChange = this.handleCelsiusChange.bind(this);\n    this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);\n    this.state = {value: '', scale: 'c'};\n  }\n\n  handleCelsiusChange(value) {\n    this.setState({scale: 'c', value});\n  }\n\n  handleFahrenheitChange(value) {\n    this.setState({scale: 'f', value});\n  }\n\n  render() {\n    const scale = this.state.scale;\n    const value = this.state.value;\n    const celsius = scale === 'f' ? tryConvert(value, toCelsius) : value;\n    const fahrenheit = scale === 'c' ? tryConvert(value, toFahrenheit) : value;\n\n    return (\n      <div>\n        <TemperatureInput\n          scale=\"c\"\n          value={celsius}\n          onChange={this.handleCelsiusChange} />\n        <TemperatureInput\n          scale=\"f\"\n          value={fahrenheit}\n          onChange={this.handleFahrenheitChange} />\n        <BoilingVerdict\n          celsius={parseFloat(celsius)} />\n      </div>\n    );\n  }\n}\n```\n#### 总结\n对于React中的任何数据，应该有一个单一的来源。通常将state添加到需要渲染的组件，如果其他组件也需要该state，将它提升到最接近的共同父组件中，而不是试图同步不同组件之间的state。这种解决方法就是自上而下的数据流。  \n提升state需要编写更多的代码，但是这可以方便寻找和修改bug。state存在一些组件中，在这些组件中都可以单独改变该state，这可以减少错误。另外，你可以控制用户的输入。  \n如果某个state属性，可以通过props或者其他state属性得到，我们可能就不需要该state属性。\n\n## 组件的组成和继承\nReact组件具有强大的组合功能，我们建议使用组合来重用组件之间的代码，而不是继承。\n#### 包含\n一些组件提前不知道自己包含什么。可以使用props的children来传递包含的组件\n```javascript\n// 使用props.children来调用被包含的组件\nfunction FancyBorder(props) {\n  return (\n    <div className={'FancyBorder FancyBorder-' + props.color}>\n      {props.children}\n    </div>\n  );\n}\n// 其他组件通过JSX传递被包含的组件给父组件\nfunction WelcomeDialog() {\n  return (\n    <FancyBorder color=\"blue\">\n      <h1 className=\"Dialog-title\">\n        Welcome\n      </h1>\n      <p className=\"Dialog-message\">\n        Thank you for visiting our spacecraft!\n      </p>\n    </FancyBorder>\n  );\n}\n```\n有时候也可以包含多个子组件，可以通过自定义props传递\n```javascript\nfunction SplitPane(props) {\n  return (\n    <div className=\"SplitPane\">\n      <div className=\"SplitPane-left\">\n        {props.left}\n      </div>\n      <div className=\"SplitPane-right\">\n        {props.right}\n      </div>\n    </div>\n  );\n}\n// 向SplitPane组件中传递Contacts和Chat组件\nfunction App() {\n  return (\n    <SplitPane\n      left={\n        <Contacts />\n      }\n      right={\n        <Chat />\n      } />\n  );\n}\n```\n### 特殊化\n有些组件是另一些组件的特殊情况。比如：WelcomDialog是Dialog的特例。可以通过传递props来实现\n```javascript\nfunction Dialog(props) {\n  return (\n    <FancyBorder color=\"blue\">\n      <h1 className=\"Dialog-title\">\n        {props.title}\n      </h1>\n      <p className=\"Dialog-message\">\n        {props.message}\n      </p>\n    </FancyBorder>\n  );\n}\n\nfunction WelcomeDialog() {\n  return (\n    <Dialog\n      title=\"Welcome\"\n      message=\"Thank you for visiting our spacecraft!\" />\n  );\n}\n```\n### 不建议使用继承\nprops和组合可以使React组件有很大的灵活性，组件可以接受任意props，原始值，React组件，以及函数。  \n如果组件之间重用非UI功能，建议可以将这部分函数单独提到一个JavaScript模块中，组件可以导入该模块中的函数、对象或者类，而不需要继承。\n\n## Think in React\n### 第一步 拆分组件\n拆分组件应该遵循单一职责原则，每个组件只负责做一件事。一般情况下，正确的组件划分能够正好的映射JSON数据模型。[具体参考这里](https://facebook.github.io/react/docs/thinking-in-react.html)\n### 第二步 构建静态版本\n根据层次解构组合组件，接受模拟的数据呈现出UI，但是这是没有交互性的。  \n构建静态版本，要构建一个重用其他组件的组件，并且使用props传递数据。在静态版本中，不要使用state。state保留用于交互，所以这里不需要使用它。  \n在构造过程中，可以自上到下，也可以使用自下到上。  \n在完成这一步后，你将有一个可重用的组件库，用来呈现你的模拟数据。组件只会有render()方法。在最上层组件，传递模拟数据，更改模拟数据查看组件的变化是否正常。\n### 第三步 识别最小且完整的state\n正确的构建项目，首先需要考虑项目所需要考虑所有需要的最小的state集合，并且通过这些state计算出所有需要的其他内容。如果是能够计算出来的，就不需要存储在state中。  \n比如在一个TODO列表中，所有数据包括：\n* 原本的列表\n* 用户输入搜索框的内容\n* 用户勾选的选项\n* 过滤掉的列表\n对于这样的所有数据，我们需要弄清哪些才是state，可以问自己三个问题：\n1. 它可以通过父组件的props传递进来吗？\n2. 是否不会变化？\n3. 是否可以通过其他state或props计算出来？\n如果有一个回答是，那么该属性不应该是state。  \n原本的列表应该是通过props传递来的，过滤掉的列表可以通过原本的列表和输入框中的值计算出来。最后得到的state是：\n* 用户输入搜索框的内容\n* 用户勾选的选项\n### 第四步 确定state应该在哪个位置\n确定好state之后，是要确定在哪里定义state，在哪里更改state。  \n对于每一个state：\n* 确定哪些组件要用到该state\n* 找到一个包含这些所有组件的父组件\n* 包含这些所有组件的父组件其中结构层次最高的组件应该拥有该state\n* 如果找不到这样的父组件，创建一个这样的父组件，并且添加state\n### 第五步 添加反向数据流\n因为是单向数据流，所以需要添加操作对state的更改。比如，输入框绑定了用户输入搜索框内容这个state，输入框就不会响应用户的输入行为，需要为input绑定修改state事件。这里是子组件修改父组件中的state，所以就是反向数据流。","source":"_posts/React Docs(3).md","raw":"---\ntitle: React Docs（3）\ndate: 2017-01-16\ntags: [JavaScript, React]\ncategories: \n- React\ncomments: true\n---\n\n### 列表和键（key）\n在React中转换数组和在JavaScript中几乎相同，可以通过数组的map方法渲染多个组件：\n```javascript\n// 显示内容为1到5的列表\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    <li>{number}</li>\n  );\n  return (\n    <ul>{listItems}</ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  <NumberList numbers={numbers} />,\n  document.getElementById('root')\n);\n```\n在运行此代码的时候，会收到一条警告，警告指出需要为每一项提供一个key，这个是很重要的。\n```javascript\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    <li key={number.toString()}>\n      {number}\n    </li>\n  );\n  return (\n    <ul>{listItems}</ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  <NumberList numbers={numbers} />,\n  document.getElementById('root')\n);\n```\n#### 键（key）\nkey可以帮助确定哪些项发生了变化，或者添加、删除了哪些项，通常使用数据的id作为key，这样在整个列表中key的值是唯一的。\nkey只有在周围环境是数据的情况下才有意义，如下：\n```javascript\n// 错误的做法\nfunction ListItem(props) {\n  const value = props.value;\n  return (\n    // 这里不必要使用key，使用\n    <li key={value.toString()}>\n      {value}\n    </li>\n  );\n}\n\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    // key属性应该添加在这里\n    <ListItem value={number} />\n  );\n  return (\n    <ul>\n      {listItems}\n    </ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  <NumberList numbers={numbers} />,\n  document.getElementById('root')\n);\n```\n其实只需要记得在map函数中使用key就可以了。\n\n#### key在兄弟节点间是唯一的\n数组中使用key需要是唯一的，但是在全局不需要是唯一的。当生成两个不同的数组，我们可以使用相同的键。  \nkey作为组件的标识，但是不会将值传递给组件，如果需要使用key中的值，需要另外传给组件的一个属性。  \nJSX中可以嵌套map函数。这种形式有时候会使代码更加清晰，有时候也会被滥用，这就需要你来决定是否需要提取出来，以提高可读性。\n\n## 表单\n表单元素自身本来就拥有一些属性（比如name等），表单在用户提交时，会执行默认的表单行为，提交到一个新的页面。但是在多数情况下，我们使用JavaScript函数处理表单的提交，处理用户提交的数据。实现这种方法的组件我们称为“受控组件”。\n\n#### 受控组件\n在HTML中，表单元素如`<input>`，`<textarea>`和`<select>`通常保持自己的状态，并根据用户的输入进行更新。而在React中，状态一般保存都state属性中，并且state属性只能通过`setState()`更新。  \n我们可以将React的state设置成HTML的输入将两者结合，然后React组件还需要控制用户的输入，这样的组件被称为“受控组件”。\n```javascript\nclass NameForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {value: ''};\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {\n    this.setState({value: event.target.value});\n  }\n\n  handleSubmit(event) {\n    alert('A name was submitted: ' + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Name:\n          <input type=\"text\" value={this.state.value} onChange={this.handleChange} />\n        </label>\n        <input type=\"submit\" value=\"Submit\" />\n      </form>\n    );\n  }\n}\n```\n其中将input元素的value值交给React组件的state，通过handleChange函数响应每次输入来更新state。使用受控组件，每个输入都会关联到处理函数，这使得可以直接修改或验证用户输入。\n\n#### textarea标签\n在React中，textarea标签也使用了value属性来代替在元素中的显示值。\n\n#### select标签\n在HTML中使用`<select>`标签时候，可以使用option中selected属性表示当前选择的选项。而在React中，将当前选项保存在select中的value，当select中的value与option的Value相同时，该选项被选择。\n\n#### 受控组件的代码\n使用受控组件有时候是很复杂的，因为你需要为更改数据的所有方式编写事件处理函数，并通过React组件管理所有输入状态。这时候可能需要不受控组件。\n\n## 提升state属性\n通常，几个组件需要反映相同的数据变化，这时候可以将共享的state提升到最接近的共同的父组件中。\n\n下面这个组件BoilingVerdict接受一个celsius温度参数，并打印是否能把水烧开\n```javascript\nfunction BoilingVerdict(props) {\n  if (props.celsius >= 100) {\n    return <p>The water would boil.</p>;\n  }\n  return <p>The water would not boil.</p>;\n}\n```\n下面这个组件Calculator，输入一个celsius摄氏温度，保存到this.state.value中，并作为BoilingVerdict输入。\n```javascript\nclass Calculator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {value: ''};\n  }\n\n  handleChange(e) {\n    this.setState({value: e.target.value});\n  }\n\n  render() {\n    const value = this.state.value;\n    return (\n      <fieldset>\n        <legend>Enter temperature in Celsius:</legend>\n        <input\n          value={value}\n          onChange={this.handleChange} />\n        <BoilingVerdict\n          celsius={parseFloat(value)} />\n      </fieldset>\n    );\n  }\n}\n```\n\n#### 添加第二个输入\n输入一个华氏温度，能够和摄氏度相互转换。  \n首先定义两个函数实现华氏度和摄氏度转换，再定义一个函数实现将值转换为字符串：\n```javascript\nfunction toCelsius(fahrenheit) {\n  return (fahrenheit - 32) * 5 / 9;\n}\n\nfunction toFahrenheit(celsius) {\n  return (celsius * 9 / 5) + 32;\n}\n\nfunction tryConvert(value, convert) {\n  const input = parseFloat(value);\n  if (Number.isNaN(input)) {\n    return '';\n  }\n  const output = convert(input);\n  const rounded = Math.round(output * 1000) / 1000;\n  return rounded.toString();\n}\n```\n下面是温度输入组件\n```javascript\nclass TemperatureInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n  }\n\n  handleChange(e) {\n    this.props.onChange(e.target.value);\n  }\n\n  render() {\n    const value = this.props.value;\n    const scale = this.props.scale;\n    return (\n      <fieldset>\n        <legend>Enter temperature in {scaleNames[scale]}:</legend>\n        <input value={value}\n               onChange={this.handleChange} />\n      </fieldset>\n    );\n  }\n}\n```\n下面是温度转换，以及显示沸水情况组件\n```javascript\nclass Calculator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleCelsiusChange = this.handleCelsiusChange.bind(this);\n    this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);\n    this.state = {value: '', scale: 'c'};\n  }\n\n  handleCelsiusChange(value) {\n    this.setState({scale: 'c', value});\n  }\n\n  handleFahrenheitChange(value) {\n    this.setState({scale: 'f', value});\n  }\n\n  render() {\n    const scale = this.state.scale;\n    const value = this.state.value;\n    const celsius = scale === 'f' ? tryConvert(value, toCelsius) : value;\n    const fahrenheit = scale === 'c' ? tryConvert(value, toFahrenheit) : value;\n\n    return (\n      <div>\n        <TemperatureInput\n          scale=\"c\"\n          value={celsius}\n          onChange={this.handleCelsiusChange} />\n        <TemperatureInput\n          scale=\"f\"\n          value={fahrenheit}\n          onChange={this.handleFahrenheitChange} />\n        <BoilingVerdict\n          celsius={parseFloat(celsius)} />\n      </div>\n    );\n  }\n}\n```\n#### 总结\n对于React中的任何数据，应该有一个单一的来源。通常将state添加到需要渲染的组件，如果其他组件也需要该state，将它提升到最接近的共同父组件中，而不是试图同步不同组件之间的state。这种解决方法就是自上而下的数据流。  \n提升state需要编写更多的代码，但是这可以方便寻找和修改bug。state存在一些组件中，在这些组件中都可以单独改变该state，这可以减少错误。另外，你可以控制用户的输入。  \n如果某个state属性，可以通过props或者其他state属性得到，我们可能就不需要该state属性。\n\n## 组件的组成和继承\nReact组件具有强大的组合功能，我们建议使用组合来重用组件之间的代码，而不是继承。\n#### 包含\n一些组件提前不知道自己包含什么。可以使用props的children来传递包含的组件\n```javascript\n// 使用props.children来调用被包含的组件\nfunction FancyBorder(props) {\n  return (\n    <div className={'FancyBorder FancyBorder-' + props.color}>\n      {props.children}\n    </div>\n  );\n}\n// 其他组件通过JSX传递被包含的组件给父组件\nfunction WelcomeDialog() {\n  return (\n    <FancyBorder color=\"blue\">\n      <h1 className=\"Dialog-title\">\n        Welcome\n      </h1>\n      <p className=\"Dialog-message\">\n        Thank you for visiting our spacecraft!\n      </p>\n    </FancyBorder>\n  );\n}\n```\n有时候也可以包含多个子组件，可以通过自定义props传递\n```javascript\nfunction SplitPane(props) {\n  return (\n    <div className=\"SplitPane\">\n      <div className=\"SplitPane-left\">\n        {props.left}\n      </div>\n      <div className=\"SplitPane-right\">\n        {props.right}\n      </div>\n    </div>\n  );\n}\n// 向SplitPane组件中传递Contacts和Chat组件\nfunction App() {\n  return (\n    <SplitPane\n      left={\n        <Contacts />\n      }\n      right={\n        <Chat />\n      } />\n  );\n}\n```\n### 特殊化\n有些组件是另一些组件的特殊情况。比如：WelcomDialog是Dialog的特例。可以通过传递props来实现\n```javascript\nfunction Dialog(props) {\n  return (\n    <FancyBorder color=\"blue\">\n      <h1 className=\"Dialog-title\">\n        {props.title}\n      </h1>\n      <p className=\"Dialog-message\">\n        {props.message}\n      </p>\n    </FancyBorder>\n  );\n}\n\nfunction WelcomeDialog() {\n  return (\n    <Dialog\n      title=\"Welcome\"\n      message=\"Thank you for visiting our spacecraft!\" />\n  );\n}\n```\n### 不建议使用继承\nprops和组合可以使React组件有很大的灵活性，组件可以接受任意props，原始值，React组件，以及函数。  \n如果组件之间重用非UI功能，建议可以将这部分函数单独提到一个JavaScript模块中，组件可以导入该模块中的函数、对象或者类，而不需要继承。\n\n## Think in React\n### 第一步 拆分组件\n拆分组件应该遵循单一职责原则，每个组件只负责做一件事。一般情况下，正确的组件划分能够正好的映射JSON数据模型。[具体参考这里](https://facebook.github.io/react/docs/thinking-in-react.html)\n### 第二步 构建静态版本\n根据层次解构组合组件，接受模拟的数据呈现出UI，但是这是没有交互性的。  \n构建静态版本，要构建一个重用其他组件的组件，并且使用props传递数据。在静态版本中，不要使用state。state保留用于交互，所以这里不需要使用它。  \n在构造过程中，可以自上到下，也可以使用自下到上。  \n在完成这一步后，你将有一个可重用的组件库，用来呈现你的模拟数据。组件只会有render()方法。在最上层组件，传递模拟数据，更改模拟数据查看组件的变化是否正常。\n### 第三步 识别最小且完整的state\n正确的构建项目，首先需要考虑项目所需要考虑所有需要的最小的state集合，并且通过这些state计算出所有需要的其他内容。如果是能够计算出来的，就不需要存储在state中。  \n比如在一个TODO列表中，所有数据包括：\n* 原本的列表\n* 用户输入搜索框的内容\n* 用户勾选的选项\n* 过滤掉的列表\n对于这样的所有数据，我们需要弄清哪些才是state，可以问自己三个问题：\n1. 它可以通过父组件的props传递进来吗？\n2. 是否不会变化？\n3. 是否可以通过其他state或props计算出来？\n如果有一个回答是，那么该属性不应该是state。  \n原本的列表应该是通过props传递来的，过滤掉的列表可以通过原本的列表和输入框中的值计算出来。最后得到的state是：\n* 用户输入搜索框的内容\n* 用户勾选的选项\n### 第四步 确定state应该在哪个位置\n确定好state之后，是要确定在哪里定义state，在哪里更改state。  \n对于每一个state：\n* 确定哪些组件要用到该state\n* 找到一个包含这些所有组件的父组件\n* 包含这些所有组件的父组件其中结构层次最高的组件应该拥有该state\n* 如果找不到这样的父组件，创建一个这样的父组件，并且添加state\n### 第五步 添加反向数据流\n因为是单向数据流，所以需要添加操作对state的更改。比如，输入框绑定了用户输入搜索框内容这个state，输入框就不会响应用户的输入行为，需要为input绑定修改state事件。这里是子组件修改父组件中的state，所以就是反向数据流。","slug":"React Docs(3)","published":1,"updated":"2017-12-28T03:47:32.455Z","layout":"post","photos":[],"link":"","_id":"cjks5i9i40010vmti4e4wb1re","content":"<h3 id=\"列表和键（key）\"><a href=\"#列表和键（key）\" class=\"headerlink\" title=\"列表和键（key）\"></a>列表和键（key）</h3><p>在React中转换数组和在JavaScript中几乎相同，可以通过数组的map方法渲染多个组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 显示内容为1到5的列表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">NumberList</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> numbers = props.numbers;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> listItems = numbers.map(<span class=\"function\">(<span class=\"params\">number</span>) =&gt;</span></span><br><span class=\"line\">    &lt;li&gt;&#123;number&#125;&lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;ul&gt;&#123;listItems&#125;&lt;/u</span>l&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>在运行此代码的时候，会收到一条警告，警告指出需要为每一项提供一个key，这个是很重要的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">NumberList</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> numbers = props.numbers;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> listItems = numbers.map(<span class=\"function\">(<span class=\"params\">number</span>) =&gt;</span></span><br><span class=\"line\">    &lt;li key=&#123;number.toString()&#125;&gt;</span><br><span class=\"line\">      &#123;number&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;ul&gt;&#123;listItems&#125;&lt;/u</span>l&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"键（key）\"><a href=\"#键（key）\" class=\"headerlink\" title=\"键（key）\"></a>键（key）</h4><p>key可以帮助确定哪些项发生了变化，或者添加、删除了哪些项，通常使用数据的id作为key，这样在整个列表中key的值是唯一的。<br>key只有在周围环境是数据的情况下才有意义，如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误的做法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ListItem</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> value = props.value;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"comment\">// 这里不必要使用key，使用</span></span><br><span class=\"line\">    &lt;li key=&#123;value.toString()&#125;&gt;</span><br><span class=\"line\">      &#123;value&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function NumberList(props) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  const numbers = props.numbers;</span></span><br><span class=\"line\"><span class=\"regexp\">  const listItems = numbers.map((number) =&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ key属性应该添加在这里</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;ListItem value=&#123;number&#125; /</span>&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">      &#123;listItems&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">const numbers = [1, 2, 3, 4, 5];</span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;NumberList numbers=&#123;numbers&#125; /</span>&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>其实只需要记得在map函数中使用key就可以了。</p>\n<h4 id=\"key在兄弟节点间是唯一的\"><a href=\"#key在兄弟节点间是唯一的\" class=\"headerlink\" title=\"key在兄弟节点间是唯一的\"></a>key在兄弟节点间是唯一的</h4><p>数组中使用key需要是唯一的，但是在全局不需要是唯一的。当生成两个不同的数组，我们可以使用相同的键。<br>key作为组件的标识，但是不会将值传递给组件，如果需要使用key中的值，需要另外传给组件的一个属性。<br>JSX中可以嵌套map函数。这种形式有时候会使代码更加清晰，有时候也会被滥用，这就需要你来决定是否需要提取出来，以提高可读性。</p>\n<h2 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h2><p>表单元素自身本来就拥有一些属性（比如name等），表单在用户提交时，会执行默认的表单行为，提交到一个新的页面。但是在多数情况下，我们使用JavaScript函数处理表单的提交，处理用户提交的数据。实现这种方法的组件我们称为“受控组件”。</p>\n<h4 id=\"受控组件\"><a href=\"#受控组件\" class=\"headerlink\" title=\"受控组件\"></a>受控组件</h4><p>在HTML中，表单元素如<code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>和<code>&lt;select&gt;</code>通常保持自己的状态，并根据用户的输入进行更新。而在React中，状态一般保存都state属性中，并且state属性只能通过<code>setState()</code>更新。<br>我们可以将React的state设置成HTML的输入将两者结合，然后React组件还需要控制用户的输入，这样的组件被称为“受控组件”。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NameForm</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">value</span>: <span class=\"string\">''</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleSubmit = <span class=\"keyword\">this</span>.handleSubmit.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange(event) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">value</span>: event.target.value&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleSubmit(event) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'A name was submitted: '</span> + <span class=\"keyword\">this</span>.state.value);</span><br><span class=\"line\">    event.preventDefault();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;form onSubmit=&#123;<span class=\"keyword\">this</span>.handleSubmit&#125;&gt;</span><br><span class=\"line\">        &lt;label&gt;</span><br><span class=\"line\">          Name:</span><br><span class=\"line\">          &lt;input type=<span class=\"string\">\"text\"</span> value=&#123;<span class=\"keyword\">this</span>.state.value&#125; onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125; /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/label&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;input type=\"submit\" value=\"Submit\" /</span>&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/form&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>其中将input元素的value值交给React组件的state，通过handleChange函数响应每次输入来更新state。使用受控组件，每个输入都会关联到处理函数，这使得可以直接修改或验证用户输入。</p>\n<h4 id=\"textarea标签\"><a href=\"#textarea标签\" class=\"headerlink\" title=\"textarea标签\"></a>textarea标签</h4><p>在React中，textarea标签也使用了value属性来代替在元素中的显示值。</p>\n<h4 id=\"select标签\"><a href=\"#select标签\" class=\"headerlink\" title=\"select标签\"></a>select标签</h4><p>在HTML中使用<code>&lt;select&gt;</code>标签时候，可以使用option中selected属性表示当前选择的选项。而在React中，将当前选项保存在select中的value，当select中的value与option的Value相同时，该选项被选择。</p>\n<h4 id=\"受控组件的代码\"><a href=\"#受控组件的代码\" class=\"headerlink\" title=\"受控组件的代码\"></a>受控组件的代码</h4><p>使用受控组件有时候是很复杂的，因为你需要为更改数据的所有方式编写事件处理函数，并通过React组件管理所有输入状态。这时候可能需要不受控组件。</p>\n<h2 id=\"提升state属性\"><a href=\"#提升state属性\" class=\"headerlink\" title=\"提升state属性\"></a>提升state属性</h2><p>通常，几个组件需要反映相同的数据变化，这时候可以将共享的state提升到最接近的共同的父组件中。</p>\n<p>下面这个组件BoilingVerdict接受一个celsius温度参数，并打印是否能把水烧开<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BoilingVerdict</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (props.celsius &gt;= <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>The water would boil.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>The water would not boil.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面这个组件Calculator，输入一个celsius摄氏温度，保存到this.state.value中，并作为BoilingVerdict输入。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Calculator</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">value</span>: <span class=\"string\">''</span>&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange(e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">value</span>: e.target.value&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = <span class=\"keyword\">this</span>.state.value;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;fieldset&gt;</span><br><span class=\"line\">        &lt;legend&gt;Enter temperature <span class=\"keyword\">in</span> Celsius:<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">legend</span>&gt;</span></span></span><br><span class=\"line\">        &lt;input</span><br><span class=\"line\">          value=&#123;value&#125;</span><br><span class=\"line\">          onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125; /&gt;</span><br><span class=\"line\">        &lt;BoilingVerdict</span><br><span class=\"line\">          celsius=&#123;<span class=\"built_in\">parseFloat</span>(value)&#125; /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/fieldset&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"添加第二个输入\"><a href=\"#添加第二个输入\" class=\"headerlink\" title=\"添加第二个输入\"></a>添加第二个输入</h4><p>输入一个华氏温度，能够和摄氏度相互转换。<br>首先定义两个函数实现华氏度和摄氏度转换，再定义一个函数实现将值转换为字符串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toCelsius</span>(<span class=\"params\">fahrenheit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (fahrenheit - <span class=\"number\">32</span>) * <span class=\"number\">5</span> / <span class=\"number\">9</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toFahrenheit</span>(<span class=\"params\">celsius</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (celsius * <span class=\"number\">9</span> / <span class=\"number\">5</span>) + <span class=\"number\">32</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tryConvert</span>(<span class=\"params\">value, convert</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> input = <span class=\"built_in\">parseFloat</span>(value);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Number</span>.isNaN(input)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> output = convert(input);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rounded = <span class=\"built_in\">Math</span>.round(output * <span class=\"number\">1000</span>) / <span class=\"number\">1000</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> rounded.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面是温度输入组件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TemperatureInput</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange(e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.props.onChange(e.target.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = <span class=\"keyword\">this</span>.props.value;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> scale = <span class=\"keyword\">this</span>.props.scale;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;fieldset&gt;</span><br><span class=\"line\">        &lt;legend&gt;Enter temperature <span class=\"keyword\">in</span> &#123;scaleNames[scale]&#125;:<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">legend</span>&gt;</span></span></span><br><span class=\"line\">        &lt;input value=&#123;value&#125;</span><br><span class=\"line\">               onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125; /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/fieldset&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>下面是温度转换，以及显示沸水情况组件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Calculator</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleCelsiusChange = <span class=\"keyword\">this</span>.handleCelsiusChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleFahrenheitChange = <span class=\"keyword\">this</span>.handleFahrenheitChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">value</span>: <span class=\"string\">''</span>, <span class=\"attr\">scale</span>: <span class=\"string\">'c'</span>&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleCelsiusChange(value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">scale</span>: <span class=\"string\">'c'</span>, value&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleFahrenheitChange(value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">scale</span>: <span class=\"string\">'f'</span>, value&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> scale = <span class=\"keyword\">this</span>.state.scale;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = <span class=\"keyword\">this</span>.state.value;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> celsius = scale === <span class=\"string\">'f'</span> ? tryConvert(value, toCelsius) : value;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fahrenheit = scale === <span class=\"string\">'c'</span> ? tryConvert(value, toFahrenheit) : value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;TemperatureInput</span><br><span class=\"line\">          scale=<span class=\"string\">\"c\"</span></span><br><span class=\"line\">          value=&#123;celsius&#125;</span><br><span class=\"line\">          onChange=&#123;<span class=\"keyword\">this</span>.handleCelsiusChange&#125; /&gt;</span><br><span class=\"line\">        &lt;TemperatureInput</span><br><span class=\"line\">          scale=<span class=\"string\">\"f\"</span></span><br><span class=\"line\">          value=&#123;fahrenheit&#125;</span><br><span class=\"line\">          onChange=&#123;<span class=\"keyword\">this</span>.handleFahrenheitChange&#125; /&gt;</span><br><span class=\"line\">        &lt;BoilingVerdict</span><br><span class=\"line\">          celsius=&#123;<span class=\"built_in\">parseFloat</span>(celsius)&#125; /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>对于React中的任何数据，应该有一个单一的来源。通常将state添加到需要渲染的组件，如果其他组件也需要该state，将它提升到最接近的共同父组件中，而不是试图同步不同组件之间的state。这种解决方法就是自上而下的数据流。<br>提升state需要编写更多的代码，但是这可以方便寻找和修改bug。state存在一些组件中，在这些组件中都可以单独改变该state，这可以减少错误。另外，你可以控制用户的输入。<br>如果某个state属性，可以通过props或者其他state属性得到，我们可能就不需要该state属性。</p>\n<h2 id=\"组件的组成和继承\"><a href=\"#组件的组成和继承\" class=\"headerlink\" title=\"组件的组成和继承\"></a>组件的组成和继承</h2><p>React组件具有强大的组合功能，我们建议使用组合来重用组件之间的代码，而不是继承。</p>\n<h4 id=\"包含\"><a href=\"#包含\" class=\"headerlink\" title=\"包含\"></a>包含</h4><p>一些组件提前不知道自己包含什么。可以使用props的children来传递包含的组件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用props.children来调用被包含的组件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FancyBorder</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div className=&#123;<span class=\"string\">'FancyBorder FancyBorder-'</span> + props.color&#125;&gt;</span><br><span class=\"line\">      &#123;props.children&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 其他组件通过JSX传递被包含的组件给父组件</span></span><br><span class=\"line\"><span class=\"regexp\">function WelcomeDialog() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;FancyBorder color=\"blue\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;h1 className=\"Dialog-title\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        Welcome</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>h1&gt;</span><br><span class=\"line\">      &lt;p className=<span class=\"string\">\"Dialog-message\"</span>&gt;</span><br><span class=\"line\">        Thank you <span class=\"keyword\">for</span> visiting our spacecraft!</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>FancyBorder&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>有时候也可以包含多个子组件，可以通过自定义props传递<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SplitPane</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div className=<span class=\"string\">\"SplitPane\"</span>&gt;</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"SplitPane-left\"</span>&gt;</span><br><span class=\"line\">        &#123;props.left&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div className=\"SplitPane-right\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;props.right&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 向SplitPane组件中传递Contacts和Chat组件</span></span><br><span class=\"line\"><span class=\"regexp\">function App() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;SplitPane</span></span><br><span class=\"line\"><span class=\"regexp\">      left=&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;Contacts /</span>&gt;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      right=&#123;</span><br><span class=\"line\">        &lt;Chat /&gt;</span><br><span class=\"line\">      &#125; /&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"特殊化\"><a href=\"#特殊化\" class=\"headerlink\" title=\"特殊化\"></a>特殊化</h3><p>有些组件是另一些组件的特殊情况。比如：WelcomDialog是Dialog的特例。可以通过传递props来实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dialog</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;FancyBorder color=<span class=\"string\">\"blue\"</span>&gt;</span><br><span class=\"line\">      &lt;h1 className=<span class=\"string\">\"Dialog-title\"</span>&gt;</span><br><span class=\"line\">        &#123;props.title&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;p className=\"Dialog-message\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;props.message&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>p&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/FancyBorder&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function WelcomeDialog() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;Dialog</span></span><br><span class=\"line\"><span class=\"regexp\">      title=\"Welcome\"</span></span><br><span class=\"line\"><span class=\"regexp\">      message=\"Thank you for visiting our spacecraft!\" /</span>&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"不建议使用继承\"><a href=\"#不建议使用继承\" class=\"headerlink\" title=\"不建议使用继承\"></a>不建议使用继承</h3><p>props和组合可以使React组件有很大的灵活性，组件可以接受任意props，原始值，React组件，以及函数。<br>如果组件之间重用非UI功能，建议可以将这部分函数单独提到一个JavaScript模块中，组件可以导入该模块中的函数、对象或者类，而不需要继承。</p>\n<h2 id=\"Think-in-React\"><a href=\"#Think-in-React\" class=\"headerlink\" title=\"Think in React\"></a>Think in React</h2><h3 id=\"第一步-拆分组件\"><a href=\"#第一步-拆分组件\" class=\"headerlink\" title=\"第一步 拆分组件\"></a>第一步 拆分组件</h3><p>拆分组件应该遵循单一职责原则，每个组件只负责做一件事。一般情况下，正确的组件划分能够正好的映射JSON数据模型。<a href=\"https://facebook.github.io/react/docs/thinking-in-react.html\" target=\"_blank\" rel=\"noopener\">具体参考这里</a></p>\n<h3 id=\"第二步-构建静态版本\"><a href=\"#第二步-构建静态版本\" class=\"headerlink\" title=\"第二步 构建静态版本\"></a>第二步 构建静态版本</h3><p>根据层次解构组合组件，接受模拟的数据呈现出UI，但是这是没有交互性的。<br>构建静态版本，要构建一个重用其他组件的组件，并且使用props传递数据。在静态版本中，不要使用state。state保留用于交互，所以这里不需要使用它。<br>在构造过程中，可以自上到下，也可以使用自下到上。<br>在完成这一步后，你将有一个可重用的组件库，用来呈现你的模拟数据。组件只会有render()方法。在最上层组件，传递模拟数据，更改模拟数据查看组件的变化是否正常。</p>\n<h3 id=\"第三步-识别最小且完整的state\"><a href=\"#第三步-识别最小且完整的state\" class=\"headerlink\" title=\"第三步 识别最小且完整的state\"></a>第三步 识别最小且完整的state</h3><p>正确的构建项目，首先需要考虑项目所需要考虑所有需要的最小的state集合，并且通过这些state计算出所有需要的其他内容。如果是能够计算出来的，就不需要存储在state中。<br>比如在一个TODO列表中，所有数据包括：</p>\n<ul>\n<li>原本的列表</li>\n<li>用户输入搜索框的内容</li>\n<li>用户勾选的选项</li>\n<li>过滤掉的列表<br>对于这样的所有数据，我们需要弄清哪些才是state，可以问自己三个问题：</li>\n</ul>\n<ol>\n<li>它可以通过父组件的props传递进来吗？</li>\n<li>是否不会变化？</li>\n<li>是否可以通过其他state或props计算出来？<br>如果有一个回答是，那么该属性不应该是state。<br>原本的列表应该是通过props传递来的，过滤掉的列表可以通过原本的列表和输入框中的值计算出来。最后得到的state是：</li>\n</ol>\n<ul>\n<li>用户输入搜索框的内容</li>\n<li>用户勾选的选项<h3 id=\"第四步-确定state应该在哪个位置\"><a href=\"#第四步-确定state应该在哪个位置\" class=\"headerlink\" title=\"第四步 确定state应该在哪个位置\"></a>第四步 确定state应该在哪个位置</h3>确定好state之后，是要确定在哪里定义state，在哪里更改state。<br>对于每一个state：</li>\n<li>确定哪些组件要用到该state</li>\n<li>找到一个包含这些所有组件的父组件</li>\n<li>包含这些所有组件的父组件其中结构层次最高的组件应该拥有该state</li>\n<li>如果找不到这样的父组件，创建一个这样的父组件，并且添加state<h3 id=\"第五步-添加反向数据流\"><a href=\"#第五步-添加反向数据流\" class=\"headerlink\" title=\"第五步 添加反向数据流\"></a>第五步 添加反向数据流</h3>因为是单向数据流，所以需要添加操作对state的更改。比如，输入框绑定了用户输入搜索框内容这个state，输入框就不会响应用户的输入行为，需要为input绑定修改state事件。这里是子组件修改父组件中的state，所以就是反向数据流。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"列表和键（key）\"><a href=\"#列表和键（key）\" class=\"headerlink\" title=\"列表和键（key）\"></a>列表和键（key）</h3><p>在React中转换数组和在JavaScript中几乎相同，可以通过数组的map方法渲染多个组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 显示内容为1到5的列表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">NumberList</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> numbers = props.numbers;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> listItems = numbers.map(<span class=\"function\">(<span class=\"params\">number</span>) =&gt;</span></span><br><span class=\"line\">    &lt;li&gt;&#123;number&#125;&lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;ul&gt;&#123;listItems&#125;&lt;/u</span>l&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>在运行此代码的时候，会收到一条警告，警告指出需要为每一项提供一个key，这个是很重要的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">NumberList</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> numbers = props.numbers;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> listItems = numbers.map(<span class=\"function\">(<span class=\"params\">number</span>) =&gt;</span></span><br><span class=\"line\">    &lt;li key=&#123;number.toString()&#125;&gt;</span><br><span class=\"line\">      &#123;number&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;ul&gt;&#123;listItems&#125;&lt;/u</span>l&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"键（key）\"><a href=\"#键（key）\" class=\"headerlink\" title=\"键（key）\"></a>键（key）</h4><p>key可以帮助确定哪些项发生了变化，或者添加、删除了哪些项，通常使用数据的id作为key，这样在整个列表中key的值是唯一的。<br>key只有在周围环境是数据的情况下才有意义，如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误的做法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ListItem</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> value = props.value;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"comment\">// 这里不必要使用key，使用</span></span><br><span class=\"line\">    &lt;li key=&#123;value.toString()&#125;&gt;</span><br><span class=\"line\">      &#123;value&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function NumberList(props) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  const numbers = props.numbers;</span></span><br><span class=\"line\"><span class=\"regexp\">  const listItems = numbers.map((number) =&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ key属性应该添加在这里</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;ListItem value=&#123;number&#125; /</span>&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">      &#123;listItems&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">const numbers = [1, 2, 3, 4, 5];</span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;NumberList numbers=&#123;numbers&#125; /</span>&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>其实只需要记得在map函数中使用key就可以了。</p>\n<h4 id=\"key在兄弟节点间是唯一的\"><a href=\"#key在兄弟节点间是唯一的\" class=\"headerlink\" title=\"key在兄弟节点间是唯一的\"></a>key在兄弟节点间是唯一的</h4><p>数组中使用key需要是唯一的，但是在全局不需要是唯一的。当生成两个不同的数组，我们可以使用相同的键。<br>key作为组件的标识，但是不会将值传递给组件，如果需要使用key中的值，需要另外传给组件的一个属性。<br>JSX中可以嵌套map函数。这种形式有时候会使代码更加清晰，有时候也会被滥用，这就需要你来决定是否需要提取出来，以提高可读性。</p>\n<h2 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h2><p>表单元素自身本来就拥有一些属性（比如name等），表单在用户提交时，会执行默认的表单行为，提交到一个新的页面。但是在多数情况下，我们使用JavaScript函数处理表单的提交，处理用户提交的数据。实现这种方法的组件我们称为“受控组件”。</p>\n<h4 id=\"受控组件\"><a href=\"#受控组件\" class=\"headerlink\" title=\"受控组件\"></a>受控组件</h4><p>在HTML中，表单元素如<code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>和<code>&lt;select&gt;</code>通常保持自己的状态，并根据用户的输入进行更新。而在React中，状态一般保存都state属性中，并且state属性只能通过<code>setState()</code>更新。<br>我们可以将React的state设置成HTML的输入将两者结合，然后React组件还需要控制用户的输入，这样的组件被称为“受控组件”。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NameForm</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">value</span>: <span class=\"string\">''</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleSubmit = <span class=\"keyword\">this</span>.handleSubmit.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange(event) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">value</span>: event.target.value&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleSubmit(event) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'A name was submitted: '</span> + <span class=\"keyword\">this</span>.state.value);</span><br><span class=\"line\">    event.preventDefault();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;form onSubmit=&#123;<span class=\"keyword\">this</span>.handleSubmit&#125;&gt;</span><br><span class=\"line\">        &lt;label&gt;</span><br><span class=\"line\">          Name:</span><br><span class=\"line\">          &lt;input type=<span class=\"string\">\"text\"</span> value=&#123;<span class=\"keyword\">this</span>.state.value&#125; onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125; /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/label&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;input type=\"submit\" value=\"Submit\" /</span>&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/form&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>其中将input元素的value值交给React组件的state，通过handleChange函数响应每次输入来更新state。使用受控组件，每个输入都会关联到处理函数，这使得可以直接修改或验证用户输入。</p>\n<h4 id=\"textarea标签\"><a href=\"#textarea标签\" class=\"headerlink\" title=\"textarea标签\"></a>textarea标签</h4><p>在React中，textarea标签也使用了value属性来代替在元素中的显示值。</p>\n<h4 id=\"select标签\"><a href=\"#select标签\" class=\"headerlink\" title=\"select标签\"></a>select标签</h4><p>在HTML中使用<code>&lt;select&gt;</code>标签时候，可以使用option中selected属性表示当前选择的选项。而在React中，将当前选项保存在select中的value，当select中的value与option的Value相同时，该选项被选择。</p>\n<h4 id=\"受控组件的代码\"><a href=\"#受控组件的代码\" class=\"headerlink\" title=\"受控组件的代码\"></a>受控组件的代码</h4><p>使用受控组件有时候是很复杂的，因为你需要为更改数据的所有方式编写事件处理函数，并通过React组件管理所有输入状态。这时候可能需要不受控组件。</p>\n<h2 id=\"提升state属性\"><a href=\"#提升state属性\" class=\"headerlink\" title=\"提升state属性\"></a>提升state属性</h2><p>通常，几个组件需要反映相同的数据变化，这时候可以将共享的state提升到最接近的共同的父组件中。</p>\n<p>下面这个组件BoilingVerdict接受一个celsius温度参数，并打印是否能把水烧开<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BoilingVerdict</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (props.celsius &gt;= <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>The water would boil.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>The water would not boil.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面这个组件Calculator，输入一个celsius摄氏温度，保存到this.state.value中，并作为BoilingVerdict输入。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Calculator</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">value</span>: <span class=\"string\">''</span>&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange(e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">value</span>: e.target.value&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = <span class=\"keyword\">this</span>.state.value;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;fieldset&gt;</span><br><span class=\"line\">        &lt;legend&gt;Enter temperature <span class=\"keyword\">in</span> Celsius:<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">legend</span>&gt;</span></span></span><br><span class=\"line\">        &lt;input</span><br><span class=\"line\">          value=&#123;value&#125;</span><br><span class=\"line\">          onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125; /&gt;</span><br><span class=\"line\">        &lt;BoilingVerdict</span><br><span class=\"line\">          celsius=&#123;<span class=\"built_in\">parseFloat</span>(value)&#125; /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/fieldset&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"添加第二个输入\"><a href=\"#添加第二个输入\" class=\"headerlink\" title=\"添加第二个输入\"></a>添加第二个输入</h4><p>输入一个华氏温度，能够和摄氏度相互转换。<br>首先定义两个函数实现华氏度和摄氏度转换，再定义一个函数实现将值转换为字符串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toCelsius</span>(<span class=\"params\">fahrenheit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (fahrenheit - <span class=\"number\">32</span>) * <span class=\"number\">5</span> / <span class=\"number\">9</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toFahrenheit</span>(<span class=\"params\">celsius</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (celsius * <span class=\"number\">9</span> / <span class=\"number\">5</span>) + <span class=\"number\">32</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tryConvert</span>(<span class=\"params\">value, convert</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> input = <span class=\"built_in\">parseFloat</span>(value);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Number</span>.isNaN(input)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> output = convert(input);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rounded = <span class=\"built_in\">Math</span>.round(output * <span class=\"number\">1000</span>) / <span class=\"number\">1000</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> rounded.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面是温度输入组件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TemperatureInput</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange(e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.props.onChange(e.target.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = <span class=\"keyword\">this</span>.props.value;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> scale = <span class=\"keyword\">this</span>.props.scale;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;fieldset&gt;</span><br><span class=\"line\">        &lt;legend&gt;Enter temperature <span class=\"keyword\">in</span> &#123;scaleNames[scale]&#125;:<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">legend</span>&gt;</span></span></span><br><span class=\"line\">        &lt;input value=&#123;value&#125;</span><br><span class=\"line\">               onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125; /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/fieldset&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>下面是温度转换，以及显示沸水情况组件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Calculator</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleCelsiusChange = <span class=\"keyword\">this</span>.handleCelsiusChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleFahrenheitChange = <span class=\"keyword\">this</span>.handleFahrenheitChange.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">value</span>: <span class=\"string\">''</span>, <span class=\"attr\">scale</span>: <span class=\"string\">'c'</span>&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleCelsiusChange(value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">scale</span>: <span class=\"string\">'c'</span>, value&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleFahrenheitChange(value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">scale</span>: <span class=\"string\">'f'</span>, value&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> scale = <span class=\"keyword\">this</span>.state.scale;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = <span class=\"keyword\">this</span>.state.value;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> celsius = scale === <span class=\"string\">'f'</span> ? tryConvert(value, toCelsius) : value;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fahrenheit = scale === <span class=\"string\">'c'</span> ? tryConvert(value, toFahrenheit) : value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;TemperatureInput</span><br><span class=\"line\">          scale=<span class=\"string\">\"c\"</span></span><br><span class=\"line\">          value=&#123;celsius&#125;</span><br><span class=\"line\">          onChange=&#123;<span class=\"keyword\">this</span>.handleCelsiusChange&#125; /&gt;</span><br><span class=\"line\">        &lt;TemperatureInput</span><br><span class=\"line\">          scale=<span class=\"string\">\"f\"</span></span><br><span class=\"line\">          value=&#123;fahrenheit&#125;</span><br><span class=\"line\">          onChange=&#123;<span class=\"keyword\">this</span>.handleFahrenheitChange&#125; /&gt;</span><br><span class=\"line\">        &lt;BoilingVerdict</span><br><span class=\"line\">          celsius=&#123;<span class=\"built_in\">parseFloat</span>(celsius)&#125; /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>对于React中的任何数据，应该有一个单一的来源。通常将state添加到需要渲染的组件，如果其他组件也需要该state，将它提升到最接近的共同父组件中，而不是试图同步不同组件之间的state。这种解决方法就是自上而下的数据流。<br>提升state需要编写更多的代码，但是这可以方便寻找和修改bug。state存在一些组件中，在这些组件中都可以单独改变该state，这可以减少错误。另外，你可以控制用户的输入。<br>如果某个state属性，可以通过props或者其他state属性得到，我们可能就不需要该state属性。</p>\n<h2 id=\"组件的组成和继承\"><a href=\"#组件的组成和继承\" class=\"headerlink\" title=\"组件的组成和继承\"></a>组件的组成和继承</h2><p>React组件具有强大的组合功能，我们建议使用组合来重用组件之间的代码，而不是继承。</p>\n<h4 id=\"包含\"><a href=\"#包含\" class=\"headerlink\" title=\"包含\"></a>包含</h4><p>一些组件提前不知道自己包含什么。可以使用props的children来传递包含的组件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用props.children来调用被包含的组件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FancyBorder</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div className=&#123;<span class=\"string\">'FancyBorder FancyBorder-'</span> + props.color&#125;&gt;</span><br><span class=\"line\">      &#123;props.children&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 其他组件通过JSX传递被包含的组件给父组件</span></span><br><span class=\"line\"><span class=\"regexp\">function WelcomeDialog() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;FancyBorder color=\"blue\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;h1 className=\"Dialog-title\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        Welcome</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>h1&gt;</span><br><span class=\"line\">      &lt;p className=<span class=\"string\">\"Dialog-message\"</span>&gt;</span><br><span class=\"line\">        Thank you <span class=\"keyword\">for</span> visiting our spacecraft!</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>FancyBorder&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>有时候也可以包含多个子组件，可以通过自定义props传递<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SplitPane</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div className=<span class=\"string\">\"SplitPane\"</span>&gt;</span><br><span class=\"line\">      &lt;div className=<span class=\"string\">\"SplitPane-left\"</span>&gt;</span><br><span class=\"line\">        &#123;props.left&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div className=\"SplitPane-right\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;props.right&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 向SplitPane组件中传递Contacts和Chat组件</span></span><br><span class=\"line\"><span class=\"regexp\">function App() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;SplitPane</span></span><br><span class=\"line\"><span class=\"regexp\">      left=&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;Contacts /</span>&gt;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      right=&#123;</span><br><span class=\"line\">        &lt;Chat /&gt;</span><br><span class=\"line\">      &#125; /&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"特殊化\"><a href=\"#特殊化\" class=\"headerlink\" title=\"特殊化\"></a>特殊化</h3><p>有些组件是另一些组件的特殊情况。比如：WelcomDialog是Dialog的特例。可以通过传递props来实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dialog</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;FancyBorder color=<span class=\"string\">\"blue\"</span>&gt;</span><br><span class=\"line\">      &lt;h1 className=<span class=\"string\">\"Dialog-title\"</span>&gt;</span><br><span class=\"line\">        &#123;props.title&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;p className=\"Dialog-message\"&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123;props.message&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>p&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/FancyBorder&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function WelcomeDialog() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;Dialog</span></span><br><span class=\"line\"><span class=\"regexp\">      title=\"Welcome\"</span></span><br><span class=\"line\"><span class=\"regexp\">      message=\"Thank you for visiting our spacecraft!\" /</span>&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"不建议使用继承\"><a href=\"#不建议使用继承\" class=\"headerlink\" title=\"不建议使用继承\"></a>不建议使用继承</h3><p>props和组合可以使React组件有很大的灵活性，组件可以接受任意props，原始值，React组件，以及函数。<br>如果组件之间重用非UI功能，建议可以将这部分函数单独提到一个JavaScript模块中，组件可以导入该模块中的函数、对象或者类，而不需要继承。</p>\n<h2 id=\"Think-in-React\"><a href=\"#Think-in-React\" class=\"headerlink\" title=\"Think in React\"></a>Think in React</h2><h3 id=\"第一步-拆分组件\"><a href=\"#第一步-拆分组件\" class=\"headerlink\" title=\"第一步 拆分组件\"></a>第一步 拆分组件</h3><p>拆分组件应该遵循单一职责原则，每个组件只负责做一件事。一般情况下，正确的组件划分能够正好的映射JSON数据模型。<a href=\"https://facebook.github.io/react/docs/thinking-in-react.html\" target=\"_blank\" rel=\"noopener\">具体参考这里</a></p>\n<h3 id=\"第二步-构建静态版本\"><a href=\"#第二步-构建静态版本\" class=\"headerlink\" title=\"第二步 构建静态版本\"></a>第二步 构建静态版本</h3><p>根据层次解构组合组件，接受模拟的数据呈现出UI，但是这是没有交互性的。<br>构建静态版本，要构建一个重用其他组件的组件，并且使用props传递数据。在静态版本中，不要使用state。state保留用于交互，所以这里不需要使用它。<br>在构造过程中，可以自上到下，也可以使用自下到上。<br>在完成这一步后，你将有一个可重用的组件库，用来呈现你的模拟数据。组件只会有render()方法。在最上层组件，传递模拟数据，更改模拟数据查看组件的变化是否正常。</p>\n<h3 id=\"第三步-识别最小且完整的state\"><a href=\"#第三步-识别最小且完整的state\" class=\"headerlink\" title=\"第三步 识别最小且完整的state\"></a>第三步 识别最小且完整的state</h3><p>正确的构建项目，首先需要考虑项目所需要考虑所有需要的最小的state集合，并且通过这些state计算出所有需要的其他内容。如果是能够计算出来的，就不需要存储在state中。<br>比如在一个TODO列表中，所有数据包括：</p>\n<ul>\n<li>原本的列表</li>\n<li>用户输入搜索框的内容</li>\n<li>用户勾选的选项</li>\n<li>过滤掉的列表<br>对于这样的所有数据，我们需要弄清哪些才是state，可以问自己三个问题：</li>\n</ul>\n<ol>\n<li>它可以通过父组件的props传递进来吗？</li>\n<li>是否不会变化？</li>\n<li>是否可以通过其他state或props计算出来？<br>如果有一个回答是，那么该属性不应该是state。<br>原本的列表应该是通过props传递来的，过滤掉的列表可以通过原本的列表和输入框中的值计算出来。最后得到的state是：</li>\n</ol>\n<ul>\n<li>用户输入搜索框的内容</li>\n<li>用户勾选的选项<h3 id=\"第四步-确定state应该在哪个位置\"><a href=\"#第四步-确定state应该在哪个位置\" class=\"headerlink\" title=\"第四步 确定state应该在哪个位置\"></a>第四步 确定state应该在哪个位置</h3>确定好state之后，是要确定在哪里定义state，在哪里更改state。<br>对于每一个state：</li>\n<li>确定哪些组件要用到该state</li>\n<li>找到一个包含这些所有组件的父组件</li>\n<li>包含这些所有组件的父组件其中结构层次最高的组件应该拥有该state</li>\n<li>如果找不到这样的父组件，创建一个这样的父组件，并且添加state<h3 id=\"第五步-添加反向数据流\"><a href=\"#第五步-添加反向数据流\" class=\"headerlink\" title=\"第五步 添加反向数据流\"></a>第五步 添加反向数据流</h3>因为是单向数据流，所以需要添加操作对state的更改。比如，输入框绑定了用户输入搜索框内容这个state，输入框就不会响应用户的输入行为，需要为input绑定修改state事件。这里是子组件修改父组件中的state，所以就是反向数据流。</li>\n</ul>\n"},{"title":"React Router学习","date":"2016-08-23T16:00:00.000Z","comments":1,"_content":"\n### 0. 路由\n\n路由也就是地址，就是定义不同url访问不同页面的功能，可以实现导航、页面切换/跳转等功能。\n\n### 1. 引入\n```javascript \nimport { Router, Route, hashHistory } from 'react-router'\n```\n\n### 2. 配置\n```javascript\n<Router history={browserHistory}>\n\t<Route path=\"/\" component={Home}></Route>\n\t<Route path=\"article\" component={Article}></Route>\n</Router>\n```\n\n### 3. 通过Link实现跳转\n```javascript\n<Link to=\"/about\">About</Link>\n```\n\n### 4.1 路由嵌套(公用导航)\n```javascript\n// 路由配置\n<Router history={hashHistory}>\n  <Route path=\"/\" component={App}>\n    <Route path=\"/repos\" component={Repos}/>\n    <Route path=\"/about\" component={About}/>\n  </Route>\n</Router>\n// 页面配置(通过this.props.children调用)\n{this.props.children}\n```\n\n### 4.2 Active Links\n```javascript\n// 活动样式\n<Link to=\"/about\" activeStyle={{ color: 'red' }}>About</Link>\n// 或者 活动类名\n<li><Link to=\"/about\" activeClassName=\"active\">About</Link></li>\n```\n\n### 5. 传参\n```javascript\n// 配置\n// :userName表示匹配参数\n<Route path=\"/repos/:userName/:repoName\" component={Repo}/>\n// 跳转地址\n<Link to=\"/repos/reactjs/react-router\">React Router</Link>\n// 页面中访问参数\n{this.props.params.repoName}\n```\n\n### 6. 嵌套路由下的默认页\n```javascript\n// 需要引入react-router下的{IndexRoute}\n<Router history={hashHistory}>\n  <Route path=\"/\" component={App}>\n\n    {/* add it here, as a child of `/` */}\n    <IndexRoute component={Home}/>\n\n    <Route path=\"/repos\" component={Repos}>\n      <Route path=\"/repos/:userName/:repoName\" component={Repo}/>\n    </Route>\n    <Route path=\"/about\" component={About}/>\n  </Route>\n</Router>\n```\n\n### 7. 首页(默认页)路由地址\n```javascript\n// 直接使用Link to=\"/\"，会导致该链接总是active状态\n<Link to=\"/\"></Link>\n// 引入react-router下的{IndexLink}\n<IndexLink to=\"/\"></IndexLink>\n// 还可以使用属性 onlyActiveOnIndex\n<Link to=\"/\" activeClassName=\"active\" onlyActiveOnIndex={true}>Home</Link>\n```\n### 8. 更好的地址browserHistory\n```javascript\n// 引入\nimport { browserHistory } from 'react-router'\n// 配置\n<Router history={browserHistory}>\n  {/* ... */}\n</Router>\n// 其他方面没有变化\n```\n\n### 9. 路由跳转\n```javascript\n// 使用browserHistory\nbrowserHistory.push(path)\n// 或者使用上下文 context\n\t// 定义对象\n\tcontextType: {\n\t\trouter: React.PropTypes.object\n\t},\n\t// 调用跳转\n\tthis.context.router.push(path)\n```\n\n### 10. 路由钩子\n每个路由都有Enter和Leave钩子，触发onEnter和onLeave。\n\nps:   \n　　[阮一峰老师](http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu)  \n　　[github](https://github.com/reactjs/react-router)","source":"_posts/React Router学习.md","raw":"---\ntitle: React Router学习\ndate: 2016-08-24\ntags: [JavaScript, React]\ncategories: \n- JavaScript\ncomments: true\n---\n\n### 0. 路由\n\n路由也就是地址，就是定义不同url访问不同页面的功能，可以实现导航、页面切换/跳转等功能。\n\n### 1. 引入\n```javascript \nimport { Router, Route, hashHistory } from 'react-router'\n```\n\n### 2. 配置\n```javascript\n<Router history={browserHistory}>\n\t<Route path=\"/\" component={Home}></Route>\n\t<Route path=\"article\" component={Article}></Route>\n</Router>\n```\n\n### 3. 通过Link实现跳转\n```javascript\n<Link to=\"/about\">About</Link>\n```\n\n### 4.1 路由嵌套(公用导航)\n```javascript\n// 路由配置\n<Router history={hashHistory}>\n  <Route path=\"/\" component={App}>\n    <Route path=\"/repos\" component={Repos}/>\n    <Route path=\"/about\" component={About}/>\n  </Route>\n</Router>\n// 页面配置(通过this.props.children调用)\n{this.props.children}\n```\n\n### 4.2 Active Links\n```javascript\n// 活动样式\n<Link to=\"/about\" activeStyle={{ color: 'red' }}>About</Link>\n// 或者 活动类名\n<li><Link to=\"/about\" activeClassName=\"active\">About</Link></li>\n```\n\n### 5. 传参\n```javascript\n// 配置\n// :userName表示匹配参数\n<Route path=\"/repos/:userName/:repoName\" component={Repo}/>\n// 跳转地址\n<Link to=\"/repos/reactjs/react-router\">React Router</Link>\n// 页面中访问参数\n{this.props.params.repoName}\n```\n\n### 6. 嵌套路由下的默认页\n```javascript\n// 需要引入react-router下的{IndexRoute}\n<Router history={hashHistory}>\n  <Route path=\"/\" component={App}>\n\n    {/* add it here, as a child of `/` */}\n    <IndexRoute component={Home}/>\n\n    <Route path=\"/repos\" component={Repos}>\n      <Route path=\"/repos/:userName/:repoName\" component={Repo}/>\n    </Route>\n    <Route path=\"/about\" component={About}/>\n  </Route>\n</Router>\n```\n\n### 7. 首页(默认页)路由地址\n```javascript\n// 直接使用Link to=\"/\"，会导致该链接总是active状态\n<Link to=\"/\"></Link>\n// 引入react-router下的{IndexLink}\n<IndexLink to=\"/\"></IndexLink>\n// 还可以使用属性 onlyActiveOnIndex\n<Link to=\"/\" activeClassName=\"active\" onlyActiveOnIndex={true}>Home</Link>\n```\n### 8. 更好的地址browserHistory\n```javascript\n// 引入\nimport { browserHistory } from 'react-router'\n// 配置\n<Router history={browserHistory}>\n  {/* ... */}\n</Router>\n// 其他方面没有变化\n```\n\n### 9. 路由跳转\n```javascript\n// 使用browserHistory\nbrowserHistory.push(path)\n// 或者使用上下文 context\n\t// 定义对象\n\tcontextType: {\n\t\trouter: React.PropTypes.object\n\t},\n\t// 调用跳转\n\tthis.context.router.push(path)\n```\n\n### 10. 路由钩子\n每个路由都有Enter和Leave钩子，触发onEnter和onLeave。\n\nps:   \n　　[阮一峰老师](http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu)  \n　　[github](https://github.com/reactjs/react-router)","slug":"React Router学习","published":1,"updated":"2017-12-28T03:47:32.455Z","layout":"post","photos":[],"link":"","_id":"cjks5i9i50013vmti3kw43zue","content":"<h3 id=\"0-路由\"><a href=\"#0-路由\" class=\"headerlink\" title=\"0. 路由\"></a>0. 路由</h3><p>路由也就是地址，就是定义不同url访问不同页面的功能，可以实现导航、页面切换/跳转等功能。</p>\n<h3 id=\"1-引入\"><a href=\"#1-引入\" class=\"headerlink\" title=\"1. 引入\"></a>1. 引入</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Router, Route, hashHistory &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Router history=&#123;browserHistory&#125;&gt;</span><br><span class=\"line\">\t&lt;Route path=<span class=\"string\">\"/\"</span> component=&#123;Home&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></span><br><span class=\"line\">\t&lt;Route path=<span class=\"string\">\"article\"</span> component=&#123;Article&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/Router&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-通过Link实现跳转\"><a href=\"#3-通过Link实现跳转\" class=\"headerlink\" title=\"3. 通过Link实现跳转\"></a>3. 通过Link实现跳转</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Link to=<span class=\"string\">\"/about\"</span>&gt;About&lt;<span class=\"regexp\">/Link&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-1-路由嵌套-公用导航\"><a href=\"#4-1-路由嵌套-公用导航\" class=\"headerlink\" title=\"4.1 路由嵌套(公用导航)\"></a>4.1 路由嵌套(公用导航)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 路由配置</span></span><br><span class=\"line\">&lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class=\"line\">  &lt;Route path=<span class=\"string\">\"/\"</span> component=&#123;App&#125;&gt;</span><br><span class=\"line\">    &lt;Route path=<span class=\"string\">\"/repos\"</span> component=&#123;Repos&#125;/&gt;</span><br><span class=\"line\">    &lt;Route path=<span class=\"string\">\"/about\"</span> component=&#123;About&#125;/&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Route&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>Router&gt;</span><br><span class=\"line\"><span class=\"comment\">// 页面配置(通过this.props.children调用)</span></span><br><span class=\"line\">&#123;<span class=\"keyword\">this</span>.props.children&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-Active-Links\"><a href=\"#4-2-Active-Links\" class=\"headerlink\" title=\"4.2 Active Links\"></a>4.2 Active Links</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 活动样式</span></span><br><span class=\"line\">&lt;Link to=<span class=\"string\">\"/about\"</span> activeStyle=&#123;&#123; <span class=\"attr\">color</span>: <span class=\"string\">'red'</span> &#125;&#125;&gt;About&lt;<span class=\"regexp\">/Link&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 或者 活动类名</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;li&gt;&lt;Link to=\"/</span>about<span class=\"string\">\" activeClassName=\"</span>active<span class=\"string\">\"&gt;About&lt;/Link&gt;&lt;/li&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"5-传参\"><a href=\"#5-传参\" class=\"headerlink\" title=\"5. 传参\"></a>5. 传参</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 配置</span></span><br><span class=\"line\"><span class=\"comment\">// :userName表示匹配参数</span></span><br><span class=\"line\">&lt;Route path=<span class=\"string\">\"/repos/:userName/:repoName\"</span> component=&#123;Repo&#125;/&gt;</span><br><span class=\"line\"><span class=\"comment\">// 跳转地址</span></span><br><span class=\"line\">&lt;Link to=<span class=\"string\">\"/repos/reactjs/react-router\"</span>&gt;React Router&lt;<span class=\"regexp\">/Link&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 页面中访问参数</span></span><br><span class=\"line\"><span class=\"regexp\">&#123;this.props.params.repoName&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6-嵌套路由下的默认页\"><a href=\"#6-嵌套路由下的默认页\" class=\"headerlink\" title=\"6. 嵌套路由下的默认页\"></a>6. 嵌套路由下的默认页</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需要引入react-router下的&#123;IndexRoute&#125;</span></span><br><span class=\"line\">&lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class=\"line\">  &lt;Route path=<span class=\"string\">\"/\"</span> component=&#123;App&#125;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;<span class=\"comment\">/* add it here, as a child of `/` */</span>&#125;</span><br><span class=\"line\">    &lt;IndexRoute component=&#123;Home&#125;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;Route path=<span class=\"string\">\"/repos\"</span> component=&#123;Repos&#125;&gt;</span><br><span class=\"line\">      &lt;Route path=<span class=\"string\">\"/repos/:userName/:repoName\"</span> component=&#123;Repo&#125;/&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/Route&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;Route path=\"/</span>about<span class=\"string\">\" component=&#123;About&#125;/&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/Route&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/Router&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-首页-默认页-路由地址\"><a href=\"#7-首页-默认页-路由地址\" class=\"headerlink\" title=\"7. 首页(默认页)路由地址\"></a>7. 首页(默认页)路由地址</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直接使用Link to=\"/\"，会导致该链接总是active状态</span></span><br><span class=\"line\">&lt;Link to=<span class=\"string\">\"/\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 引入react-router下的&#123;IndexLink&#125;</span></span><br><span class=\"line\">&lt;IndexLink to=<span class=\"string\">\"/\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">IndexLink</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 还可以使用属性 onlyActiveOnIndex</span></span><br><span class=\"line\">&lt;Link to=<span class=\"string\">\"/\"</span> activeClassName=<span class=\"string\">\"active\"</span> onlyActiveOnIndex=&#123;<span class=\"literal\">true</span>&#125;&gt;Home&lt;<span class=\"regexp\">/Link&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"8-更好的地址browserHistory\"><a href=\"#8-更好的地址browserHistory\" class=\"headerlink\" title=\"8. 更好的地址browserHistory\"></a>8. 更好的地址browserHistory</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; browserHistory &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router'</span></span><br><span class=\"line\"><span class=\"comment\">// 配置</span></span><br><span class=\"line\">&lt;Router history=&#123;browserHistory&#125;&gt;</span><br><span class=\"line\">  &#123;<span class=\"comment\">/* ... */</span>&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/Router&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 其他方面没有变化</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"9-路由跳转\"><a href=\"#9-路由跳转\" class=\"headerlink\" title=\"9. 路由跳转\"></a>9. 路由跳转</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用browserHistory</span></span><br><span class=\"line\">browserHistory.push(path)</span><br><span class=\"line\"><span class=\"comment\">// 或者使用上下文 context</span></span><br><span class=\"line\">\t<span class=\"comment\">// 定义对象</span></span><br><span class=\"line\">\tcontextType: &#123;</span><br><span class=\"line\">\t\trouter: React.PropTypes.object</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t<span class=\"comment\">// 调用跳转</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.context.router.push(path)</span><br></pre></td></tr></table></figure>\n<h3 id=\"10-路由钩子\"><a href=\"#10-路由钩子\" class=\"headerlink\" title=\"10. 路由钩子\"></a>10. 路由钩子</h3><p>每个路由都有Enter和Leave钩子，触发onEnter和onLeave。</p>\n<p>ps:<br>　　<a href=\"http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu\" target=\"_blank\" rel=\"noopener\">阮一峰老师</a><br>　　<a href=\"https://github.com/reactjs/react-router\" target=\"_blank\" rel=\"noopener\">github</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"0-路由\"><a href=\"#0-路由\" class=\"headerlink\" title=\"0. 路由\"></a>0. 路由</h3><p>路由也就是地址，就是定义不同url访问不同页面的功能，可以实现导航、页面切换/跳转等功能。</p>\n<h3 id=\"1-引入\"><a href=\"#1-引入\" class=\"headerlink\" title=\"1. 引入\"></a>1. 引入</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Router, Route, hashHistory &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Router history=&#123;browserHistory&#125;&gt;</span><br><span class=\"line\">\t&lt;Route path=<span class=\"string\">\"/\"</span> component=&#123;Home&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></span><br><span class=\"line\">\t&lt;Route path=<span class=\"string\">\"article\"</span> component=&#123;Article&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/Router&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-通过Link实现跳转\"><a href=\"#3-通过Link实现跳转\" class=\"headerlink\" title=\"3. 通过Link实现跳转\"></a>3. 通过Link实现跳转</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Link to=<span class=\"string\">\"/about\"</span>&gt;About&lt;<span class=\"regexp\">/Link&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-1-路由嵌套-公用导航\"><a href=\"#4-1-路由嵌套-公用导航\" class=\"headerlink\" title=\"4.1 路由嵌套(公用导航)\"></a>4.1 路由嵌套(公用导航)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 路由配置</span></span><br><span class=\"line\">&lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class=\"line\">  &lt;Route path=<span class=\"string\">\"/\"</span> component=&#123;App&#125;&gt;</span><br><span class=\"line\">    &lt;Route path=<span class=\"string\">\"/repos\"</span> component=&#123;Repos&#125;/&gt;</span><br><span class=\"line\">    &lt;Route path=<span class=\"string\">\"/about\"</span> component=&#123;About&#125;/&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Route&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>Router&gt;</span><br><span class=\"line\"><span class=\"comment\">// 页面配置(通过this.props.children调用)</span></span><br><span class=\"line\">&#123;<span class=\"keyword\">this</span>.props.children&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-Active-Links\"><a href=\"#4-2-Active-Links\" class=\"headerlink\" title=\"4.2 Active Links\"></a>4.2 Active Links</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 活动样式</span></span><br><span class=\"line\">&lt;Link to=<span class=\"string\">\"/about\"</span> activeStyle=&#123;&#123; <span class=\"attr\">color</span>: <span class=\"string\">'red'</span> &#125;&#125;&gt;About&lt;<span class=\"regexp\">/Link&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 或者 活动类名</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;li&gt;&lt;Link to=\"/</span>about<span class=\"string\">\" activeClassName=\"</span>active<span class=\"string\">\"&gt;About&lt;/Link&gt;&lt;/li&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"5-传参\"><a href=\"#5-传参\" class=\"headerlink\" title=\"5. 传参\"></a>5. 传参</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 配置</span></span><br><span class=\"line\"><span class=\"comment\">// :userName表示匹配参数</span></span><br><span class=\"line\">&lt;Route path=<span class=\"string\">\"/repos/:userName/:repoName\"</span> component=&#123;Repo&#125;/&gt;</span><br><span class=\"line\"><span class=\"comment\">// 跳转地址</span></span><br><span class=\"line\">&lt;Link to=<span class=\"string\">\"/repos/reactjs/react-router\"</span>&gt;React Router&lt;<span class=\"regexp\">/Link&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 页面中访问参数</span></span><br><span class=\"line\"><span class=\"regexp\">&#123;this.props.params.repoName&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6-嵌套路由下的默认页\"><a href=\"#6-嵌套路由下的默认页\" class=\"headerlink\" title=\"6. 嵌套路由下的默认页\"></a>6. 嵌套路由下的默认页</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需要引入react-router下的&#123;IndexRoute&#125;</span></span><br><span class=\"line\">&lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class=\"line\">  &lt;Route path=<span class=\"string\">\"/\"</span> component=&#123;App&#125;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;<span class=\"comment\">/* add it here, as a child of `/` */</span>&#125;</span><br><span class=\"line\">    &lt;IndexRoute component=&#123;Home&#125;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;Route path=<span class=\"string\">\"/repos\"</span> component=&#123;Repos&#125;&gt;</span><br><span class=\"line\">      &lt;Route path=<span class=\"string\">\"/repos/:userName/:repoName\"</span> component=&#123;Repo&#125;/&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/Route&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;Route path=\"/</span>about<span class=\"string\">\" component=&#123;About&#125;/&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/Route&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/Router&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-首页-默认页-路由地址\"><a href=\"#7-首页-默认页-路由地址\" class=\"headerlink\" title=\"7. 首页(默认页)路由地址\"></a>7. 首页(默认页)路由地址</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直接使用Link to=\"/\"，会导致该链接总是active状态</span></span><br><span class=\"line\">&lt;Link to=<span class=\"string\">\"/\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 引入react-router下的&#123;IndexLink&#125;</span></span><br><span class=\"line\">&lt;IndexLink to=<span class=\"string\">\"/\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">IndexLink</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 还可以使用属性 onlyActiveOnIndex</span></span><br><span class=\"line\">&lt;Link to=<span class=\"string\">\"/\"</span> activeClassName=<span class=\"string\">\"active\"</span> onlyActiveOnIndex=&#123;<span class=\"literal\">true</span>&#125;&gt;Home&lt;<span class=\"regexp\">/Link&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"8-更好的地址browserHistory\"><a href=\"#8-更好的地址browserHistory\" class=\"headerlink\" title=\"8. 更好的地址browserHistory\"></a>8. 更好的地址browserHistory</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; browserHistory &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router'</span></span><br><span class=\"line\"><span class=\"comment\">// 配置</span></span><br><span class=\"line\">&lt;Router history=&#123;browserHistory&#125;&gt;</span><br><span class=\"line\">  &#123;<span class=\"comment\">/* ... */</span>&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/Router&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 其他方面没有变化</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"9-路由跳转\"><a href=\"#9-路由跳转\" class=\"headerlink\" title=\"9. 路由跳转\"></a>9. 路由跳转</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用browserHistory</span></span><br><span class=\"line\">browserHistory.push(path)</span><br><span class=\"line\"><span class=\"comment\">// 或者使用上下文 context</span></span><br><span class=\"line\">\t<span class=\"comment\">// 定义对象</span></span><br><span class=\"line\">\tcontextType: &#123;</span><br><span class=\"line\">\t\trouter: React.PropTypes.object</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t<span class=\"comment\">// 调用跳转</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.context.router.push(path)</span><br></pre></td></tr></table></figure>\n<h3 id=\"10-路由钩子\"><a href=\"#10-路由钩子\" class=\"headerlink\" title=\"10. 路由钩子\"></a>10. 路由钩子</h3><p>每个路由都有Enter和Leave钩子，触发onEnter和onLeave。</p>\n<p>ps:<br>　　<a href=\"http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu\" target=\"_blank\" rel=\"noopener\">阮一峰老师</a><br>　　<a href=\"https://github.com/reactjs/react-router\" target=\"_blank\" rel=\"noopener\">github</a></p>\n"},{"title":"RxJS入门","date":"2018-02-12T16:00:00.000Z","comments":1,"_content":"\n### RxJS\n\n定义： 通过使用observable序列来编写异步和基于事件的程序\n\n核心思想： 函数式编程 + 响应式编程\n\n#### 原因\n\n* Reactive Programming的兴起\n\n* Observable标准化\n\n* 多语言支持\n\n#### 解决的问题（异步带来的问题）\n\n* 竞态条件\n\n* 内存泄露\n\n* 复杂的状态\n\n* 异常处理\n\n* ps: 统一API\n\n#### 函数式编程\n\n* 条件： 函数是一等公民\n\n```JavaScript\n// 可以被赋值\nvar sayHello = function () {\n  console.log('hello')\n}\n// 可以当做参数\ndocument.getElementById('a').click(sayHello)\n// 可以被函数返回\nfunction getFunc () {\n  return function (content) {\n    console.log(content)\n  }\n}\n```\n\n* 纯函数\n\n```JavaScript\n// 非纯函数（有副作用）\nfunction addArray (array, item) {\n  array.push(item)\n  return array\n}\n// 非纯函数（依赖外部变量）\nlet array = [1, 2, 3]\nfunction addArray(item) {\n  let result = []\n  result.push(...array)\n  result.push(item)\n  return result\n}\n// 纯函数（创建了变量，开辟了新的内存空间，也是副作用，所以要柯里化）\nfunction addArray (array, item) {\n  let result = []\n  result.push(...array)\n  result.push(item)\n  return result\n}\n```\n\n#### 观察者模式（生产者推送数据）\n\n```JavaScript\nclass Producer {\n\n  constructor() {\n    this.listeners = []\n  }\n\n  addListener(listener) {\n    if(typeof listener === 'function') {\n      this.listeners.push(listener)\n    } else {\n      throw new Error('listener必须是function')\n    }\n  }\n\n  removeListener(listener) {\n    this.listeners.splice(this.listeners.indexOf(listener), 1)\n  }\n\n  notify(message) {\n    this.listeners.forEach(listener => {\n      listener(message)\n    })\n  }\n}\n```\n\n#### 迭代器模式（消费者拉取数据）\n\n```JavaScript\nclass IteratorFromArray {\n  \n  constructor(arr) {\n    this._array = arr\n    this._cursor = 0\n  }\n  \n  next() {\n    return this._cursor < this._array.length ? \n      {\n        value: this._array[this._cursor++],\n        done: false \n      } : { done: true }\n  }\n}\n```\n\nps:\n\n| |单个值|多个值|\n|:----:|:----:|:----:|\n|拉取|Function|Iterator|\n|推送|Promise|Observable|\n\nObservable具备生产者推送数据的能力，又拥有序列处理数据的方法\n\n#### Observable\n\n```JavaScript\n// 声明一个可观察对象\nvar observable = Rx.Observable\n  .create(function(observer) {\n    observer.next('Hello')\n    observer.next('World')\n    observer.complete()\n    observer.next('not work')\n  })\n  \n// 声明一个观察者，具备next、error、complete方法\nvar observer = {\n  next: function(value) {\n    console.log(value)\n  },\n  error: function(error) {\n    console.log(error)\n  },\n  complete: function() {\n    console.log('complete')\n  }\n}\n\n// 用观察者订阅可观察对象\nobservable.subscribe(observer)\n```\n\n#### Observable实现细节\n\n```JavaScript\nfunction subscribe(observer) {\n    observer.next('Hello')\n    observer.next('World')\n}\n\nsubscribe({\n  next: function(value) {\n    console.log(value)\n  },\n  error: function(error) {\n    console.log(error)\n  },\n  complete: function() {\n    console.log('complete')\n  }\n})\n```\n\n#### 操作符\n\n* 创建操作符、转换操作符、过滤操作符、组合操作符、多播操作符、错误处理操作符、工具操作符、条件和布尔操作符、数学和聚合操作符\n\n```JavaScript\nvar people = Rx.Observable.of('World', 'China')\n\nfunction map(source, callback) {\n  // 返回new Observable对象\n  return Rx.Observable.create((observer) => {\n    // 订阅原本的Observable对象\n    return source.subscribe(\n      (value) => { \n        try{\n          observer.next(callback(value))\n        } catch(e) {\n          observer.error(e)\n        }\n      },\n      (err) => { observer.error(err) },\n      () => { observer.complete() }\n    )\n  })\n}\n\nvar helloPeople = map(people, (item) => ' Hello~' + item)\n\nhelloPeople.subscribe(console.log)\n```\n\n#### Subject\n\n```JavaScript\nvar source = Rx.Observable.interval(1000).take(3)\n\nvar observerA = {\n  next: value => console.log('A next: ' + value),\n\n  error: error => console.log('A error: ' + error),\n\n  complete: () => console.log('A complete!')\n}\n\nvar observerB = {\n  next: value => console.log('B next: ' + value),\n\n  error: error => console.log('B error: ' + error),\n\n  complete: () => console.log('B complete!')\n}\n\nvar subject = {\n  observers: [],\n\n  addObserver: function(observer) {\n    this.observers.push(observer)\n  },\n\n  next: function(value) {\n    this.observers.forEach(o => o.next(value))    \n  },\n\n  error: function(error){\n    this.observers.forEach(o => o.error(error))\n  },\n\n  complete: function() {\n    this.observers.forEach(o => o.complete())\n  }\n}\n\nsubject.addObserver(observerA)\n\nsource.subscribe(subject)\n\nsubject.addObserver(observerB)\n```\n\n* Subject同时是Observable又是Observer\n\n* Subject会对内部的observers数组进行组播\n\n\n","source":"_posts/RxJS.md","raw":"---\ntitle: RxJS入门\ndate: 2018-02-13\ntags: [JavaScript]\ncategories:\n- JavaScript\ncomments: true\n---\n\n### RxJS\n\n定义： 通过使用observable序列来编写异步和基于事件的程序\n\n核心思想： 函数式编程 + 响应式编程\n\n#### 原因\n\n* Reactive Programming的兴起\n\n* Observable标准化\n\n* 多语言支持\n\n#### 解决的问题（异步带来的问题）\n\n* 竞态条件\n\n* 内存泄露\n\n* 复杂的状态\n\n* 异常处理\n\n* ps: 统一API\n\n#### 函数式编程\n\n* 条件： 函数是一等公民\n\n```JavaScript\n// 可以被赋值\nvar sayHello = function () {\n  console.log('hello')\n}\n// 可以当做参数\ndocument.getElementById('a').click(sayHello)\n// 可以被函数返回\nfunction getFunc () {\n  return function (content) {\n    console.log(content)\n  }\n}\n```\n\n* 纯函数\n\n```JavaScript\n// 非纯函数（有副作用）\nfunction addArray (array, item) {\n  array.push(item)\n  return array\n}\n// 非纯函数（依赖外部变量）\nlet array = [1, 2, 3]\nfunction addArray(item) {\n  let result = []\n  result.push(...array)\n  result.push(item)\n  return result\n}\n// 纯函数（创建了变量，开辟了新的内存空间，也是副作用，所以要柯里化）\nfunction addArray (array, item) {\n  let result = []\n  result.push(...array)\n  result.push(item)\n  return result\n}\n```\n\n#### 观察者模式（生产者推送数据）\n\n```JavaScript\nclass Producer {\n\n  constructor() {\n    this.listeners = []\n  }\n\n  addListener(listener) {\n    if(typeof listener === 'function') {\n      this.listeners.push(listener)\n    } else {\n      throw new Error('listener必须是function')\n    }\n  }\n\n  removeListener(listener) {\n    this.listeners.splice(this.listeners.indexOf(listener), 1)\n  }\n\n  notify(message) {\n    this.listeners.forEach(listener => {\n      listener(message)\n    })\n  }\n}\n```\n\n#### 迭代器模式（消费者拉取数据）\n\n```JavaScript\nclass IteratorFromArray {\n  \n  constructor(arr) {\n    this._array = arr\n    this._cursor = 0\n  }\n  \n  next() {\n    return this._cursor < this._array.length ? \n      {\n        value: this._array[this._cursor++],\n        done: false \n      } : { done: true }\n  }\n}\n```\n\nps:\n\n| |单个值|多个值|\n|:----:|:----:|:----:|\n|拉取|Function|Iterator|\n|推送|Promise|Observable|\n\nObservable具备生产者推送数据的能力，又拥有序列处理数据的方法\n\n#### Observable\n\n```JavaScript\n// 声明一个可观察对象\nvar observable = Rx.Observable\n  .create(function(observer) {\n    observer.next('Hello')\n    observer.next('World')\n    observer.complete()\n    observer.next('not work')\n  })\n  \n// 声明一个观察者，具备next、error、complete方法\nvar observer = {\n  next: function(value) {\n    console.log(value)\n  },\n  error: function(error) {\n    console.log(error)\n  },\n  complete: function() {\n    console.log('complete')\n  }\n}\n\n// 用观察者订阅可观察对象\nobservable.subscribe(observer)\n```\n\n#### Observable实现细节\n\n```JavaScript\nfunction subscribe(observer) {\n    observer.next('Hello')\n    observer.next('World')\n}\n\nsubscribe({\n  next: function(value) {\n    console.log(value)\n  },\n  error: function(error) {\n    console.log(error)\n  },\n  complete: function() {\n    console.log('complete')\n  }\n})\n```\n\n#### 操作符\n\n* 创建操作符、转换操作符、过滤操作符、组合操作符、多播操作符、错误处理操作符、工具操作符、条件和布尔操作符、数学和聚合操作符\n\n```JavaScript\nvar people = Rx.Observable.of('World', 'China')\n\nfunction map(source, callback) {\n  // 返回new Observable对象\n  return Rx.Observable.create((observer) => {\n    // 订阅原本的Observable对象\n    return source.subscribe(\n      (value) => { \n        try{\n          observer.next(callback(value))\n        } catch(e) {\n          observer.error(e)\n        }\n      },\n      (err) => { observer.error(err) },\n      () => { observer.complete() }\n    )\n  })\n}\n\nvar helloPeople = map(people, (item) => ' Hello~' + item)\n\nhelloPeople.subscribe(console.log)\n```\n\n#### Subject\n\n```JavaScript\nvar source = Rx.Observable.interval(1000).take(3)\n\nvar observerA = {\n  next: value => console.log('A next: ' + value),\n\n  error: error => console.log('A error: ' + error),\n\n  complete: () => console.log('A complete!')\n}\n\nvar observerB = {\n  next: value => console.log('B next: ' + value),\n\n  error: error => console.log('B error: ' + error),\n\n  complete: () => console.log('B complete!')\n}\n\nvar subject = {\n  observers: [],\n\n  addObserver: function(observer) {\n    this.observers.push(observer)\n  },\n\n  next: function(value) {\n    this.observers.forEach(o => o.next(value))    \n  },\n\n  error: function(error){\n    this.observers.forEach(o => o.error(error))\n  },\n\n  complete: function() {\n    this.observers.forEach(o => o.complete())\n  }\n}\n\nsubject.addObserver(observerA)\n\nsource.subscribe(subject)\n\nsubject.addObserver(observerB)\n```\n\n* Subject同时是Observable又是Observer\n\n* Subject会对内部的observers数组进行组播\n\n\n","slug":"RxJS","published":1,"updated":"2018-02-11T06:28:53.616Z","layout":"post","photos":[],"link":"","_id":"cjks5i9i70017vmti85wndpnx","content":"<h3 id=\"RxJS\"><a href=\"#RxJS\" class=\"headerlink\" title=\"RxJS\"></a>RxJS</h3><p>定义： 通过使用observable序列来编写异步和基于事件的程序</p>\n<p>核心思想： 函数式编程 + 响应式编程</p>\n<h4 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h4><ul>\n<li><p>Reactive Programming的兴起</p>\n</li>\n<li><p>Observable标准化</p>\n</li>\n<li><p>多语言支持</p>\n</li>\n</ul>\n<h4 id=\"解决的问题（异步带来的问题）\"><a href=\"#解决的问题（异步带来的问题）\" class=\"headerlink\" title=\"解决的问题（异步带来的问题）\"></a>解决的问题（异步带来的问题）</h4><ul>\n<li><p>竞态条件</p>\n</li>\n<li><p>内存泄露</p>\n</li>\n<li><p>复杂的状态</p>\n</li>\n<li><p>异常处理</p>\n</li>\n<li><p>ps: 统一API</p>\n</li>\n</ul>\n<h4 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h4><ul>\n<li>条件： 函数是一等公民</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以被赋值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sayHello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 可以当做参数</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'a'</span>).click(sayHello)</span><br><span class=\"line\"><span class=\"comment\">// 可以被函数返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFunc</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(content)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>纯函数</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 非纯函数（有副作用）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addArray</span> (<span class=\"params\">array, item</span>) </span>&#123;</span><br><span class=\"line\">  array.push(item)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 非纯函数（依赖外部变量）</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addArray</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = []</span><br><span class=\"line\">  result.push(...array)</span><br><span class=\"line\">  result.push(item)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 纯函数（创建了变量，开辟了新的内存空间，也是副作用，所以要柯里化）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addArray</span> (<span class=\"params\">array, item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = []</span><br><span class=\"line\">  result.push(...array)</span><br><span class=\"line\">  result.push(item)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"观察者模式（生产者推送数据）\"><a href=\"#观察者模式（生产者推送数据）\" class=\"headerlink\" title=\"观察者模式（生产者推送数据）\"></a>观察者模式（生产者推送数据）</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.listeners = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  addListener(listener) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> listener === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.listeners.push(listener)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'listener必须是function'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  removeListener(listener) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.listeners.splice(<span class=\"keyword\">this</span>.listeners.indexOf(listener), <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  notify(message) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.listeners.forEach(<span class=\"function\"><span class=\"params\">listener</span> =&gt;</span> &#123;</span><br><span class=\"line\">      listener(message)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"迭代器模式（消费者拉取数据）\"><a href=\"#迭代器模式（消费者拉取数据）\" class=\"headerlink\" title=\"迭代器模式（消费者拉取数据）\"></a>迭代器模式（消费者拉取数据）</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IteratorFromArray</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(arr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._array = arr</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._cursor = <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  next() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._cursor &lt; <span class=\"keyword\">this</span>._array.length ? </span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        value: <span class=\"keyword\">this</span>._array[<span class=\"keyword\">this</span>._cursor++],</span><br><span class=\"line\">        done: <span class=\"literal\">false</span> </span><br><span class=\"line\">      &#125; : &#123; <span class=\"attr\">done</span>: <span class=\"literal\">true</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ps:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">单个值</th>\n<th style=\"text-align:center\">多个值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">拉取</td>\n<td style=\"text-align:center\">Function</td>\n<td style=\"text-align:center\">Iterator</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">推送</td>\n<td style=\"text-align:center\">Promise</td>\n<td style=\"text-align:center\">Observable</td>\n</tr>\n</tbody>\n</table>\n<p>Observable具备生产者推送数据的能力，又拥有序列处理数据的方法</p>\n<h4 id=\"Observable\"><a href=\"#Observable\" class=\"headerlink\" title=\"Observable\"></a>Observable</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明一个可观察对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> observable = Rx.Observable</span><br><span class=\"line\">  .create(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">observer</span>) </span>&#123;</span><br><span class=\"line\">    observer.next(<span class=\"string\">'Hello'</span>)</span><br><span class=\"line\">    observer.next(<span class=\"string\">'World'</span>)</span><br><span class=\"line\">    observer.complete()</span><br><span class=\"line\">    observer.next(<span class=\"string\">'not work'</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 声明一个观察者，具备next、error、complete方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> observer = &#123;</span><br><span class=\"line\">  next: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  error: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  complete: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'complete'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用观察者订阅可观察对象</span></span><br><span class=\"line\">observable.subscribe(observer)</span><br></pre></td></tr></table></figure>\n<h4 id=\"Observable实现细节\"><a href=\"#Observable实现细节\" class=\"headerlink\" title=\"Observable实现细节\"></a>Observable实现细节</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span>(<span class=\"params\">observer</span>) </span>&#123;</span><br><span class=\"line\">    observer.next(<span class=\"string\">'Hello'</span>)</span><br><span class=\"line\">    observer.next(<span class=\"string\">'World'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">subscribe(&#123;</span><br><span class=\"line\">  next: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  error: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  complete: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'complete'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h4><ul>\n<li>创建操作符、转换操作符、过滤操作符、组合操作符、多播操作符、错误处理操作符、工具操作符、条件和布尔操作符、数学和聚合操作符</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> people = Rx.Observable.of(<span class=\"string\">'World'</span>, <span class=\"string\">'China'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">map</span>(<span class=\"params\">source, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 返回new Observable对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> Rx.Observable.create(<span class=\"function\">(<span class=\"params\">observer</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 订阅原本的Observable对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> source.subscribe(</span><br><span class=\"line\">      (value) =&gt; &#123; </span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">          observer.next(callback(value))</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">          observer.error(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      (err) =&gt; &#123; observer.error(err) &#125;,</span><br><span class=\"line\">      () =&gt; &#123; observer.complete() &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> helloPeople = map(people, (item) =&gt; <span class=\"string\">' Hello~'</span> + item)</span><br><span class=\"line\"></span><br><span class=\"line\">helloPeople.subscribe(<span class=\"built_in\">console</span>.log)</span><br></pre></td></tr></table></figure>\n<h4 id=\"Subject\"><a href=\"#Subject\" class=\"headerlink\" title=\"Subject\"></a>Subject</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> source = Rx.Observable.interval(<span class=\"number\">1000</span>).take(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> observerA = &#123;</span><br><span class=\"line\">  next: <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'A next: '</span> + value),</span><br><span class=\"line\"></span><br><span class=\"line\">  error: <span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'A error: '</span> + error),</span><br><span class=\"line\"></span><br><span class=\"line\">  complete: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'A complete!'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> observerB = &#123;</span><br><span class=\"line\">  next: <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'B next: '</span> + value),</span><br><span class=\"line\"></span><br><span class=\"line\">  error: <span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'B error: '</span> + error),</span><br><span class=\"line\"></span><br><span class=\"line\">  complete: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'B complete!'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> subject = &#123;</span><br><span class=\"line\">  observers: [],</span><br><span class=\"line\"></span><br><span class=\"line\">  addObserver: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">observer</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.observers.push(observer)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  next: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.observers.forEach(<span class=\"function\"><span class=\"params\">o</span> =&gt;</span> o.next(value))    </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  error: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.observers.forEach(<span class=\"function\"><span class=\"params\">o</span> =&gt;</span> o.error(error))</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  complete: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.observers.forEach(<span class=\"function\"><span class=\"params\">o</span> =&gt;</span> o.complete())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">subject.addObserver(observerA)</span><br><span class=\"line\"></span><br><span class=\"line\">source.subscribe(subject)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.addObserver(observerB)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>Subject同时是Observable又是Observer</p>\n</li>\n<li><p>Subject会对内部的observers数组进行组播</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"RxJS\"><a href=\"#RxJS\" class=\"headerlink\" title=\"RxJS\"></a>RxJS</h3><p>定义： 通过使用observable序列来编写异步和基于事件的程序</p>\n<p>核心思想： 函数式编程 + 响应式编程</p>\n<h4 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h4><ul>\n<li><p>Reactive Programming的兴起</p>\n</li>\n<li><p>Observable标准化</p>\n</li>\n<li><p>多语言支持</p>\n</li>\n</ul>\n<h4 id=\"解决的问题（异步带来的问题）\"><a href=\"#解决的问题（异步带来的问题）\" class=\"headerlink\" title=\"解决的问题（异步带来的问题）\"></a>解决的问题（异步带来的问题）</h4><ul>\n<li><p>竞态条件</p>\n</li>\n<li><p>内存泄露</p>\n</li>\n<li><p>复杂的状态</p>\n</li>\n<li><p>异常处理</p>\n</li>\n<li><p>ps: 统一API</p>\n</li>\n</ul>\n<h4 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h4><ul>\n<li>条件： 函数是一等公民</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以被赋值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sayHello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 可以当做参数</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'a'</span>).click(sayHello)</span><br><span class=\"line\"><span class=\"comment\">// 可以被函数返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFunc</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(content)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>纯函数</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 非纯函数（有副作用）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addArray</span> (<span class=\"params\">array, item</span>) </span>&#123;</span><br><span class=\"line\">  array.push(item)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 非纯函数（依赖外部变量）</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addArray</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = []</span><br><span class=\"line\">  result.push(...array)</span><br><span class=\"line\">  result.push(item)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 纯函数（创建了变量，开辟了新的内存空间，也是副作用，所以要柯里化）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addArray</span> (<span class=\"params\">array, item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = []</span><br><span class=\"line\">  result.push(...array)</span><br><span class=\"line\">  result.push(item)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"观察者模式（生产者推送数据）\"><a href=\"#观察者模式（生产者推送数据）\" class=\"headerlink\" title=\"观察者模式（生产者推送数据）\"></a>观察者模式（生产者推送数据）</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.listeners = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  addListener(listener) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> listener === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.listeners.push(listener)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'listener必须是function'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  removeListener(listener) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.listeners.splice(<span class=\"keyword\">this</span>.listeners.indexOf(listener), <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  notify(message) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.listeners.forEach(<span class=\"function\"><span class=\"params\">listener</span> =&gt;</span> &#123;</span><br><span class=\"line\">      listener(message)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"迭代器模式（消费者拉取数据）\"><a href=\"#迭代器模式（消费者拉取数据）\" class=\"headerlink\" title=\"迭代器模式（消费者拉取数据）\"></a>迭代器模式（消费者拉取数据）</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IteratorFromArray</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(arr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._array = arr</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._cursor = <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  next() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._cursor &lt; <span class=\"keyword\">this</span>._array.length ? </span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        value: <span class=\"keyword\">this</span>._array[<span class=\"keyword\">this</span>._cursor++],</span><br><span class=\"line\">        done: <span class=\"literal\">false</span> </span><br><span class=\"line\">      &#125; : &#123; <span class=\"attr\">done</span>: <span class=\"literal\">true</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ps:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">单个值</th>\n<th style=\"text-align:center\">多个值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">拉取</td>\n<td style=\"text-align:center\">Function</td>\n<td style=\"text-align:center\">Iterator</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">推送</td>\n<td style=\"text-align:center\">Promise</td>\n<td style=\"text-align:center\">Observable</td>\n</tr>\n</tbody>\n</table>\n<p>Observable具备生产者推送数据的能力，又拥有序列处理数据的方法</p>\n<h4 id=\"Observable\"><a href=\"#Observable\" class=\"headerlink\" title=\"Observable\"></a>Observable</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明一个可观察对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> observable = Rx.Observable</span><br><span class=\"line\">  .create(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">observer</span>) </span>&#123;</span><br><span class=\"line\">    observer.next(<span class=\"string\">'Hello'</span>)</span><br><span class=\"line\">    observer.next(<span class=\"string\">'World'</span>)</span><br><span class=\"line\">    observer.complete()</span><br><span class=\"line\">    observer.next(<span class=\"string\">'not work'</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 声明一个观察者，具备next、error、complete方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> observer = &#123;</span><br><span class=\"line\">  next: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  error: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  complete: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'complete'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用观察者订阅可观察对象</span></span><br><span class=\"line\">observable.subscribe(observer)</span><br></pre></td></tr></table></figure>\n<h4 id=\"Observable实现细节\"><a href=\"#Observable实现细节\" class=\"headerlink\" title=\"Observable实现细节\"></a>Observable实现细节</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span>(<span class=\"params\">observer</span>) </span>&#123;</span><br><span class=\"line\">    observer.next(<span class=\"string\">'Hello'</span>)</span><br><span class=\"line\">    observer.next(<span class=\"string\">'World'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">subscribe(&#123;</span><br><span class=\"line\">  next: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  error: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  complete: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'complete'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h4><ul>\n<li>创建操作符、转换操作符、过滤操作符、组合操作符、多播操作符、错误处理操作符、工具操作符、条件和布尔操作符、数学和聚合操作符</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> people = Rx.Observable.of(<span class=\"string\">'World'</span>, <span class=\"string\">'China'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">map</span>(<span class=\"params\">source, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 返回new Observable对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> Rx.Observable.create(<span class=\"function\">(<span class=\"params\">observer</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 订阅原本的Observable对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> source.subscribe(</span><br><span class=\"line\">      (value) =&gt; &#123; </span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">          observer.next(callback(value))</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">          observer.error(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      (err) =&gt; &#123; observer.error(err) &#125;,</span><br><span class=\"line\">      () =&gt; &#123; observer.complete() &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> helloPeople = map(people, (item) =&gt; <span class=\"string\">' Hello~'</span> + item)</span><br><span class=\"line\"></span><br><span class=\"line\">helloPeople.subscribe(<span class=\"built_in\">console</span>.log)</span><br></pre></td></tr></table></figure>\n<h4 id=\"Subject\"><a href=\"#Subject\" class=\"headerlink\" title=\"Subject\"></a>Subject</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> source = Rx.Observable.interval(<span class=\"number\">1000</span>).take(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> observerA = &#123;</span><br><span class=\"line\">  next: <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'A next: '</span> + value),</span><br><span class=\"line\"></span><br><span class=\"line\">  error: <span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'A error: '</span> + error),</span><br><span class=\"line\"></span><br><span class=\"line\">  complete: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'A complete!'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> observerB = &#123;</span><br><span class=\"line\">  next: <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'B next: '</span> + value),</span><br><span class=\"line\"></span><br><span class=\"line\">  error: <span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'B error: '</span> + error),</span><br><span class=\"line\"></span><br><span class=\"line\">  complete: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'B complete!'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> subject = &#123;</span><br><span class=\"line\">  observers: [],</span><br><span class=\"line\"></span><br><span class=\"line\">  addObserver: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">observer</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.observers.push(observer)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  next: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.observers.forEach(<span class=\"function\"><span class=\"params\">o</span> =&gt;</span> o.next(value))    </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  error: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.observers.forEach(<span class=\"function\"><span class=\"params\">o</span> =&gt;</span> o.error(error))</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  complete: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.observers.forEach(<span class=\"function\"><span class=\"params\">o</span> =&gt;</span> o.complete())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">subject.addObserver(observerA)</span><br><span class=\"line\"></span><br><span class=\"line\">source.subscribe(subject)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.addObserver(observerB)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>Subject同时是Observable又是Observer</p>\n</li>\n<li><p>Subject会对内部的observers数组进行组播</p>\n</li>\n</ul>\n"},{"title":"RxJS文档划重点","date":"2018-02-10T16:00:00.000Z","comments":1,"_content":"\n### 基本概念\n\n* RxJS的基本概念： Observable(可观察对象)，Observer(观察者)，Subscription(订阅者)，Operators(操作符)，Subject(主体)，Schedulers(调度器)\n\n* 订阅Observable类似于调用函数\n\n* Observable和函数的区别主要是Observable可以“返回”多个值，可以是同步也可以是异步\n\n### Observable(可观察对象)\n\n* Observable核心关注点：创建、订阅、执行、清理\n\n* 创建： `Rx.Observable.create(function subscribe(observer) {...})`。Rx.Observable.create 是 Observable 构造函数的别名，它接收一个参数：subscribe 函数\n\n* 订阅： `observable.subscribe(data => {...})`\n\n* 执行： 创建中的`function subscribe(observer) {...}`中的...表示要执行的代码，订阅才会被执行。执行可以传递三种类型的值next、error、complete\n\n* 清理： 订阅会返回一个subscription，通过`subscription.unsubscribe()`可以清理执行\n\n### Observer(观察者)\n\n* 观察者是由Observable发送的值的消费者（订阅中的回调方法）\n\n* 观察者只是一组回调函数的集合，包括next、error、complete\n\n* 观察者的使用： 将提供给Observable的subscribe方法`observable.subscribe(observer)`\n\n* 参数可以传递为{next?: Function, error?: Function, complete?: Function}对象形式，也可以为fun1, func2, func3多个参数形式\n\n### Subscription(订阅者)\n\n* Subscription是表示可清理资源的对象，主要用来执行unsubscribe\n\n* 通过add、remove方法可以组合多个Subscription用于一起执行unsubscribe\n\n### Subject(主体)\n\n* Subject是一种特殊类型的Observable，它允许将值多播给多个观察者\n\n* BehaviorSubject会保存了发送给消费者的最新值。并且当有新的观察者订阅时，会立即从 BehaviorSubject那接收到“当前值”\n\n```JavaScript\n  var subject = new Rx.BehaviorSubject(0) // 0是初始值\n  subject.subscribe({\n    next: (v) => console.log('observerA: ' + v)\n  })\n  subject.next(1)\n  subject.next(2)\n  subject.subscribe({\n    next: (v) => console.log('observerB: ' + v)\n  })\n  subject.next(3)\n  // 输出\n  observerA: 0 // 初始化0立即发送给了新的订阅A\n  observerA: 1\n  observerA: 2\n  observerB: 2 // 保存的2会立即发送给了新的订阅B\n  observerA: 3\n  observerB: 3\n```\n\n* ReplaySubject可以发送旧值给新的观察者订阅（创建时指定缓存数量和缓存时间）\n\n```JavaScript\n  var subject = new Rx.ReplaySubject(3) // 为新的订阅者缓冲3个值\n  subject.subscribe({\n    next: (v) => console.log('observerA: ' + v)\n  })\n  subject.next(1)\n  subject.next(2)\n  subject.next(3)\n  subject.next(4)\n  subject.subscribe({\n    next: (v) => console.log('observerB: ' + v)\n  })\n  subject.next(5)\n  // 输出\n  observerA: 1\n  observerA: 2\n  observerA: 3\n  observerA: 4\n  observerB: 2 // 缓存中的2、3、4被发送给订阅B\n  observerB: 3\n  observerB: 4\n  observerA: 5\n  observerB: 5\n```\n\n* AsyncSubject只有当 Observable执行完成时(执行了complete())，它才会将执行的最后一个值（上一个next）发送给观察者\n\n### 操作符\n\n* 操作符是Observable类型上的方法，是纯函数产生新的Observable，订阅输出Observalbe 同样会订阅输入Observable\n\n### Scheduler(调度器)\n\n* 调度器控制着何时启动subscription和何时发送通知\n\n* 调度器类型主要包括null、Rx.Scheduler.queue、Rx.Scheduler.asap、Rx.Scheduler.async\n\n* 如果没有提供调度器，会通过使用最小并发原则选择一个默认调度器\n\n* 使用subscribeOn来调度subscribe()调用在什么样的上下文中执行\n\n* 使用observeOn来调度发送通知的的上下文\n\n### 其他\n\nSubject和Observable一个疑问\n\n```javascript\n// Subject\nconst subject = new Rx.Subject()\nlet sub1 = null\nlet sub2 = null\nfunction a () {\n  sub1 = subject.subscribe({\n    next: v => console.log('a: ' + v)\n  })\n  subject.next(1)\n}\nfunction b () {\n  sub2 = subject.subscribe({\n    next: (v) => console.log('b: ' + v)\n  })\n  subject.next(2)\n  subject.complete()\n  sub1.next(3) // 不会被订阅到\n}\na()\nb()\n\n// Observable\nlet obs = null\n\nconst observable = Rx.Observable.create(function (observer) {\n  obs = observer\n  observer.next(1)\n  observer.next(2)\n  observer.next(3)\n})\n\nconst a = observable.subscribe({\n  next: x => console.log('a ' + x),\n  error: err => console.error('a: ' + err),\n  complete: () => console.log('a done')\n})\n\nconst b = observable.subscribe({\n  next: x => console.log('b ' + x),\n  error: err => console.error('b: ' + err),\n  complete: () => console.log('b done')\n})\n\nobs.complete() // 只会调用到b中的complete，输出b done\nobs.next(4) // a、b都不会订阅执行到\na.next(5) // a会执行订阅\nb.next(5) // b不会执行订阅\na.complete() // 输出a done\na.next(6) // 不会执行订阅\n```","source":"_posts/RxJS文档划重点.md","raw":"---\ntitle: RxJS文档划重点\ndate: 2018-02-11\ntags: [JavaScript]\ncategories:\n- JavaScript\ncomments: true\n---\n\n### 基本概念\n\n* RxJS的基本概念： Observable(可观察对象)，Observer(观察者)，Subscription(订阅者)，Operators(操作符)，Subject(主体)，Schedulers(调度器)\n\n* 订阅Observable类似于调用函数\n\n* Observable和函数的区别主要是Observable可以“返回”多个值，可以是同步也可以是异步\n\n### Observable(可观察对象)\n\n* Observable核心关注点：创建、订阅、执行、清理\n\n* 创建： `Rx.Observable.create(function subscribe(observer) {...})`。Rx.Observable.create 是 Observable 构造函数的别名，它接收一个参数：subscribe 函数\n\n* 订阅： `observable.subscribe(data => {...})`\n\n* 执行： 创建中的`function subscribe(observer) {...}`中的...表示要执行的代码，订阅才会被执行。执行可以传递三种类型的值next、error、complete\n\n* 清理： 订阅会返回一个subscription，通过`subscription.unsubscribe()`可以清理执行\n\n### Observer(观察者)\n\n* 观察者是由Observable发送的值的消费者（订阅中的回调方法）\n\n* 观察者只是一组回调函数的集合，包括next、error、complete\n\n* 观察者的使用： 将提供给Observable的subscribe方法`observable.subscribe(observer)`\n\n* 参数可以传递为{next?: Function, error?: Function, complete?: Function}对象形式，也可以为fun1, func2, func3多个参数形式\n\n### Subscription(订阅者)\n\n* Subscription是表示可清理资源的对象，主要用来执行unsubscribe\n\n* 通过add、remove方法可以组合多个Subscription用于一起执行unsubscribe\n\n### Subject(主体)\n\n* Subject是一种特殊类型的Observable，它允许将值多播给多个观察者\n\n* BehaviorSubject会保存了发送给消费者的最新值。并且当有新的观察者订阅时，会立即从 BehaviorSubject那接收到“当前值”\n\n```JavaScript\n  var subject = new Rx.BehaviorSubject(0) // 0是初始值\n  subject.subscribe({\n    next: (v) => console.log('observerA: ' + v)\n  })\n  subject.next(1)\n  subject.next(2)\n  subject.subscribe({\n    next: (v) => console.log('observerB: ' + v)\n  })\n  subject.next(3)\n  // 输出\n  observerA: 0 // 初始化0立即发送给了新的订阅A\n  observerA: 1\n  observerA: 2\n  observerB: 2 // 保存的2会立即发送给了新的订阅B\n  observerA: 3\n  observerB: 3\n```\n\n* ReplaySubject可以发送旧值给新的观察者订阅（创建时指定缓存数量和缓存时间）\n\n```JavaScript\n  var subject = new Rx.ReplaySubject(3) // 为新的订阅者缓冲3个值\n  subject.subscribe({\n    next: (v) => console.log('observerA: ' + v)\n  })\n  subject.next(1)\n  subject.next(2)\n  subject.next(3)\n  subject.next(4)\n  subject.subscribe({\n    next: (v) => console.log('observerB: ' + v)\n  })\n  subject.next(5)\n  // 输出\n  observerA: 1\n  observerA: 2\n  observerA: 3\n  observerA: 4\n  observerB: 2 // 缓存中的2、3、4被发送给订阅B\n  observerB: 3\n  observerB: 4\n  observerA: 5\n  observerB: 5\n```\n\n* AsyncSubject只有当 Observable执行完成时(执行了complete())，它才会将执行的最后一个值（上一个next）发送给观察者\n\n### 操作符\n\n* 操作符是Observable类型上的方法，是纯函数产生新的Observable，订阅输出Observalbe 同样会订阅输入Observable\n\n### Scheduler(调度器)\n\n* 调度器控制着何时启动subscription和何时发送通知\n\n* 调度器类型主要包括null、Rx.Scheduler.queue、Rx.Scheduler.asap、Rx.Scheduler.async\n\n* 如果没有提供调度器，会通过使用最小并发原则选择一个默认调度器\n\n* 使用subscribeOn来调度subscribe()调用在什么样的上下文中执行\n\n* 使用observeOn来调度发送通知的的上下文\n\n### 其他\n\nSubject和Observable一个疑问\n\n```javascript\n// Subject\nconst subject = new Rx.Subject()\nlet sub1 = null\nlet sub2 = null\nfunction a () {\n  sub1 = subject.subscribe({\n    next: v => console.log('a: ' + v)\n  })\n  subject.next(1)\n}\nfunction b () {\n  sub2 = subject.subscribe({\n    next: (v) => console.log('b: ' + v)\n  })\n  subject.next(2)\n  subject.complete()\n  sub1.next(3) // 不会被订阅到\n}\na()\nb()\n\n// Observable\nlet obs = null\n\nconst observable = Rx.Observable.create(function (observer) {\n  obs = observer\n  observer.next(1)\n  observer.next(2)\n  observer.next(3)\n})\n\nconst a = observable.subscribe({\n  next: x => console.log('a ' + x),\n  error: err => console.error('a: ' + err),\n  complete: () => console.log('a done')\n})\n\nconst b = observable.subscribe({\n  next: x => console.log('b ' + x),\n  error: err => console.error('b: ' + err),\n  complete: () => console.log('b done')\n})\n\nobs.complete() // 只会调用到b中的complete，输出b done\nobs.next(4) // a、b都不会订阅执行到\na.next(5) // a会执行订阅\nb.next(5) // b不会执行订阅\na.complete() // 输出a done\na.next(6) // 不会执行订阅\n```","slug":"RxJS文档划重点","published":1,"updated":"2018-02-11T06:28:38.234Z","layout":"post","photos":[],"link":"","_id":"cjks5i9i80019vmtibxjjff9g","content":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li><p>RxJS的基本概念： Observable(可观察对象)，Observer(观察者)，Subscription(订阅者)，Operators(操作符)，Subject(主体)，Schedulers(调度器)</p>\n</li>\n<li><p>订阅Observable类似于调用函数</p>\n</li>\n<li><p>Observable和函数的区别主要是Observable可以“返回”多个值，可以是同步也可以是异步</p>\n</li>\n</ul>\n<h3 id=\"Observable-可观察对象\"><a href=\"#Observable-可观察对象\" class=\"headerlink\" title=\"Observable(可观察对象)\"></a>Observable(可观察对象)</h3><ul>\n<li><p>Observable核心关注点：创建、订阅、执行、清理</p>\n</li>\n<li><p>创建： <code>Rx.Observable.create(function subscribe(observer) {...})</code>。Rx.Observable.create 是 Observable 构造函数的别名，它接收一个参数：subscribe 函数</p>\n</li>\n<li><p>订阅： <code>observable.subscribe(data =&gt; {...})</code></p>\n</li>\n<li><p>执行： 创建中的<code>function subscribe(observer) {...}</code>中的…表示要执行的代码，订阅才会被执行。执行可以传递三种类型的值next、error、complete</p>\n</li>\n<li><p>清理： 订阅会返回一个subscription，通过<code>subscription.unsubscribe()</code>可以清理执行</p>\n</li>\n</ul>\n<h3 id=\"Observer-观察者\"><a href=\"#Observer-观察者\" class=\"headerlink\" title=\"Observer(观察者)\"></a>Observer(观察者)</h3><ul>\n<li><p>观察者是由Observable发送的值的消费者（订阅中的回调方法）</p>\n</li>\n<li><p>观察者只是一组回调函数的集合，包括next、error、complete</p>\n</li>\n<li><p>观察者的使用： 将提供给Observable的subscribe方法<code>observable.subscribe(observer)</code></p>\n</li>\n<li><p>参数可以传递为{next?: Function, error?: Function, complete?: Function}对象形式，也可以为fun1, func2, func3多个参数形式</p>\n</li>\n</ul>\n<h3 id=\"Subscription-订阅者\"><a href=\"#Subscription-订阅者\" class=\"headerlink\" title=\"Subscription(订阅者)\"></a>Subscription(订阅者)</h3><ul>\n<li><p>Subscription是表示可清理资源的对象，主要用来执行unsubscribe</p>\n</li>\n<li><p>通过add、remove方法可以组合多个Subscription用于一起执行unsubscribe</p>\n</li>\n</ul>\n<h3 id=\"Subject-主体\"><a href=\"#Subject-主体\" class=\"headerlink\" title=\"Subject(主体)\"></a>Subject(主体)</h3><ul>\n<li><p>Subject是一种特殊类型的Observable，它允许将值多播给多个观察者</p>\n</li>\n<li><p>BehaviorSubject会保存了发送给消费者的最新值。并且当有新的观察者订阅时，会立即从 BehaviorSubject那接收到“当前值”</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> subject = <span class=\"keyword\">new</span> Rx.BehaviorSubject(<span class=\"number\">0</span>) <span class=\"comment\">// 0是初始值</span></span><br><span class=\"line\">subject.subscribe(&#123;</span><br><span class=\"line\">  next: <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'observerA: '</span> + v)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">subject.next(<span class=\"number\">1</span>)</span><br><span class=\"line\">subject.next(<span class=\"number\">2</span>)</span><br><span class=\"line\">subject.subscribe(&#123;</span><br><span class=\"line\">  next: <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'observerB: '</span> + v)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">subject.next(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\">observerA: <span class=\"number\">0</span> <span class=\"comment\">// 初始化0立即发送给了新的订阅A</span></span><br><span class=\"line\">observerA: <span class=\"number\">1</span></span><br><span class=\"line\">observerA: <span class=\"number\">2</span></span><br><span class=\"line\">observerB: <span class=\"number\">2</span> <span class=\"comment\">// 保存的2会立即发送给了新的订阅B</span></span><br><span class=\"line\">observerA: <span class=\"number\">3</span></span><br><span class=\"line\">observerB: <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>ReplaySubject可以发送旧值给新的观察者订阅（创建时指定缓存数量和缓存时间）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> subject = <span class=\"keyword\">new</span> Rx.ReplaySubject(<span class=\"number\">3</span>) <span class=\"comment\">// 为新的订阅者缓冲3个值</span></span><br><span class=\"line\">subject.subscribe(&#123;</span><br><span class=\"line\">  next: <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'observerA: '</span> + v)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">subject.next(<span class=\"number\">1</span>)</span><br><span class=\"line\">subject.next(<span class=\"number\">2</span>)</span><br><span class=\"line\">subject.next(<span class=\"number\">3</span>)</span><br><span class=\"line\">subject.next(<span class=\"number\">4</span>)</span><br><span class=\"line\">subject.subscribe(&#123;</span><br><span class=\"line\">  next: <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'observerB: '</span> + v)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">subject.next(<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\">observerA: <span class=\"number\">1</span></span><br><span class=\"line\">observerA: <span class=\"number\">2</span></span><br><span class=\"line\">observerA: <span class=\"number\">3</span></span><br><span class=\"line\">observerA: <span class=\"number\">4</span></span><br><span class=\"line\">observerB: <span class=\"number\">2</span> <span class=\"comment\">// 缓存中的2、3、4被发送给订阅B</span></span><br><span class=\"line\">observerB: <span class=\"number\">3</span></span><br><span class=\"line\">observerB: <span class=\"number\">4</span></span><br><span class=\"line\">observerA: <span class=\"number\">5</span></span><br><span class=\"line\">observerB: <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>AsyncSubject只有当 Observable执行完成时(执行了complete())，它才会将执行的最后一个值（上一个next）发送给观察者</li>\n</ul>\n<h3 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h3><ul>\n<li>操作符是Observable类型上的方法，是纯函数产生新的Observable，订阅输出Observalbe 同样会订阅输入Observable</li>\n</ul>\n<h3 id=\"Scheduler-调度器\"><a href=\"#Scheduler-调度器\" class=\"headerlink\" title=\"Scheduler(调度器)\"></a>Scheduler(调度器)</h3><ul>\n<li><p>调度器控制着何时启动subscription和何时发送通知</p>\n</li>\n<li><p>调度器类型主要包括null、Rx.Scheduler.queue、Rx.Scheduler.asap、Rx.Scheduler.async</p>\n</li>\n<li><p>如果没有提供调度器，会通过使用最小并发原则选择一个默认调度器</p>\n</li>\n<li><p>使用subscribeOn来调度subscribe()调用在什么样的上下文中执行</p>\n</li>\n<li><p>使用observeOn来调度发送通知的的上下文</p>\n</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>Subject和Observable一个疑问</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Subject</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> subject = <span class=\"keyword\">new</span> Rx.Subject()</span><br><span class=\"line\"><span class=\"keyword\">let</span> sub1 = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sub2 = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  sub1 = subject.subscribe(&#123;</span><br><span class=\"line\">    next: <span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'a: '</span> + v)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  subject.next(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  sub2 = subject.subscribe(&#123;</span><br><span class=\"line\">    next: <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'b: '</span> + v)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  subject.next(<span class=\"number\">2</span>)</span><br><span class=\"line\">  subject.complete()</span><br><span class=\"line\">  sub1.next(<span class=\"number\">3</span>) <span class=\"comment\">// 不会被订阅到</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br><span class=\"line\">b()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Observable</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obs = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> observable = Rx.Observable.create(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">observer</span>) </span>&#123;</span><br><span class=\"line\">  obs = observer</span><br><span class=\"line\">  observer.next(<span class=\"number\">1</span>)</span><br><span class=\"line\">  observer.next(<span class=\"number\">2</span>)</span><br><span class=\"line\">  observer.next(<span class=\"number\">3</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = observable.subscribe(&#123;</span><br><span class=\"line\">  next: <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'a '</span> + x),</span><br><span class=\"line\">  error: <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.error(<span class=\"string\">'a: '</span> + err),</span><br><span class=\"line\">  complete: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'a done'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = observable.subscribe(&#123;</span><br><span class=\"line\">  next: <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'b '</span> + x),</span><br><span class=\"line\">  error: <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.error(<span class=\"string\">'b: '</span> + err),</span><br><span class=\"line\">  complete: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'b done'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">obs.complete() <span class=\"comment\">// 只会调用到b中的complete，输出b done</span></span><br><span class=\"line\">obs.next(<span class=\"number\">4</span>) <span class=\"comment\">// a、b都不会订阅执行到</span></span><br><span class=\"line\">a.next(<span class=\"number\">5</span>) <span class=\"comment\">// a会执行订阅</span></span><br><span class=\"line\">b.next(<span class=\"number\">5</span>) <span class=\"comment\">// b不会执行订阅</span></span><br><span class=\"line\">a.complete() <span class=\"comment\">// 输出a done</span></span><br><span class=\"line\">a.next(<span class=\"number\">6</span>) <span class=\"comment\">// 不会执行订阅</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li><p>RxJS的基本概念： Observable(可观察对象)，Observer(观察者)，Subscription(订阅者)，Operators(操作符)，Subject(主体)，Schedulers(调度器)</p>\n</li>\n<li><p>订阅Observable类似于调用函数</p>\n</li>\n<li><p>Observable和函数的区别主要是Observable可以“返回”多个值，可以是同步也可以是异步</p>\n</li>\n</ul>\n<h3 id=\"Observable-可观察对象\"><a href=\"#Observable-可观察对象\" class=\"headerlink\" title=\"Observable(可观察对象)\"></a>Observable(可观察对象)</h3><ul>\n<li><p>Observable核心关注点：创建、订阅、执行、清理</p>\n</li>\n<li><p>创建： <code>Rx.Observable.create(function subscribe(observer) {...})</code>。Rx.Observable.create 是 Observable 构造函数的别名，它接收一个参数：subscribe 函数</p>\n</li>\n<li><p>订阅： <code>observable.subscribe(data =&gt; {...})</code></p>\n</li>\n<li><p>执行： 创建中的<code>function subscribe(observer) {...}</code>中的…表示要执行的代码，订阅才会被执行。执行可以传递三种类型的值next、error、complete</p>\n</li>\n<li><p>清理： 订阅会返回一个subscription，通过<code>subscription.unsubscribe()</code>可以清理执行</p>\n</li>\n</ul>\n<h3 id=\"Observer-观察者\"><a href=\"#Observer-观察者\" class=\"headerlink\" title=\"Observer(观察者)\"></a>Observer(观察者)</h3><ul>\n<li><p>观察者是由Observable发送的值的消费者（订阅中的回调方法）</p>\n</li>\n<li><p>观察者只是一组回调函数的集合，包括next、error、complete</p>\n</li>\n<li><p>观察者的使用： 将提供给Observable的subscribe方法<code>observable.subscribe(observer)</code></p>\n</li>\n<li><p>参数可以传递为{next?: Function, error?: Function, complete?: Function}对象形式，也可以为fun1, func2, func3多个参数形式</p>\n</li>\n</ul>\n<h3 id=\"Subscription-订阅者\"><a href=\"#Subscription-订阅者\" class=\"headerlink\" title=\"Subscription(订阅者)\"></a>Subscription(订阅者)</h3><ul>\n<li><p>Subscription是表示可清理资源的对象，主要用来执行unsubscribe</p>\n</li>\n<li><p>通过add、remove方法可以组合多个Subscription用于一起执行unsubscribe</p>\n</li>\n</ul>\n<h3 id=\"Subject-主体\"><a href=\"#Subject-主体\" class=\"headerlink\" title=\"Subject(主体)\"></a>Subject(主体)</h3><ul>\n<li><p>Subject是一种特殊类型的Observable，它允许将值多播给多个观察者</p>\n</li>\n<li><p>BehaviorSubject会保存了发送给消费者的最新值。并且当有新的观察者订阅时，会立即从 BehaviorSubject那接收到“当前值”</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> subject = <span class=\"keyword\">new</span> Rx.BehaviorSubject(<span class=\"number\">0</span>) <span class=\"comment\">// 0是初始值</span></span><br><span class=\"line\">subject.subscribe(&#123;</span><br><span class=\"line\">  next: <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'observerA: '</span> + v)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">subject.next(<span class=\"number\">1</span>)</span><br><span class=\"line\">subject.next(<span class=\"number\">2</span>)</span><br><span class=\"line\">subject.subscribe(&#123;</span><br><span class=\"line\">  next: <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'observerB: '</span> + v)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">subject.next(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\">observerA: <span class=\"number\">0</span> <span class=\"comment\">// 初始化0立即发送给了新的订阅A</span></span><br><span class=\"line\">observerA: <span class=\"number\">1</span></span><br><span class=\"line\">observerA: <span class=\"number\">2</span></span><br><span class=\"line\">observerB: <span class=\"number\">2</span> <span class=\"comment\">// 保存的2会立即发送给了新的订阅B</span></span><br><span class=\"line\">observerA: <span class=\"number\">3</span></span><br><span class=\"line\">observerB: <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>ReplaySubject可以发送旧值给新的观察者订阅（创建时指定缓存数量和缓存时间）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> subject = <span class=\"keyword\">new</span> Rx.ReplaySubject(<span class=\"number\">3</span>) <span class=\"comment\">// 为新的订阅者缓冲3个值</span></span><br><span class=\"line\">subject.subscribe(&#123;</span><br><span class=\"line\">  next: <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'observerA: '</span> + v)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">subject.next(<span class=\"number\">1</span>)</span><br><span class=\"line\">subject.next(<span class=\"number\">2</span>)</span><br><span class=\"line\">subject.next(<span class=\"number\">3</span>)</span><br><span class=\"line\">subject.next(<span class=\"number\">4</span>)</span><br><span class=\"line\">subject.subscribe(&#123;</span><br><span class=\"line\">  next: <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'observerB: '</span> + v)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">subject.next(<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\">observerA: <span class=\"number\">1</span></span><br><span class=\"line\">observerA: <span class=\"number\">2</span></span><br><span class=\"line\">observerA: <span class=\"number\">3</span></span><br><span class=\"line\">observerA: <span class=\"number\">4</span></span><br><span class=\"line\">observerB: <span class=\"number\">2</span> <span class=\"comment\">// 缓存中的2、3、4被发送给订阅B</span></span><br><span class=\"line\">observerB: <span class=\"number\">3</span></span><br><span class=\"line\">observerB: <span class=\"number\">4</span></span><br><span class=\"line\">observerA: <span class=\"number\">5</span></span><br><span class=\"line\">observerB: <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>AsyncSubject只有当 Observable执行完成时(执行了complete())，它才会将执行的最后一个值（上一个next）发送给观察者</li>\n</ul>\n<h3 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h3><ul>\n<li>操作符是Observable类型上的方法，是纯函数产生新的Observable，订阅输出Observalbe 同样会订阅输入Observable</li>\n</ul>\n<h3 id=\"Scheduler-调度器\"><a href=\"#Scheduler-调度器\" class=\"headerlink\" title=\"Scheduler(调度器)\"></a>Scheduler(调度器)</h3><ul>\n<li><p>调度器控制着何时启动subscription和何时发送通知</p>\n</li>\n<li><p>调度器类型主要包括null、Rx.Scheduler.queue、Rx.Scheduler.asap、Rx.Scheduler.async</p>\n</li>\n<li><p>如果没有提供调度器，会通过使用最小并发原则选择一个默认调度器</p>\n</li>\n<li><p>使用subscribeOn来调度subscribe()调用在什么样的上下文中执行</p>\n</li>\n<li><p>使用observeOn来调度发送通知的的上下文</p>\n</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>Subject和Observable一个疑问</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Subject</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> subject = <span class=\"keyword\">new</span> Rx.Subject()</span><br><span class=\"line\"><span class=\"keyword\">let</span> sub1 = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sub2 = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  sub1 = subject.subscribe(&#123;</span><br><span class=\"line\">    next: <span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'a: '</span> + v)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  subject.next(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  sub2 = subject.subscribe(&#123;</span><br><span class=\"line\">    next: <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'b: '</span> + v)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  subject.next(<span class=\"number\">2</span>)</span><br><span class=\"line\">  subject.complete()</span><br><span class=\"line\">  sub1.next(<span class=\"number\">3</span>) <span class=\"comment\">// 不会被订阅到</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br><span class=\"line\">b()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Observable</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obs = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> observable = Rx.Observable.create(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">observer</span>) </span>&#123;</span><br><span class=\"line\">  obs = observer</span><br><span class=\"line\">  observer.next(<span class=\"number\">1</span>)</span><br><span class=\"line\">  observer.next(<span class=\"number\">2</span>)</span><br><span class=\"line\">  observer.next(<span class=\"number\">3</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = observable.subscribe(&#123;</span><br><span class=\"line\">  next: <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'a '</span> + x),</span><br><span class=\"line\">  error: <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.error(<span class=\"string\">'a: '</span> + err),</span><br><span class=\"line\">  complete: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'a done'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = observable.subscribe(&#123;</span><br><span class=\"line\">  next: <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'b '</span> + x),</span><br><span class=\"line\">  error: <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.error(<span class=\"string\">'b: '</span> + err),</span><br><span class=\"line\">  complete: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'b done'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">obs.complete() <span class=\"comment\">// 只会调用到b中的complete，输出b done</span></span><br><span class=\"line\">obs.next(<span class=\"number\">4</span>) <span class=\"comment\">// a、b都不会订阅执行到</span></span><br><span class=\"line\">a.next(<span class=\"number\">5</span>) <span class=\"comment\">// a会执行订阅</span></span><br><span class=\"line\">b.next(<span class=\"number\">5</span>) <span class=\"comment\">// b不会执行订阅</span></span><br><span class=\"line\">a.complete() <span class=\"comment\">// 输出a done</span></span><br><span class=\"line\">a.next(<span class=\"number\">6</span>) <span class=\"comment\">// 不会执行订阅</span></span><br></pre></td></tr></table></figure>"},{"title":"Swagger学习","date":"2017-05-09T16:00:00.000Z","comments":1,"_content":"\nSwagger是一个API设计工具，使用它可以生成规范的API文档，甚至是生成服务端和客户端代码。\n\nSwagger工具主要包括Swagger Editor、Swagger Codegen和Swagger UI，分别用于API的设计、生成服务端和客户端代码、可视化浏览API文档，另外还提供在线版Swagger Editor，以及Swaggerhub平台（就叫做云版吧）。在体验中，Swaggerhub提供了更好的使用方式。\n\n一般事例：\n```yaml\nswagger: \"2.0\"                                  # 必须，后跟版本号，目前是2.0\ninfo:                                           # 必须\n  title: Sample API                             # 必须，API标题\n  version: 1.0.0                                # 必须，API版本号\n  description: API description in Markdown.     # 可选\n\nhost: api.example.com                           # 可选 默认为文件所在host\nbasePath: /v1                                   # 可选 默认为/\nschemes:                                        # 可选\n  - https\n\npaths:                                          # 必须\n  /users:\n    get:\n      summary: Returns a list of users.\n      description: Optional extended description in Markdown.\n      produces:\n        - application/json\n      responses:\n        200:\n          description: OK\n```\nYAML语法中尽最大可能省略了括号、引号，使用缩进表示结构层次，使用`-`表示数组，Swagger支持JSON与YAML进行编写。\n\n## paths\n最常用、最核心的配置应该是paths的配置，首先跟的是路径`/usrs`，路径下是方法get、post、put、delete等，之后是方法的summary、description等。\n\n### parameters\n第一个要注意的是parameters，参数支持查询参数、路径参数、header参数以及表单参数。  \n```yaml\n# 查询参数使用方法\n# GET /users?name={name}&age={age}\npaths:\n  /users:\n    get:\n      parameters:\n        - in: query                 # 查询参数方式\n          name: name                # 参数名\n          type: string              # 类型\n          description: username     # 可选， 描述\n        - in: query\n          name: age\n          type: integer\n# 路径参数\n# GET /cars/{carId}/drivers/{driverId}\npath:\n  /cars/{carId}/drivers/{driverId}: # 路径方式地址需要带参数，已表示参数位置\n    get:\n      parameters:\n        - in: path                  # 路径参数方式\n          name: carsId\n          type: integer\n          required: true            # 路径参数中，必须。 其他方式中此参数可选\n          description: carsId\n        - in: path\n          name: driverId\n          type: integer\n          required: true\n# header参数\n# GET /ping HTTP/1.1\n# Host: example.com\n# X-Request-ID: 77e1c83b-7bb0-437b-bc50-a7a58e5660ac\npaths:\n  /ping:\n    get:\n      summary: Checks if the server is alive.\n      parameters:\n        - in: header\n          name: X-Request-ID\n          type: string\n          required: true\n# 表单参数\npaths:\n  /survey:\n    post:\n      summary: A sample survey.\n      consumes:                                   # 用于表示参数类型\n        - application/x-www-form-urlencoded       # 表单参数类型\n        # 常用的表单类型有application/x-www-form-urlencoded （用于POST原始值和原始值的数组）\n        # 和multipart/form-data （用于上传文件或文件和原始数据的组合）。\n      parameters:\n        - in: formData\n          name: name\n          type: string\n          description: A person's name.\n        - in: formData\n          name: fav_number\n          type: number\n          description: A person's favorite number.\n```\n在参数配置中，还包括可选参数required(true/false)、default(默认值)、enum(枚举值：[]表示)、allowEmptyValue(true/false)。\n\n### responses\n```yaml\npaths:\n  /ping:\n    get:\n      produces:                         # 用于表示responses类型\n        - application/json\n        # 常用类型application/json和application/xml\n      responses:\n        200:                            # 必须，状态码\n          description: OK               # 必须，描述\n          schema:                       # 可选，用于描述返回内容\n            type: object\n            properties:\n              id:\n                type: integer\n                description: The user ID.\n              username:\n                type: string\n                description: The user name.\n          header:                       # 可选，返回header内容\n            X-RateLimit-Limit:\n              type: integer\n              description: Request limit per hour.\n        default:                        # 可选，未定义的状态码\n          description: Unexpected error\n          schema:\n            $ref: '#/definitions/Error\n```\n### 数据类型\n| Name | type | format | Comments |\n| -------| ---- | ---- | ------ | -------- |\n| integer(整数) | integer | int32 | signed 32 bits |\n| long(长整数) | integer | int64 | signed 64 bits |\n| float(浮点数) | number | float |  |\n| double(双浮点数) | number | double |  | \n| string(字符串) | string |  |  |\n| byte(字节) | string | byte | base64 encoded characters |\n| binary(二进制) | string | binary | any sequence of octets |\n| boolean(布尔) | boolean  |  |  | \n| date(日期) | string | date | As defined by full-date - RFC3339 |\n| dateTime(时间) | string | date-time | As defined by date-time - RFC3339 |\n| password(密码) | string | password | Used to hint UIs the input needs to be obscured. |\nps: 除了上面定义的format，可以自定义format。\n\n本文仅列出常用的，方便自己查找的内容，更多内容参考[swagger文档](http://swagger.io/docs/specification/what-is-swagger/)。","source":"_posts/Swagger学习.md","raw":"---\ntitle: Swagger学习\ndate: 2017-05-10\ntags: API\ncategories:\n- 工具\ncomments: true\n---\n\nSwagger是一个API设计工具，使用它可以生成规范的API文档，甚至是生成服务端和客户端代码。\n\nSwagger工具主要包括Swagger Editor、Swagger Codegen和Swagger UI，分别用于API的设计、生成服务端和客户端代码、可视化浏览API文档，另外还提供在线版Swagger Editor，以及Swaggerhub平台（就叫做云版吧）。在体验中，Swaggerhub提供了更好的使用方式。\n\n一般事例：\n```yaml\nswagger: \"2.0\"                                  # 必须，后跟版本号，目前是2.0\ninfo:                                           # 必须\n  title: Sample API                             # 必须，API标题\n  version: 1.0.0                                # 必须，API版本号\n  description: API description in Markdown.     # 可选\n\nhost: api.example.com                           # 可选 默认为文件所在host\nbasePath: /v1                                   # 可选 默认为/\nschemes:                                        # 可选\n  - https\n\npaths:                                          # 必须\n  /users:\n    get:\n      summary: Returns a list of users.\n      description: Optional extended description in Markdown.\n      produces:\n        - application/json\n      responses:\n        200:\n          description: OK\n```\nYAML语法中尽最大可能省略了括号、引号，使用缩进表示结构层次，使用`-`表示数组，Swagger支持JSON与YAML进行编写。\n\n## paths\n最常用、最核心的配置应该是paths的配置，首先跟的是路径`/usrs`，路径下是方法get、post、put、delete等，之后是方法的summary、description等。\n\n### parameters\n第一个要注意的是parameters，参数支持查询参数、路径参数、header参数以及表单参数。  \n```yaml\n# 查询参数使用方法\n# GET /users?name={name}&age={age}\npaths:\n  /users:\n    get:\n      parameters:\n        - in: query                 # 查询参数方式\n          name: name                # 参数名\n          type: string              # 类型\n          description: username     # 可选， 描述\n        - in: query\n          name: age\n          type: integer\n# 路径参数\n# GET /cars/{carId}/drivers/{driverId}\npath:\n  /cars/{carId}/drivers/{driverId}: # 路径方式地址需要带参数，已表示参数位置\n    get:\n      parameters:\n        - in: path                  # 路径参数方式\n          name: carsId\n          type: integer\n          required: true            # 路径参数中，必须。 其他方式中此参数可选\n          description: carsId\n        - in: path\n          name: driverId\n          type: integer\n          required: true\n# header参数\n# GET /ping HTTP/1.1\n# Host: example.com\n# X-Request-ID: 77e1c83b-7bb0-437b-bc50-a7a58e5660ac\npaths:\n  /ping:\n    get:\n      summary: Checks if the server is alive.\n      parameters:\n        - in: header\n          name: X-Request-ID\n          type: string\n          required: true\n# 表单参数\npaths:\n  /survey:\n    post:\n      summary: A sample survey.\n      consumes:                                   # 用于表示参数类型\n        - application/x-www-form-urlencoded       # 表单参数类型\n        # 常用的表单类型有application/x-www-form-urlencoded （用于POST原始值和原始值的数组）\n        # 和multipart/form-data （用于上传文件或文件和原始数据的组合）。\n      parameters:\n        - in: formData\n          name: name\n          type: string\n          description: A person's name.\n        - in: formData\n          name: fav_number\n          type: number\n          description: A person's favorite number.\n```\n在参数配置中，还包括可选参数required(true/false)、default(默认值)、enum(枚举值：[]表示)、allowEmptyValue(true/false)。\n\n### responses\n```yaml\npaths:\n  /ping:\n    get:\n      produces:                         # 用于表示responses类型\n        - application/json\n        # 常用类型application/json和application/xml\n      responses:\n        200:                            # 必须，状态码\n          description: OK               # 必须，描述\n          schema:                       # 可选，用于描述返回内容\n            type: object\n            properties:\n              id:\n                type: integer\n                description: The user ID.\n              username:\n                type: string\n                description: The user name.\n          header:                       # 可选，返回header内容\n            X-RateLimit-Limit:\n              type: integer\n              description: Request limit per hour.\n        default:                        # 可选，未定义的状态码\n          description: Unexpected error\n          schema:\n            $ref: '#/definitions/Error\n```\n### 数据类型\n| Name | type | format | Comments |\n| -------| ---- | ---- | ------ | -------- |\n| integer(整数) | integer | int32 | signed 32 bits |\n| long(长整数) | integer | int64 | signed 64 bits |\n| float(浮点数) | number | float |  |\n| double(双浮点数) | number | double |  | \n| string(字符串) | string |  |  |\n| byte(字节) | string | byte | base64 encoded characters |\n| binary(二进制) | string | binary | any sequence of octets |\n| boolean(布尔) | boolean  |  |  | \n| date(日期) | string | date | As defined by full-date - RFC3339 |\n| dateTime(时间) | string | date-time | As defined by date-time - RFC3339 |\n| password(密码) | string | password | Used to hint UIs the input needs to be obscured. |\nps: 除了上面定义的format，可以自定义format。\n\n本文仅列出常用的，方便自己查找的内容，更多内容参考[swagger文档](http://swagger.io/docs/specification/what-is-swagger/)。","slug":"Swagger学习","published":1,"updated":"2017-12-28T03:47:32.455Z","layout":"post","photos":[],"link":"","_id":"cjks5i9i9001dvmtijdu5d7kl","content":"<p>Swagger是一个API设计工具，使用它可以生成规范的API文档，甚至是生成服务端和客户端代码。</p>\n<p>Swagger工具主要包括Swagger Editor、Swagger Codegen和Swagger UI，分别用于API的设计、生成服务端和客户端代码、可视化浏览API文档，另外还提供在线版Swagger Editor，以及Swaggerhub平台（就叫做云版吧）。在体验中，Swaggerhub提供了更好的使用方式。</p>\n<p>一般事例：<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">swagger:</span> <span class=\"string\">\"2.0\"</span>                                  <span class=\"comment\"># 必须，后跟版本号，目前是2.0</span></span><br><span class=\"line\"><span class=\"attr\">info:</span>                                           <span class=\"comment\"># 必须</span></span><br><span class=\"line\"><span class=\"attr\">  title:</span> <span class=\"string\">Sample</span> <span class=\"string\">API</span>                             <span class=\"comment\"># 必须，API标题</span></span><br><span class=\"line\"><span class=\"attr\">  version:</span> <span class=\"number\">1.0</span><span class=\"number\">.0</span>                                <span class=\"comment\"># 必须，API版本号</span></span><br><span class=\"line\"><span class=\"attr\">  description:</span> <span class=\"string\">API</span> <span class=\"string\">description</span> <span class=\"string\">in</span> <span class=\"string\">Markdown.</span>     <span class=\"comment\"># 可选</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">host:</span> <span class=\"string\">api.example.com</span>                           <span class=\"comment\"># 可选 默认为文件所在host</span></span><br><span class=\"line\"><span class=\"attr\">basePath:</span> <span class=\"string\">/v1</span>                                   <span class=\"comment\"># 可选 默认为/</span></span><br><span class=\"line\"><span class=\"attr\">schemes:</span>                                        <span class=\"comment\"># 可选</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">https</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">paths:</span>                                          <span class=\"comment\"># 必须</span></span><br><span class=\"line\">  <span class=\"string\">/users:</span></span><br><span class=\"line\"><span class=\"attr\">    get:</span></span><br><span class=\"line\"><span class=\"attr\">      summary:</span> <span class=\"string\">Returns</span> <span class=\"string\">a</span> <span class=\"string\">list</span> <span class=\"string\">of</span> <span class=\"string\">users.</span></span><br><span class=\"line\"><span class=\"attr\">      description:</span> <span class=\"string\">Optional</span> <span class=\"string\">extended</span> <span class=\"string\">description</span> <span class=\"string\">in</span> <span class=\"string\">Markdown.</span></span><br><span class=\"line\"><span class=\"attr\">      produces:</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">application/json</span></span><br><span class=\"line\"><span class=\"attr\">      responses:</span></span><br><span class=\"line\">        <span class=\"number\">200</span><span class=\"string\">:</span></span><br><span class=\"line\"><span class=\"attr\">          description:</span> <span class=\"string\">OK</span></span><br></pre></td></tr></table></figure></p>\n<p>YAML语法中尽最大可能省略了括号、引号，使用缩进表示结构层次，使用<code>-</code>表示数组，Swagger支持JSON与YAML进行编写。</p>\n<h2 id=\"paths\"><a href=\"#paths\" class=\"headerlink\" title=\"paths\"></a>paths</h2><p>最常用、最核心的配置应该是paths的配置，首先跟的是路径<code>/usrs</code>，路径下是方法get、post、put、delete等，之后是方法的summary、description等。</p>\n<h3 id=\"parameters\"><a href=\"#parameters\" class=\"headerlink\" title=\"parameters\"></a>parameters</h3><p>第一个要注意的是parameters，参数支持查询参数、路径参数、header参数以及表单参数。<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查询参数使用方法</span></span><br><span class=\"line\"><span class=\"comment\"># GET /users?name=&#123;name&#125;&amp;age=&#123;age&#125;</span></span><br><span class=\"line\"><span class=\"attr\">paths:</span></span><br><span class=\"line\">  <span class=\"string\">/users:</span></span><br><span class=\"line\"><span class=\"attr\">    get:</span></span><br><span class=\"line\"><span class=\"attr\">      parameters:</span></span><br><span class=\"line\"><span class=\"attr\">        - in:</span> <span class=\"string\">query</span>                 <span class=\"comment\"># 查询参数方式</span></span><br><span class=\"line\"><span class=\"attr\">          name:</span> <span class=\"string\">name</span>                <span class=\"comment\"># 参数名</span></span><br><span class=\"line\"><span class=\"attr\">          type:</span> <span class=\"string\">string</span>              <span class=\"comment\"># 类型</span></span><br><span class=\"line\"><span class=\"attr\">          description:</span> <span class=\"string\">username</span>     <span class=\"comment\"># 可选， 描述</span></span><br><span class=\"line\"><span class=\"attr\">        - in:</span> <span class=\"string\">query</span></span><br><span class=\"line\"><span class=\"attr\">          name:</span> <span class=\"string\">age</span></span><br><span class=\"line\"><span class=\"attr\">          type:</span> <span class=\"string\">integer</span></span><br><span class=\"line\"><span class=\"comment\"># 路径参数</span></span><br><span class=\"line\"><span class=\"comment\"># GET /cars/&#123;carId&#125;/drivers/&#123;driverId&#125;</span></span><br><span class=\"line\"><span class=\"attr\">path:</span></span><br><span class=\"line\">  <span class=\"string\">/cars/&#123;carId&#125;/drivers/&#123;driverId&#125;:</span> <span class=\"comment\"># 路径方式地址需要带参数，已表示参数位置</span></span><br><span class=\"line\"><span class=\"attr\">    get:</span></span><br><span class=\"line\"><span class=\"attr\">      parameters:</span></span><br><span class=\"line\"><span class=\"attr\">        - in:</span> <span class=\"string\">path</span>                  <span class=\"comment\"># 路径参数方式</span></span><br><span class=\"line\"><span class=\"attr\">          name:</span> <span class=\"string\">carsId</span></span><br><span class=\"line\"><span class=\"attr\">          type:</span> <span class=\"string\">integer</span></span><br><span class=\"line\"><span class=\"attr\">          required:</span> <span class=\"literal\">true</span>            <span class=\"comment\"># 路径参数中，必须。 其他方式中此参数可选</span></span><br><span class=\"line\"><span class=\"attr\">          description:</span> <span class=\"string\">carsId</span></span><br><span class=\"line\"><span class=\"attr\">        - in:</span> <span class=\"string\">path</span></span><br><span class=\"line\"><span class=\"attr\">          name:</span> <span class=\"string\">driverId</span></span><br><span class=\"line\"><span class=\"attr\">          type:</span> <span class=\"string\">integer</span></span><br><span class=\"line\"><span class=\"attr\">          required:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># header参数</span></span><br><span class=\"line\"><span class=\"comment\"># GET /ping HTTP/1.1</span></span><br><span class=\"line\"><span class=\"comment\"># Host: example.com</span></span><br><span class=\"line\"><span class=\"comment\"># X-Request-ID: 77e1c83b-7bb0-437b-bc50-a7a58e5660ac</span></span><br><span class=\"line\"><span class=\"attr\">paths:</span></span><br><span class=\"line\">  <span class=\"string\">/ping:</span></span><br><span class=\"line\"><span class=\"attr\">    get:</span></span><br><span class=\"line\"><span class=\"attr\">      summary:</span> <span class=\"string\">Checks</span> <span class=\"string\">if</span> <span class=\"string\">the</span> <span class=\"string\">server</span> <span class=\"string\">is</span> <span class=\"string\">alive.</span></span><br><span class=\"line\"><span class=\"attr\">      parameters:</span></span><br><span class=\"line\"><span class=\"attr\">        - in:</span> <span class=\"string\">header</span></span><br><span class=\"line\"><span class=\"attr\">          name:</span> <span class=\"string\">X-Request-ID</span></span><br><span class=\"line\"><span class=\"attr\">          type:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">          required:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 表单参数</span></span><br><span class=\"line\"><span class=\"attr\">paths:</span></span><br><span class=\"line\">  <span class=\"string\">/survey:</span></span><br><span class=\"line\"><span class=\"attr\">    post:</span></span><br><span class=\"line\"><span class=\"attr\">      summary:</span> <span class=\"string\">A</span> <span class=\"string\">sample</span> <span class=\"string\">survey.</span></span><br><span class=\"line\"><span class=\"attr\">      consumes:</span>                                   <span class=\"comment\"># 用于表示参数类型</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">application/x-www-form-urlencoded</span>       <span class=\"comment\"># 表单参数类型</span></span><br><span class=\"line\">        <span class=\"comment\"># 常用的表单类型有application/x-www-form-urlencoded （用于POST原始值和原始值的数组）</span></span><br><span class=\"line\">        <span class=\"comment\"># 和multipart/form-data （用于上传文件或文件和原始数据的组合）。</span></span><br><span class=\"line\"><span class=\"attr\">      parameters:</span></span><br><span class=\"line\"><span class=\"attr\">        - in:</span> <span class=\"string\">formData</span></span><br><span class=\"line\"><span class=\"attr\">          name:</span> <span class=\"string\">name</span></span><br><span class=\"line\"><span class=\"attr\">          type:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">          description:</span> <span class=\"string\">A</span> <span class=\"string\">person's</span> <span class=\"string\">name.</span></span><br><span class=\"line\"><span class=\"attr\">        - in:</span> <span class=\"string\">formData</span></span><br><span class=\"line\"><span class=\"attr\">          name:</span> <span class=\"string\">fav_number</span></span><br><span class=\"line\"><span class=\"attr\">          type:</span> <span class=\"string\">number</span></span><br><span class=\"line\"><span class=\"attr\">          description:</span> <span class=\"string\">A</span> <span class=\"string\">person's</span> <span class=\"string\">favorite</span> <span class=\"string\">number.</span></span><br></pre></td></tr></table></figure></p>\n<p>在参数配置中，还包括可选参数required(true/false)、default(默认值)、enum(枚举值：[]表示)、allowEmptyValue(true/false)。</p>\n<h3 id=\"responses\"><a href=\"#responses\" class=\"headerlink\" title=\"responses\"></a>responses</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">paths:</span></span><br><span class=\"line\">  <span class=\"string\">/ping:</span></span><br><span class=\"line\"><span class=\"attr\">    get:</span></span><br><span class=\"line\"><span class=\"attr\">      produces:</span>                         <span class=\"comment\"># 用于表示responses类型</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">application/json</span></span><br><span class=\"line\">        <span class=\"comment\"># 常用类型application/json和application/xml</span></span><br><span class=\"line\"><span class=\"attr\">      responses:</span></span><br><span class=\"line\">        <span class=\"number\">200</span><span class=\"string\">:</span>                            <span class=\"comment\"># 必须，状态码</span></span><br><span class=\"line\"><span class=\"attr\">          description:</span> <span class=\"string\">OK</span>               <span class=\"comment\"># 必须，描述</span></span><br><span class=\"line\"><span class=\"attr\">          schema:</span>                       <span class=\"comment\"># 可选，用于描述返回内容</span></span><br><span class=\"line\"><span class=\"attr\">            type:</span> <span class=\"string\">object</span></span><br><span class=\"line\"><span class=\"attr\">            properties:</span></span><br><span class=\"line\"><span class=\"attr\">              id:</span></span><br><span class=\"line\"><span class=\"attr\">                type:</span> <span class=\"string\">integer</span></span><br><span class=\"line\"><span class=\"attr\">                description:</span> <span class=\"string\">The</span> <span class=\"string\">user</span> <span class=\"string\">ID.</span></span><br><span class=\"line\"><span class=\"attr\">              username:</span></span><br><span class=\"line\"><span class=\"attr\">                type:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">                description:</span> <span class=\"string\">The</span> <span class=\"string\">user</span> <span class=\"string\">name.</span></span><br><span class=\"line\"><span class=\"attr\">          header:</span>                       <span class=\"comment\"># 可选，返回header内容</span></span><br><span class=\"line\"><span class=\"attr\">            X-RateLimit-Limit:</span></span><br><span class=\"line\"><span class=\"attr\">              type:</span> <span class=\"string\">integer</span></span><br><span class=\"line\"><span class=\"attr\">              description:</span> <span class=\"string\">Request</span> <span class=\"string\">limit</span> <span class=\"string\">per</span> <span class=\"string\">hour.</span></span><br><span class=\"line\"><span class=\"attr\">        default:</span>                        <span class=\"comment\"># 可选，未定义的状态码</span></span><br><span class=\"line\"><span class=\"attr\">          description:</span> <span class=\"string\">Unexpected</span> <span class=\"string\">error</span></span><br><span class=\"line\"><span class=\"attr\">          schema:</span></span><br><span class=\"line\">            <span class=\"string\">$ref:</span> <span class=\"string\">'#/definitions/Error</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><table>\n<thead>\n<tr>\n<th>Name</th>\n<th>type</th>\n<th>format</th>\n<th>Comments</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>integer(整数)</td>\n<td>integer</td>\n<td>int32</td>\n<td>signed 32 bits</td>\n</tr>\n<tr>\n<td>long(长整数)</td>\n<td>integer</td>\n<td>int64</td>\n<td>signed 64 bits</td>\n</tr>\n<tr>\n<td>float(浮点数)</td>\n<td>number</td>\n<td>float</td>\n<td></td>\n</tr>\n<tr>\n<td>double(双浮点数)</td>\n<td>number</td>\n<td>double</td>\n<td></td>\n</tr>\n<tr>\n<td>string(字符串)</td>\n<td>string</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>byte(字节)</td>\n<td>string</td>\n<td>byte</td>\n<td>base64 encoded characters</td>\n</tr>\n<tr>\n<td>binary(二进制)</td>\n<td>string</td>\n<td>binary</td>\n<td>any sequence of octets</td>\n</tr>\n<tr>\n<td>boolean(布尔)</td>\n<td>boolean</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>date(日期)</td>\n<td>string</td>\n<td>date</td>\n<td>As defined by full-date - RFC3339</td>\n</tr>\n<tr>\n<td>dateTime(时间)</td>\n<td>string</td>\n<td>date-time</td>\n<td>As defined by date-time - RFC3339</td>\n</tr>\n<tr>\n<td>password(密码)</td>\n<td>string</td>\n<td>password</td>\n<td>Used to hint UIs the input needs to be obscured.</td>\n</tr>\n</tbody>\n</table>\n<p>ps: 除了上面定义的format，可以自定义format。</p>\n<p>本文仅列出常用的，方便自己查找的内容，更多内容参考<a href=\"http://swagger.io/docs/specification/what-is-swagger/\" target=\"_blank\" rel=\"noopener\">swagger文档</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Swagger是一个API设计工具，使用它可以生成规范的API文档，甚至是生成服务端和客户端代码。</p>\n<p>Swagger工具主要包括Swagger Editor、Swagger Codegen和Swagger UI，分别用于API的设计、生成服务端和客户端代码、可视化浏览API文档，另外还提供在线版Swagger Editor，以及Swaggerhub平台（就叫做云版吧）。在体验中，Swaggerhub提供了更好的使用方式。</p>\n<p>一般事例：<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">swagger:</span> <span class=\"string\">\"2.0\"</span>                                  <span class=\"comment\"># 必须，后跟版本号，目前是2.0</span></span><br><span class=\"line\"><span class=\"attr\">info:</span>                                           <span class=\"comment\"># 必须</span></span><br><span class=\"line\"><span class=\"attr\">  title:</span> <span class=\"string\">Sample</span> <span class=\"string\">API</span>                             <span class=\"comment\"># 必须，API标题</span></span><br><span class=\"line\"><span class=\"attr\">  version:</span> <span class=\"number\">1.0</span><span class=\"number\">.0</span>                                <span class=\"comment\"># 必须，API版本号</span></span><br><span class=\"line\"><span class=\"attr\">  description:</span> <span class=\"string\">API</span> <span class=\"string\">description</span> <span class=\"string\">in</span> <span class=\"string\">Markdown.</span>     <span class=\"comment\"># 可选</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">host:</span> <span class=\"string\">api.example.com</span>                           <span class=\"comment\"># 可选 默认为文件所在host</span></span><br><span class=\"line\"><span class=\"attr\">basePath:</span> <span class=\"string\">/v1</span>                                   <span class=\"comment\"># 可选 默认为/</span></span><br><span class=\"line\"><span class=\"attr\">schemes:</span>                                        <span class=\"comment\"># 可选</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">https</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">paths:</span>                                          <span class=\"comment\"># 必须</span></span><br><span class=\"line\">  <span class=\"string\">/users:</span></span><br><span class=\"line\"><span class=\"attr\">    get:</span></span><br><span class=\"line\"><span class=\"attr\">      summary:</span> <span class=\"string\">Returns</span> <span class=\"string\">a</span> <span class=\"string\">list</span> <span class=\"string\">of</span> <span class=\"string\">users.</span></span><br><span class=\"line\"><span class=\"attr\">      description:</span> <span class=\"string\">Optional</span> <span class=\"string\">extended</span> <span class=\"string\">description</span> <span class=\"string\">in</span> <span class=\"string\">Markdown.</span></span><br><span class=\"line\"><span class=\"attr\">      produces:</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">application/json</span></span><br><span class=\"line\"><span class=\"attr\">      responses:</span></span><br><span class=\"line\">        <span class=\"number\">200</span><span class=\"string\">:</span></span><br><span class=\"line\"><span class=\"attr\">          description:</span> <span class=\"string\">OK</span></span><br></pre></td></tr></table></figure></p>\n<p>YAML语法中尽最大可能省略了括号、引号，使用缩进表示结构层次，使用<code>-</code>表示数组，Swagger支持JSON与YAML进行编写。</p>\n<h2 id=\"paths\"><a href=\"#paths\" class=\"headerlink\" title=\"paths\"></a>paths</h2><p>最常用、最核心的配置应该是paths的配置，首先跟的是路径<code>/usrs</code>，路径下是方法get、post、put、delete等，之后是方法的summary、description等。</p>\n<h3 id=\"parameters\"><a href=\"#parameters\" class=\"headerlink\" title=\"parameters\"></a>parameters</h3><p>第一个要注意的是parameters，参数支持查询参数、路径参数、header参数以及表单参数。<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查询参数使用方法</span></span><br><span class=\"line\"><span class=\"comment\"># GET /users?name=&#123;name&#125;&amp;age=&#123;age&#125;</span></span><br><span class=\"line\"><span class=\"attr\">paths:</span></span><br><span class=\"line\">  <span class=\"string\">/users:</span></span><br><span class=\"line\"><span class=\"attr\">    get:</span></span><br><span class=\"line\"><span class=\"attr\">      parameters:</span></span><br><span class=\"line\"><span class=\"attr\">        - in:</span> <span class=\"string\">query</span>                 <span class=\"comment\"># 查询参数方式</span></span><br><span class=\"line\"><span class=\"attr\">          name:</span> <span class=\"string\">name</span>                <span class=\"comment\"># 参数名</span></span><br><span class=\"line\"><span class=\"attr\">          type:</span> <span class=\"string\">string</span>              <span class=\"comment\"># 类型</span></span><br><span class=\"line\"><span class=\"attr\">          description:</span> <span class=\"string\">username</span>     <span class=\"comment\"># 可选， 描述</span></span><br><span class=\"line\"><span class=\"attr\">        - in:</span> <span class=\"string\">query</span></span><br><span class=\"line\"><span class=\"attr\">          name:</span> <span class=\"string\">age</span></span><br><span class=\"line\"><span class=\"attr\">          type:</span> <span class=\"string\">integer</span></span><br><span class=\"line\"><span class=\"comment\"># 路径参数</span></span><br><span class=\"line\"><span class=\"comment\"># GET /cars/&#123;carId&#125;/drivers/&#123;driverId&#125;</span></span><br><span class=\"line\"><span class=\"attr\">path:</span></span><br><span class=\"line\">  <span class=\"string\">/cars/&#123;carId&#125;/drivers/&#123;driverId&#125;:</span> <span class=\"comment\"># 路径方式地址需要带参数，已表示参数位置</span></span><br><span class=\"line\"><span class=\"attr\">    get:</span></span><br><span class=\"line\"><span class=\"attr\">      parameters:</span></span><br><span class=\"line\"><span class=\"attr\">        - in:</span> <span class=\"string\">path</span>                  <span class=\"comment\"># 路径参数方式</span></span><br><span class=\"line\"><span class=\"attr\">          name:</span> <span class=\"string\">carsId</span></span><br><span class=\"line\"><span class=\"attr\">          type:</span> <span class=\"string\">integer</span></span><br><span class=\"line\"><span class=\"attr\">          required:</span> <span class=\"literal\">true</span>            <span class=\"comment\"># 路径参数中，必须。 其他方式中此参数可选</span></span><br><span class=\"line\"><span class=\"attr\">          description:</span> <span class=\"string\">carsId</span></span><br><span class=\"line\"><span class=\"attr\">        - in:</span> <span class=\"string\">path</span></span><br><span class=\"line\"><span class=\"attr\">          name:</span> <span class=\"string\">driverId</span></span><br><span class=\"line\"><span class=\"attr\">          type:</span> <span class=\"string\">integer</span></span><br><span class=\"line\"><span class=\"attr\">          required:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># header参数</span></span><br><span class=\"line\"><span class=\"comment\"># GET /ping HTTP/1.1</span></span><br><span class=\"line\"><span class=\"comment\"># Host: example.com</span></span><br><span class=\"line\"><span class=\"comment\"># X-Request-ID: 77e1c83b-7bb0-437b-bc50-a7a58e5660ac</span></span><br><span class=\"line\"><span class=\"attr\">paths:</span></span><br><span class=\"line\">  <span class=\"string\">/ping:</span></span><br><span class=\"line\"><span class=\"attr\">    get:</span></span><br><span class=\"line\"><span class=\"attr\">      summary:</span> <span class=\"string\">Checks</span> <span class=\"string\">if</span> <span class=\"string\">the</span> <span class=\"string\">server</span> <span class=\"string\">is</span> <span class=\"string\">alive.</span></span><br><span class=\"line\"><span class=\"attr\">      parameters:</span></span><br><span class=\"line\"><span class=\"attr\">        - in:</span> <span class=\"string\">header</span></span><br><span class=\"line\"><span class=\"attr\">          name:</span> <span class=\"string\">X-Request-ID</span></span><br><span class=\"line\"><span class=\"attr\">          type:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">          required:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 表单参数</span></span><br><span class=\"line\"><span class=\"attr\">paths:</span></span><br><span class=\"line\">  <span class=\"string\">/survey:</span></span><br><span class=\"line\"><span class=\"attr\">    post:</span></span><br><span class=\"line\"><span class=\"attr\">      summary:</span> <span class=\"string\">A</span> <span class=\"string\">sample</span> <span class=\"string\">survey.</span></span><br><span class=\"line\"><span class=\"attr\">      consumes:</span>                                   <span class=\"comment\"># 用于表示参数类型</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">application/x-www-form-urlencoded</span>       <span class=\"comment\"># 表单参数类型</span></span><br><span class=\"line\">        <span class=\"comment\"># 常用的表单类型有application/x-www-form-urlencoded （用于POST原始值和原始值的数组）</span></span><br><span class=\"line\">        <span class=\"comment\"># 和multipart/form-data （用于上传文件或文件和原始数据的组合）。</span></span><br><span class=\"line\"><span class=\"attr\">      parameters:</span></span><br><span class=\"line\"><span class=\"attr\">        - in:</span> <span class=\"string\">formData</span></span><br><span class=\"line\"><span class=\"attr\">          name:</span> <span class=\"string\">name</span></span><br><span class=\"line\"><span class=\"attr\">          type:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">          description:</span> <span class=\"string\">A</span> <span class=\"string\">person's</span> <span class=\"string\">name.</span></span><br><span class=\"line\"><span class=\"attr\">        - in:</span> <span class=\"string\">formData</span></span><br><span class=\"line\"><span class=\"attr\">          name:</span> <span class=\"string\">fav_number</span></span><br><span class=\"line\"><span class=\"attr\">          type:</span> <span class=\"string\">number</span></span><br><span class=\"line\"><span class=\"attr\">          description:</span> <span class=\"string\">A</span> <span class=\"string\">person's</span> <span class=\"string\">favorite</span> <span class=\"string\">number.</span></span><br></pre></td></tr></table></figure></p>\n<p>在参数配置中，还包括可选参数required(true/false)、default(默认值)、enum(枚举值：[]表示)、allowEmptyValue(true/false)。</p>\n<h3 id=\"responses\"><a href=\"#responses\" class=\"headerlink\" title=\"responses\"></a>responses</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">paths:</span></span><br><span class=\"line\">  <span class=\"string\">/ping:</span></span><br><span class=\"line\"><span class=\"attr\">    get:</span></span><br><span class=\"line\"><span class=\"attr\">      produces:</span>                         <span class=\"comment\"># 用于表示responses类型</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">application/json</span></span><br><span class=\"line\">        <span class=\"comment\"># 常用类型application/json和application/xml</span></span><br><span class=\"line\"><span class=\"attr\">      responses:</span></span><br><span class=\"line\">        <span class=\"number\">200</span><span class=\"string\">:</span>                            <span class=\"comment\"># 必须，状态码</span></span><br><span class=\"line\"><span class=\"attr\">          description:</span> <span class=\"string\">OK</span>               <span class=\"comment\"># 必须，描述</span></span><br><span class=\"line\"><span class=\"attr\">          schema:</span>                       <span class=\"comment\"># 可选，用于描述返回内容</span></span><br><span class=\"line\"><span class=\"attr\">            type:</span> <span class=\"string\">object</span></span><br><span class=\"line\"><span class=\"attr\">            properties:</span></span><br><span class=\"line\"><span class=\"attr\">              id:</span></span><br><span class=\"line\"><span class=\"attr\">                type:</span> <span class=\"string\">integer</span></span><br><span class=\"line\"><span class=\"attr\">                description:</span> <span class=\"string\">The</span> <span class=\"string\">user</span> <span class=\"string\">ID.</span></span><br><span class=\"line\"><span class=\"attr\">              username:</span></span><br><span class=\"line\"><span class=\"attr\">                type:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">                description:</span> <span class=\"string\">The</span> <span class=\"string\">user</span> <span class=\"string\">name.</span></span><br><span class=\"line\"><span class=\"attr\">          header:</span>                       <span class=\"comment\"># 可选，返回header内容</span></span><br><span class=\"line\"><span class=\"attr\">            X-RateLimit-Limit:</span></span><br><span class=\"line\"><span class=\"attr\">              type:</span> <span class=\"string\">integer</span></span><br><span class=\"line\"><span class=\"attr\">              description:</span> <span class=\"string\">Request</span> <span class=\"string\">limit</span> <span class=\"string\">per</span> <span class=\"string\">hour.</span></span><br><span class=\"line\"><span class=\"attr\">        default:</span>                        <span class=\"comment\"># 可选，未定义的状态码</span></span><br><span class=\"line\"><span class=\"attr\">          description:</span> <span class=\"string\">Unexpected</span> <span class=\"string\">error</span></span><br><span class=\"line\"><span class=\"attr\">          schema:</span></span><br><span class=\"line\">            <span class=\"string\">$ref:</span> <span class=\"string\">'#/definitions/Error</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><table>\n<thead>\n<tr>\n<th>Name</th>\n<th>type</th>\n<th>format</th>\n<th>Comments</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>integer(整数)</td>\n<td>integer</td>\n<td>int32</td>\n<td>signed 32 bits</td>\n</tr>\n<tr>\n<td>long(长整数)</td>\n<td>integer</td>\n<td>int64</td>\n<td>signed 64 bits</td>\n</tr>\n<tr>\n<td>float(浮点数)</td>\n<td>number</td>\n<td>float</td>\n<td></td>\n</tr>\n<tr>\n<td>double(双浮点数)</td>\n<td>number</td>\n<td>double</td>\n<td></td>\n</tr>\n<tr>\n<td>string(字符串)</td>\n<td>string</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>byte(字节)</td>\n<td>string</td>\n<td>byte</td>\n<td>base64 encoded characters</td>\n</tr>\n<tr>\n<td>binary(二进制)</td>\n<td>string</td>\n<td>binary</td>\n<td>any sequence of octets</td>\n</tr>\n<tr>\n<td>boolean(布尔)</td>\n<td>boolean</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>date(日期)</td>\n<td>string</td>\n<td>date</td>\n<td>As defined by full-date - RFC3339</td>\n</tr>\n<tr>\n<td>dateTime(时间)</td>\n<td>string</td>\n<td>date-time</td>\n<td>As defined by date-time - RFC3339</td>\n</tr>\n<tr>\n<td>password(密码)</td>\n<td>string</td>\n<td>password</td>\n<td>Used to hint UIs the input needs to be obscured.</td>\n</tr>\n</tbody>\n</table>\n<p>ps: 除了上面定义的format，可以自定义format。</p>\n<p>本文仅列出常用的，方便自己查找的内容，更多内容参考<a href=\"http://swagger.io/docs/specification/what-is-swagger/\" target=\"_blank\" rel=\"noopener\">swagger文档</a>。</p>\n"},{"title":"dva中的handleAction","date":"2017-03-20T16:00:00.000Z","comments":1,"_content":"\nDva是支付宝基于React、redux、redux-saga和react-router的轻量级框架，代码不多，主要是实现了一些现有应用的一层封装，使得编写React应用编写更清晰方便。  \n最近在学习使用Dva，主要学习了之前没有接触redux-saga的使用，熟悉了Dva的项目结构和开发流程。这两天试着看了下源码，又被虐得不要不要的。\n\n在Dva中有个handleActions.js，只有三十行代码，三个函数，却是困扰我半天。只能说自己还是太菜、太初级。\n\n从文件名handleActions显然是处理redux中的actions的，redux中通过触发action来执行reducer（就是将action传递给reducer），返回新的state以实现页面的更新。\n\n出口函数handleActions是这样的\n```javascript\nfunction handleActions(handlers, defaultState) {\n  const reducers = Object.keys(handlers).map(type => handleAction(type, handlers[type]));\n  const reducer = reduceReducers(...reducers);\n  return (state = defaultState, action) => reducer(state, action);\n}\n```\n参数handlers、defaultState分别表示处理函数和默认state。从使用方法和函数中的定义可以看出handlers和defaultState都是对象。  \n第一句，Object.keys(handlers).map用于对对象的循环，虽然看到Object.keys能够知道是什么作用，但是自己在编写代码时会忘记该方法而使用for...in，for...in循环包括原型链上的属性显然要差些。接着调用了handleAction，传入了type（也就是key）以及处理函数handlers[type]。\n```javascript\nfunction handleAction(actionType, reducer = identify) {\n  return (state, action) => {\n    const { type } = action;\n    if (type && actionType !== type) {\n      return state;\n    }\n    return reducer(state, action);\n  };\n}\n```\nhandleAction接受参数actionType和reducer，reducer默认值是一个直接返回原参数的函数。最后返回的是一个函数，函数中使用了actionType以及reducer，这属于闭包的应用。这个函数如果使用的话是这样的`handleAction(actionType, reducer)(state, action)`，<del>这个应该属于函数的柯里化，对柯里化看了一些资料，但是依然一知半解，这里使用柯里化的目的应该是保存变量actionType和reducer</del>(柯里化应该是单个参数，之前理解有误)。\n\n回到handleActions函数中，reducers最后就被保存为了元素是下面这样函数的数组，其中的actionType和reducer是通过闭包保存不同的内容的。\n```javascript\n(state, action) => {\n  const { type } = action;\n  if (type && actionType !== type) {\n    return state;\n  }\n  return reducer(state, action);\n}\n```\n\n第二句执行函数reduceReducers\n```javascript\nfunction reduceReducers(...reducers) {\n  return (previous, current) =>\n    reducers.reduce(\n      (p, r) => r(p, current),\n      previous,\n    );\n}\n```\n同样又是返回一个函数保存到reducer中，reducer这个函数中通过闭包保存了函数数组reducers。\n\n第三句是return，返回值依然是一个函数。函数中调用reducer，并且传参state和action。  \n这样我们可以知道reducer函数中previous表示的state，current表示action。  \n然后通过reducers.reduce循环执行所有的reducers，传参为state和action。然后在handleAction返回参数中，根据action.type和之前保存的actionType比较决定是否执行之前保存的reducer来处理state。如果type不同，不对state进行处理直接返回。\n\n功能并不是特别复杂，相当于reduceReducers对reducers进行循环，handleAction对action进行判断。主要困扰集中在了对reduce使用上的不熟悉，柯里化的复杂，闭包的实际应用等。\n\n","source":"_posts/dva中的handleAction.md","raw":"---\ntitle: dva中的handleAction\ndate: 2017-03-21\ntags: [JavaScript, React]\ncategories: \n- React\ncomments: true\n---\n\nDva是支付宝基于React、redux、redux-saga和react-router的轻量级框架，代码不多，主要是实现了一些现有应用的一层封装，使得编写React应用编写更清晰方便。  \n最近在学习使用Dva，主要学习了之前没有接触redux-saga的使用，熟悉了Dva的项目结构和开发流程。这两天试着看了下源码，又被虐得不要不要的。\n\n在Dva中有个handleActions.js，只有三十行代码，三个函数，却是困扰我半天。只能说自己还是太菜、太初级。\n\n从文件名handleActions显然是处理redux中的actions的，redux中通过触发action来执行reducer（就是将action传递给reducer），返回新的state以实现页面的更新。\n\n出口函数handleActions是这样的\n```javascript\nfunction handleActions(handlers, defaultState) {\n  const reducers = Object.keys(handlers).map(type => handleAction(type, handlers[type]));\n  const reducer = reduceReducers(...reducers);\n  return (state = defaultState, action) => reducer(state, action);\n}\n```\n参数handlers、defaultState分别表示处理函数和默认state。从使用方法和函数中的定义可以看出handlers和defaultState都是对象。  \n第一句，Object.keys(handlers).map用于对对象的循环，虽然看到Object.keys能够知道是什么作用，但是自己在编写代码时会忘记该方法而使用for...in，for...in循环包括原型链上的属性显然要差些。接着调用了handleAction，传入了type（也就是key）以及处理函数handlers[type]。\n```javascript\nfunction handleAction(actionType, reducer = identify) {\n  return (state, action) => {\n    const { type } = action;\n    if (type && actionType !== type) {\n      return state;\n    }\n    return reducer(state, action);\n  };\n}\n```\nhandleAction接受参数actionType和reducer，reducer默认值是一个直接返回原参数的函数。最后返回的是一个函数，函数中使用了actionType以及reducer，这属于闭包的应用。这个函数如果使用的话是这样的`handleAction(actionType, reducer)(state, action)`，<del>这个应该属于函数的柯里化，对柯里化看了一些资料，但是依然一知半解，这里使用柯里化的目的应该是保存变量actionType和reducer</del>(柯里化应该是单个参数，之前理解有误)。\n\n回到handleActions函数中，reducers最后就被保存为了元素是下面这样函数的数组，其中的actionType和reducer是通过闭包保存不同的内容的。\n```javascript\n(state, action) => {\n  const { type } = action;\n  if (type && actionType !== type) {\n    return state;\n  }\n  return reducer(state, action);\n}\n```\n\n第二句执行函数reduceReducers\n```javascript\nfunction reduceReducers(...reducers) {\n  return (previous, current) =>\n    reducers.reduce(\n      (p, r) => r(p, current),\n      previous,\n    );\n}\n```\n同样又是返回一个函数保存到reducer中，reducer这个函数中通过闭包保存了函数数组reducers。\n\n第三句是return，返回值依然是一个函数。函数中调用reducer，并且传参state和action。  \n这样我们可以知道reducer函数中previous表示的state，current表示action。  \n然后通过reducers.reduce循环执行所有的reducers，传参为state和action。然后在handleAction返回参数中，根据action.type和之前保存的actionType比较决定是否执行之前保存的reducer来处理state。如果type不同，不对state进行处理直接返回。\n\n功能并不是特别复杂，相当于reduceReducers对reducers进行循环，handleAction对action进行判断。主要困扰集中在了对reduce使用上的不熟悉，柯里化的复杂，闭包的实际应用等。\n\n","slug":"dva中的handleAction","published":1,"updated":"2017-12-28T03:47:32.456Z","layout":"post","photos":[],"link":"","_id":"cjks5i9ia001gvmti4dv04sp7","content":"<p>Dva是支付宝基于React、redux、redux-saga和react-router的轻量级框架，代码不多，主要是实现了一些现有应用的一层封装，使得编写React应用编写更清晰方便。<br>最近在学习使用Dva，主要学习了之前没有接触redux-saga的使用，熟悉了Dva的项目结构和开发流程。这两天试着看了下源码，又被虐得不要不要的。</p>\n<p>在Dva中有个handleActions.js，只有三十行代码，三个函数，却是困扰我半天。只能说自己还是太菜、太初级。</p>\n<p>从文件名handleActions显然是处理redux中的actions的，redux中通过触发action来执行reducer（就是将action传递给reducer），返回新的state以实现页面的更新。</p>\n<p>出口函数handleActions是这样的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleActions</span>(<span class=\"params\">handlers, defaultState</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> reducers = <span class=\"built_in\">Object</span>.keys(handlers).map(<span class=\"function\"><span class=\"params\">type</span> =&gt;</span> handleAction(type, handlers[type]));</span><br><span class=\"line\">  <span class=\"keyword\">const</span> reducer = reduceReducers(...reducers);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">state = defaultState, action</span>) =&gt;</span> reducer(state, action);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>参数handlers、defaultState分别表示处理函数和默认state。从使用方法和函数中的定义可以看出handlers和defaultState都是对象。<br>第一句，Object.keys(handlers).map用于对对象的循环，虽然看到Object.keys能够知道是什么作用，但是自己在编写代码时会忘记该方法而使用for…in，for…in循环包括原型链上的属性显然要差些。接着调用了handleAction，传入了type（也就是key）以及处理函数handlers[type]。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleAction</span>(<span class=\"params\">actionType, reducer = identify</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">state, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; type &#125; = action;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp;&amp; actionType !== type) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reducer(state, action);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>handleAction接受参数actionType和reducer，reducer默认值是一个直接返回原参数的函数。最后返回的是一个函数，函数中使用了actionType以及reducer，这属于闭包的应用。这个函数如果使用的话是这样的<code>handleAction(actionType, reducer)(state, action)</code>，<del>这个应该属于函数的柯里化，对柯里化看了一些资料，但是依然一知半解，这里使用柯里化的目的应该是保存变量actionType和reducer</del>(柯里化应该是单个参数，之前理解有误)。</p>\n<p>回到handleActions函数中，reducers最后就被保存为了元素是下面这样函数的数组，其中的actionType和reducer是通过闭包保存不同的内容的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(state, action) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; type &#125; = action;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type &amp;&amp; actionType !== type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> reducer(state, action);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第二句执行函数reduceReducers<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reduceReducers</span>(<span class=\"params\">...reducers</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">previous, current</span>) =&gt;</span></span><br><span class=\"line\">    reducers.reduce(</span><br><span class=\"line\">      (p, r) =&gt; r(p, current),</span><br><span class=\"line\">      previous,</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同样又是返回一个函数保存到reducer中，reducer这个函数中通过闭包保存了函数数组reducers。</p>\n<p>第三句是return，返回值依然是一个函数。函数中调用reducer，并且传参state和action。<br>这样我们可以知道reducer函数中previous表示的state，current表示action。<br>然后通过reducers.reduce循环执行所有的reducers，传参为state和action。然后在handleAction返回参数中，根据action.type和之前保存的actionType比较决定是否执行之前保存的reducer来处理state。如果type不同，不对state进行处理直接返回。</p>\n<p>功能并不是特别复杂，相当于reduceReducers对reducers进行循环，handleAction对action进行判断。主要困扰集中在了对reduce使用上的不熟悉，柯里化的复杂，闭包的实际应用等。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Dva是支付宝基于React、redux、redux-saga和react-router的轻量级框架，代码不多，主要是实现了一些现有应用的一层封装，使得编写React应用编写更清晰方便。<br>最近在学习使用Dva，主要学习了之前没有接触redux-saga的使用，熟悉了Dva的项目结构和开发流程。这两天试着看了下源码，又被虐得不要不要的。</p>\n<p>在Dva中有个handleActions.js，只有三十行代码，三个函数，却是困扰我半天。只能说自己还是太菜、太初级。</p>\n<p>从文件名handleActions显然是处理redux中的actions的，redux中通过触发action来执行reducer（就是将action传递给reducer），返回新的state以实现页面的更新。</p>\n<p>出口函数handleActions是这样的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleActions</span>(<span class=\"params\">handlers, defaultState</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> reducers = <span class=\"built_in\">Object</span>.keys(handlers).map(<span class=\"function\"><span class=\"params\">type</span> =&gt;</span> handleAction(type, handlers[type]));</span><br><span class=\"line\">  <span class=\"keyword\">const</span> reducer = reduceReducers(...reducers);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">state = defaultState, action</span>) =&gt;</span> reducer(state, action);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>参数handlers、defaultState分别表示处理函数和默认state。从使用方法和函数中的定义可以看出handlers和defaultState都是对象。<br>第一句，Object.keys(handlers).map用于对对象的循环，虽然看到Object.keys能够知道是什么作用，但是自己在编写代码时会忘记该方法而使用for…in，for…in循环包括原型链上的属性显然要差些。接着调用了handleAction，传入了type（也就是key）以及处理函数handlers[type]。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleAction</span>(<span class=\"params\">actionType, reducer = identify</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">state, action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; type &#125; = action;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp;&amp; actionType !== type) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reducer(state, action);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>handleAction接受参数actionType和reducer，reducer默认值是一个直接返回原参数的函数。最后返回的是一个函数，函数中使用了actionType以及reducer，这属于闭包的应用。这个函数如果使用的话是这样的<code>handleAction(actionType, reducer)(state, action)</code>，<del>这个应该属于函数的柯里化，对柯里化看了一些资料，但是依然一知半解，这里使用柯里化的目的应该是保存变量actionType和reducer</del>(柯里化应该是单个参数，之前理解有误)。</p>\n<p>回到handleActions函数中，reducers最后就被保存为了元素是下面这样函数的数组，其中的actionType和reducer是通过闭包保存不同的内容的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(state, action) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; type &#125; = action;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type &amp;&amp; actionType !== type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> reducer(state, action);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第二句执行函数reduceReducers<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reduceReducers</span>(<span class=\"params\">...reducers</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">previous, current</span>) =&gt;</span></span><br><span class=\"line\">    reducers.reduce(</span><br><span class=\"line\">      (p, r) =&gt; r(p, current),</span><br><span class=\"line\">      previous,</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同样又是返回一个函数保存到reducer中，reducer这个函数中通过闭包保存了函数数组reducers。</p>\n<p>第三句是return，返回值依然是一个函数。函数中调用reducer，并且传参state和action。<br>这样我们可以知道reducer函数中previous表示的state，current表示action。<br>然后通过reducers.reduce循环执行所有的reducers，传参为state和action。然后在handleAction返回参数中，根据action.type和之前保存的actionType比较决定是否执行之前保存的reducer来处理state。如果type不同，不对state进行处理直接返回。</p>\n<p>功能并不是特别复杂，相当于reduceReducers对reducers进行循环，handleAction对action进行判断。主要困扰集中在了对reduce使用上的不熟悉，柯里化的复杂，闭包的实际应用等。</p>\n"},{"title":"fixed移动端解决","date":"2016-07-28T16:00:00.000Z","comments":1,"_content":"\nFrom [here](http://efe.baidu.com/blog/mobile-fixed-layout/)\n\n### fixed移动端解决\n\n主要是IOS上的。\n\n\t思路：滚动内容在标签中，固定标签的位置。\n\n1. 将所有非fixed定位的，也就是需要滚动的元素用block标签包裹。\n2. fixed定位的元素给fixed或者absolute都可以。\n3. 包裹标签绝对定位在fixed和边界中间，`overflow-y: scroll`。\n4. 标签内滚动不流畅，给包裹标签增加`-webkit-overflow-scrolling: touch;`\n\n```html\n<body class=\"layout-scroll-fixed\">\n    <!-- fixed定位的头部 -->\n    <header>\n        \n    </header>\n    \n    <!-- 可以滚动的区域 -->\n    <main>\n        <div class=\"content\">\n        <!-- 内容在这里... -->\n        </div>\n    </main>\n    \n    <!-- fixed定位的底部 -->\n    <footer>\n        <input type=\"text\" placeholder=\"Footer...\"/>\n        <button class=\"submit\">提交</button>\n    </footer>\n</body>\n```\n\n```css\nheader, footer, main {\n    display: block;\n}\n\nheader {\n    position: fixed;  /* fixed、absolute都可以 */\n    height: 50px;\n    left: 0;\n    right: 0;\n    top: 0;\n}\n\nfooter {\n    position: fixed;\n    height: 34px;\n    left: 0;\n    right: 0;\n    bottom: 0;\n}\n\nmain {\n    /* main绝对定位，进行内部滚动 */\n    position: absolute;\n    top: 50px;\n    bottom: 34px;\n    /* 使之可以滚动 */\n    overflow-y: scroll;\n    /* 增加该属性，可以增加弹性 */\n    -webkit-overflow-scrolling: touch;\n}\n\nmain .content {\n    height: 2000px;\n}\n```\n\nFrom [here](http://imweb.io/topic/577e64a47c99347163ec0b10)\n\n### 图片高度占位\n给图片提供一个容器，设置高度为0，根据图片比例使用padding-top设置百分值。\n```css\n.img-wrap{\n    position: relative;\n    height: 0;\n    padding-top: 50%；// 图片宽度的一半\n}\n.img{\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n```","source":"_posts/fixed移动端解决.md","raw":"---\ntitle: fixed移动端解决\ndate: 2016-07-29\ntags: [JavaScript, 移动Web]\ncategories: \n- JavaScript\ncomments: true\n---\n\nFrom [here](http://efe.baidu.com/blog/mobile-fixed-layout/)\n\n### fixed移动端解决\n\n主要是IOS上的。\n\n\t思路：滚动内容在标签中，固定标签的位置。\n\n1. 将所有非fixed定位的，也就是需要滚动的元素用block标签包裹。\n2. fixed定位的元素给fixed或者absolute都可以。\n3. 包裹标签绝对定位在fixed和边界中间，`overflow-y: scroll`。\n4. 标签内滚动不流畅，给包裹标签增加`-webkit-overflow-scrolling: touch;`\n\n```html\n<body class=\"layout-scroll-fixed\">\n    <!-- fixed定位的头部 -->\n    <header>\n        \n    </header>\n    \n    <!-- 可以滚动的区域 -->\n    <main>\n        <div class=\"content\">\n        <!-- 内容在这里... -->\n        </div>\n    </main>\n    \n    <!-- fixed定位的底部 -->\n    <footer>\n        <input type=\"text\" placeholder=\"Footer...\"/>\n        <button class=\"submit\">提交</button>\n    </footer>\n</body>\n```\n\n```css\nheader, footer, main {\n    display: block;\n}\n\nheader {\n    position: fixed;  /* fixed、absolute都可以 */\n    height: 50px;\n    left: 0;\n    right: 0;\n    top: 0;\n}\n\nfooter {\n    position: fixed;\n    height: 34px;\n    left: 0;\n    right: 0;\n    bottom: 0;\n}\n\nmain {\n    /* main绝对定位，进行内部滚动 */\n    position: absolute;\n    top: 50px;\n    bottom: 34px;\n    /* 使之可以滚动 */\n    overflow-y: scroll;\n    /* 增加该属性，可以增加弹性 */\n    -webkit-overflow-scrolling: touch;\n}\n\nmain .content {\n    height: 2000px;\n}\n```\n\nFrom [here](http://imweb.io/topic/577e64a47c99347163ec0b10)\n\n### 图片高度占位\n给图片提供一个容器，设置高度为0，根据图片比例使用padding-top设置百分值。\n```css\n.img-wrap{\n    position: relative;\n    height: 0;\n    padding-top: 50%；// 图片宽度的一半\n}\n.img{\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n```","slug":"fixed移动端解决","published":1,"updated":"2017-12-28T03:47:32.456Z","layout":"post","photos":[],"link":"","_id":"cjks5i9ib001kvmtibnfbqbtb","content":"<p>From <a href=\"http://efe.baidu.com/blog/mobile-fixed-layout/\" target=\"_blank\" rel=\"noopener\">here</a></p>\n<h3 id=\"fixed移动端解决\"><a href=\"#fixed移动端解决\" class=\"headerlink\" title=\"fixed移动端解决\"></a>fixed移动端解决</h3><p>主要是IOS上的。</p>\n<pre><code>思路：滚动内容在标签中，固定标签的位置。\n</code></pre><ol>\n<li>将所有非fixed定位的，也就是需要滚动的元素用block标签包裹。</li>\n<li>fixed定位的元素给fixed或者absolute都可以。</li>\n<li>包裹标签绝对定位在fixed和边界中间，<code>overflow-y: scroll</code>。</li>\n<li>标签内滚动不流畅，给包裹标签增加<code>-webkit-overflow-scrolling: touch;</code></li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">class</span>=<span class=\"string\">\"layout-scroll-fixed\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- fixed定位的头部 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 可以滚动的区域 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 内容在这里... --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- fixed定位的底部 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Footer...\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"submit\"</span>&gt;</span>提交<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">header</span>, <span class=\"selector-tag\">footer</span>, <span class=\"selector-tag\">main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">header</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: fixed;  <span class=\"comment\">/* fixed、absolute都可以 */</span></span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">footer</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">34px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">main</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* main绝对定位，进行内部滚动 */</span></span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">34px</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 使之可以滚动 */</span></span><br><span class=\"line\">    <span class=\"attribute\">overflow-y</span>: scroll;</span><br><span class=\"line\">    <span class=\"comment\">/* 增加该属性，可以增加弹性 */</span></span><br><span class=\"line\">    <span class=\"attribute\">-webkit-overflow-scrolling</span>: touch;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">main</span> <span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">2000px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From <a href=\"http://imweb.io/topic/577e64a47c99347163ec0b10\" target=\"_blank\" rel=\"noopener\">here</a></p>\n<h3 id=\"图片高度占位\"><a href=\"#图片高度占位\" class=\"headerlink\" title=\"图片高度占位\"></a>图片高度占位</h3><p>给图片提供一个容器，设置高度为0，根据图片比例使用padding-top设置百分值。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.img-wrap</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding-top</span>: <span class=\"number\">50%</span>；// 图片宽度的一半</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.img</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>From <a href=\"http://efe.baidu.com/blog/mobile-fixed-layout/\" target=\"_blank\" rel=\"noopener\">here</a></p>\n<h3 id=\"fixed移动端解决\"><a href=\"#fixed移动端解决\" class=\"headerlink\" title=\"fixed移动端解决\"></a>fixed移动端解决</h3><p>主要是IOS上的。</p>\n<pre><code>思路：滚动内容在标签中，固定标签的位置。\n</code></pre><ol>\n<li>将所有非fixed定位的，也就是需要滚动的元素用block标签包裹。</li>\n<li>fixed定位的元素给fixed或者absolute都可以。</li>\n<li>包裹标签绝对定位在fixed和边界中间，<code>overflow-y: scroll</code>。</li>\n<li>标签内滚动不流畅，给包裹标签增加<code>-webkit-overflow-scrolling: touch;</code></li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">class</span>=<span class=\"string\">\"layout-scroll-fixed\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- fixed定位的头部 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 可以滚动的区域 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 内容在这里... --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- fixed定位的底部 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Footer...\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"submit\"</span>&gt;</span>提交<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">header</span>, <span class=\"selector-tag\">footer</span>, <span class=\"selector-tag\">main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">header</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: fixed;  <span class=\"comment\">/* fixed、absolute都可以 */</span></span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">footer</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">34px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">main</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* main绝对定位，进行内部滚动 */</span></span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">34px</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 使之可以滚动 */</span></span><br><span class=\"line\">    <span class=\"attribute\">overflow-y</span>: scroll;</span><br><span class=\"line\">    <span class=\"comment\">/* 增加该属性，可以增加弹性 */</span></span><br><span class=\"line\">    <span class=\"attribute\">-webkit-overflow-scrolling</span>: touch;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">main</span> <span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">2000px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>From <a href=\"http://imweb.io/topic/577e64a47c99347163ec0b10\" target=\"_blank\" rel=\"noopener\">here</a></p>\n<h3 id=\"图片高度占位\"><a href=\"#图片高度占位\" class=\"headerlink\" title=\"图片高度占位\"></a>图片高度占位</h3><p>给图片提供一个容器，设置高度为0，根据图片比例使用padding-top设置百分值。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.img-wrap</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding-top</span>: <span class=\"number\">50%</span>；// 图片宽度的一半</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.img</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"GitHub大小写问题","date":"2017-04-17T16:00:00.000Z","comments":1,"_content":"\n经过几天的整理，将博客添加了网易云音乐，加入了谷歌搜索以及谷歌分析，虽然访客重来都是0，但是在用Google搜索到自己的博客的时候，还是挺高兴的。  \n结果第二天谷歌就发来邮件，检测到有几个死链，经过排查发现是hexo生成文件夹大小写的问题，之前没有太主要大小写问题，导致tags和categories中存在大小写共存，导致链接混乱的问题。  \n经过多次删除GitHub上分支，重新生成、部署Hexo依然无法解决大小写问题（本地生成、预览是没有问题的），问题应该从本地Git上出发。\n\n在Mac OS、Windows系统下，文件名是不区分大小写的，也就是你在同一个目录下，使用大小写不同的命名不能建立两个文件。Git在默认情况下，对大小写也是不敏感的，比如将git管理的一个文件名修改大小写，`git status`并不会检测到文件有变化。在GitHub下，文件名大小写会被区分。\n\n第一步，要做的是修改git的配置，使其对大小写敏感，这样才能修改github上的大小写问题。\n```bash\ngit config core.ignorecase false\n```\nps: 通过`git config -l`可以列出当前config\n\n第二步，将Hexo在GitHub上的master分支拉去下来（这里看自己的分支所在，我的是默认分支为hexo用于存储Hexo原始项目，master用于部署Hexo项目）。\n```bash\ngit pull master:master\ngit checkout master\n```\n\n第三步，移除错误大小写文件，比如我这里是将`./tags/javascript/index.html`移除，改为`./tags/JavaScript/index.html`\n```bash\ngit rm tags/javascript/index.html\n```\n这里需要注意的是pull下来的master中的tags文件夹只有JavaScript，可以先将文件夹下的index.html另存一份。然后这里执行`git rm`中的文件夹名字应该是小写的javascript，如果使用JavaScript会找不到该文件，这说明在git的保存中是区分大小写的。\n\n第四步，就是将另存的index.html剪切过来，并执行正常的`add commit push`就可以了。至此，Hexo中的错误大小写路径就能修改正常。同样，方法应该适用于GitHub其他项目。","source":"_posts/github大小写问题.md","raw":"---\ntitle: GitHub大小写问题\ndate: 2017-04-18\ntags: [Hexo, Git]\ncategories: \n- 杂记\ncomments: true\n---\n\n经过几天的整理，将博客添加了网易云音乐，加入了谷歌搜索以及谷歌分析，虽然访客重来都是0，但是在用Google搜索到自己的博客的时候，还是挺高兴的。  \n结果第二天谷歌就发来邮件，检测到有几个死链，经过排查发现是hexo生成文件夹大小写的问题，之前没有太主要大小写问题，导致tags和categories中存在大小写共存，导致链接混乱的问题。  \n经过多次删除GitHub上分支，重新生成、部署Hexo依然无法解决大小写问题（本地生成、预览是没有问题的），问题应该从本地Git上出发。\n\n在Mac OS、Windows系统下，文件名是不区分大小写的，也就是你在同一个目录下，使用大小写不同的命名不能建立两个文件。Git在默认情况下，对大小写也是不敏感的，比如将git管理的一个文件名修改大小写，`git status`并不会检测到文件有变化。在GitHub下，文件名大小写会被区分。\n\n第一步，要做的是修改git的配置，使其对大小写敏感，这样才能修改github上的大小写问题。\n```bash\ngit config core.ignorecase false\n```\nps: 通过`git config -l`可以列出当前config\n\n第二步，将Hexo在GitHub上的master分支拉去下来（这里看自己的分支所在，我的是默认分支为hexo用于存储Hexo原始项目，master用于部署Hexo项目）。\n```bash\ngit pull master:master\ngit checkout master\n```\n\n第三步，移除错误大小写文件，比如我这里是将`./tags/javascript/index.html`移除，改为`./tags/JavaScript/index.html`\n```bash\ngit rm tags/javascript/index.html\n```\n这里需要注意的是pull下来的master中的tags文件夹只有JavaScript，可以先将文件夹下的index.html另存一份。然后这里执行`git rm`中的文件夹名字应该是小写的javascript，如果使用JavaScript会找不到该文件，这说明在git的保存中是区分大小写的。\n\n第四步，就是将另存的index.html剪切过来，并执行正常的`add commit push`就可以了。至此，Hexo中的错误大小写路径就能修改正常。同样，方法应该适用于GitHub其他项目。","slug":"github大小写问题","published":1,"updated":"2017-12-28T03:47:32.456Z","layout":"post","photos":[],"link":"","_id":"cjks5i9ic001nvmtiham6til6","content":"<p>经过几天的整理，将博客添加了网易云音乐，加入了谷歌搜索以及谷歌分析，虽然访客重来都是0，但是在用Google搜索到自己的博客的时候，还是挺高兴的。<br>结果第二天谷歌就发来邮件，检测到有几个死链，经过排查发现是hexo生成文件夹大小写的问题，之前没有太主要大小写问题，导致tags和categories中存在大小写共存，导致链接混乱的问题。<br>经过多次删除GitHub上分支，重新生成、部署Hexo依然无法解决大小写问题（本地生成、预览是没有问题的），问题应该从本地Git上出发。</p>\n<p>在Mac OS、Windows系统下，文件名是不区分大小写的，也就是你在同一个目录下，使用大小写不同的命名不能建立两个文件。Git在默认情况下，对大小写也是不敏感的，比如将git管理的一个文件名修改大小写，<code>git status</code>并不会检测到文件有变化。在GitHub下，文件名大小写会被区分。</p>\n<p>第一步，要做的是修改git的配置，使其对大小写敏感，这样才能修改github上的大小写问题。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config core.ignorecase <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></p>\n<p>ps: 通过<code>git config -l</code>可以列出当前config</p>\n<p>第二步，将Hexo在GitHub上的master分支拉去下来（这里看自己的分支所在，我的是默认分支为hexo用于存储Hexo原始项目，master用于部署Hexo项目）。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull master:master</span><br><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure></p>\n<p>第三步，移除错误大小写文件，比如我这里是将<code>./tags/javascript/index.html</code>移除，改为<code>./tags/JavaScript/index.html</code><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm tags/javascript/index.html</span><br></pre></td></tr></table></figure></p>\n<p>这里需要注意的是pull下来的master中的tags文件夹只有JavaScript，可以先将文件夹下的index.html另存一份。然后这里执行<code>git rm</code>中的文件夹名字应该是小写的javascript，如果使用JavaScript会找不到该文件，这说明在git的保存中是区分大小写的。</p>\n<p>第四步，就是将另存的index.html剪切过来，并执行正常的<code>add commit push</code>就可以了。至此，Hexo中的错误大小写路径就能修改正常。同样，方法应该适用于GitHub其他项目。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>经过几天的整理，将博客添加了网易云音乐，加入了谷歌搜索以及谷歌分析，虽然访客重来都是0，但是在用Google搜索到自己的博客的时候，还是挺高兴的。<br>结果第二天谷歌就发来邮件，检测到有几个死链，经过排查发现是hexo生成文件夹大小写的问题，之前没有太主要大小写问题，导致tags和categories中存在大小写共存，导致链接混乱的问题。<br>经过多次删除GitHub上分支，重新生成、部署Hexo依然无法解决大小写问题（本地生成、预览是没有问题的），问题应该从本地Git上出发。</p>\n<p>在Mac OS、Windows系统下，文件名是不区分大小写的，也就是你在同一个目录下，使用大小写不同的命名不能建立两个文件。Git在默认情况下，对大小写也是不敏感的，比如将git管理的一个文件名修改大小写，<code>git status</code>并不会检测到文件有变化。在GitHub下，文件名大小写会被区分。</p>\n<p>第一步，要做的是修改git的配置，使其对大小写敏感，这样才能修改github上的大小写问题。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config core.ignorecase <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></p>\n<p>ps: 通过<code>git config -l</code>可以列出当前config</p>\n<p>第二步，将Hexo在GitHub上的master分支拉去下来（这里看自己的分支所在，我的是默认分支为hexo用于存储Hexo原始项目，master用于部署Hexo项目）。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull master:master</span><br><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure></p>\n<p>第三步，移除错误大小写文件，比如我这里是将<code>./tags/javascript/index.html</code>移除，改为<code>./tags/JavaScript/index.html</code><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm tags/javascript/index.html</span><br></pre></td></tr></table></figure></p>\n<p>这里需要注意的是pull下来的master中的tags文件夹只有JavaScript，可以先将文件夹下的index.html另存一份。然后这里执行<code>git rm</code>中的文件夹名字应该是小写的javascript，如果使用JavaScript会找不到该文件，这说明在git的保存中是区分大小写的。</p>\n<p>第四步，就是将另存的index.html剪切过来，并执行正常的<code>add commit push</code>就可以了。至此，Hexo中的错误大小写路径就能修改正常。同样，方法应该适用于GitHub其他项目。</p>\n"},{"title":"Redux学习","date":"2016-11-01T00:00:00.000Z","comments":1,"_content":"\naction: 规定动作以及数据\nreducer: 如何更新action中的数据。接受旧的action、state,返回新的。(state)\nstore: 调用reducer更改action中的数据\n\n定义action\naction一般形式：\nfunction addTodo(data) {\n\treturn {\n\t\ttype: type,\t\t\t\t\t\t\t// type属性是必须的\n\t\tdata: data\t\t\t\t\t\t\t// 其他属性，任意定义，保存数据\n\t}\n}\n\nreducer一般形式：\nfunction todos(state = [], action) {\t\t// 参数state,action state给默认值\n  switch (action.type) {\t\t\t\t\t\t\t\t// 对action进行switch判断\n    case ADD_TODO:\n      return [\n        ...state,\n        {\n          text: action.text,\n          completed: false\n        }\n      ]\n    case COMPLETE_TODO:\n      return [\n\n      ]\n    default:\n      return state\n  }\n}\n\n// 通过redux提供的combineReducers方法将多个reducer结合\nconst todoApp = combineReducers({\t\t\t\t\t\t\n  visibilityFilter,\n  todos\n})\nexport default todoApp;\n\nstore通过redux提供的createStore方法传递reducer方法作为参数去创建。\nlet store = createStore(todoApp) // todoApp为reducer\n\nreact-redux的Provider组件通过store属性传递。\n<Provider store={store}>\n  <App />\n</Provider>\n\n组件中通过react-redux的connect方法，将store映射到props上。\nfunction select(state) {\n  return {\n    visibleTodos: ...\n    visibilityFilter: ... \n  };\n}\nexport default connect(select)(App);  // App为组件名，select方法在connect中调用，会将store的getState()传递过去。te()值\n\n组件中通过connect传递过来的props中的dispatch方法更改\nconst { dispatch } = this.props \t// this.props为调用connect后自动传递god了的的。\ndispatch(completeTodo(index))\t\t\t// dispatch调用某action\n\n中间件\n\n// 中间件由三个嵌套的函数构成（会依次调用）：\n// 1) 第一层向其余两层提供分发函数和 getState 函数\n//    （因为你的中间件或 action creator 可能需要从 state 中读取数据）\n// 2) 第二层提供 next 函数，它允许你显式的将处理过的输入传递给下一个中间件或 Redux\n//    （这样 Redux 才能调用所有 reducer)。\n// 3) 第三层提供从上一个中间件或从 dispatch 传递来的 action，\n//     这个 action 可以调用下一个中间件（让 action 继续流动) 或者\n//     以想要的方式处理 action。\n\nvar thunkMiddleware = function ({ dispatch, getState }) {\n  // console.log('Enter thunkMiddleware');\n  return function(next) {\n    // console.log('Function \"next\" provided:', next);\n    return function (action) {\n      // console.log('Handling action:', action);\n      return typeof action === 'function' ?\n          action(dispatch, getState) :\n          next(action)\n    }\n  }\n}\n\n调用中间件\nimport { createStore, combineReducers, applyMiddleware } from 'redux'\nconst finalCreateStore = applyMiddleware(thunkMiddleware)(createStore)\n\n###\n\nFrom [Here](http://div.io/topic/1309?utm_source=tuicool&utm_medium=referral)\n首先，设计state\n```javascript\nlet state = {\n  todos: [{\n    id: 123,\n    text: 'todo item',\n    status: false\n  }],\n  activeFilter: SHOW_ALL\n}\n```\n设计action常量\n```javascript\n//ActionTypes.js 真正改动了数据的 actionType 在这里\nexport const ADD_ITEM = 'ADD_ITEM'\nexport const DELETE_ITEM = 'DELETE_ITEM'\nexport const DELETE_ITEMS = 'DELETE_ITEMS'\nexport const UPDATE_ITEM = 'UPDATE_ITEM'\nexport const UPDATE_ITEMS = 'UPDATE_ITEMS'\n\n//API.js 服务端接口统一放这里\nexport const API_TODOS = '/todos'\n\n//SocketTypes.js websocket 也触发了某个 action 改变了 state，单独放这里\nexport const SERVER_UPDATE = 'SERVER_UPDATE'\n\n//KeyCode.js 键盘的回车键与取消键对应的编码\nexport const ENTER_KEY = 13\nexport const ESCAPE_KEY = 27\n\n//FilterTypes.js 只是筛选数据，没有改变 state 的过滤 action 的常量\nexport const FILTER_ITEMS = 'FILTER_ITEMS'\nexport const SHOW_ALL = 'SHOW_ALL'\nexport const SHOW_ACTIVE = 'SHOW_ACTIVE'\nexport const SHOW_COMPLETED = 'SHOW_COMPLETED'\n```\n开始写actionCreaetor\n```javascript\n//index.js\nimport * as types from '../constants/ActionTypes'\nexport function addItem(text) {\n  return { type: types.ADD_ITEM, text }\n}\nexport function deleteItem(id) {\n  return { type: types.DELETE_ITEM, id }\n}\nexport function updateItem(data) {\n  return { type: types.UPDATE_ITEM, data }\n}\nexport function deleteItems(query) {\n  return { type: types.DELETE_ITEMS, query }\n}\nexport function updateItems(data) {\n  return { type: types.UPDATE_ITEMS, data }\n}\n```\nreducer\n```javacript\n//index.js\nimport * as types from '../constants/ActionTypes'\nexport function addItem(text) {\n  return { type: types.ADD_ITEM, text }\n}\nexport function deleteItem(id) {\n  return { type: types.DELETE_ITEM, id }\n}\nexport function updateItem(data) {\n  return { type: types.UPDATE_ITEM, data }\n}\nexport function deleteItems(query) {\n  return { type: types.DELETE_ITEMS, query }\n}\nexport function updateItems(data) {\n  return { type: types.UPDATE_ITEMS, data }\n}\n\n```\n\n###\n\nFrom [Here](https://github.com/kenberkeley/redux-simple-tutorial)\nstate是应用的状态，store是state的管理器,唯一的 (state == store.getState())\nstrore包括getState()、 dispatch(action)、 subscribe(listener)、 replaceReducer(nextReducer)\naction就是普通对象，用于规定数据格式。\nreducer用来更新state,根据action type修改state，返回新的state。","source":"_posts/redux学习.md","raw":"---\ntitle: Redux学习\ndate: 2016-11\ntags: [React, Redux]\ncategories: \n- React\ncomments: true\n---\n\naction: 规定动作以及数据\nreducer: 如何更新action中的数据。接受旧的action、state,返回新的。(state)\nstore: 调用reducer更改action中的数据\n\n定义action\naction一般形式：\nfunction addTodo(data) {\n\treturn {\n\t\ttype: type,\t\t\t\t\t\t\t// type属性是必须的\n\t\tdata: data\t\t\t\t\t\t\t// 其他属性，任意定义，保存数据\n\t}\n}\n\nreducer一般形式：\nfunction todos(state = [], action) {\t\t// 参数state,action state给默认值\n  switch (action.type) {\t\t\t\t\t\t\t\t// 对action进行switch判断\n    case ADD_TODO:\n      return [\n        ...state,\n        {\n          text: action.text,\n          completed: false\n        }\n      ]\n    case COMPLETE_TODO:\n      return [\n\n      ]\n    default:\n      return state\n  }\n}\n\n// 通过redux提供的combineReducers方法将多个reducer结合\nconst todoApp = combineReducers({\t\t\t\t\t\t\n  visibilityFilter,\n  todos\n})\nexport default todoApp;\n\nstore通过redux提供的createStore方法传递reducer方法作为参数去创建。\nlet store = createStore(todoApp) // todoApp为reducer\n\nreact-redux的Provider组件通过store属性传递。\n<Provider store={store}>\n  <App />\n</Provider>\n\n组件中通过react-redux的connect方法，将store映射到props上。\nfunction select(state) {\n  return {\n    visibleTodos: ...\n    visibilityFilter: ... \n  };\n}\nexport default connect(select)(App);  // App为组件名，select方法在connect中调用，会将store的getState()传递过去。te()值\n\n组件中通过connect传递过来的props中的dispatch方法更改\nconst { dispatch } = this.props \t// this.props为调用connect后自动传递god了的的。\ndispatch(completeTodo(index))\t\t\t// dispatch调用某action\n\n中间件\n\n// 中间件由三个嵌套的函数构成（会依次调用）：\n// 1) 第一层向其余两层提供分发函数和 getState 函数\n//    （因为你的中间件或 action creator 可能需要从 state 中读取数据）\n// 2) 第二层提供 next 函数，它允许你显式的将处理过的输入传递给下一个中间件或 Redux\n//    （这样 Redux 才能调用所有 reducer)。\n// 3) 第三层提供从上一个中间件或从 dispatch 传递来的 action，\n//     这个 action 可以调用下一个中间件（让 action 继续流动) 或者\n//     以想要的方式处理 action。\n\nvar thunkMiddleware = function ({ dispatch, getState }) {\n  // console.log('Enter thunkMiddleware');\n  return function(next) {\n    // console.log('Function \"next\" provided:', next);\n    return function (action) {\n      // console.log('Handling action:', action);\n      return typeof action === 'function' ?\n          action(dispatch, getState) :\n          next(action)\n    }\n  }\n}\n\n调用中间件\nimport { createStore, combineReducers, applyMiddleware } from 'redux'\nconst finalCreateStore = applyMiddleware(thunkMiddleware)(createStore)\n\n###\n\nFrom [Here](http://div.io/topic/1309?utm_source=tuicool&utm_medium=referral)\n首先，设计state\n```javascript\nlet state = {\n  todos: [{\n    id: 123,\n    text: 'todo item',\n    status: false\n  }],\n  activeFilter: SHOW_ALL\n}\n```\n设计action常量\n```javascript\n//ActionTypes.js 真正改动了数据的 actionType 在这里\nexport const ADD_ITEM = 'ADD_ITEM'\nexport const DELETE_ITEM = 'DELETE_ITEM'\nexport const DELETE_ITEMS = 'DELETE_ITEMS'\nexport const UPDATE_ITEM = 'UPDATE_ITEM'\nexport const UPDATE_ITEMS = 'UPDATE_ITEMS'\n\n//API.js 服务端接口统一放这里\nexport const API_TODOS = '/todos'\n\n//SocketTypes.js websocket 也触发了某个 action 改变了 state，单独放这里\nexport const SERVER_UPDATE = 'SERVER_UPDATE'\n\n//KeyCode.js 键盘的回车键与取消键对应的编码\nexport const ENTER_KEY = 13\nexport const ESCAPE_KEY = 27\n\n//FilterTypes.js 只是筛选数据，没有改变 state 的过滤 action 的常量\nexport const FILTER_ITEMS = 'FILTER_ITEMS'\nexport const SHOW_ALL = 'SHOW_ALL'\nexport const SHOW_ACTIVE = 'SHOW_ACTIVE'\nexport const SHOW_COMPLETED = 'SHOW_COMPLETED'\n```\n开始写actionCreaetor\n```javascript\n//index.js\nimport * as types from '../constants/ActionTypes'\nexport function addItem(text) {\n  return { type: types.ADD_ITEM, text }\n}\nexport function deleteItem(id) {\n  return { type: types.DELETE_ITEM, id }\n}\nexport function updateItem(data) {\n  return { type: types.UPDATE_ITEM, data }\n}\nexport function deleteItems(query) {\n  return { type: types.DELETE_ITEMS, query }\n}\nexport function updateItems(data) {\n  return { type: types.UPDATE_ITEMS, data }\n}\n```\nreducer\n```javacript\n//index.js\nimport * as types from '../constants/ActionTypes'\nexport function addItem(text) {\n  return { type: types.ADD_ITEM, text }\n}\nexport function deleteItem(id) {\n  return { type: types.DELETE_ITEM, id }\n}\nexport function updateItem(data) {\n  return { type: types.UPDATE_ITEM, data }\n}\nexport function deleteItems(query) {\n  return { type: types.DELETE_ITEMS, query }\n}\nexport function updateItems(data) {\n  return { type: types.UPDATE_ITEMS, data }\n}\n\n```\n\n###\n\nFrom [Here](https://github.com/kenberkeley/redux-simple-tutorial)\nstate是应用的状态，store是state的管理器,唯一的 (state == store.getState())\nstrore包括getState()、 dispatch(action)、 subscribe(listener)、 replaceReducer(nextReducer)\naction就是普通对象，用于规定数据格式。\nreducer用来更新state,根据action type修改state，返回新的state。","slug":"redux学习","published":1,"updated":"2017-12-28T03:47:32.462Z","layout":"post","photos":[],"link":"","_id":"cjks5i9ie001qvmti9muyxxf5","content":"<p>action: 规定动作以及数据<br>reducer: 如何更新action中的数据。接受旧的action、state,返回新的。(state)<br>store: 调用reducer更改action中的数据</p>\n<p>定义action<br>action一般形式：<br>function addTodo(data) {<br>    return {<br>        type: type,                            // type属性是必须的<br>        data: data                            // 其他属性，任意定义，保存数据<br>    }<br>}</p>\n<p>reducer一般形式：<br>function todos(state = [], action) {        // 参数state,action state给默认值<br>  switch (action.type) {                                // 对action进行switch判断<br>    case ADD_TODO:<br>      return [<br>        …state,<br>        {<br>          text: action.text,<br>          completed: false<br>        }<br>      ]<br>    case COMPLETE_TODO:<br>      return [</p>\n<pre><code>  ]\ndefault:\n  return state\n</code></pre><p>  }<br>}</p>\n<p>// 通过redux提供的combineReducers方法将多个reducer结合<br>const todoApp = combineReducers({<br>  visibilityFilter,<br>  todos<br>})<br>export default todoApp;</p>\n<p>store通过redux提供的createStore方法传递reducer方法作为参数去创建。<br>let store = createStore(todoApp) // todoApp为reducer</p>\n<p>react-redux的Provider组件通过store属性传递。</p>\n<provider store=\"{store}\"><br>  <app><br></app></provider>\n\n<p>组件中通过react-redux的connect方法，将store映射到props上。<br>function select(state) {<br>  return {<br>    visibleTodos: …<br>    visibilityFilter: …<br>  };<br>}<br>export default connect(select)(App);  // App为组件名，select方法在connect中调用，会将store的getState()传递过去。te()值</p>\n<p>组件中通过connect传递过来的props中的dispatch方法更改<br>const { dispatch } = this.props     // this.props为调用connect后自动传递god了的的。<br>dispatch(completeTodo(index))            // dispatch调用某action</p>\n<p>中间件</p>\n<p>// 中间件由三个嵌套的函数构成（会依次调用）：<br>// 1) 第一层向其余两层提供分发函数和 getState 函数<br>//    （因为你的中间件或 action creator 可能需要从 state 中读取数据）<br>// 2) 第二层提供 next 函数，它允许你显式的将处理过的输入传递给下一个中间件或 Redux<br>//    （这样 Redux 才能调用所有 reducer)。<br>// 3) 第三层提供从上一个中间件或从 dispatch 传递来的 action，<br>//     这个 action 可以调用下一个中间件（让 action 继续流动) 或者<br>//     以想要的方式处理 action。</p>\n<p>var thunkMiddleware = function ({ dispatch, getState }) {<br>  // console.log(‘Enter thunkMiddleware’);<br>  return function(next) {<br>    // console.log(‘Function “next” provided:’, next);<br>    return function (action) {<br>      // console.log(‘Handling action:’, action);<br>      return typeof action === ‘function’ ?<br>          action(dispatch, getState) :<br>          next(action)<br>    }<br>  }<br>}</p>\n<p>调用中间件<br>import { createStore, combineReducers, applyMiddleware } from ‘redux’<br>const finalCreateStore = applyMiddleware(thunkMiddleware)(createStore)</p>\n<p>###</p>\n<p>From <a href=\"http://div.io/topic/1309?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">Here</a><br>首先，设计state<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> state = &#123;</span><br><span class=\"line\">  todos: [&#123;</span><br><span class=\"line\">    id: <span class=\"number\">123</span>,</span><br><span class=\"line\">    text: <span class=\"string\">'todo item'</span>,</span><br><span class=\"line\">    status: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\">  activeFilter: SHOW_ALL</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>设计action常量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ActionTypes.js 真正改动了数据的 actionType 在这里</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ADD_ITEM = <span class=\"string\">'ADD_ITEM'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DELETE_ITEM = <span class=\"string\">'DELETE_ITEM'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DELETE_ITEMS = <span class=\"string\">'DELETE_ITEMS'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> UPDATE_ITEM = <span class=\"string\">'UPDATE_ITEM'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> UPDATE_ITEMS = <span class=\"string\">'UPDATE_ITEMS'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//API.js 服务端接口统一放这里</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> API_TODOS = <span class=\"string\">'/todos'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//SocketTypes.js websocket 也触发了某个 action 改变了 state，单独放这里</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SERVER_UPDATE = <span class=\"string\">'SERVER_UPDATE'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//KeyCode.js 键盘的回车键与取消键对应的编码</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ENTER_KEY = <span class=\"number\">13</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ESCAPE_KEY = <span class=\"number\">27</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//FilterTypes.js 只是筛选数据，没有改变 state 的过滤 action 的常量</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> FILTER_ITEMS = <span class=\"string\">'FILTER_ITEMS'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_ALL = <span class=\"string\">'SHOW_ALL'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_ACTIVE = <span class=\"string\">'SHOW_ACTIVE'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_COMPLETED = <span class=\"string\">'SHOW_COMPLETED'</span></span><br></pre></td></tr></table></figure></p>\n<p>开始写actionCreaetor<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> types <span class=\"keyword\">from</span> <span class=\"string\">'../constants/ActionTypes'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addItem</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.ADD_ITEM, text &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deleteItem</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.DELETE_ITEM, id &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateItem</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.UPDATE_ITEM, data &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deleteItems</span>(<span class=\"params\">query</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.DELETE_ITEMS, query &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateItems</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.UPDATE_ITEMS, data &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>reducer<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//index.js</span><br><span class=\"line\">import * as types from &apos;../constants/ActionTypes&apos;</span><br><span class=\"line\">export function addItem(text) &#123;</span><br><span class=\"line\">  return &#123; type: types.ADD_ITEM, text &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export function deleteItem(id) &#123;</span><br><span class=\"line\">  return &#123; type: types.DELETE_ITEM, id &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export function updateItem(data) &#123;</span><br><span class=\"line\">  return &#123; type: types.UPDATE_ITEM, data &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export function deleteItems(query) &#123;</span><br><span class=\"line\">  return &#123; type: types.DELETE_ITEMS, query &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export function updateItems(data) &#123;</span><br><span class=\"line\">  return &#123; type: types.UPDATE_ITEMS, data &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>###</p>\n<p>From <a href=\"https://github.com/kenberkeley/redux-simple-tutorial\" target=\"_blank\" rel=\"noopener\">Here</a><br>state是应用的状态，store是state的管理器,唯一的 (state == store.getState())<br>strore包括getState()、 dispatch(action)、 subscribe(listener)、 replaceReducer(nextReducer)<br>action就是普通对象，用于规定数据格式。<br>reducer用来更新state,根据action type修改state，返回新的state。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>action: 规定动作以及数据<br>reducer: 如何更新action中的数据。接受旧的action、state,返回新的。(state)<br>store: 调用reducer更改action中的数据</p>\n<p>定义action<br>action一般形式：<br>function addTodo(data) {<br>    return {<br>        type: type,                            // type属性是必须的<br>        data: data                            // 其他属性，任意定义，保存数据<br>    }<br>}</p>\n<p>reducer一般形式：<br>function todos(state = [], action) {        // 参数state,action state给默认值<br>  switch (action.type) {                                // 对action进行switch判断<br>    case ADD_TODO:<br>      return [<br>        …state,<br>        {<br>          text: action.text,<br>          completed: false<br>        }<br>      ]<br>    case COMPLETE_TODO:<br>      return [</p>\n<pre><code>  ]\ndefault:\n  return state\n</code></pre><p>  }<br>}</p>\n<p>// 通过redux提供的combineReducers方法将多个reducer结合<br>const todoApp = combineReducers({<br>  visibilityFilter,<br>  todos<br>})<br>export default todoApp;</p>\n<p>store通过redux提供的createStore方法传递reducer方法作为参数去创建。<br>let store = createStore(todoApp) // todoApp为reducer</p>\n<p>react-redux的Provider组件通过store属性传递。</p>\n<provider store=\"{store}\"><br>  <app><br></app></provider>\n\n<p>组件中通过react-redux的connect方法，将store映射到props上。<br>function select(state) {<br>  return {<br>    visibleTodos: …<br>    visibilityFilter: …<br>  };<br>}<br>export default connect(select)(App);  // App为组件名，select方法在connect中调用，会将store的getState()传递过去。te()值</p>\n<p>组件中通过connect传递过来的props中的dispatch方法更改<br>const { dispatch } = this.props     // this.props为调用connect后自动传递god了的的。<br>dispatch(completeTodo(index))            // dispatch调用某action</p>\n<p>中间件</p>\n<p>// 中间件由三个嵌套的函数构成（会依次调用）：<br>// 1) 第一层向其余两层提供分发函数和 getState 函数<br>//    （因为你的中间件或 action creator 可能需要从 state 中读取数据）<br>// 2) 第二层提供 next 函数，它允许你显式的将处理过的输入传递给下一个中间件或 Redux<br>//    （这样 Redux 才能调用所有 reducer)。<br>// 3) 第三层提供从上一个中间件或从 dispatch 传递来的 action，<br>//     这个 action 可以调用下一个中间件（让 action 继续流动) 或者<br>//     以想要的方式处理 action。</p>\n<p>var thunkMiddleware = function ({ dispatch, getState }) {<br>  // console.log(‘Enter thunkMiddleware’);<br>  return function(next) {<br>    // console.log(‘Function “next” provided:’, next);<br>    return function (action) {<br>      // console.log(‘Handling action:’, action);<br>      return typeof action === ‘function’ ?<br>          action(dispatch, getState) :<br>          next(action)<br>    }<br>  }<br>}</p>\n<p>调用中间件<br>import { createStore, combineReducers, applyMiddleware } from ‘redux’<br>const finalCreateStore = applyMiddleware(thunkMiddleware)(createStore)</p>\n<p>###</p>\n<p>From <a href=\"http://div.io/topic/1309?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">Here</a><br>首先，设计state<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> state = &#123;</span><br><span class=\"line\">  todos: [&#123;</span><br><span class=\"line\">    id: <span class=\"number\">123</span>,</span><br><span class=\"line\">    text: <span class=\"string\">'todo item'</span>,</span><br><span class=\"line\">    status: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\">  activeFilter: SHOW_ALL</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>设计action常量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ActionTypes.js 真正改动了数据的 actionType 在这里</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ADD_ITEM = <span class=\"string\">'ADD_ITEM'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DELETE_ITEM = <span class=\"string\">'DELETE_ITEM'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DELETE_ITEMS = <span class=\"string\">'DELETE_ITEMS'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> UPDATE_ITEM = <span class=\"string\">'UPDATE_ITEM'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> UPDATE_ITEMS = <span class=\"string\">'UPDATE_ITEMS'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//API.js 服务端接口统一放这里</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> API_TODOS = <span class=\"string\">'/todos'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//SocketTypes.js websocket 也触发了某个 action 改变了 state，单独放这里</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SERVER_UPDATE = <span class=\"string\">'SERVER_UPDATE'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//KeyCode.js 键盘的回车键与取消键对应的编码</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ENTER_KEY = <span class=\"number\">13</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ESCAPE_KEY = <span class=\"number\">27</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//FilterTypes.js 只是筛选数据，没有改变 state 的过滤 action 的常量</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> FILTER_ITEMS = <span class=\"string\">'FILTER_ITEMS'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_ALL = <span class=\"string\">'SHOW_ALL'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_ACTIVE = <span class=\"string\">'SHOW_ACTIVE'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_COMPLETED = <span class=\"string\">'SHOW_COMPLETED'</span></span><br></pre></td></tr></table></figure></p>\n<p>开始写actionCreaetor<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> types <span class=\"keyword\">from</span> <span class=\"string\">'../constants/ActionTypes'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addItem</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.ADD_ITEM, text &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deleteItem</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.DELETE_ITEM, id &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateItem</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.UPDATE_ITEM, data &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deleteItems</span>(<span class=\"params\">query</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.DELETE_ITEMS, query &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateItems</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.UPDATE_ITEMS, data &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>reducer<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//index.js</span><br><span class=\"line\">import * as types from &apos;../constants/ActionTypes&apos;</span><br><span class=\"line\">export function addItem(text) &#123;</span><br><span class=\"line\">  return &#123; type: types.ADD_ITEM, text &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export function deleteItem(id) &#123;</span><br><span class=\"line\">  return &#123; type: types.DELETE_ITEM, id &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export function updateItem(data) &#123;</span><br><span class=\"line\">  return &#123; type: types.UPDATE_ITEM, data &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export function deleteItems(query) &#123;</span><br><span class=\"line\">  return &#123; type: types.DELETE_ITEMS, query &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export function updateItems(data) &#123;</span><br><span class=\"line\">  return &#123; type: types.UPDATE_ITEMS, data &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>###</p>\n<p>From <a href=\"https://github.com/kenberkeley/redux-simple-tutorial\" target=\"_blank\" rel=\"noopener\">Here</a><br>state是应用的状态，store是state的管理器,唯一的 (state == store.getState())<br>strore包括getState()、 dispatch(action)、 subscribe(listener)、 replaceReducer(nextReducer)<br>action就是普通对象，用于规定数据格式。<br>reducer用来更新state,根据action type修改state，返回新的state。</p>\n"},{"title":"gulp初次实践","date":"2016-06-30T16:00:00.000Z","comments":1,"_content":"\ngulp是前端构建工具，通过一系列gulp插件，可以实现实时监控、格式化代码、合并代码、压缩代码、测试功能等功能。\n\n------\n\n前提：node环境，会使用基本命令行\n\n------\n\n### 全局安装gulp\n```\nsudo npm install -g gulp\n```\nWindows环境下不需要sudo命令\n\n### 项目搭建\n#### 第一步，包管理文件 package.json\n通过cd命令进入项目目录，执行`npm init`，之后可以一路的回车来创建`package.json`文件。关于此配置文件的内容挺简单的，可以自己看下，然后搜索下。\n#### 第二步，寻找、安装所需要的插件\n项目目录安装gulp，并写入配置文件package.json中。\n```\nnpm install --save-dev gulp\n```\n这样会把gulp的依赖写入到package.json文件中。\n\n#### 添加需要的各个gulp插件\n比如这里我用到了gulp-clean-css用于css压缩、gulp-uglify用于js压缩、gulp-watch用于文件监控、gulp-sass用于sass编译。\n安装各插件(方法相同)\n```\nnpm install --save-dev gulp-uglify\n```\n#### 第三步，配置gulp任务\n在项目目录下创建文件`gulpfile.js`，用于编写gulp任务。\ngulp基础语法比较简单，管道方式也很容易理解。\n这里我的项目目录如下：\n```\n├── dist\n│   ├── css\n│   ├── img\n│   └── js\n├── gulpfile.js\n├── index.html\n├── node_modules\n│   ├── eruda\n│   ├── gulp\n│   ├── gulp-clean-css\n│   ├── gulp-sass\n│   ├── gulp-uglify\n├── package.json\n└── src\n    ├── css\n    ├── img\n    ├── js\n    ├── libs\n    └── sass\n```\n其中src文件夹中是源文件，\ndist文件夹下是项目用到的压缩后的js、css文件。\n\ngulp任务配置文件gulpfile.js如下：\n```javascript\nvar gulp = require('gulp'),\n\t\tcleanCSS = require('gulp-clean-css'),\n\t\tuglify = require('gulp-uglify'),\n\t\twatch = require('gulp-watch'),\n\t\tsass = require('gulp-sass');\n\ngulp.task('default', function() {\n\t// 默认任务代码\n});\n\n// 压缩文件\ngulp.task('minfile', function() {\n\t// sass\n\tgulp.src('src/sass/*.scss')\n\t\t.pipe(sass())\n\t\t.pipe(gulp.dest('src/css'))\n\t\t.pipe(cleanCSS())\n\t\t.pipe(gulp.dest('dist/css'));\n\t// js\n\tgulp.src('src/js/*.js')\n\t\t.pipe(uglify())\n\t\t.pipe(gulp.dest('dist/js'));\n\t// img\n\tgulp.src('src/img/*')\n\t\t.pipe(gulp.dest('dist/img'));\n});\n\n// 监听\ngulp.task('watchFile', ['minfile'], function() {\n\tgulp.watch('src/**/*', ['minfile']);\n});\n\ngulp.task('default', ['minfile', 'watchFile']);\n```\ngulp API只有五个：task，src，dest，watch和run。\ntask用于定义任务；src用于表示源文件路径；dest用于输出，写入新文件；watch用于监听文件变化；run用于执行任务。\nps:上面的pipe表示管道。\n#### 第四步，开启任务\n项目目录下，执行`gulp`即可。之后就可以开始编写代码了。\n\n---------\n\n第一次对gulp的尝试，也是第一次对构建工具的尝试，其中只是用到了一些最简单也是最常用的插件，给我的感觉就是省去了每次手动编译、压缩等操作，这次使用就像一次Hello World。","source":"_posts/gulp初次实践.md","raw":"---\ntitle: gulp初次实践\ndate: 2016-06-31\ntags: [JavaScript, gulp, 构建工具]\ncategories: \n- JavaScript\ncomments: true\n---\n\ngulp是前端构建工具，通过一系列gulp插件，可以实现实时监控、格式化代码、合并代码、压缩代码、测试功能等功能。\n\n------\n\n前提：node环境，会使用基本命令行\n\n------\n\n### 全局安装gulp\n```\nsudo npm install -g gulp\n```\nWindows环境下不需要sudo命令\n\n### 项目搭建\n#### 第一步，包管理文件 package.json\n通过cd命令进入项目目录，执行`npm init`，之后可以一路的回车来创建`package.json`文件。关于此配置文件的内容挺简单的，可以自己看下，然后搜索下。\n#### 第二步，寻找、安装所需要的插件\n项目目录安装gulp，并写入配置文件package.json中。\n```\nnpm install --save-dev gulp\n```\n这样会把gulp的依赖写入到package.json文件中。\n\n#### 添加需要的各个gulp插件\n比如这里我用到了gulp-clean-css用于css压缩、gulp-uglify用于js压缩、gulp-watch用于文件监控、gulp-sass用于sass编译。\n安装各插件(方法相同)\n```\nnpm install --save-dev gulp-uglify\n```\n#### 第三步，配置gulp任务\n在项目目录下创建文件`gulpfile.js`，用于编写gulp任务。\ngulp基础语法比较简单，管道方式也很容易理解。\n这里我的项目目录如下：\n```\n├── dist\n│   ├── css\n│   ├── img\n│   └── js\n├── gulpfile.js\n├── index.html\n├── node_modules\n│   ├── eruda\n│   ├── gulp\n│   ├── gulp-clean-css\n│   ├── gulp-sass\n│   ├── gulp-uglify\n├── package.json\n└── src\n    ├── css\n    ├── img\n    ├── js\n    ├── libs\n    └── sass\n```\n其中src文件夹中是源文件，\ndist文件夹下是项目用到的压缩后的js、css文件。\n\ngulp任务配置文件gulpfile.js如下：\n```javascript\nvar gulp = require('gulp'),\n\t\tcleanCSS = require('gulp-clean-css'),\n\t\tuglify = require('gulp-uglify'),\n\t\twatch = require('gulp-watch'),\n\t\tsass = require('gulp-sass');\n\ngulp.task('default', function() {\n\t// 默认任务代码\n});\n\n// 压缩文件\ngulp.task('minfile', function() {\n\t// sass\n\tgulp.src('src/sass/*.scss')\n\t\t.pipe(sass())\n\t\t.pipe(gulp.dest('src/css'))\n\t\t.pipe(cleanCSS())\n\t\t.pipe(gulp.dest('dist/css'));\n\t// js\n\tgulp.src('src/js/*.js')\n\t\t.pipe(uglify())\n\t\t.pipe(gulp.dest('dist/js'));\n\t// img\n\tgulp.src('src/img/*')\n\t\t.pipe(gulp.dest('dist/img'));\n});\n\n// 监听\ngulp.task('watchFile', ['minfile'], function() {\n\tgulp.watch('src/**/*', ['minfile']);\n});\n\ngulp.task('default', ['minfile', 'watchFile']);\n```\ngulp API只有五个：task，src，dest，watch和run。\ntask用于定义任务；src用于表示源文件路径；dest用于输出，写入新文件；watch用于监听文件变化；run用于执行任务。\nps:上面的pipe表示管道。\n#### 第四步，开启任务\n项目目录下，执行`gulp`即可。之后就可以开始编写代码了。\n\n---------\n\n第一次对gulp的尝试，也是第一次对构建工具的尝试，其中只是用到了一些最简单也是最常用的插件，给我的感觉就是省去了每次手动编译、压缩等操作，这次使用就像一次Hello World。","slug":"gulp初次实践","published":1,"updated":"2017-12-28T03:47:32.456Z","layout":"post","photos":[],"link":"","_id":"cjks5i9if001uvmtitblmvq82","content":"<p>gulp是前端构建工具，通过一系列gulp插件，可以实现实时监控、格式化代码、合并代码、压缩代码、测试功能等功能。</p>\n<hr>\n<p>前提：node环境，会使用基本命令行</p>\n<hr>\n<h3 id=\"全局安装gulp\"><a href=\"#全局安装gulp\" class=\"headerlink\" title=\"全局安装gulp\"></a>全局安装gulp</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm <span class=\"keyword\">install</span> -g gulp</span><br></pre></td></tr></table></figure>\n<p>Windows环境下不需要sudo命令</p>\n<h3 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h3><h4 id=\"第一步，包管理文件-package-json\"><a href=\"#第一步，包管理文件-package-json\" class=\"headerlink\" title=\"第一步，包管理文件 package.json\"></a>第一步，包管理文件 package.json</h4><p>通过cd命令进入项目目录，执行<code>npm init</code>，之后可以一路的回车来创建<code>package.json</code>文件。关于此配置文件的内容挺简单的，可以自己看下，然后搜索下。</p>\n<h4 id=\"第二步，寻找、安装所需要的插件\"><a href=\"#第二步，寻找、安装所需要的插件\" class=\"headerlink\" title=\"第二步，寻找、安装所需要的插件\"></a>第二步，寻找、安装所需要的插件</h4><p>项目目录安装gulp，并写入配置文件package.json中。<br><figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --<span class=\"built_in\">save</span>-<span class=\"built_in\">dev</span> gulp</span><br></pre></td></tr></table></figure></p>\n<p>这样会把gulp的依赖写入到package.json文件中。</p>\n<h4 id=\"添加需要的各个gulp插件\"><a href=\"#添加需要的各个gulp插件\" class=\"headerlink\" title=\"添加需要的各个gulp插件\"></a>添加需要的各个gulp插件</h4><p>比如这里我用到了gulp-clean-css用于css压缩、gulp-uglify用于js压缩、gulp-watch用于文件监控、gulp-sass用于sass编译。<br>安装各插件(方法相同)<br><figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --<span class=\"built_in\">save</span>-<span class=\"built_in\">dev</span> gulp-uglify</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"第三步，配置gulp任务\"><a href=\"#第三步，配置gulp任务\" class=\"headerlink\" title=\"第三步，配置gulp任务\"></a>第三步，配置gulp任务</h4><p>在项目目录下创建文件<code>gulpfile.js</code>，用于编写gulp任务。<br>gulp基础语法比较简单，管道方式也很容易理解。<br>这里我的项目目录如下：<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── dist</span><br><span class=\"line\">│   ├── css</span><br><span class=\"line\">│   ├── img</span><br><span class=\"line\">│   └── js</span><br><span class=\"line\">├── gulpfile.js</span><br><span class=\"line\">├── index.html</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">│   ├── eruda</span><br><span class=\"line\">│   ├── gulp</span><br><span class=\"line\">│   ├── gulp-clean-css</span><br><span class=\"line\">│   ├── gulp-sass</span><br><span class=\"line\">│   ├── gulp-uglify</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── css</span><br><span class=\"line\">    ├── img</span><br><span class=\"line\">    ├── js</span><br><span class=\"line\">    ├── libs</span><br><span class=\"line\">    └── sass</span><br></pre></td></tr></table></figure></p>\n<p>其中src文件夹中是源文件，<br>dist文件夹下是项目用到的压缩后的js、css文件。</p>\n<p>gulp任务配置文件gulpfile.js如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>),</span><br><span class=\"line\">\t\tcleanCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-clean-css'</span>),</span><br><span class=\"line\">\t\tuglify = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-uglify'</span>),</span><br><span class=\"line\">\t\twatch = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-watch'</span>),</span><br><span class=\"line\">\t\tsass = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-sass'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'default'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 默认任务代码</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 压缩文件</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'minfile'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// sass</span></span><br><span class=\"line\">\tgulp.src(<span class=\"string\">'src/sass/*.scss'</span>)</span><br><span class=\"line\">\t\t.pipe(sass())</span><br><span class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'src/css'</span>))</span><br><span class=\"line\">\t\t.pipe(cleanCSS())</span><br><span class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/css'</span>));</span><br><span class=\"line\">\t<span class=\"comment\">// js</span></span><br><span class=\"line\">\tgulp.src(<span class=\"string\">'src/js/*.js'</span>)</span><br><span class=\"line\">\t\t.pipe(uglify())</span><br><span class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/js'</span>));</span><br><span class=\"line\">\t<span class=\"comment\">// img</span></span><br><span class=\"line\">\tgulp.src(<span class=\"string\">'src/img/*'</span>)</span><br><span class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/img'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'watchFile'</span>, [<span class=\"string\">'minfile'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\tgulp.watch(<span class=\"string\">'src/**/*'</span>, [<span class=\"string\">'minfile'</span>]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'default'</span>, [<span class=\"string\">'minfile'</span>, <span class=\"string\">'watchFile'</span>]);</span><br></pre></td></tr></table></figure></p>\n<p>gulp API只有五个：task，src，dest，watch和run。<br>task用于定义任务；src用于表示源文件路径；dest用于输出，写入新文件；watch用于监听文件变化；run用于执行任务。<br>ps:上面的pipe表示管道。</p>\n<h4 id=\"第四步，开启任务\"><a href=\"#第四步，开启任务\" class=\"headerlink\" title=\"第四步，开启任务\"></a>第四步，开启任务</h4><p>项目目录下，执行<code>gulp</code>即可。之后就可以开始编写代码了。</p>\n<hr>\n<p>第一次对gulp的尝试，也是第一次对构建工具的尝试，其中只是用到了一些最简单也是最常用的插件，给我的感觉就是省去了每次手动编译、压缩等操作，这次使用就像一次Hello World。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>gulp是前端构建工具，通过一系列gulp插件，可以实现实时监控、格式化代码、合并代码、压缩代码、测试功能等功能。</p>\n<hr>\n<p>前提：node环境，会使用基本命令行</p>\n<hr>\n<h3 id=\"全局安装gulp\"><a href=\"#全局安装gulp\" class=\"headerlink\" title=\"全局安装gulp\"></a>全局安装gulp</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm <span class=\"keyword\">install</span> -g gulp</span><br></pre></td></tr></table></figure>\n<p>Windows环境下不需要sudo命令</p>\n<h3 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h3><h4 id=\"第一步，包管理文件-package-json\"><a href=\"#第一步，包管理文件-package-json\" class=\"headerlink\" title=\"第一步，包管理文件 package.json\"></a>第一步，包管理文件 package.json</h4><p>通过cd命令进入项目目录，执行<code>npm init</code>，之后可以一路的回车来创建<code>package.json</code>文件。关于此配置文件的内容挺简单的，可以自己看下，然后搜索下。</p>\n<h4 id=\"第二步，寻找、安装所需要的插件\"><a href=\"#第二步，寻找、安装所需要的插件\" class=\"headerlink\" title=\"第二步，寻找、安装所需要的插件\"></a>第二步，寻找、安装所需要的插件</h4><p>项目目录安装gulp，并写入配置文件package.json中。<br><figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --<span class=\"built_in\">save</span>-<span class=\"built_in\">dev</span> gulp</span><br></pre></td></tr></table></figure></p>\n<p>这样会把gulp的依赖写入到package.json文件中。</p>\n<h4 id=\"添加需要的各个gulp插件\"><a href=\"#添加需要的各个gulp插件\" class=\"headerlink\" title=\"添加需要的各个gulp插件\"></a>添加需要的各个gulp插件</h4><p>比如这里我用到了gulp-clean-css用于css压缩、gulp-uglify用于js压缩、gulp-watch用于文件监控、gulp-sass用于sass编译。<br>安装各插件(方法相同)<br><figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --<span class=\"built_in\">save</span>-<span class=\"built_in\">dev</span> gulp-uglify</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"第三步，配置gulp任务\"><a href=\"#第三步，配置gulp任务\" class=\"headerlink\" title=\"第三步，配置gulp任务\"></a>第三步，配置gulp任务</h4><p>在项目目录下创建文件<code>gulpfile.js</code>，用于编写gulp任务。<br>gulp基础语法比较简单，管道方式也很容易理解。<br>这里我的项目目录如下：<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── dist</span><br><span class=\"line\">│   ├── css</span><br><span class=\"line\">│   ├── img</span><br><span class=\"line\">│   └── js</span><br><span class=\"line\">├── gulpfile.js</span><br><span class=\"line\">├── index.html</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">│   ├── eruda</span><br><span class=\"line\">│   ├── gulp</span><br><span class=\"line\">│   ├── gulp-clean-css</span><br><span class=\"line\">│   ├── gulp-sass</span><br><span class=\"line\">│   ├── gulp-uglify</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── css</span><br><span class=\"line\">    ├── img</span><br><span class=\"line\">    ├── js</span><br><span class=\"line\">    ├── libs</span><br><span class=\"line\">    └── sass</span><br></pre></td></tr></table></figure></p>\n<p>其中src文件夹中是源文件，<br>dist文件夹下是项目用到的压缩后的js、css文件。</p>\n<p>gulp任务配置文件gulpfile.js如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>),</span><br><span class=\"line\">\t\tcleanCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-clean-css'</span>),</span><br><span class=\"line\">\t\tuglify = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-uglify'</span>),</span><br><span class=\"line\">\t\twatch = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-watch'</span>),</span><br><span class=\"line\">\t\tsass = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-sass'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'default'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 默认任务代码</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 压缩文件</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'minfile'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// sass</span></span><br><span class=\"line\">\tgulp.src(<span class=\"string\">'src/sass/*.scss'</span>)</span><br><span class=\"line\">\t\t.pipe(sass())</span><br><span class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'src/css'</span>))</span><br><span class=\"line\">\t\t.pipe(cleanCSS())</span><br><span class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/css'</span>));</span><br><span class=\"line\">\t<span class=\"comment\">// js</span></span><br><span class=\"line\">\tgulp.src(<span class=\"string\">'src/js/*.js'</span>)</span><br><span class=\"line\">\t\t.pipe(uglify())</span><br><span class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/js'</span>));</span><br><span class=\"line\">\t<span class=\"comment\">// img</span></span><br><span class=\"line\">\tgulp.src(<span class=\"string\">'src/img/*'</span>)</span><br><span class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/img'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'watchFile'</span>, [<span class=\"string\">'minfile'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\tgulp.watch(<span class=\"string\">'src/**/*'</span>, [<span class=\"string\">'minfile'</span>]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'default'</span>, [<span class=\"string\">'minfile'</span>, <span class=\"string\">'watchFile'</span>]);</span><br></pre></td></tr></table></figure></p>\n<p>gulp API只有五个：task，src，dest，watch和run。<br>task用于定义任务；src用于表示源文件路径；dest用于输出，写入新文件；watch用于监听文件变化；run用于执行任务。<br>ps:上面的pipe表示管道。</p>\n<h4 id=\"第四步，开启任务\"><a href=\"#第四步，开启任务\" class=\"headerlink\" title=\"第四步，开启任务\"></a>第四步，开启任务</h4><p>项目目录下，执行<code>gulp</code>即可。之后就可以开始编写代码了。</p>\n<hr>\n<p>第一次对gulp的尝试，也是第一次对构建工具的尝试，其中只是用到了一些最简单也是最常用的插件，给我的感觉就是省去了每次手动编译、压缩等操作，这次使用就像一次Hello World。</p>\n"},{"title":"redux应用于React","date":"2016-09-21T16:00:00.000Z","comments":1,"_content":"\n　　不知道有多少人和我一样，redux的文档看了一遍又一遍，各种教程翻来翻去，还是不知道在自己的React项目中该如何加入redux。  \n　　经过这段时间，总算有些入门的感觉，明白大致的编写流程。  \n　　对于在React项目中使用redux，首先需要理解`展示型组件和容器型组件`。  \n　　简单来说，展示型组件用于对展示页面，数据通过`props`获得，只有容器型组件与redux交道。一般情况下，容器型组件通过redux的`connect`函数获得state，以及action，然后调用展示型组件并通过`props`传递所需要的state和action。展示型组件需要修改state就通过容器型组件传递过来的action调用。  \neg\n```jsx\n// Login.js  Login组件 (此为容器组件)\n\n// 通过connect传递state中的userData和user action\n@connect(\n  ({userData}) => ({userData}),\n  require('ACTION/user').default\n)\nexport default class Login extends Component {\n\trender() {\n\t\treturn (\n        <div className=\"login-content\">\n      \t\t<div className=\"login\">\n            <p className=\"login-close\"><Link to=\"user\">&times;</Link></p>\n            {/* 调用LoginForm组件，并把user action中的login方法通过props传递给LoginForm组件 */}\n            <LoginForm\n              toLogin = { this.props.login }\n            >\n            </LoginForm>\n          </div>\n        </div>\n\t\t\t);\n\t}\n}\n```\n\n```jsx\n// LoginForm.js  LoginForm组件 (此为展示组件)\n\nexport default class LoginForm extends Component {\n  \n  constructor (props) {\n    super(props);\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    let username = this.refs.username.value;\n    let password = this.refs.password.value;\n    // 对输入的处理\n    if(username == '' || password == '') {\n      return alert('请输入用户名和密码');\n    }\n    // 调用redux action来修改state\n    return this.props.toLogin(username, password);\n  }\n\n  render() {\n\t\treturn (\n        <div className=\"login-form\">\n          <from>\n            <input className=\"username-input\" type=\"text\" placeholder=\"用户名\"\n              ref=\"username\"\n            />\n            <input className=\"password-input\" type=\"password\" placeholder=\"密码\"\n              ref=\"password\"\n            />\n            <submit className=\"submit-btn\" onClick={ this.handleClick }>进入头条</submit>\n          </from>\n        </div>\n\t\t\t);\n\t}\n}\n```\n\n#####\n\n关于action, reducer, store的编写，需要明白这个流程：\n\n\t1. dispatch()用于触发action，参数为具体action(actionCreate其实也是产生一个action)。\n\t2. 当有action被触发时，就会去store中查询注册的reducer(通过action.type查找),并执行该reducer返回新的state。\n\n所以我们需要做的：\n\n\t1. 编写reducer，参数为(initstate, action)，(一般样式为switch(action.type))。\n\t2. 合并reducer，主要目的是可以将reducer分成多个编写，更方便管理和理解。\n\t3. 编写store，注册reducer到store中，这里一般都会添加redux的中间件。\n\tps:\n\t应该是最先编写action，包括action type常量定义，可以用于action create和reducer；action create函数；action dispatch函数。函数位置具体怎么分，各有所爱吧。","source":"_posts/redux应用于React.md","raw":"---\ntitle: redux应用于React\ndate: 2016-09-22\ntags: [JavaScript, React, Redux]\ncategories: \n- React\ncomments: true\n---\n\n　　不知道有多少人和我一样，redux的文档看了一遍又一遍，各种教程翻来翻去，还是不知道在自己的React项目中该如何加入redux。  \n　　经过这段时间，总算有些入门的感觉，明白大致的编写流程。  \n　　对于在React项目中使用redux，首先需要理解`展示型组件和容器型组件`。  \n　　简单来说，展示型组件用于对展示页面，数据通过`props`获得，只有容器型组件与redux交道。一般情况下，容器型组件通过redux的`connect`函数获得state，以及action，然后调用展示型组件并通过`props`传递所需要的state和action。展示型组件需要修改state就通过容器型组件传递过来的action调用。  \neg\n```jsx\n// Login.js  Login组件 (此为容器组件)\n\n// 通过connect传递state中的userData和user action\n@connect(\n  ({userData}) => ({userData}),\n  require('ACTION/user').default\n)\nexport default class Login extends Component {\n\trender() {\n\t\treturn (\n        <div className=\"login-content\">\n      \t\t<div className=\"login\">\n            <p className=\"login-close\"><Link to=\"user\">&times;</Link></p>\n            {/* 调用LoginForm组件，并把user action中的login方法通过props传递给LoginForm组件 */}\n            <LoginForm\n              toLogin = { this.props.login }\n            >\n            </LoginForm>\n          </div>\n        </div>\n\t\t\t);\n\t}\n}\n```\n\n```jsx\n// LoginForm.js  LoginForm组件 (此为展示组件)\n\nexport default class LoginForm extends Component {\n  \n  constructor (props) {\n    super(props);\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    let username = this.refs.username.value;\n    let password = this.refs.password.value;\n    // 对输入的处理\n    if(username == '' || password == '') {\n      return alert('请输入用户名和密码');\n    }\n    // 调用redux action来修改state\n    return this.props.toLogin(username, password);\n  }\n\n  render() {\n\t\treturn (\n        <div className=\"login-form\">\n          <from>\n            <input className=\"username-input\" type=\"text\" placeholder=\"用户名\"\n              ref=\"username\"\n            />\n            <input className=\"password-input\" type=\"password\" placeholder=\"密码\"\n              ref=\"password\"\n            />\n            <submit className=\"submit-btn\" onClick={ this.handleClick }>进入头条</submit>\n          </from>\n        </div>\n\t\t\t);\n\t}\n}\n```\n\n#####\n\n关于action, reducer, store的编写，需要明白这个流程：\n\n\t1. dispatch()用于触发action，参数为具体action(actionCreate其实也是产生一个action)。\n\t2. 当有action被触发时，就会去store中查询注册的reducer(通过action.type查找),并执行该reducer返回新的state。\n\n所以我们需要做的：\n\n\t1. 编写reducer，参数为(initstate, action)，(一般样式为switch(action.type))。\n\t2. 合并reducer，主要目的是可以将reducer分成多个编写，更方便管理和理解。\n\t3. 编写store，注册reducer到store中，这里一般都会添加redux的中间件。\n\tps:\n\t应该是最先编写action，包括action type常量定义，可以用于action create和reducer；action create函数；action dispatch函数。函数位置具体怎么分，各有所爱吧。","slug":"redux应用于React","published":1,"updated":"2017-12-28T03:47:32.463Z","layout":"post","photos":[],"link":"","_id":"cjks5i9ih001yvmti2t3p94u3","content":"<p>　　不知道有多少人和我一样，redux的文档看了一遍又一遍，各种教程翻来翻去，还是不知道在自己的React项目中该如何加入redux。<br>　　经过这段时间，总算有些入门的感觉，明白大致的编写流程。<br>　　对于在React项目中使用redux，首先需要理解<code>展示型组件和容器型组件</code>。<br>　　简单来说，展示型组件用于对展示页面，数据通过<code>props</code>获得，只有容器型组件与redux交道。一般情况下，容器型组件通过redux的<code>connect</code>函数获得state，以及action，然后调用展示型组件并通过<code>props</code>传递所需要的state和action。展示型组件需要修改state就通过容器型组件传递过来的action调用。<br>eg<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Login.js  Login组件 (此为容器组件)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过connect传递state中的userData和user action</span></span><br><span class=\"line\">@connect(</span><br><span class=\"line\">  (&#123;userData&#125;) =&gt; (&#123;userData&#125;),</span><br><span class=\"line\">  <span class=\"built_in\">require</span>(<span class=\"string\">'ACTION/user'</span>).default</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Login</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">\trender() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div className=<span class=\"string\">\"login-content\"</span>&gt;</span><br><span class=\"line\">      \t\t&lt;div className=<span class=\"string\">\"login\"</span>&gt;</span><br><span class=\"line\">            &lt;p className=<span class=\"string\">\"login-close\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"user\"</span>&gt;</span>&amp;times;<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\">            &#123;<span class=\"comment\">/* 调用LoginForm组件，并把user action中的login方法通过props传递给LoginForm组件 */</span>&#125;</span><br><span class=\"line\">            &lt;LoginForm</span><br><span class=\"line\">              toLogin = &#123; <span class=\"keyword\">this</span>.props.login &#125;</span><br><span class=\"line\">            &gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/LoginForm&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>div&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t\t);</span></span><br><span class=\"line\"><span class=\"regexp\">\t&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LoginForm.js  LoginForm组件 (此为展示组件)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginForm</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> username = <span class=\"keyword\">this</span>.refs.username.value;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> password = <span class=\"keyword\">this</span>.refs.password.value;</span><br><span class=\"line\">    <span class=\"comment\">// 对输入的处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(username == <span class=\"string\">''</span> || password == <span class=\"string\">''</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> alert(<span class=\"string\">'请输入用户名和密码'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 调用redux action来修改state</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.toLogin(username, password);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div className=<span class=\"string\">\"login-form\"</span>&gt;</span><br><span class=\"line\">          &lt;<span class=\"keyword\">from</span>&gt;</span><br><span class=\"line\">            &lt;input className=<span class=\"string\">\"username-input\"</span> type=<span class=\"string\">\"text\"</span> placeholder=<span class=\"string\">\"用户名\"</span></span><br><span class=\"line\">              ref=<span class=\"string\">\"username\"</span></span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;input className=<span class=\"string\">\"password-input\"</span> type=<span class=\"string\">\"password\"</span> placeholder=<span class=\"string\">\"密码\"</span></span><br><span class=\"line\">              ref=<span class=\"string\">\"password\"</span></span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;submit className=<span class=\"string\">\"submit-btn\"</span> onClick=&#123; <span class=\"keyword\">this</span>.handleClick &#125;&gt;进入头条&lt;<span class=\"regexp\">/submit&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span><span class=\"keyword\">from</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t\t);</span></span><br><span class=\"line\"><span class=\"regexp\">\t&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>#####</p>\n<p>关于action, reducer, store的编写，需要明白这个流程：</p>\n<pre><code>1. dispatch()用于触发action，参数为具体action(actionCreate其实也是产生一个action)。\n2. 当有action被触发时，就会去store中查询注册的reducer(通过action.type查找),并执行该reducer返回新的state。\n</code></pre><p>所以我们需要做的：</p>\n<pre><code>1. 编写reducer，参数为(initstate, action)，(一般样式为switch(action.type))。\n2. 合并reducer，主要目的是可以将reducer分成多个编写，更方便管理和理解。\n3. 编写store，注册reducer到store中，这里一般都会添加redux的中间件。\nps:\n应该是最先编写action，包括action type常量定义，可以用于action create和reducer；action create函数；action dispatch函数。函数位置具体怎么分，各有所爱吧。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>　　不知道有多少人和我一样，redux的文档看了一遍又一遍，各种教程翻来翻去，还是不知道在自己的React项目中该如何加入redux。<br>　　经过这段时间，总算有些入门的感觉，明白大致的编写流程。<br>　　对于在React项目中使用redux，首先需要理解<code>展示型组件和容器型组件</code>。<br>　　简单来说，展示型组件用于对展示页面，数据通过<code>props</code>获得，只有容器型组件与redux交道。一般情况下，容器型组件通过redux的<code>connect</code>函数获得state，以及action，然后调用展示型组件并通过<code>props</code>传递所需要的state和action。展示型组件需要修改state就通过容器型组件传递过来的action调用。<br>eg<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Login.js  Login组件 (此为容器组件)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过connect传递state中的userData和user action</span></span><br><span class=\"line\">@connect(</span><br><span class=\"line\">  (&#123;userData&#125;) =&gt; (&#123;userData&#125;),</span><br><span class=\"line\">  <span class=\"built_in\">require</span>(<span class=\"string\">'ACTION/user'</span>).default</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Login</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">\trender() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div className=<span class=\"string\">\"login-content\"</span>&gt;</span><br><span class=\"line\">      \t\t&lt;div className=<span class=\"string\">\"login\"</span>&gt;</span><br><span class=\"line\">            &lt;p className=<span class=\"string\">\"login-close\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"user\"</span>&gt;</span>&amp;times;<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\">            &#123;<span class=\"comment\">/* 调用LoginForm组件，并把user action中的login方法通过props传递给LoginForm组件 */</span>&#125;</span><br><span class=\"line\">            &lt;LoginForm</span><br><span class=\"line\">              toLogin = &#123; <span class=\"keyword\">this</span>.props.login &#125;</span><br><span class=\"line\">            &gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/LoginForm&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span>div&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t\t);</span></span><br><span class=\"line\"><span class=\"regexp\">\t&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LoginForm.js  LoginForm组件 (此为展示组件)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginForm</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> username = <span class=\"keyword\">this</span>.refs.username.value;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> password = <span class=\"keyword\">this</span>.refs.password.value;</span><br><span class=\"line\">    <span class=\"comment\">// 对输入的处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(username == <span class=\"string\">''</span> || password == <span class=\"string\">''</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> alert(<span class=\"string\">'请输入用户名和密码'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 调用redux action来修改state</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.toLogin(username, password);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div className=<span class=\"string\">\"login-form\"</span>&gt;</span><br><span class=\"line\">          &lt;<span class=\"keyword\">from</span>&gt;</span><br><span class=\"line\">            &lt;input className=<span class=\"string\">\"username-input\"</span> type=<span class=\"string\">\"text\"</span> placeholder=<span class=\"string\">\"用户名\"</span></span><br><span class=\"line\">              ref=<span class=\"string\">\"username\"</span></span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;input className=<span class=\"string\">\"password-input\"</span> type=<span class=\"string\">\"password\"</span> placeholder=<span class=\"string\">\"密码\"</span></span><br><span class=\"line\">              ref=<span class=\"string\">\"password\"</span></span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;submit className=<span class=\"string\">\"submit-btn\"</span> onClick=&#123; <span class=\"keyword\">this</span>.handleClick &#125;&gt;进入头条&lt;<span class=\"regexp\">/submit&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;/</span><span class=\"keyword\">from</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">\t\t\t);</span></span><br><span class=\"line\"><span class=\"regexp\">\t&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>#####</p>\n<p>关于action, reducer, store的编写，需要明白这个流程：</p>\n<pre><code>1. dispatch()用于触发action，参数为具体action(actionCreate其实也是产生一个action)。\n2. 当有action被触发时，就会去store中查询注册的reducer(通过action.type查找),并执行该reducer返回新的state。\n</code></pre><p>所以我们需要做的：</p>\n<pre><code>1. 编写reducer，参数为(initstate, action)，(一般样式为switch(action.type))。\n2. 合并reducer，主要目的是可以将reducer分成多个编写，更方便管理和理解。\n3. 编写store，注册reducer到store中，这里一般都会添加redux的中间件。\nps:\n应该是最先编写action，包括action type常量定义，可以用于action create和reducer；action create函数；action dispatch函数。函数位置具体怎么分，各有所爱吧。\n</code></pre>"},{"title":"Redux简单分享","date":"2017-12-27T16:00:00.000Z","comments":1,"_content":"\nRedux是JavaScript实现的状态容器，提供了可预测化的状态管理。\n\n为什么需要状态容器？  \n\n1. 随着页面的复杂度不断增加，需要将页面的状态进行统一的管理。这些状态更多的是指那些和数据无关的数据，比如：一个简单的注册页面，包含了用户名验证的状态、密码验证的状态、确认密码验证的状态等等。  \n2. 在React中，一个页面是由各种组件组成的，而React将组件看成是个状态机，一开始会有个初始状态，用户的交互导致状态的编导，从而重新渲染UI。（在React中通过setState修改state，触发UI的重新渲染）。\n3. 因为存在父子组件的通信、异步等问题，状态的情况会更加复杂，很难去预测。\n\nRedux的核心\n\nAction，就是定义一个行动，被定义为包含type属性的对象，用于声明需要修改的state。可以理解为Action就是描述一件事情的发生的。\n\n```JavaScript\nlet nextTodoId = 0\nconst addTodo = text => {\n  return {\n    type: 'ADD_TODO',\n    id: nextTodoId++,\n    text\n  }\n}\n```\n感觉有点类似数据库的插入，type表示要执行插入，id这里是个自增的整型，text为内容。\n\nReducer，通过接受Action来更新state，这里的更新并不能直接改变state的值，而是返回一个新的state。(纯函数，为了实现状态的预测)\n\n```JavaScript\nconst todos = (state = [], action) => {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return [\n        ...state,\n        {\n          id: action.id,\n          text: action.text,\n          completed: false\n        }\n      ]\n    default:\n      return state\n  }\n}\n```\n\nStore，用于存放所有state。\n\n```JavaScript\nconst store = Store.createStore(todos)\n\n```\n\nRedux中的数据流\n\n![Redux数据流](/images/redux简化数据流.jpeg)\n\n\n```JavaScript\nconst Store = (() => {\n\n  // 首先是store需要存放state，并且该state应该私有。\n  let currState = {}\n  const getState = () => currState\n\n  // 提供触发Action的方法\n  // setState(todos(getState, addTodo('abc')))\n  // 但是这样显然就会造成state的混乱\n  let currReducer = () => {}\n  const dispatch = (action) => {\n    currState = currReducer(currState, action)\n  }\n\n  // 将reducer传入store中\n  const createStore = function (reducer) {\n    currReducer = reducer\n    return this\n  }\n\n  return {\n    getState,\n    dispatch,\n    createStore\n  }\n})()\n```\n","source":"_posts/redux简单分享.md","raw":"---\ntitle: Redux简单分享\ndate: 2017-12-28\ntags: [JavaScript, React]\ncategories:\n- JavaScript\ncomments: true\n---\n\nRedux是JavaScript实现的状态容器，提供了可预测化的状态管理。\n\n为什么需要状态容器？  \n\n1. 随着页面的复杂度不断增加，需要将页面的状态进行统一的管理。这些状态更多的是指那些和数据无关的数据，比如：一个简单的注册页面，包含了用户名验证的状态、密码验证的状态、确认密码验证的状态等等。  \n2. 在React中，一个页面是由各种组件组成的，而React将组件看成是个状态机，一开始会有个初始状态，用户的交互导致状态的编导，从而重新渲染UI。（在React中通过setState修改state，触发UI的重新渲染）。\n3. 因为存在父子组件的通信、异步等问题，状态的情况会更加复杂，很难去预测。\n\nRedux的核心\n\nAction，就是定义一个行动，被定义为包含type属性的对象，用于声明需要修改的state。可以理解为Action就是描述一件事情的发生的。\n\n```JavaScript\nlet nextTodoId = 0\nconst addTodo = text => {\n  return {\n    type: 'ADD_TODO',\n    id: nextTodoId++,\n    text\n  }\n}\n```\n感觉有点类似数据库的插入，type表示要执行插入，id这里是个自增的整型，text为内容。\n\nReducer，通过接受Action来更新state，这里的更新并不能直接改变state的值，而是返回一个新的state。(纯函数，为了实现状态的预测)\n\n```JavaScript\nconst todos = (state = [], action) => {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return [\n        ...state,\n        {\n          id: action.id,\n          text: action.text,\n          completed: false\n        }\n      ]\n    default:\n      return state\n  }\n}\n```\n\nStore，用于存放所有state。\n\n```JavaScript\nconst store = Store.createStore(todos)\n\n```\n\nRedux中的数据流\n\n![Redux数据流](/images/redux简化数据流.jpeg)\n\n\n```JavaScript\nconst Store = (() => {\n\n  // 首先是store需要存放state，并且该state应该私有。\n  let currState = {}\n  const getState = () => currState\n\n  // 提供触发Action的方法\n  // setState(todos(getState, addTodo('abc')))\n  // 但是这样显然就会造成state的混乱\n  let currReducer = () => {}\n  const dispatch = (action) => {\n    currState = currReducer(currState, action)\n  }\n\n  // 将reducer传入store中\n  const createStore = function (reducer) {\n    currReducer = reducer\n    return this\n  }\n\n  return {\n    getState,\n    dispatch,\n    createStore\n  }\n})()\n```\n","slug":"redux简单分享","published":1,"updated":"2018-01-04T10:00:46.841Z","layout":"post","photos":[],"link":"","_id":"cjks5i9ij0022vmtik58ws1zm","content":"<p>Redux是JavaScript实现的状态容器，提供了可预测化的状态管理。</p>\n<p>为什么需要状态容器？  </p>\n<ol>\n<li>随着页面的复杂度不断增加，需要将页面的状态进行统一的管理。这些状态更多的是指那些和数据无关的数据，比如：一个简单的注册页面，包含了用户名验证的状态、密码验证的状态、确认密码验证的状态等等。  </li>\n<li>在React中，一个页面是由各种组件组成的，而React将组件看成是个状态机，一开始会有个初始状态，用户的交互导致状态的编导，从而重新渲染UI。（在React中通过setState修改state，触发UI的重新渲染）。</li>\n<li>因为存在父子组件的通信、异步等问题，状态的情况会更加复杂，很难去预测。</li>\n</ol>\n<p>Redux的核心</p>\n<p>Action，就是定义一个行动，被定义为包含type属性的对象，用于声明需要修改的state。可以理解为Action就是描述一件事情的发生的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nextTodoId = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> addTodo = <span class=\"function\"><span class=\"params\">text</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: <span class=\"string\">'ADD_TODO'</span>,</span><br><span class=\"line\">    id: nextTodoId++,</span><br><span class=\"line\">    text</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>感觉有点类似数据库的插入，type表示要执行插入，id这里是个自增的整型，text为内容。</p>\n<p>Reducer，通过接受Action来更新state，这里的更新并不能直接改变state的值，而是返回一个新的state。(纯函数，为了实现状态的预测)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> todos = <span class=\"function\">(<span class=\"params\">state = [], action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          id: action.id,</span><br><span class=\"line\">          text: action.text,</span><br><span class=\"line\">          completed: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Store，用于存放所有state。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = Store.createStore(todos)</span><br></pre></td></tr></table></figure>\n<p>Redux中的数据流</p>\n<p><img src=\"/images/redux简化数据流.jpeg\" alt=\"Redux数据流\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Store = <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 首先是store需要存放state，并且该state应该私有。</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currState = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> getState = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> currState</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 提供触发Action的方法</span></span><br><span class=\"line\">  <span class=\"comment\">// setState(todos(getState, addTodo('abc')))</span></span><br><span class=\"line\">  <span class=\"comment\">// 但是这样显然就会造成state的混乱</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currReducer = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dispatch = <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    currState = currReducer(currState, action)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将reducer传入store中</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> createStore = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reducer</span>) </span>&#123;</span><br><span class=\"line\">    currReducer = reducer</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    getState,</span><br><span class=\"line\">    dispatch,</span><br><span class=\"line\">    createStore</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Redux是JavaScript实现的状态容器，提供了可预测化的状态管理。</p>\n<p>为什么需要状态容器？  </p>\n<ol>\n<li>随着页面的复杂度不断增加，需要将页面的状态进行统一的管理。这些状态更多的是指那些和数据无关的数据，比如：一个简单的注册页面，包含了用户名验证的状态、密码验证的状态、确认密码验证的状态等等。  </li>\n<li>在React中，一个页面是由各种组件组成的，而React将组件看成是个状态机，一开始会有个初始状态，用户的交互导致状态的编导，从而重新渲染UI。（在React中通过setState修改state，触发UI的重新渲染）。</li>\n<li>因为存在父子组件的通信、异步等问题，状态的情况会更加复杂，很难去预测。</li>\n</ol>\n<p>Redux的核心</p>\n<p>Action，就是定义一个行动，被定义为包含type属性的对象，用于声明需要修改的state。可以理解为Action就是描述一件事情的发生的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nextTodoId = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> addTodo = <span class=\"function\"><span class=\"params\">text</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: <span class=\"string\">'ADD_TODO'</span>,</span><br><span class=\"line\">    id: nextTodoId++,</span><br><span class=\"line\">    text</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>感觉有点类似数据库的插入，type表示要执行插入，id这里是个自增的整型，text为内容。</p>\n<p>Reducer，通过接受Action来更新state，这里的更新并不能直接改变state的值，而是返回一个新的state。(纯函数，为了实现状态的预测)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> todos = <span class=\"function\">(<span class=\"params\">state = [], action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          id: action.id,</span><br><span class=\"line\">          text: action.text,</span><br><span class=\"line\">          completed: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Store，用于存放所有state。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = Store.createStore(todos)</span><br></pre></td></tr></table></figure>\n<p>Redux中的数据流</p>\n<p><img src=\"/images/redux简化数据流.jpeg\" alt=\"Redux数据流\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Store = <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 首先是store需要存放state，并且该state应该私有。</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currState = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> getState = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> currState</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 提供触发Action的方法</span></span><br><span class=\"line\">  <span class=\"comment\">// setState(todos(getState, addTodo('abc')))</span></span><br><span class=\"line\">  <span class=\"comment\">// 但是这样显然就会造成state的混乱</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currReducer = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dispatch = <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    currState = currReducer(currState, action)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将reducer传入store中</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> createStore = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reducer</span>) </span>&#123;</span><br><span class=\"line\">    currReducer = reducer</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    getState,</span><br><span class=\"line\">    dispatch,</span><br><span class=\"line\">    createStore</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n"},{"title":"一些关于git","date":"2017-09-12T16:00:00.000Z","comments":1,"_content":"\n.git文件夹下  \n  1. 不重要：\n    * config文件保存项目特有的配置  \n    * info目录，不希望在.gitignore文件中管理的忽略模式的全局可执行文件  \n    * hooks钩子脚本\n  2. 重要：\n    * HEAD文件指向当前分支\n    * index文件保存暂存区信息\n    * objects目录存储所有数据\n    * refs目录存储指向数据(分支)的提交对象的指针\n\nobjects文件夹下\n\n  主要对象：（通过键值对进行保存，键为hash，值为对象）\n  1. blob对象（文件内容）\n  2. tree对象（用于包含blob对象，组织结构。版本、分支指向根tree对象）\n  3. commit对象 （提交信息）\n  4. tag对象\n  5. ... ...\n\nPackfiles：  \n  将blob压缩，当前版本保存完整信息，其他版本保存差量信息。大部分情况是自动完成，可以调用git gc手动执行\n","source":"_posts/一些关于git.md","raw":"---\ntitle: 一些关于git\ndate: 2017-09-13\ntags: git\ncategories:\n- git\ncomments: true\n---\n\n.git文件夹下  \n  1. 不重要：\n    * config文件保存项目特有的配置  \n    * info目录，不希望在.gitignore文件中管理的忽略模式的全局可执行文件  \n    * hooks钩子脚本\n  2. 重要：\n    * HEAD文件指向当前分支\n    * index文件保存暂存区信息\n    * objects目录存储所有数据\n    * refs目录存储指向数据(分支)的提交对象的指针\n\nobjects文件夹下\n\n  主要对象：（通过键值对进行保存，键为hash，值为对象）\n  1. blob对象（文件内容）\n  2. tree对象（用于包含blob对象，组织结构。版本、分支指向根tree对象）\n  3. commit对象 （提交信息）\n  4. tag对象\n  5. ... ...\n\nPackfiles：  \n  将blob压缩，当前版本保存完整信息，其他版本保存差量信息。大部分情况是自动完成，可以调用git gc手动执行\n","slug":"一些关于git","published":1,"updated":"2017-12-28T03:47:32.463Z","layout":"post","photos":[],"link":"","_id":"cjks5i9ik0025vmtiqkwqc4wn","content":"<p>.git文件夹下  </p>\n<ol>\n<li>不重要：<ul>\n<li>config文件保存项目特有的配置  </li>\n<li>info目录，不希望在.gitignore文件中管理的忽略模式的全局可执行文件  </li>\n<li>hooks钩子脚本</li>\n</ul>\n</li>\n<li>重要：<ul>\n<li>HEAD文件指向当前分支</li>\n<li>index文件保存暂存区信息</li>\n<li>objects目录存储所有数据</li>\n<li>refs目录存储指向数据(分支)的提交对象的指针</li>\n</ul>\n</li>\n</ol>\n<p>objects文件夹下</p>\n<p>  主要对象：（通过键值对进行保存，键为hash，值为对象）</p>\n<ol>\n<li>blob对象（文件内容）</li>\n<li>tree对象（用于包含blob对象，组织结构。版本、分支指向根tree对象）</li>\n<li>commit对象 （提交信息）</li>\n<li>tag对象</li>\n<li>… …</li>\n</ol>\n<p>Packfiles：<br>  将blob压缩，当前版本保存完整信息，其他版本保存差量信息。大部分情况是自动完成，可以调用git gc手动执行</p>\n","site":{"data":{}},"excerpt":"","more":"<p>.git文件夹下  </p>\n<ol>\n<li>不重要：<ul>\n<li>config文件保存项目特有的配置  </li>\n<li>info目录，不希望在.gitignore文件中管理的忽略模式的全局可执行文件  </li>\n<li>hooks钩子脚本</li>\n</ul>\n</li>\n<li>重要：<ul>\n<li>HEAD文件指向当前分支</li>\n<li>index文件保存暂存区信息</li>\n<li>objects目录存储所有数据</li>\n<li>refs目录存储指向数据(分支)的提交对象的指针</li>\n</ul>\n</li>\n</ol>\n<p>objects文件夹下</p>\n<p>  主要对象：（通过键值对进行保存，键为hash，值为对象）</p>\n<ol>\n<li>blob对象（文件内容）</li>\n<li>tree对象（用于包含blob对象，组织结构。版本、分支指向根tree对象）</li>\n<li>commit对象 （提交信息）</li>\n<li>tag对象</li>\n<li>… …</li>\n</ol>\n<p>Packfiles：<br>  将blob压缩，当前版本保存完整信息，其他版本保存差量信息。大部分情况是自动完成，可以调用git gc手动执行</p>\n"},{"title":"一次H5页面","date":"2016-08-02T16:00:00.000Z","comments":1,"_content":"\n任务：环球网-2016七夕H5页面  \n环境：swiper插件，gulp及相关常用工具。\n\n---\n\n### 适配\n使用的还是lib-flexible那套解决方案，需要查看的可以点击[这里](https://github.com/amfe/lib-flexible)  \n### 使用swiper\n使用swiper页面的控制以及滑动功能就变得非常容易，可以参见[Swiper中文网](http://www.swiper.com.cn/)，其中添加给类名添加`swiper-slide`即可表示一页。  \n在Swiper实例化中，属性`direction`可以定义横向/竖向滑动，`nextButton`可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在`onSlideChangeStart`中不能够出发`slideTo()`方法。  \nSwiper还有许多其他功能，可以参见[Swiper中文网](http://www.swiper.com.cn/)中API。\n\n### ES6的使用\nES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是`gulp-babel`。\n\n### 目录、git以及gulp相关\n目录和之前的项目目录基本相同。\n```\n.\n├── .eslintrc.json\n├── .gitignore\n├── dist\n│   ├── css\n│   ├── imgs\n│   ├── js\n│   └── libs\n├── gulpfile.js\n├── index.html\n├── node_modules\n├── package.json\n├── psd\n└── src\n    ├── ES6\n    ├── css\n    ├── imgs\n    ├── js\n    ├── libs\n    └── sass\n```\ndist目录存放合并、压缩的代码，用于上线使用。(自动生成)  \nsrc目录存放源文件。  \nnode_modules目录存放用到的node工具。(自动生成)  \npsd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。  \n相比之前增加的文件：\n\n*  .eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看[这里](https://segmentfault.com/a/1190000004468428)。\n*  .gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。\n```\n/node_modules/\n/psd/\n```\n* src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。\n\ngit开始学习使用分支处理bug、添加尝试性功能等。\n\n### 坑是用来爬的\n#### 最经典的坑——this\n在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过`fn.bind(this)`来指向想要的this，在旧版本浏览器下需要使用兼容写法。\n\n#### 省事也被坑——autoprefixer\nautoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是`remove`，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。  \nandriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。\n\n#### 没想到的坑——微信分享\n关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。  \n问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中`mqq.data.setShareInfo`可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。\n\n### 其他\n#### 自定义单选框\n自定义单选框并没有想象中的那么难，除了`<input type=\"radio\">`外，还有个label标签和after伪类。  \n设置css`[type=radio]: display: none;`，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)\n\n#### 文字居中\n要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。\n\n#### 横屏问题\n我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。\n\n### 改进\n需要改进的东西就太多太多了。 \n \n* 最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。\n* 图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。\n* 动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。","source":"_posts/一次H5页面.md","raw":"---\ntitle: 一次H5页面\ndate: 2016-08-03\ntags: [JavaScript, H5]\ncategories: \n- H5\ncomments: true\n---\n\n任务：环球网-2016七夕H5页面  \n环境：swiper插件，gulp及相关常用工具。\n\n---\n\n### 适配\n使用的还是lib-flexible那套解决方案，需要查看的可以点击[这里](https://github.com/amfe/lib-flexible)  \n### 使用swiper\n使用swiper页面的控制以及滑动功能就变得非常容易，可以参见[Swiper中文网](http://www.swiper.com.cn/)，其中添加给类名添加`swiper-slide`即可表示一页。  \n在Swiper实例化中，属性`direction`可以定义横向/竖向滑动，`nextButton`可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在`onSlideChangeStart`中不能够出发`slideTo()`方法。  \nSwiper还有许多其他功能，可以参见[Swiper中文网](http://www.swiper.com.cn/)中API。\n\n### ES6的使用\nES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是`gulp-babel`。\n\n### 目录、git以及gulp相关\n目录和之前的项目目录基本相同。\n```\n.\n├── .eslintrc.json\n├── .gitignore\n├── dist\n│   ├── css\n│   ├── imgs\n│   ├── js\n│   └── libs\n├── gulpfile.js\n├── index.html\n├── node_modules\n├── package.json\n├── psd\n└── src\n    ├── ES6\n    ├── css\n    ├── imgs\n    ├── js\n    ├── libs\n    └── sass\n```\ndist目录存放合并、压缩的代码，用于上线使用。(自动生成)  \nsrc目录存放源文件。  \nnode_modules目录存放用到的node工具。(自动生成)  \npsd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。  \n相比之前增加的文件：\n\n*  .eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看[这里](https://segmentfault.com/a/1190000004468428)。\n*  .gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。\n```\n/node_modules/\n/psd/\n```\n* src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。\n\ngit开始学习使用分支处理bug、添加尝试性功能等。\n\n### 坑是用来爬的\n#### 最经典的坑——this\n在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过`fn.bind(this)`来指向想要的this，在旧版本浏览器下需要使用兼容写法。\n\n#### 省事也被坑——autoprefixer\nautoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是`remove`，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。  \nandriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。\n\n#### 没想到的坑——微信分享\n关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。  \n问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中`mqq.data.setShareInfo`可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。\n\n### 其他\n#### 自定义单选框\n自定义单选框并没有想象中的那么难，除了`<input type=\"radio\">`外，还有个label标签和after伪类。  \n设置css`[type=radio]: display: none;`，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)\n\n#### 文字居中\n要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。\n\n#### 横屏问题\n我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。\n\n### 改进\n需要改进的东西就太多太多了。 \n \n* 最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。\n* 图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。\n* 动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。","slug":"一次H5页面","published":1,"updated":"2017-12-28T03:47:32.463Z","layout":"post","photos":[],"link":"","_id":"cjks5i9il0029vmtiub9gmjhi","content":"<p>任务：环球网-2016七夕H5页面<br>环境：swiper插件，gulp及相关常用工具。</p>\n<hr>\n<h3 id=\"适配\"><a href=\"#适配\" class=\"headerlink\" title=\"适配\"></a>适配</h3><p>使用的还是lib-flexible那套解决方案，需要查看的可以点击<a href=\"https://github.com/amfe/lib-flexible\" target=\"_blank\" rel=\"noopener\">这里</a>  </p>\n<h3 id=\"使用swiper\"><a href=\"#使用swiper\" class=\"headerlink\" title=\"使用swiper\"></a>使用swiper</h3><p>使用swiper页面的控制以及滑动功能就变得非常容易，可以参见<a href=\"http://www.swiper.com.cn/\" target=\"_blank\" rel=\"noopener\">Swiper中文网</a>，其中添加给类名添加<code>swiper-slide</code>即可表示一页。<br>在Swiper实例化中，属性<code>direction</code>可以定义横向/竖向滑动，<code>nextButton</code>可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在<code>onSlideChangeStart</code>中不能够出发<code>slideTo()</code>方法。<br>Swiper还有许多其他功能，可以参见<a href=\"http://www.swiper.com.cn/\" target=\"_blank\" rel=\"noopener\">Swiper中文网</a>中API。</p>\n<h3 id=\"ES6的使用\"><a href=\"#ES6的使用\" class=\"headerlink\" title=\"ES6的使用\"></a>ES6的使用</h3><p>ES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是<code>gulp-babel</code>。</p>\n<h3 id=\"目录、git以及gulp相关\"><a href=\"#目录、git以及gulp相关\" class=\"headerlink\" title=\"目录、git以及gulp相关\"></a>目录、git以及gulp相关</h3><p>目录和之前的项目目录基本相同。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── <span class=\"selector-class\">.eslintrc</span><span class=\"selector-class\">.json</span></span><br><span class=\"line\">├── .gitignore</span><br><span class=\"line\">├── dist</span><br><span class=\"line\">│   ├── css</span><br><span class=\"line\">│   ├── imgs</span><br><span class=\"line\">│   ├── js</span><br><span class=\"line\">│   └── libs</span><br><span class=\"line\">├── gulpfile.js</span><br><span class=\"line\">├── index.html</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── psd</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── ES6</span><br><span class=\"line\">    ├── css</span><br><span class=\"line\">    ├── imgs</span><br><span class=\"line\">    ├── js</span><br><span class=\"line\">    ├── libs</span><br><span class=\"line\">    └── sass</span><br></pre></td></tr></table></figure></p>\n<p>dist目录存放合并、压缩的代码，用于上线使用。(自动生成)<br>src目录存放源文件。<br>node_modules目录存放用到的node工具。(自动生成)<br>psd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。<br>相比之前增加的文件：</p>\n<ul>\n<li>.eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看<a href=\"https://segmentfault.com/a/1190000004468428\" target=\"_blank\" rel=\"noopener\">这里</a>。</li>\n<li><p>.gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">/node_modules/</span></span><br><span class=\"line\"><span class=\"regexp\">/psd/</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。</p>\n</li>\n</ul>\n<p>git开始学习使用分支处理bug、添加尝试性功能等。</p>\n<h3 id=\"坑是用来爬的\"><a href=\"#坑是用来爬的\" class=\"headerlink\" title=\"坑是用来爬的\"></a>坑是用来爬的</h3><h4 id=\"最经典的坑——this\"><a href=\"#最经典的坑——this\" class=\"headerlink\" title=\"最经典的坑——this\"></a>最经典的坑——this</h4><p>在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过<code>fn.bind(this)</code>来指向想要的this，在旧版本浏览器下需要使用兼容写法。</p>\n<h4 id=\"省事也被坑——autoprefixer\"><a href=\"#省事也被坑——autoprefixer\" class=\"headerlink\" title=\"省事也被坑——autoprefixer\"></a>省事也被坑——autoprefixer</h4><p>autoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是<code>remove</code>，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。<br>andriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。</p>\n<h4 id=\"没想到的坑——微信分享\"><a href=\"#没想到的坑——微信分享\" class=\"headerlink\" title=\"没想到的坑——微信分享\"></a>没想到的坑——微信分享</h4><p>关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。<br>问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中<code>mqq.data.setShareInfo</code>可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"自定义单选框\"><a href=\"#自定义单选框\" class=\"headerlink\" title=\"自定义单选框\"></a>自定义单选框</h4><p>自定义单选框并没有想象中的那么难，除了<code>&lt;input type=&quot;radio&quot;&gt;</code>外，还有个label标签和after伪类。<br>设置css<code>[type=radio]: display: none;</code>，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)</p>\n<h4 id=\"文字居中\"><a href=\"#文字居中\" class=\"headerlink\" title=\"文字居中\"></a>文字居中</h4><p>要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。</p>\n<h4 id=\"横屏问题\"><a href=\"#横屏问题\" class=\"headerlink\" title=\"横屏问题\"></a>横屏问题</h4><p>我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。</p>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>需要改进的东西就太多太多了。 </p>\n<ul>\n<li>最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。</li>\n<li>图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。</li>\n<li>动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>任务：环球网-2016七夕H5页面<br>环境：swiper插件，gulp及相关常用工具。</p>\n<hr>\n<h3 id=\"适配\"><a href=\"#适配\" class=\"headerlink\" title=\"适配\"></a>适配</h3><p>使用的还是lib-flexible那套解决方案，需要查看的可以点击<a href=\"https://github.com/amfe/lib-flexible\" target=\"_blank\" rel=\"noopener\">这里</a>  </p>\n<h3 id=\"使用swiper\"><a href=\"#使用swiper\" class=\"headerlink\" title=\"使用swiper\"></a>使用swiper</h3><p>使用swiper页面的控制以及滑动功能就变得非常容易，可以参见<a href=\"http://www.swiper.com.cn/\" target=\"_blank\" rel=\"noopener\">Swiper中文网</a>，其中添加给类名添加<code>swiper-slide</code>即可表示一页。<br>在Swiper实例化中，属性<code>direction</code>可以定义横向/竖向滑动，<code>nextButton</code>可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在<code>onSlideChangeStart</code>中不能够出发<code>slideTo()</code>方法。<br>Swiper还有许多其他功能，可以参见<a href=\"http://www.swiper.com.cn/\" target=\"_blank\" rel=\"noopener\">Swiper中文网</a>中API。</p>\n<h3 id=\"ES6的使用\"><a href=\"#ES6的使用\" class=\"headerlink\" title=\"ES6的使用\"></a>ES6的使用</h3><p>ES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是<code>gulp-babel</code>。</p>\n<h3 id=\"目录、git以及gulp相关\"><a href=\"#目录、git以及gulp相关\" class=\"headerlink\" title=\"目录、git以及gulp相关\"></a>目录、git以及gulp相关</h3><p>目录和之前的项目目录基本相同。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── <span class=\"selector-class\">.eslintrc</span><span class=\"selector-class\">.json</span></span><br><span class=\"line\">├── .gitignore</span><br><span class=\"line\">├── dist</span><br><span class=\"line\">│   ├── css</span><br><span class=\"line\">│   ├── imgs</span><br><span class=\"line\">│   ├── js</span><br><span class=\"line\">│   └── libs</span><br><span class=\"line\">├── gulpfile.js</span><br><span class=\"line\">├── index.html</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── psd</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── ES6</span><br><span class=\"line\">    ├── css</span><br><span class=\"line\">    ├── imgs</span><br><span class=\"line\">    ├── js</span><br><span class=\"line\">    ├── libs</span><br><span class=\"line\">    └── sass</span><br></pre></td></tr></table></figure></p>\n<p>dist目录存放合并、压缩的代码，用于上线使用。(自动生成)<br>src目录存放源文件。<br>node_modules目录存放用到的node工具。(自动生成)<br>psd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。<br>相比之前增加的文件：</p>\n<ul>\n<li>.eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看<a href=\"https://segmentfault.com/a/1190000004468428\" target=\"_blank\" rel=\"noopener\">这里</a>。</li>\n<li><p>.gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">/node_modules/</span></span><br><span class=\"line\"><span class=\"regexp\">/psd/</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。</p>\n</li>\n</ul>\n<p>git开始学习使用分支处理bug、添加尝试性功能等。</p>\n<h3 id=\"坑是用来爬的\"><a href=\"#坑是用来爬的\" class=\"headerlink\" title=\"坑是用来爬的\"></a>坑是用来爬的</h3><h4 id=\"最经典的坑——this\"><a href=\"#最经典的坑——this\" class=\"headerlink\" title=\"最经典的坑——this\"></a>最经典的坑——this</h4><p>在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过<code>fn.bind(this)</code>来指向想要的this，在旧版本浏览器下需要使用兼容写法。</p>\n<h4 id=\"省事也被坑——autoprefixer\"><a href=\"#省事也被坑——autoprefixer\" class=\"headerlink\" title=\"省事也被坑——autoprefixer\"></a>省事也被坑——autoprefixer</h4><p>autoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是<code>remove</code>，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。<br>andriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。</p>\n<h4 id=\"没想到的坑——微信分享\"><a href=\"#没想到的坑——微信分享\" class=\"headerlink\" title=\"没想到的坑——微信分享\"></a>没想到的坑——微信分享</h4><p>关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。<br>问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中<code>mqq.data.setShareInfo</code>可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"自定义单选框\"><a href=\"#自定义单选框\" class=\"headerlink\" title=\"自定义单选框\"></a>自定义单选框</h4><p>自定义单选框并没有想象中的那么难，除了<code>&lt;input type=&quot;radio&quot;&gt;</code>外，还有个label标签和after伪类。<br>设置css<code>[type=radio]: display: none;</code>，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)</p>\n<h4 id=\"文字居中\"><a href=\"#文字居中\" class=\"headerlink\" title=\"文字居中\"></a>文字居中</h4><p>要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。</p>\n<h4 id=\"横屏问题\"><a href=\"#横屏问题\" class=\"headerlink\" title=\"横屏问题\"></a>横屏问题</h4><p>我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。</p>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>需要改进的东西就太多太多了。 </p>\n<ul>\n<li>最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。</li>\n<li>图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。</li>\n<li>动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。</li>\n</ul>\n"},{"title":"一次麻烦的投票","date":"2016-10-30T16:00:00.000Z","comments":1,"_content":"\n刚开始接到任务只是一个将一个之前的页面进行修改，没想到遇到了各种问题。  \n\n### 1. 三角形照片以及遮盖层。\n三角形的实现网上面试题、技术贴也常看到，第一反应就是使用border来实现三角形。使用border来实现三角形还是很方便的。只需要根据三角形的各边给4个border不同的值即可实现。但是这种方法更多的是单色的三角形图标，好像没办法实现三角形照片。只能另找他法。  \n搜索下找到了变换方法，使用的是rotate和skew。需要两层div，先是外层div旋转45度，然后里层div沿X、Y轴倾斜相同度数，就可以生成一个菱形，如果遮住一半即可生成三角形。图片呢，就是放在内层div中，然后在旋转-45度并且倾斜负的里层div旋转度数，使得形成图片正常方形。如下：\n```html\n<div class=\"row\">\n  <div class=\"a\">\n    <div class=\"b\">\n      <img src=\"\" alt=\"\">\n      <div class=\"cover\"></div>\n    </div>\n  </div>\n</div>\n```\n```css\n.a {\n  float: left;\n  transform: rotate(45deg);\n}\n.b {\n  width: 217.1px;\n  height: 217.1px;\n  transform: skew(10deg, 10deg);\n  background: #000;\n}\n```\n.row是用来遮盖菱形上或下半部分形成三角形，img标签和.cover使用绝对定位相对于.row，使得正好将三角形覆盖，.cover中的内容使用margin以及width，使内容正好居中。效果如下：\n<img src=\"images/triangles.png\" alt=\"\">\n\n实现的缺点是IE8即以下不兼容，并且绝对定位因为变换不是特别好调整位置，最后是选择上传图片直接使用三角形图片，IE8以下使用另一套绝对定位，但是遮盖层还是会方形显示。\n\n### 2. 投票功能\n投票系统主要两个麻烦，一个是跨域问题，一个是投票的限制问题。因为投票系统是西安部门进行开发的，是刚开发不久的系统，而且是个问卷系统，并没有充分考虑投票这方面的限制，以及投票成功的反馈。投票的限制前端可以做的应该就是使用localstorage或者cookie来进行一部分限制，更多限制应该还是后端来做支持。跨域问题，GET方法可以使用jsonp很容易解决，但是对于POST就不是特别清晰，我们这边后端做限制的支持，就将投票也改成了GET请求。  \n其实这里的反馈并不怎么好，网速慢的话可能会造成点击没有任何反馈。所以就前端点击，直接投票技术+1，并且投票的心形变成红色，然后请求后端。如果发生错误，提示刷新页面就可以重新投票。","source":"_posts/一次麻烦的投票.md","raw":"---\ntitle: 一次麻烦的投票\ndate: 2016-10-31\ntags: [JavaScript, 项目经验]\ncategories:\n- JavaScript\ncomments: true\n---\n\n刚开始接到任务只是一个将一个之前的页面进行修改，没想到遇到了各种问题。  \n\n### 1. 三角形照片以及遮盖层。\n三角形的实现网上面试题、技术贴也常看到，第一反应就是使用border来实现三角形。使用border来实现三角形还是很方便的。只需要根据三角形的各边给4个border不同的值即可实现。但是这种方法更多的是单色的三角形图标，好像没办法实现三角形照片。只能另找他法。  \n搜索下找到了变换方法，使用的是rotate和skew。需要两层div，先是外层div旋转45度，然后里层div沿X、Y轴倾斜相同度数，就可以生成一个菱形，如果遮住一半即可生成三角形。图片呢，就是放在内层div中，然后在旋转-45度并且倾斜负的里层div旋转度数，使得形成图片正常方形。如下：\n```html\n<div class=\"row\">\n  <div class=\"a\">\n    <div class=\"b\">\n      <img src=\"\" alt=\"\">\n      <div class=\"cover\"></div>\n    </div>\n  </div>\n</div>\n```\n```css\n.a {\n  float: left;\n  transform: rotate(45deg);\n}\n.b {\n  width: 217.1px;\n  height: 217.1px;\n  transform: skew(10deg, 10deg);\n  background: #000;\n}\n```\n.row是用来遮盖菱形上或下半部分形成三角形，img标签和.cover使用绝对定位相对于.row，使得正好将三角形覆盖，.cover中的内容使用margin以及width，使内容正好居中。效果如下：\n<img src=\"images/triangles.png\" alt=\"\">\n\n实现的缺点是IE8即以下不兼容，并且绝对定位因为变换不是特别好调整位置，最后是选择上传图片直接使用三角形图片，IE8以下使用另一套绝对定位，但是遮盖层还是会方形显示。\n\n### 2. 投票功能\n投票系统主要两个麻烦，一个是跨域问题，一个是投票的限制问题。因为投票系统是西安部门进行开发的，是刚开发不久的系统，而且是个问卷系统，并没有充分考虑投票这方面的限制，以及投票成功的反馈。投票的限制前端可以做的应该就是使用localstorage或者cookie来进行一部分限制，更多限制应该还是后端来做支持。跨域问题，GET方法可以使用jsonp很容易解决，但是对于POST就不是特别清晰，我们这边后端做限制的支持，就将投票也改成了GET请求。  \n其实这里的反馈并不怎么好，网速慢的话可能会造成点击没有任何反馈。所以就前端点击，直接投票技术+1，并且投票的心形变成红色，然后请求后端。如果发生错误，提示刷新页面就可以重新投票。","slug":"一次麻烦的投票","published":1,"updated":"2017-12-28T03:47:32.463Z","layout":"post","photos":[],"link":"","_id":"cjks5i9im002cvmtidrud360u","content":"<p>刚开始接到任务只是一个将一个之前的页面进行修改，没想到遇到了各种问题。  </p>\n<h3 id=\"1-三角形照片以及遮盖层。\"><a href=\"#1-三角形照片以及遮盖层。\" class=\"headerlink\" title=\"1. 三角形照片以及遮盖层。\"></a>1. 三角形照片以及遮盖层。</h3><p>三角形的实现网上面试题、技术贴也常看到，第一反应就是使用border来实现三角形。使用border来实现三角形还是很方便的。只需要根据三角形的各边给4个border不同的值即可实现。但是这种方法更多的是单色的三角形图标，好像没办法实现三角形照片。只能另找他法。<br>搜索下找到了变换方法，使用的是rotate和skew。需要两层div，先是外层div旋转45度，然后里层div沿X、Y轴倾斜相同度数，就可以生成一个菱形，如果遮住一半即可生成三角形。图片呢，就是放在内层div中，然后在旋转-45度并且倾斜负的里层div旋转度数，使得形成图片正常方形。如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"a\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"b\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cover\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(45deg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.b</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">217.1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">217.1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">skew</span>(10deg, 10deg);</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#000</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>.row是用来遮盖菱形上或下半部分形成三角形，img标签和.cover使用绝对定位相对于.row，使得正好将三角形覆盖，.cover中的内容使用margin以及width，使内容正好居中。效果如下：<br><img src=\"images/triangles.png\" alt=\"\"></p>\n<p>实现的缺点是IE8即以下不兼容，并且绝对定位因为变换不是特别好调整位置，最后是选择上传图片直接使用三角形图片，IE8以下使用另一套绝对定位，但是遮盖层还是会方形显示。</p>\n<h3 id=\"2-投票功能\"><a href=\"#2-投票功能\" class=\"headerlink\" title=\"2. 投票功能\"></a>2. 投票功能</h3><p>投票系统主要两个麻烦，一个是跨域问题，一个是投票的限制问题。因为投票系统是西安部门进行开发的，是刚开发不久的系统，而且是个问卷系统，并没有充分考虑投票这方面的限制，以及投票成功的反馈。投票的限制前端可以做的应该就是使用localstorage或者cookie来进行一部分限制，更多限制应该还是后端来做支持。跨域问题，GET方法可以使用jsonp很容易解决，但是对于POST就不是特别清晰，我们这边后端做限制的支持，就将投票也改成了GET请求。<br>其实这里的反馈并不怎么好，网速慢的话可能会造成点击没有任何反馈。所以就前端点击，直接投票技术+1，并且投票的心形变成红色，然后请求后端。如果发生错误，提示刷新页面就可以重新投票。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>刚开始接到任务只是一个将一个之前的页面进行修改，没想到遇到了各种问题。  </p>\n<h3 id=\"1-三角形照片以及遮盖层。\"><a href=\"#1-三角形照片以及遮盖层。\" class=\"headerlink\" title=\"1. 三角形照片以及遮盖层。\"></a>1. 三角形照片以及遮盖层。</h3><p>三角形的实现网上面试题、技术贴也常看到，第一反应就是使用border来实现三角形。使用border来实现三角形还是很方便的。只需要根据三角形的各边给4个border不同的值即可实现。但是这种方法更多的是单色的三角形图标，好像没办法实现三角形照片。只能另找他法。<br>搜索下找到了变换方法，使用的是rotate和skew。需要两层div，先是外层div旋转45度，然后里层div沿X、Y轴倾斜相同度数，就可以生成一个菱形，如果遮住一半即可生成三角形。图片呢，就是放在内层div中，然后在旋转-45度并且倾斜负的里层div旋转度数，使得形成图片正常方形。如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"a\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"b\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cover\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(45deg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.b</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">217.1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">217.1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">skew</span>(10deg, 10deg);</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#000</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>.row是用来遮盖菱形上或下半部分形成三角形，img标签和.cover使用绝对定位相对于.row，使得正好将三角形覆盖，.cover中的内容使用margin以及width，使内容正好居中。效果如下：<br><img src=\"images/triangles.png\" alt=\"\"></p>\n<p>实现的缺点是IE8即以下不兼容，并且绝对定位因为变换不是特别好调整位置，最后是选择上传图片直接使用三角形图片，IE8以下使用另一套绝对定位，但是遮盖层还是会方形显示。</p>\n<h3 id=\"2-投票功能\"><a href=\"#2-投票功能\" class=\"headerlink\" title=\"2. 投票功能\"></a>2. 投票功能</h3><p>投票系统主要两个麻烦，一个是跨域问题，一个是投票的限制问题。因为投票系统是西安部门进行开发的，是刚开发不久的系统，而且是个问卷系统，并没有充分考虑投票这方面的限制，以及投票成功的反馈。投票的限制前端可以做的应该就是使用localstorage或者cookie来进行一部分限制，更多限制应该还是后端来做支持。跨域问题，GET方法可以使用jsonp很容易解决，但是对于POST就不是特别清晰，我们这边后端做限制的支持，就将投票也改成了GET请求。<br>其实这里的反馈并不怎么好，网速慢的话可能会造成点击没有任何反馈。所以就前端点击，直接投票技术+1，并且投票的心形变成红色，然后请求后端。如果发生错误，提示刷新页面就可以重新投票。</p>\n"},{"title":"为gulp添加更多","date":"2016-07-22T16:00:00.000Z","comments":1,"_content":"\n有了之前的gulp经验，使用其他gulp工具就是很简单的工作了。\n\n> ps:\t以下代码前均包含`var gulp = require('gulp')`\n\n> 类似`sass()`表示前面包含`var sass = require('gulp-sass')`\n\n--------------\n\n[gulp-autoprefixer](https://www.npmjs.com/package/gulp-autoprefixer)：应该属于css后处理工具，在编写css完成之后，会根据我们的配置自动按需添加浏览器前缀。\n\n任务事例：\n```javascript\ngulp.task('sass', function() {\n\treturn gulp.src('src/sass/*.scss')\n\t\t\t\t\t.pipe(sass())\n\t\t\t\t\t.pipe(autoprefixer('last 2 versions', 'ios 6', 'android 4'))\t//autoprefixer\n\t\t\t\t\t.pipe(gulp.dest('src/css'))\n\t\t\t\t\t.pipe(cleanCSS())\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//css压缩工具，前面介绍有\n\t\t\t\t\t.pipe(gulp.dest('dist/css'))\n});\n```\n其中`autoprefixer('...','...','...')`为简写形式，其中`last 2 versions`表示兼容所有浏览器最新两个版本。\n完整形式应该为`autoprefixer({ \n\tbrowsers: ['last 2 versions', 'ios 6'],\n\tcascade: true\n})`\n\n***\n\n[gulp-imagemin](https://www.npmjs.com/package/gulp-imagemin):图片压缩工具。\n\n任务事例：\n```javascript\ngulp.task('imageMin', function() {\n\tgulp.src('src/img/*')\n\t\t.pipe(imagemin())\n\t\t.pipe(gulp.dest('dist/img'));\n});\n```\n对于imagemin()进行图片压缩，可以结合使用`gulp-cache`对图片进行缓存。具体用法，我也没研究太懂 :joy:\n\n***\n\n[browser-sync](https://www.npmjs.com/package/browser-sync):属于综合测试的工具，可以实现页面自动刷新、多屏同步操作等功能。\n\n任务实例：\n```javascript\n//首先browser-sync的引用，官方推荐使用create()方法\nvar browserSync = require('browser-sync').create();\n\ngulp.task('serve', ['sass'], function() {\n\tbrowserSync.init({\n\t\tserver: './'\n\t});\n\n\tgulp.watch('src/sass/*.scss', ['sass']);\n\tgulp.watch('*.html').on('change', browserSync.reload);\n});\n```\n其中`server: './'`会将当前目录作为服务器访问地址<br/>\n`gulp.watch('src/sass/*.scss', ['sass'])`会监听*.scss文件，执行`sass`任务，并且实时反应到浏览器上。\n`gulp.watch('*.html').on('change', browserSync.reload)`不同之处在于，会执行reload方法，重新加载页面。\n\n--------\n\n对于工具，我觉得更多的是直接拿过来使用，而不是非要去研究清楚每个API的作用。当然，特别感兴趣的也可以尝试研究工具，甚至是自己动手去制造这些工具。","source":"_posts/为gulp添加更多.md","raw":"---\ntitle: 为gulp添加更多\ndate: 2016-07-23\ntags: [JavaScript, 构建工具, gulp]\ncategories: \n- JavaScript\ncomments: true\n---\n\n有了之前的gulp经验，使用其他gulp工具就是很简单的工作了。\n\n> ps:\t以下代码前均包含`var gulp = require('gulp')`\n\n> 类似`sass()`表示前面包含`var sass = require('gulp-sass')`\n\n--------------\n\n[gulp-autoprefixer](https://www.npmjs.com/package/gulp-autoprefixer)：应该属于css后处理工具，在编写css完成之后，会根据我们的配置自动按需添加浏览器前缀。\n\n任务事例：\n```javascript\ngulp.task('sass', function() {\n\treturn gulp.src('src/sass/*.scss')\n\t\t\t\t\t.pipe(sass())\n\t\t\t\t\t.pipe(autoprefixer('last 2 versions', 'ios 6', 'android 4'))\t//autoprefixer\n\t\t\t\t\t.pipe(gulp.dest('src/css'))\n\t\t\t\t\t.pipe(cleanCSS())\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//css压缩工具，前面介绍有\n\t\t\t\t\t.pipe(gulp.dest('dist/css'))\n});\n```\n其中`autoprefixer('...','...','...')`为简写形式，其中`last 2 versions`表示兼容所有浏览器最新两个版本。\n完整形式应该为`autoprefixer({ \n\tbrowsers: ['last 2 versions', 'ios 6'],\n\tcascade: true\n})`\n\n***\n\n[gulp-imagemin](https://www.npmjs.com/package/gulp-imagemin):图片压缩工具。\n\n任务事例：\n```javascript\ngulp.task('imageMin', function() {\n\tgulp.src('src/img/*')\n\t\t.pipe(imagemin())\n\t\t.pipe(gulp.dest('dist/img'));\n});\n```\n对于imagemin()进行图片压缩，可以结合使用`gulp-cache`对图片进行缓存。具体用法，我也没研究太懂 :joy:\n\n***\n\n[browser-sync](https://www.npmjs.com/package/browser-sync):属于综合测试的工具，可以实现页面自动刷新、多屏同步操作等功能。\n\n任务实例：\n```javascript\n//首先browser-sync的引用，官方推荐使用create()方法\nvar browserSync = require('browser-sync').create();\n\ngulp.task('serve', ['sass'], function() {\n\tbrowserSync.init({\n\t\tserver: './'\n\t});\n\n\tgulp.watch('src/sass/*.scss', ['sass']);\n\tgulp.watch('*.html').on('change', browserSync.reload);\n});\n```\n其中`server: './'`会将当前目录作为服务器访问地址<br/>\n`gulp.watch('src/sass/*.scss', ['sass'])`会监听*.scss文件，执行`sass`任务，并且实时反应到浏览器上。\n`gulp.watch('*.html').on('change', browserSync.reload)`不同之处在于，会执行reload方法，重新加载页面。\n\n--------\n\n对于工具，我觉得更多的是直接拿过来使用，而不是非要去研究清楚每个API的作用。当然，特别感兴趣的也可以尝试研究工具，甚至是自己动手去制造这些工具。","slug":"为gulp添加更多","published":1,"updated":"2017-12-28T03:47:32.464Z","layout":"post","photos":[],"link":"","_id":"cjks5i9io002hvmtin0etoskh","content":"<p>有了之前的gulp经验，使用其他gulp工具就是很简单的工作了。</p>\n<blockquote>\n<p>ps:    以下代码前均包含<code>var gulp = require(&#39;gulp&#39;)</code></p>\n</blockquote>\n<blockquote>\n<p>类似<code>sass()</code>表示前面包含<code>var sass = require(&#39;gulp-sass&#39;)</code></p>\n</blockquote>\n<hr>\n<p><a href=\"https://www.npmjs.com/package/gulp-autoprefixer\" target=\"_blank\" rel=\"noopener\">gulp-autoprefixer</a>：应该属于css后处理工具，在编写css完成之后，会根据我们的配置自动按需添加浏览器前缀。</p>\n<p>任务事例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'sass'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'src/sass/*.scss'</span>)</span><br><span class=\"line\">\t\t\t\t\t.pipe(sass())</span><br><span class=\"line\">\t\t\t\t\t.pipe(autoprefixer(<span class=\"string\">'last 2 versions'</span>, <span class=\"string\">'ios 6'</span>, <span class=\"string\">'android 4'</span>))\t<span class=\"comment\">//autoprefixer</span></span><br><span class=\"line\">\t\t\t\t\t.pipe(gulp.dest(<span class=\"string\">'src/css'</span>))</span><br><span class=\"line\">\t\t\t\t\t.pipe(cleanCSS())\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//css压缩工具，前面介绍有</span></span><br><span class=\"line\">\t\t\t\t\t.pipe(gulp.dest(<span class=\"string\">'dist/css'</span>))</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>其中<code>autoprefixer(&#39;...&#39;,&#39;...&#39;,&#39;...&#39;)</code>为简写形式，其中<code>last 2 versions</code>表示兼容所有浏览器最新两个版本。<br>完整形式应该为<code>autoprefixer({ \n    browsers: [&#39;last 2 versions&#39;, &#39;ios 6&#39;],\n    cascade: true\n})</code></p>\n<hr>\n<p><a href=\"https://www.npmjs.com/package/gulp-imagemin\" target=\"_blank\" rel=\"noopener\">gulp-imagemin</a>:图片压缩工具。</p>\n<p>任务事例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'imageMin'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\tgulp.src(<span class=\"string\">'src/img/*'</span>)</span><br><span class=\"line\">\t\t.pipe(imagemin())</span><br><span class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/img'</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>对于imagemin()进行图片压缩，可以结合使用<code>gulp-cache</code>对图片进行缓存。具体用法，我也没研究太懂 :joy:</p>\n<hr>\n<p><a href=\"https://www.npmjs.com/package/browser-sync\" target=\"_blank\" rel=\"noopener\">browser-sync</a>:属于综合测试的工具，可以实现页面自动刷新、多屏同步操作等功能。</p>\n<p>任务实例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//首先browser-sync的引用，官方推荐使用create()方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> browserSync = <span class=\"built_in\">require</span>(<span class=\"string\">'browser-sync'</span>).create();</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'serve'</span>, [<span class=\"string\">'sass'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\tbrowserSync.init(&#123;</span><br><span class=\"line\">\t\tserver: <span class=\"string\">'./'</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tgulp.watch(<span class=\"string\">'src/sass/*.scss'</span>, [<span class=\"string\">'sass'</span>]);</span><br><span class=\"line\">\tgulp.watch(<span class=\"string\">'*.html'</span>).on(<span class=\"string\">'change'</span>, browserSync.reload);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>其中<code>server: &#39;./&#39;</code>会将当前目录作为服务器访问地址<br><br><code>gulp.watch(&#39;src/sass/*.scss&#39;, [&#39;sass&#39;])</code>会监听<em>.scss文件，执行<code>sass</code>任务，并且实时反应到浏览器上。<br>`gulp.watch(‘</em>.html’).on(‘change’, browserSync.reload)`不同之处在于，会执行reload方法，重新加载页面。</p>\n<hr>\n<p>对于工具，我觉得更多的是直接拿过来使用，而不是非要去研究清楚每个API的作用。当然，特别感兴趣的也可以尝试研究工具，甚至是自己动手去制造这些工具。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>有了之前的gulp经验，使用其他gulp工具就是很简单的工作了。</p>\n<blockquote>\n<p>ps:    以下代码前均包含<code>var gulp = require(&#39;gulp&#39;)</code></p>\n</blockquote>\n<blockquote>\n<p>类似<code>sass()</code>表示前面包含<code>var sass = require(&#39;gulp-sass&#39;)</code></p>\n</blockquote>\n<hr>\n<p><a href=\"https://www.npmjs.com/package/gulp-autoprefixer\" target=\"_blank\" rel=\"noopener\">gulp-autoprefixer</a>：应该属于css后处理工具，在编写css完成之后，会根据我们的配置自动按需添加浏览器前缀。</p>\n<p>任务事例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'sass'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'src/sass/*.scss'</span>)</span><br><span class=\"line\">\t\t\t\t\t.pipe(sass())</span><br><span class=\"line\">\t\t\t\t\t.pipe(autoprefixer(<span class=\"string\">'last 2 versions'</span>, <span class=\"string\">'ios 6'</span>, <span class=\"string\">'android 4'</span>))\t<span class=\"comment\">//autoprefixer</span></span><br><span class=\"line\">\t\t\t\t\t.pipe(gulp.dest(<span class=\"string\">'src/css'</span>))</span><br><span class=\"line\">\t\t\t\t\t.pipe(cleanCSS())\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//css压缩工具，前面介绍有</span></span><br><span class=\"line\">\t\t\t\t\t.pipe(gulp.dest(<span class=\"string\">'dist/css'</span>))</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>其中<code>autoprefixer(&#39;...&#39;,&#39;...&#39;,&#39;...&#39;)</code>为简写形式，其中<code>last 2 versions</code>表示兼容所有浏览器最新两个版本。<br>完整形式应该为<code>autoprefixer({ \n    browsers: [&#39;last 2 versions&#39;, &#39;ios 6&#39;],\n    cascade: true\n})</code></p>\n<hr>\n<p><a href=\"https://www.npmjs.com/package/gulp-imagemin\" target=\"_blank\" rel=\"noopener\">gulp-imagemin</a>:图片压缩工具。</p>\n<p>任务事例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'imageMin'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\tgulp.src(<span class=\"string\">'src/img/*'</span>)</span><br><span class=\"line\">\t\t.pipe(imagemin())</span><br><span class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/img'</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>对于imagemin()进行图片压缩，可以结合使用<code>gulp-cache</code>对图片进行缓存。具体用法，我也没研究太懂 :joy:</p>\n<hr>\n<p><a href=\"https://www.npmjs.com/package/browser-sync\" target=\"_blank\" rel=\"noopener\">browser-sync</a>:属于综合测试的工具，可以实现页面自动刷新、多屏同步操作等功能。</p>\n<p>任务实例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//首先browser-sync的引用，官方推荐使用create()方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> browserSync = <span class=\"built_in\">require</span>(<span class=\"string\">'browser-sync'</span>).create();</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'serve'</span>, [<span class=\"string\">'sass'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\tbrowserSync.init(&#123;</span><br><span class=\"line\">\t\tserver: <span class=\"string\">'./'</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tgulp.watch(<span class=\"string\">'src/sass/*.scss'</span>, [<span class=\"string\">'sass'</span>]);</span><br><span class=\"line\">\tgulp.watch(<span class=\"string\">'*.html'</span>).on(<span class=\"string\">'change'</span>, browserSync.reload);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>其中<code>server: &#39;./&#39;</code>会将当前目录作为服务器访问地址<br><br><code>gulp.watch(&#39;src/sass/*.scss&#39;, [&#39;sass&#39;])</code>会监听<em>.scss文件，执行<code>sass</code>任务，并且实时反应到浏览器上。<br>`gulp.watch(‘</em>.html’).on(‘change’, browserSync.reload)`不同之处在于，会执行reload方法，重新加载页面。</p>\n<hr>\n<p>对于工具，我觉得更多的是直接拿过来使用，而不是非要去研究清楚每个API的作用。当然，特别感兴趣的也可以尝试研究工具，甚至是自己动手去制造这些工具。</p>\n"},{"title":"了解Flutter","date":"2018-08-12T16:00:00.000Z","comments":1,"_content":"\n### 跨平台解决方案\n\n目前跨平台解决方案主要有WebView（Cordova）、转化为系统平台自带控件（RN），Flutter采取得的是使用自身的高性能渲染引擎(Skia)自绘。\n\nWebView: 界面通过HTML、CSS； 与原生交互通过桥接。    \n假跳转的请求拦截、弹窗拦截（alert、prompt、confirm）、JS上下文注入（iOS的JavaScriptCore、Android的addJavaScriptInterface）。\n\nReact Native： 界面通过React技术实现； 与原生交互通过桥接。\n\nFlutter: 界面通过自绘； 与原生交互，通过转换为原生代码。\n\n<img src=\"https://gw.alicdn.com/tfs/TB188eCw4GYBuNjy0FnXXX5lpXa-1271-922.png\">\n\n### Dart语言\n\n1. 面向对象语言，入口函数main函数。\n2. 所有变量的值都是对象，包括数字、字符串`1.toDouble();`。所有对象继承Object，未初始化的所有变量为null。\n3. 强类型语言，支持类型推断。\n4. 不具有public，protected和private关键字，以_开头的相当于私有。\n5. new可以省去。\n6. 级联运算符(..)，返回前一个值。\n```\n// JavaScript\nlet arr1 = [1, 2, 3]\narr1.push(4)\nlet arr2 = arr1\n\n// Dart\nList<int> list1 = [1, 2, 3];\nList<int> list2 = list1..insert(3, 4);\n```\n7. 提供??、?.等操作符。(js中&&，angular模板中的?.)\n8. 异步Future，可以使用async和await。(then、catch)\n9. 支持AOT和JIT运行方式（热重载）。\n\n### Flutter\n\n1. 所有内容继承自`Widget`。\n2. 主要分为`StatefulWidget`与`StatelessWidget`。\n3. 通过调用`setState`重新渲染组件。\n4. 布局支持flex、grid等。\n5. 组件丰富、自带icon。\n6. 通过`plugin`实现原生调用。\n7. 热重载，开发方便。\n\n生命周期： \n\n    initState，build, didUpdateWidget(oldWidget), deactivate， dispose等。\n\n全局密钥：\n\n    通过GlobalKey可以获得部件。","source":"_posts/了解Flutter.md","raw":"---\ntitle: 了解Flutter\ndate: 2018-08-13\ntags: [移动端, Flutter]\ncategories: \n- 移动端\ncomments: true\n---\n\n### 跨平台解决方案\n\n目前跨平台解决方案主要有WebView（Cordova）、转化为系统平台自带控件（RN），Flutter采取得的是使用自身的高性能渲染引擎(Skia)自绘。\n\nWebView: 界面通过HTML、CSS； 与原生交互通过桥接。    \n假跳转的请求拦截、弹窗拦截（alert、prompt、confirm）、JS上下文注入（iOS的JavaScriptCore、Android的addJavaScriptInterface）。\n\nReact Native： 界面通过React技术实现； 与原生交互通过桥接。\n\nFlutter: 界面通过自绘； 与原生交互，通过转换为原生代码。\n\n<img src=\"https://gw.alicdn.com/tfs/TB188eCw4GYBuNjy0FnXXX5lpXa-1271-922.png\">\n\n### Dart语言\n\n1. 面向对象语言，入口函数main函数。\n2. 所有变量的值都是对象，包括数字、字符串`1.toDouble();`。所有对象继承Object，未初始化的所有变量为null。\n3. 强类型语言，支持类型推断。\n4. 不具有public，protected和private关键字，以_开头的相当于私有。\n5. new可以省去。\n6. 级联运算符(..)，返回前一个值。\n```\n// JavaScript\nlet arr1 = [1, 2, 3]\narr1.push(4)\nlet arr2 = arr1\n\n// Dart\nList<int> list1 = [1, 2, 3];\nList<int> list2 = list1..insert(3, 4);\n```\n7. 提供??、?.等操作符。(js中&&，angular模板中的?.)\n8. 异步Future，可以使用async和await。(then、catch)\n9. 支持AOT和JIT运行方式（热重载）。\n\n### Flutter\n\n1. 所有内容继承自`Widget`。\n2. 主要分为`StatefulWidget`与`StatelessWidget`。\n3. 通过调用`setState`重新渲染组件。\n4. 布局支持flex、grid等。\n5. 组件丰富、自带icon。\n6. 通过`plugin`实现原生调用。\n7. 热重载，开发方便。\n\n生命周期： \n\n    initState，build, didUpdateWidget(oldWidget), deactivate， dispose等。\n\n全局密钥：\n\n    通过GlobalKey可以获得部件。","slug":"了解Flutter","published":1,"updated":"2018-08-13T07:49:16.980Z","layout":"post","photos":[],"link":"","_id":"cjks5i9ip002kvmti3sj6r1ru","content":"<h3 id=\"跨平台解决方案\"><a href=\"#跨平台解决方案\" class=\"headerlink\" title=\"跨平台解决方案\"></a>跨平台解决方案</h3><p>目前跨平台解决方案主要有WebView（Cordova）、转化为系统平台自带控件（RN），Flutter采取得的是使用自身的高性能渲染引擎(Skia)自绘。</p>\n<p>WebView: 界面通过HTML、CSS； 与原生交互通过桥接。<br>假跳转的请求拦截、弹窗拦截（alert、prompt、confirm）、JS上下文注入（iOS的JavaScriptCore、Android的addJavaScriptInterface）。</p>\n<p>React Native： 界面通过React技术实现； 与原生交互通过桥接。</p>\n<p>Flutter: 界面通过自绘； 与原生交互，通过转换为原生代码。</p>\n<p><img src=\"https://gw.alicdn.com/tfs/TB188eCw4GYBuNjy0FnXXX5lpXa-1271-922.png\"></p>\n<h3 id=\"Dart语言\"><a href=\"#Dart语言\" class=\"headerlink\" title=\"Dart语言\"></a>Dart语言</h3><ol>\n<li>面向对象语言，入口函数main函数。</li>\n<li>所有变量的值都是对象，包括数字、字符串<code>1.toDouble();</code>。所有对象继承Object，未初始化的所有变量为null。</li>\n<li>强类型语言，支持类型推断。</li>\n<li>不具有public，protected和private关键字，以_开头的相当于私有。</li>\n<li>new可以省去。</li>\n<li><p>级联运算符(..)，返回前一个值。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JavaScript</span></span><br><span class=\"line\">let arr1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">arr1.push(<span class=\"number\">4</span>)</span><br><span class=\"line\">let arr2 = arr1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dart</span></span><br><span class=\"line\">List&lt;int&gt; list1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">List&lt;int&gt; list2 = list1..insert(<span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>提供??、?.等操作符。(js中&amp;&amp;，angular模板中的?.)</p>\n</li>\n<li>异步Future，可以使用async和await。(then、catch)</li>\n<li>支持AOT和JIT运行方式（热重载）。</li>\n</ol>\n<h3 id=\"Flutter\"><a href=\"#Flutter\" class=\"headerlink\" title=\"Flutter\"></a>Flutter</h3><ol>\n<li>所有内容继承自<code>Widget</code>。</li>\n<li>主要分为<code>StatefulWidget</code>与<code>StatelessWidget</code>。</li>\n<li>通过调用<code>setState</code>重新渲染组件。</li>\n<li>布局支持flex、grid等。</li>\n<li>组件丰富、自带icon。</li>\n<li>通过<code>plugin</code>实现原生调用。</li>\n<li>热重载，开发方便。</li>\n</ol>\n<p>生命周期： </p>\n<pre><code>initState，build, didUpdateWidget(oldWidget), deactivate， dispose等。\n</code></pre><p>全局密钥：</p>\n<pre><code>通过GlobalKey可以获得部件。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"跨平台解决方案\"><a href=\"#跨平台解决方案\" class=\"headerlink\" title=\"跨平台解决方案\"></a>跨平台解决方案</h3><p>目前跨平台解决方案主要有WebView（Cordova）、转化为系统平台自带控件（RN），Flutter采取得的是使用自身的高性能渲染引擎(Skia)自绘。</p>\n<p>WebView: 界面通过HTML、CSS； 与原生交互通过桥接。<br>假跳转的请求拦截、弹窗拦截（alert、prompt、confirm）、JS上下文注入（iOS的JavaScriptCore、Android的addJavaScriptInterface）。</p>\n<p>React Native： 界面通过React技术实现； 与原生交互通过桥接。</p>\n<p>Flutter: 界面通过自绘； 与原生交互，通过转换为原生代码。</p>\n<p><img src=\"https://gw.alicdn.com/tfs/TB188eCw4GYBuNjy0FnXXX5lpXa-1271-922.png\"></p>\n<h3 id=\"Dart语言\"><a href=\"#Dart语言\" class=\"headerlink\" title=\"Dart语言\"></a>Dart语言</h3><ol>\n<li>面向对象语言，入口函数main函数。</li>\n<li>所有变量的值都是对象，包括数字、字符串<code>1.toDouble();</code>。所有对象继承Object，未初始化的所有变量为null。</li>\n<li>强类型语言，支持类型推断。</li>\n<li>不具有public，protected和private关键字，以_开头的相当于私有。</li>\n<li>new可以省去。</li>\n<li><p>级联运算符(..)，返回前一个值。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JavaScript</span></span><br><span class=\"line\">let arr1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">arr1.push(<span class=\"number\">4</span>)</span><br><span class=\"line\">let arr2 = arr1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dart</span></span><br><span class=\"line\">List&lt;int&gt; list1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">List&lt;int&gt; list2 = list1..insert(<span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>提供??、?.等操作符。(js中&amp;&amp;，angular模板中的?.)</p>\n</li>\n<li>异步Future，可以使用async和await。(then、catch)</li>\n<li>支持AOT和JIT运行方式（热重载）。</li>\n</ol>\n<h3 id=\"Flutter\"><a href=\"#Flutter\" class=\"headerlink\" title=\"Flutter\"></a>Flutter</h3><ol>\n<li>所有内容继承自<code>Widget</code>。</li>\n<li>主要分为<code>StatefulWidget</code>与<code>StatelessWidget</code>。</li>\n<li>通过调用<code>setState</code>重新渲染组件。</li>\n<li>布局支持flex、grid等。</li>\n<li>组件丰富、自带icon。</li>\n<li>通过<code>plugin</code>实现原生调用。</li>\n<li>热重载，开发方便。</li>\n</ol>\n<p>生命周期： </p>\n<pre><code>initState，build, didUpdateWidget(oldWidget), deactivate， dispose等。\n</code></pre><p>全局密钥：</p>\n<pre><code>通过GlobalKey可以获得部件。\n</code></pre>"},{"title":"今天的面试","date":"2016-06-13T14:04:00.000Z","comments":1,"_content":"　　英语教育方面公司，笔试+面试，题目类型主要包括JS基础、git操作、Linux基础。\n　　首先就把题目虐了一遍，全英文题目，幸好只是简单的output之类勉强能够理解题目内容。\n　　API不熟悉：考察了reduce、for of,这两个函数完全没用过，对于for of我只知道for in。NaN不熟悉，<!--more-->typeof NaN当时蒙逼的我竟然回答个NaN，typeof结果只有string、number、boolean、object、function、undefined，白记了。最最最蒙逼的是，`console.log(function(){} && null)`这个竟然不是考察类型转换的，感觉就像是被前面的一大堆==和===带跑了，好吧，我承认还是自己的基础问题。之后的angular就不说了，我那入门水平真不够看的。\n　　git和linux的考察就不是我能够掌控得了的了，考察了git分支的合并，git中移除某个项目不再管理。linux考察了权限，vim的基本操作。git平时都是一个人写写，提交一下，linux更是自从大二考试结束后就没再接触，哎~只能是自己的叹息。\n　　总结下来，基础方面是有些差，JS那些基础问题应该都明白的，和自己有些浮躁有关。期间几个问题挺尴尬的，一个是问到了英语水平，一个是问我JS方面的书读过几本，细细想来，好像一本完整的都没有。git和linux的问题也许情有可原，JS就是一个大问题了。","source":"_posts/今天的面试.md","raw":"---\ntitle: 今天的面试\ndate: 2016-06-13 22:04\ntags: [面试, JavaScript]\ncategories: \n- 杂记\ncomments: true\n---\n　　英语教育方面公司，笔试+面试，题目类型主要包括JS基础、git操作、Linux基础。\n　　首先就把题目虐了一遍，全英文题目，幸好只是简单的output之类勉强能够理解题目内容。\n　　API不熟悉：考察了reduce、for of,这两个函数完全没用过，对于for of我只知道for in。NaN不熟悉，<!--more-->typeof NaN当时蒙逼的我竟然回答个NaN，typeof结果只有string、number、boolean、object、function、undefined，白记了。最最最蒙逼的是，`console.log(function(){} && null)`这个竟然不是考察类型转换的，感觉就像是被前面的一大堆==和===带跑了，好吧，我承认还是自己的基础问题。之后的angular就不说了，我那入门水平真不够看的。\n　　git和linux的考察就不是我能够掌控得了的了，考察了git分支的合并，git中移除某个项目不再管理。linux考察了权限，vim的基本操作。git平时都是一个人写写，提交一下，linux更是自从大二考试结束后就没再接触，哎~只能是自己的叹息。\n　　总结下来，基础方面是有些差，JS那些基础问题应该都明白的，和自己有些浮躁有关。期间几个问题挺尴尬的，一个是问到了英语水平，一个是问我JS方面的书读过几本，细细想来，好像一本完整的都没有。git和linux的问题也许情有可原，JS就是一个大问题了。","slug":"今天的面试","published":1,"updated":"2017-12-28T03:47:32.464Z","layout":"post","photos":[],"link":"","_id":"cjks5i9ir002pvmtiil1qsuul","content":"<p>　　英语教育方面公司，笔试+面试，题目类型主要包括JS基础、git操作、Linux基础。<br>　　首先就把题目虐了一遍，全英文题目，幸好只是简单的output之类勉强能够理解题目内容。<br>　　API不熟悉：考察了reduce、for of,这两个函数完全没用过，对于for of我只知道for in。NaN不熟悉，<a id=\"more\"></a>typeof NaN当时蒙逼的我竟然回答个NaN，typeof结果只有string、number、boolean、object、function、undefined，白记了。最最最蒙逼的是，<code>console.log(function(){} &amp;&amp; null)</code>这个竟然不是考察类型转换的，感觉就像是被前面的一大堆==和===带跑了，好吧，我承认还是自己的基础问题。之后的angular就不说了，我那入门水平真不够看的。<br>　　git和linux的考察就不是我能够掌控得了的了，考察了git分支的合并，git中移除某个项目不再管理。linux考察了权限，vim的基本操作。git平时都是一个人写写，提交一下，linux更是自从大二考试结束后就没再接触，哎~只能是自己的叹息。<br>　　总结下来，基础方面是有些差，JS那些基础问题应该都明白的，和自己有些浮躁有关。期间几个问题挺尴尬的，一个是问到了英语水平，一个是问我JS方面的书读过几本，细细想来，好像一本完整的都没有。git和linux的问题也许情有可原，JS就是一个大问题了。</p>\n","site":{"data":{}},"excerpt":"<p>　　英语教育方面公司，笔试+面试，题目类型主要包括JS基础、git操作、Linux基础。<br>　　首先就把题目虐了一遍，全英文题目，幸好只是简单的output之类勉强能够理解题目内容。<br>　　API不熟悉：考察了reduce、for of,这两个函数完全没用过，对于for of我只知道for in。NaN不熟悉，","more":"typeof NaN当时蒙逼的我竟然回答个NaN，typeof结果只有string、number、boolean、object、function、undefined，白记了。最最最蒙逼的是，<code>console.log(function(){} &amp;&amp; null)</code>这个竟然不是考察类型转换的，感觉就像是被前面的一大堆==和===带跑了，好吧，我承认还是自己的基础问题。之后的angular就不说了，我那入门水平真不够看的。<br>　　git和linux的考察就不是我能够掌控得了的了，考察了git分支的合并，git中移除某个项目不再管理。linux考察了权限，vim的基本操作。git平时都是一个人写写，提交一下，linux更是自从大二考试结束后就没再接触，哎~只能是自己的叹息。<br>　　总结下来，基础方面是有些差，JS那些基础问题应该都明白的，和自己有些浮躁有关。期间几个问题挺尴尬的，一个是问到了英语水平，一个是问我JS方面的书读过几本，细细想来，好像一本完整的都没有。git和linux的问题也许情有可原，JS就是一个大问题了。</p>"},{"title":"从零开始搭建React(1)","date":"2016-11-12T16:00:00.000Z","comments":1,"_content":"\n学习React几乎绕不开Webpack，就像使用Java需要搭建环境、规划目录结构、写各种配置文件一样，这里我们也要搭建这样的一个脚手架。当然，这里只是我的简单总结，并不是什么最佳实践，只是一步步去理解这个搭建过程。  \n目录结构开始只是简单的`myapp/src`，首先肯定是安装react、react-dom、webpack，webpack官网是安装在全局的。[参见官网](http://webpack.github.io/docs/tutorials/getting-started/#welcome)  \n这时候就可以开始写webpack配置文件，在编写之前，可以安装eslint来规范代码，这里的配置文件我是写在`myapp/src/config/webpack.config.js`，最基本的样子如下（可以在官网找到各配置项表示，这里使用的是node API形式）：\n```javascript\n// webpack.config.js\nvar path = require('path')\nvar webpack = require('webpack')\n\nvar src = path.resolve(__dirname, '../../src')  // 源码目录\nvar build = path.resolve(__dirname, '../../dist')   // 编译目录\n\nmodule.exports = {\n  entry: {\n    app: path.join(src, 'app.js')\n  },\n  output: {\n    filename: '[name].js',\n    path: build,\n    publicPath: '/static/'\n  },\n  resolve: {\n    extensions: ['', '.js']\n  },\n  module: {\n    loaders: [{\n      test: /\\.js$/,\n      include: src,\n      loader: 'babel'\n    }, {\n      test: /\\.scss$/,\n      loaders: ['style', 'css', 'sass']\n    }]\n  }\n}\n```\n\n接下来就是根据loaders安装各种webpack-loader，以后随着项目的需要，这里肯定还会添加更多的webpack-loader，安装方式就是`npm install --save-dev babel-loader style-loader css-loader sass-loader`。然后，创建`myapp/src/app.js`文件用于测试我们的环境。执行`webpack --config src/config/webpack.config.js`，会发现报错`can't find module 'babel-core'`，那么就按照提示，安装babel-core，一定要学会看提示/报错信息。  \n再次执行`webpack --config src/config/webpack.config.js`(以下简称执行webpack)应该会生成`myapp/dist/app.js`文件，里面应该是只有一段webpackBootstrap以及一段空函数function(module, exports)。  \n在`src/app.js`中编写代码用于环境测试：\n```javascript\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\nReactDOM.render(\n    <h1>Hello React</h1>,\n    document.getElementById('app')\n  )\n```\n再次执行`webpack --config src/config/webpack.config.js`，发现报错Unexpected token在<h1\\>位置，显然是babel不能识别jsx格式，我们并没有配置babel的转换规则。创建`myapp/.babelrc`，一般的基础配置是，具体规则[参见官网](http://babeljs.io/docs/plugins/)。\n```json\n{\n  \"presets\": [\"es2015\", \"react\", \"stage-0\"]\n}\n```\n安装这些preset，再次执行webpack，生成编译后的文件。创建html文件：\n```html\n<!-- 我这里的路径是myapp/src/index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title></title>\n</head>\n<body>\n  <div id=\"app\"></div>\n  <script type=\"text/javascript\" src=\"../dist/app.js\"></script>\n</body>\n</html>\n```\n用浏览器打开该文件，则能看到Hello React。  \n然后测试sass文件怎么样，创建`myapp/src/app.scss`\n```sass\nh1 {\n  background: red;\n}\n```\n在`myapp/src/app.js`中引入该scss文件`import './app.scss'`  \n执行webpack，可能会报错can't find module node-sass，再次安装此模块，执行webpack刷新页面，应该会看到Hello React背景色变成红色。\n\n至此，一个最简单的webpack打包React的环境完成。虽然这个环境可以使用，但是没有好好利用webpack，也就没有提高一点我们的工作效率。","source":"_posts/从零搭建React(1).md","raw":"---\ntitle: 从零开始搭建React(1)\ndate: 2016-11-13\ntags: [JavaScript, React, Webpack]\ncategories: \n- React\ncomments: true\n---\n\n学习React几乎绕不开Webpack，就像使用Java需要搭建环境、规划目录结构、写各种配置文件一样，这里我们也要搭建这样的一个脚手架。当然，这里只是我的简单总结，并不是什么最佳实践，只是一步步去理解这个搭建过程。  \n目录结构开始只是简单的`myapp/src`，首先肯定是安装react、react-dom、webpack，webpack官网是安装在全局的。[参见官网](http://webpack.github.io/docs/tutorials/getting-started/#welcome)  \n这时候就可以开始写webpack配置文件，在编写之前，可以安装eslint来规范代码，这里的配置文件我是写在`myapp/src/config/webpack.config.js`，最基本的样子如下（可以在官网找到各配置项表示，这里使用的是node API形式）：\n```javascript\n// webpack.config.js\nvar path = require('path')\nvar webpack = require('webpack')\n\nvar src = path.resolve(__dirname, '../../src')  // 源码目录\nvar build = path.resolve(__dirname, '../../dist')   // 编译目录\n\nmodule.exports = {\n  entry: {\n    app: path.join(src, 'app.js')\n  },\n  output: {\n    filename: '[name].js',\n    path: build,\n    publicPath: '/static/'\n  },\n  resolve: {\n    extensions: ['', '.js']\n  },\n  module: {\n    loaders: [{\n      test: /\\.js$/,\n      include: src,\n      loader: 'babel'\n    }, {\n      test: /\\.scss$/,\n      loaders: ['style', 'css', 'sass']\n    }]\n  }\n}\n```\n\n接下来就是根据loaders安装各种webpack-loader，以后随着项目的需要，这里肯定还会添加更多的webpack-loader，安装方式就是`npm install --save-dev babel-loader style-loader css-loader sass-loader`。然后，创建`myapp/src/app.js`文件用于测试我们的环境。执行`webpack --config src/config/webpack.config.js`，会发现报错`can't find module 'babel-core'`，那么就按照提示，安装babel-core，一定要学会看提示/报错信息。  \n再次执行`webpack --config src/config/webpack.config.js`(以下简称执行webpack)应该会生成`myapp/dist/app.js`文件，里面应该是只有一段webpackBootstrap以及一段空函数function(module, exports)。  \n在`src/app.js`中编写代码用于环境测试：\n```javascript\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\nReactDOM.render(\n    <h1>Hello React</h1>,\n    document.getElementById('app')\n  )\n```\n再次执行`webpack --config src/config/webpack.config.js`，发现报错Unexpected token在<h1\\>位置，显然是babel不能识别jsx格式，我们并没有配置babel的转换规则。创建`myapp/.babelrc`，一般的基础配置是，具体规则[参见官网](http://babeljs.io/docs/plugins/)。\n```json\n{\n  \"presets\": [\"es2015\", \"react\", \"stage-0\"]\n}\n```\n安装这些preset，再次执行webpack，生成编译后的文件。创建html文件：\n```html\n<!-- 我这里的路径是myapp/src/index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title></title>\n</head>\n<body>\n  <div id=\"app\"></div>\n  <script type=\"text/javascript\" src=\"../dist/app.js\"></script>\n</body>\n</html>\n```\n用浏览器打开该文件，则能看到Hello React。  \n然后测试sass文件怎么样，创建`myapp/src/app.scss`\n```sass\nh1 {\n  background: red;\n}\n```\n在`myapp/src/app.js`中引入该scss文件`import './app.scss'`  \n执行webpack，可能会报错can't find module node-sass，再次安装此模块，执行webpack刷新页面，应该会看到Hello React背景色变成红色。\n\n至此，一个最简单的webpack打包React的环境完成。虽然这个环境可以使用，但是没有好好利用webpack，也就没有提高一点我们的工作效率。","slug":"从零搭建React(1)","published":1,"updated":"2017-12-28T03:47:32.464Z","layout":"post","photos":[],"link":"","_id":"cjks5i9is002svmtir6k2ba7e","content":"<p>学习React几乎绕不开Webpack，就像使用Java需要搭建环境、规划目录结构、写各种配置文件一样，这里我们也要搭建这样的一个脚手架。当然，这里只是我的简单总结，并不是什么最佳实践，只是一步步去理解这个搭建过程。<br>目录结构开始只是简单的<code>myapp/src</code>，首先肯定是安装react、react-dom、webpack，webpack官网是安装在全局的。<a href=\"http://webpack.github.io/docs/tutorials/getting-started/#welcome\" target=\"_blank\" rel=\"noopener\">参见官网</a><br>这时候就可以开始写webpack配置文件，在编写之前，可以安装eslint来规范代码，这里的配置文件我是写在<code>myapp/src/config/webpack.config.js</code>，最基本的样子如下（可以在官网找到各配置项表示，这里使用的是node API形式）：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> src = path.resolve(__dirname, <span class=\"string\">'../../src'</span>)  <span class=\"comment\">// 源码目录</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> build = path.resolve(__dirname, <span class=\"string\">'../../dist'</span>)   <span class=\"comment\">// 编译目录</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    app: path.join(src, <span class=\"string\">'app.js'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span>,</span><br><span class=\"line\">    path: build,</span><br><span class=\"line\">    publicPath: <span class=\"string\">'/static/'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    extensions: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    loaders: [&#123;</span><br><span class=\"line\">      test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">      include: src,</span><br><span class=\"line\">      loader: <span class=\"string\">'babel'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      test: <span class=\"regexp\">/\\.scss$/</span>,</span><br><span class=\"line\">      loaders: [<span class=\"string\">'style'</span>, <span class=\"string\">'css'</span>, <span class=\"string\">'sass'</span>]</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来就是根据loaders安装各种webpack-loader，以后随着项目的需要，这里肯定还会添加更多的webpack-loader，安装方式就是<code>npm install --save-dev babel-loader style-loader css-loader sass-loader</code>。然后，创建<code>myapp/src/app.js</code>文件用于测试我们的环境。执行<code>webpack --config src/config/webpack.config.js</code>，会发现报错<code>can&#39;t find module &#39;babel-core&#39;</code>，那么就按照提示，安装babel-core，一定要学会看提示/报错信息。<br>再次执行<code>webpack --config src/config/webpack.config.js</code>(以下简称执行webpack)应该会生成<code>myapp/dist/app.js</code>文件，里面应该是只有一段webpackBootstrap以及一段空函数function(module, exports)。<br>在<code>src/app.js</code>中编写代码用于环境测试：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">    &lt;h1&gt;Hello React&lt;<span class=\"regexp\">/h1&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">    document.getElementById('app')</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br></pre></td></tr></table></figure></p>\n<p>再次执行<code>webpack --config src/config/webpack.config.js</code>，发现报错Unexpected token在&lt;h1>位置，显然是babel不能识别jsx格式，我们并没有配置babel的转换规则。创建<code>myapp/.babelrc</code>，一般的基础配置是，具体规则<a href=\"http://babeljs.io/docs/plugins/\" target=\"_blank\" rel=\"noopener\">参见官网</a>。<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"presets\"</span>: [<span class=\"string\">\"es2015\"</span>, <span class=\"string\">\"react\"</span>, <span class=\"string\">\"stage-0\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>安装这些preset，再次执行webpack，生成编译后的文件。创建html文件：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 我这里的路径是myapp/src/index.html --&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../dist/app.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>用浏览器打开该文件，则能看到Hello React。<br>然后测试sass文件怎么样，创建<code>myapp/src/app.scss</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h1 &#123;</span><br><span class=\"line\">  background: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>myapp/src/app.js</code>中引入该scss文件<code>import &#39;./app.scss&#39;</code><br>执行webpack，可能会报错can’t find module node-sass，再次安装此模块，执行webpack刷新页面，应该会看到Hello React背景色变成红色。</p>\n<p>至此，一个最简单的webpack打包React的环境完成。虽然这个环境可以使用，但是没有好好利用webpack，也就没有提高一点我们的工作效率。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>学习React几乎绕不开Webpack，就像使用Java需要搭建环境、规划目录结构、写各种配置文件一样，这里我们也要搭建这样的一个脚手架。当然，这里只是我的简单总结，并不是什么最佳实践，只是一步步去理解这个搭建过程。<br>目录结构开始只是简单的<code>myapp/src</code>，首先肯定是安装react、react-dom、webpack，webpack官网是安装在全局的。<a href=\"http://webpack.github.io/docs/tutorials/getting-started/#welcome\" target=\"_blank\" rel=\"noopener\">参见官网</a><br>这时候就可以开始写webpack配置文件，在编写之前，可以安装eslint来规范代码，这里的配置文件我是写在<code>myapp/src/config/webpack.config.js</code>，最基本的样子如下（可以在官网找到各配置项表示，这里使用的是node API形式）：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> src = path.resolve(__dirname, <span class=\"string\">'../../src'</span>)  <span class=\"comment\">// 源码目录</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> build = path.resolve(__dirname, <span class=\"string\">'../../dist'</span>)   <span class=\"comment\">// 编译目录</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    app: path.join(src, <span class=\"string\">'app.js'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span>,</span><br><span class=\"line\">    path: build,</span><br><span class=\"line\">    publicPath: <span class=\"string\">'/static/'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    extensions: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    loaders: [&#123;</span><br><span class=\"line\">      test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">      include: src,</span><br><span class=\"line\">      loader: <span class=\"string\">'babel'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      test: <span class=\"regexp\">/\\.scss$/</span>,</span><br><span class=\"line\">      loaders: [<span class=\"string\">'style'</span>, <span class=\"string\">'css'</span>, <span class=\"string\">'sass'</span>]</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来就是根据loaders安装各种webpack-loader，以后随着项目的需要，这里肯定还会添加更多的webpack-loader，安装方式就是<code>npm install --save-dev babel-loader style-loader css-loader sass-loader</code>。然后，创建<code>myapp/src/app.js</code>文件用于测试我们的环境。执行<code>webpack --config src/config/webpack.config.js</code>，会发现报错<code>can&#39;t find module &#39;babel-core&#39;</code>，那么就按照提示，安装babel-core，一定要学会看提示/报错信息。<br>再次执行<code>webpack --config src/config/webpack.config.js</code>(以下简称执行webpack)应该会生成<code>myapp/dist/app.js</code>文件，里面应该是只有一段webpackBootstrap以及一段空函数function(module, exports)。<br>在<code>src/app.js</code>中编写代码用于环境测试：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">    &lt;h1&gt;Hello React&lt;<span class=\"regexp\">/h1&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">    document.getElementById('app')</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br></pre></td></tr></table></figure></p>\n<p>再次执行<code>webpack --config src/config/webpack.config.js</code>，发现报错Unexpected token在&lt;h1>位置，显然是babel不能识别jsx格式，我们并没有配置babel的转换规则。创建<code>myapp/.babelrc</code>，一般的基础配置是，具体规则<a href=\"http://babeljs.io/docs/plugins/\" target=\"_blank\" rel=\"noopener\">参见官网</a>。<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"presets\"</span>: [<span class=\"string\">\"es2015\"</span>, <span class=\"string\">\"react\"</span>, <span class=\"string\">\"stage-0\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>安装这些preset，再次执行webpack，生成编译后的文件。创建html文件：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 我这里的路径是myapp/src/index.html --&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../dist/app.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>用浏览器打开该文件，则能看到Hello React。<br>然后测试sass文件怎么样，创建<code>myapp/src/app.scss</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h1 &#123;</span><br><span class=\"line\">  background: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>myapp/src/app.js</code>中引入该scss文件<code>import &#39;./app.scss&#39;</code><br>执行webpack，可能会报错can’t find module node-sass，再次安装此模块，执行webpack刷新页面，应该会看到Hello React背景色变成红色。</p>\n<p>至此，一个最简单的webpack打包React的环境完成。虽然这个环境可以使用，但是没有好好利用webpack，也就没有提高一点我们的工作效率。</p>\n"},{"title":"从零开始搭建React(2)","date":"2016-11-13T16:00:00.000Z","comments":1,"_content":"\n提高开发效率，我们发现前面用的最多的就是`webpack --config ***`，然后去刷新页面。解决此问题，可以使用[react-hot-loader](https://github.com/gaearon/react-hot-loader)，这应该也是我们使用github的原因，在这里我们可以找到解决各种问题的办法。  \n查看其中使用方法（看不懂英文就用翻译一句一句看呗，其实我也是这么看过来的），会发现这一句These steps are covered by [the walkthrough](http://gaearon.github.io/react-hot-loader/getstarted/)（这里应该是1版本的写法）。  \n根据这里的步骤，先是安装react-hot-loader，然后是server.js，提供有事例：\n```javascript\n// 我的路径 myapp/src/config/server.js\nvar path = require('path')\nvar webpack = require('webpack')\nvar express = require('express')\nvar config = require('./webpack.config')\n\nvar app = express()\nvar compiler = webpack(config)\n\napp.use(require('webpack-dev-middleware')(compiler, {\n  publicPath: config.output.publicPath\n}))\n\napp.use(require('webpack-hot-middleware')(compiler))\n\napp.get('*', function (req, res) {\n  res.sendFile(path.join(__dirname, '../index.html'))\n})\n\napp.listen(3000, function (err) {\n  if (err) {\n    return console.error(err)\n  }\n\n  console.log('Listening at http://localhost:3000/')\n})\n```\n需要安装express，另外需要修改`res.sendFile(path.join(__dirname, '../index.html'))`这里的路径，还有端口。  \n接着修改webpack的配置文件，在入口配置项前面添加，\n```javascript\nentry: {\n  app: [\n  'webpack-dev-server/client?http://0.0.0.0:3000', // WebpackDevServer host and port\n  'webpack/hot/only-dev-server', // \"only\" prevents reload on syntax errors\n  path.join(src, 'app.js')\n  ]\n}\n```\n这个应该是1版本的写法，而我这里安装的是3版本，导致页面会多次刷新。下面是3版本，具体参看[事例](https://github.com/gaearon/react-hot-boilerplate/tree/next)\n```javascript\nentry: {\n    app: [\n      'react-hot-loader/patch',\n      'webpack-hot-middleware/client',\n      path.join(src, 'app.js')\n    ]\n  },\n```\n接着是在oader中添加react-hot，按照官网是将react-hot添加在babel前面即可\n```javascript\nloaders: [{\n  test: /\\.js$/,\n  include: src,\n  loaders: ['react-hot', 'babel']\n}]\n```\n但是在我这里报错了，报错提示还算明显，大致就是将react-hot-loader/babel添加到babel的plugins中，于是修改`myapp/.babelrc`解决。同样是1和3的区别\n```json\n{\n  \"presets\": [\"es2015\", \"react\", \"stage-0\"],\n  \"plugins\": [\"react-hot-loader/babel\"]\n}\n```\n最后一步，是webpack中添加plugins\n```javascript\nplugins: [\n  new webpack.HotModuleReplacementPlugin()\n]\n```\n1版本到这里就结束了，3版本是这样的\n```javascript\n// myapp/src/app.js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport { AppContainer } from 'react-hot-loader'\nimport Hello from './Hello'\nimport './app.scss'\n\nReactDOM.render(\n    <AppContainer>\n      <Hello />\n    </AppContainer>,\n    document.getElementById('app')\n  )\n\nif (module.hot) {\n  module.hot.accept('./Hello', () => {\n    // If you use Webpack 2 in ES modules mode, you can\n    // use <App /> here rather than require() a <NextApp />.\n    const NextApp = require('./Hello').default\n    ReactDOM.render(\n      <AppContainer>\n         <NextApp />\n      </AppContainer>,\n      document.getElementById('app')\n    )\n  })\n}\n```\n```javascript\n// myapp/src/Hello.js\nimport React from 'react'\nexport default function Layout () {\n  return (\n    <div>\n      <h1>Hello, world!!</h1>\n    </div>\n  )\n}\n```\n这里有个小坑，改变app.js文件中的内容并不会刷新，需要手动刷新页面。\n\n启动就是`node src/config/server.js`，可以将其写入到package.json文件中`\"script\": {\"start\": \"node src/config/server.js\"}`\n\n最后遇到一个小坑，在HTML文件引用入口文件中，地址应该是webpack配置中的`output.publicPath/[name].js`，如`<script src=\"/static/app.js\"></script>`。引用不到，或者路径错误会将html文件作为js文件引入，报错。  \n至此，在之后的编写中就不需要一遍又一遍的`webpack --config ****`\n\n------------------\n11.18补充\n\n分离打包：  \n在入口文件中添加要分离的模块：(这里将react和react-dom打包到vendor中)\n```javascript\nentry: {\n    app: [\n      'react-hot-loader/patch',\n      'webpack-hot-middleware/client',\n      path.join(src, 'index.js')\n    ],\n+    // 打包分离\n+    vendor: [\n+      'react',\n+      'react-dom'\n+    ]\n  },\n```\n增加CommonsChunkPlugin插件：\n```javascript\n  plugins: [\n+    // 分离打包\n+    new webpack.optimize.CommonsChunkPlugin({\n+      names: ['vendor']\n+    }),\n    // 热加载\n    new webpack.HotModuleReplacementPlugin()\n  ]\n```\n分离打包后，两个app.js和vendor.js都需要引入。","source":"_posts/从零搭建React(2).md","raw":"---\ntitle: 从零开始搭建React(2)\ndate: 2016-11-14\ntags: [JavaScript, React, Webpack]\ncategories: \n- React\ncomments: true\n---\n\n提高开发效率，我们发现前面用的最多的就是`webpack --config ***`，然后去刷新页面。解决此问题，可以使用[react-hot-loader](https://github.com/gaearon/react-hot-loader)，这应该也是我们使用github的原因，在这里我们可以找到解决各种问题的办法。  \n查看其中使用方法（看不懂英文就用翻译一句一句看呗，其实我也是这么看过来的），会发现这一句These steps are covered by [the walkthrough](http://gaearon.github.io/react-hot-loader/getstarted/)（这里应该是1版本的写法）。  \n根据这里的步骤，先是安装react-hot-loader，然后是server.js，提供有事例：\n```javascript\n// 我的路径 myapp/src/config/server.js\nvar path = require('path')\nvar webpack = require('webpack')\nvar express = require('express')\nvar config = require('./webpack.config')\n\nvar app = express()\nvar compiler = webpack(config)\n\napp.use(require('webpack-dev-middleware')(compiler, {\n  publicPath: config.output.publicPath\n}))\n\napp.use(require('webpack-hot-middleware')(compiler))\n\napp.get('*', function (req, res) {\n  res.sendFile(path.join(__dirname, '../index.html'))\n})\n\napp.listen(3000, function (err) {\n  if (err) {\n    return console.error(err)\n  }\n\n  console.log('Listening at http://localhost:3000/')\n})\n```\n需要安装express，另外需要修改`res.sendFile(path.join(__dirname, '../index.html'))`这里的路径，还有端口。  \n接着修改webpack的配置文件，在入口配置项前面添加，\n```javascript\nentry: {\n  app: [\n  'webpack-dev-server/client?http://0.0.0.0:3000', // WebpackDevServer host and port\n  'webpack/hot/only-dev-server', // \"only\" prevents reload on syntax errors\n  path.join(src, 'app.js')\n  ]\n}\n```\n这个应该是1版本的写法，而我这里安装的是3版本，导致页面会多次刷新。下面是3版本，具体参看[事例](https://github.com/gaearon/react-hot-boilerplate/tree/next)\n```javascript\nentry: {\n    app: [\n      'react-hot-loader/patch',\n      'webpack-hot-middleware/client',\n      path.join(src, 'app.js')\n    ]\n  },\n```\n接着是在oader中添加react-hot，按照官网是将react-hot添加在babel前面即可\n```javascript\nloaders: [{\n  test: /\\.js$/,\n  include: src,\n  loaders: ['react-hot', 'babel']\n}]\n```\n但是在我这里报错了，报错提示还算明显，大致就是将react-hot-loader/babel添加到babel的plugins中，于是修改`myapp/.babelrc`解决。同样是1和3的区别\n```json\n{\n  \"presets\": [\"es2015\", \"react\", \"stage-0\"],\n  \"plugins\": [\"react-hot-loader/babel\"]\n}\n```\n最后一步，是webpack中添加plugins\n```javascript\nplugins: [\n  new webpack.HotModuleReplacementPlugin()\n]\n```\n1版本到这里就结束了，3版本是这样的\n```javascript\n// myapp/src/app.js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport { AppContainer } from 'react-hot-loader'\nimport Hello from './Hello'\nimport './app.scss'\n\nReactDOM.render(\n    <AppContainer>\n      <Hello />\n    </AppContainer>,\n    document.getElementById('app')\n  )\n\nif (module.hot) {\n  module.hot.accept('./Hello', () => {\n    // If you use Webpack 2 in ES modules mode, you can\n    // use <App /> here rather than require() a <NextApp />.\n    const NextApp = require('./Hello').default\n    ReactDOM.render(\n      <AppContainer>\n         <NextApp />\n      </AppContainer>,\n      document.getElementById('app')\n    )\n  })\n}\n```\n```javascript\n// myapp/src/Hello.js\nimport React from 'react'\nexport default function Layout () {\n  return (\n    <div>\n      <h1>Hello, world!!</h1>\n    </div>\n  )\n}\n```\n这里有个小坑，改变app.js文件中的内容并不会刷新，需要手动刷新页面。\n\n启动就是`node src/config/server.js`，可以将其写入到package.json文件中`\"script\": {\"start\": \"node src/config/server.js\"}`\n\n最后遇到一个小坑，在HTML文件引用入口文件中，地址应该是webpack配置中的`output.publicPath/[name].js`，如`<script src=\"/static/app.js\"></script>`。引用不到，或者路径错误会将html文件作为js文件引入，报错。  \n至此，在之后的编写中就不需要一遍又一遍的`webpack --config ****`\n\n------------------\n11.18补充\n\n分离打包：  \n在入口文件中添加要分离的模块：(这里将react和react-dom打包到vendor中)\n```javascript\nentry: {\n    app: [\n      'react-hot-loader/patch',\n      'webpack-hot-middleware/client',\n      path.join(src, 'index.js')\n    ],\n+    // 打包分离\n+    vendor: [\n+      'react',\n+      'react-dom'\n+    ]\n  },\n```\n增加CommonsChunkPlugin插件：\n```javascript\n  plugins: [\n+    // 分离打包\n+    new webpack.optimize.CommonsChunkPlugin({\n+      names: ['vendor']\n+    }),\n    // 热加载\n    new webpack.HotModuleReplacementPlugin()\n  ]\n```\n分离打包后，两个app.js和vendor.js都需要引入。","slug":"从零搭建React(2)","published":1,"updated":"2017-12-28T03:47:32.464Z","layout":"post","photos":[],"link":"","_id":"cjks5i9iu002wvmticng7tsqw","content":"<p>提高开发效率，我们发现前面用的最多的就是<code>webpack --config ***</code>，然后去刷新页面。解决此问题，可以使用<a href=\"https://github.com/gaearon/react-hot-loader\" target=\"_blank\" rel=\"noopener\">react-hot-loader</a>，这应该也是我们使用github的原因，在这里我们可以找到解决各种问题的办法。<br>查看其中使用方法（看不懂英文就用翻译一句一句看呗，其实我也是这么看过来的），会发现这一句These steps are covered by <a href=\"http://gaearon.github.io/react-hot-loader/getstarted/\" target=\"_blank\" rel=\"noopener\">the walkthrough</a>（这里应该是1版本的写法）。<br>根据这里的步骤，先是安装react-hot-loader，然后是server.js，提供有事例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我的路径 myapp/src/config/server.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.config'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express()</span><br><span class=\"line\"><span class=\"keyword\">var</span> compiler = webpack(config)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"built_in\">require</span>(<span class=\"string\">'webpack-dev-middleware'</span>)(compiler, &#123;</span><br><span class=\"line\">  publicPath: config.output.publicPath</span><br><span class=\"line\">&#125;))</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"built_in\">require</span>(<span class=\"string\">'webpack-hot-middleware'</span>)(compiler))</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'*'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  res.sendFile(path.join(__dirname, <span class=\"string\">'../index.html'</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.error(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Listening at http://localhost:3000/'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>需要安装express，另外需要修改<code>res.sendFile(path.join(__dirname, &#39;../index.html&#39;))</code>这里的路径，还有端口。<br>接着修改webpack的配置文件，在入口配置项前面添加，<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">  app: [</span><br><span class=\"line\">  <span class=\"string\">'webpack-dev-server/client?http://0.0.0.0:3000'</span>, <span class=\"comment\">// WebpackDevServer host and port</span></span><br><span class=\"line\">  <span class=\"string\">'webpack/hot/only-dev-server'</span>, <span class=\"comment\">// \"only\" prevents reload on syntax errors</span></span><br><span class=\"line\">  path.join(src, <span class=\"string\">'app.js'</span>)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个应该是1版本的写法，而我这里安装的是3版本，导致页面会多次刷新。下面是3版本，具体参看<a href=\"https://github.com/gaearon/react-hot-boilerplate/tree/next\" target=\"_blank\" rel=\"noopener\">事例</a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">    app: [</span><br><span class=\"line\">      <span class=\"string\">'react-hot-loader/patch'</span>,</span><br><span class=\"line\">      <span class=\"string\">'webpack-hot-middleware/client'</span>,</span><br><span class=\"line\">      path.join(src, <span class=\"string\">'app.js'</span>)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure></p>\n<p>接着是在oader中添加react-hot，按照官网是将react-hot添加在babel前面即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loaders: [&#123;</span><br><span class=\"line\">  test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">  include: src,</span><br><span class=\"line\">  loaders: [<span class=\"string\">'react-hot'</span>, <span class=\"string\">'babel'</span>]</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>但是在我这里报错了，报错提示还算明显，大致就是将react-hot-loader/babel添加到babel的plugins中，于是修改<code>myapp/.babelrc</code>解决。同样是1和3的区别<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"presets\"</span>: [<span class=\"string\">\"es2015\"</span>, <span class=\"string\">\"react\"</span>, <span class=\"string\">\"stage-0\"</span>],</span><br><span class=\"line\">  <span class=\"attr\">\"plugins\"</span>: [<span class=\"string\">\"react-hot-loader/babel\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后一步，是webpack中添加plugins<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>1版本到这里就结束了，3版本是这样的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// myapp/src/app.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; AppContainer &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-hot-loader'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'./Hello'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./app.scss'</span></span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">    &lt;AppContainer&gt;</span><br><span class=\"line\">      &lt;Hello /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/AppContainer&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">    document.getElementById('app')</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">if (module.hot) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  module.hot.accept('./</span>Hello<span class=\"string\">', () =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">    // If you use Webpack 2 in ES modules mode, you can</span></span><br><span class=\"line\"><span class=\"string\">    // use &lt;App /&gt; here rather than require() a &lt;NextApp /&gt;.</span></span><br><span class=\"line\"><span class=\"string\">    const NextApp = require('</span>./Hello<span class=\"string\">').default</span></span><br><span class=\"line\"><span class=\"string\">    ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"string\">      &lt;AppContainer&gt;</span></span><br><span class=\"line\"><span class=\"string\">         &lt;NextApp /&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/AppContainer&gt;,</span></span><br><span class=\"line\"><span class=\"string\">      document.getElementById('</span>app<span class=\"string\">')</span></span><br><span class=\"line\"><span class=\"string\">    )</span></span><br><span class=\"line\"><span class=\"string\">  &#125;)</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// myapp/src/Hello.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Layout</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;h1&gt;Hello, world!!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这里有个小坑，改变app.js文件中的内容并不会刷新，需要手动刷新页面。</p>\n<p>启动就是<code>node src/config/server.js</code>，可以将其写入到package.json文件中<code>&quot;script&quot;: {&quot;start&quot;: &quot;node src/config/server.js&quot;}</code></p>\n<p>最后遇到一个小坑，在HTML文件引用入口文件中，地址应该是webpack配置中的<code>output.publicPath/[name].js</code>，如<code>&lt;script src=&quot;/static/app.js&quot;&gt;&lt;/script&gt;</code>。引用不到，或者路径错误会将html文件作为js文件引入，报错。<br>至此，在之后的编写中就不需要一遍又一遍的<code>webpack --config ****</code></p>\n<hr>\n<p>11.18补充</p>\n<p>分离打包：<br>在入口文件中添加要分离的模块：(这里将react和react-dom打包到vendor中)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">    app: [</span><br><span class=\"line\">      <span class=\"string\">'react-hot-loader/patch'</span>,</span><br><span class=\"line\">      <span class=\"string\">'webpack-hot-middleware/client'</span>,</span><br><span class=\"line\">      path.join(src, <span class=\"string\">'index.js'</span>)</span><br><span class=\"line\">    ],</span><br><span class=\"line\">+    <span class=\"comment\">// 打包分离</span></span><br><span class=\"line\">+    vendor: [</span><br><span class=\"line\">+      <span class=\"string\">'react'</span>,</span><br><span class=\"line\">+      <span class=\"string\">'react-dom'</span></span><br><span class=\"line\">+    ]</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure></p>\n<p>增加CommonsChunkPlugin插件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  plugins: [</span><br><span class=\"line\">+    <span class=\"comment\">// 分离打包</span></span><br><span class=\"line\">+    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">+      names: [<span class=\"string\">'vendor'</span>]</span><br><span class=\"line\">+    &#125;),</span><br><span class=\"line\">    <span class=\"comment\">// 热加载</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class=\"line\">  ]</span><br></pre></td></tr></table></figure></p>\n<p>分离打包后，两个app.js和vendor.js都需要引入。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>提高开发效率，我们发现前面用的最多的就是<code>webpack --config ***</code>，然后去刷新页面。解决此问题，可以使用<a href=\"https://github.com/gaearon/react-hot-loader\" target=\"_blank\" rel=\"noopener\">react-hot-loader</a>，这应该也是我们使用github的原因，在这里我们可以找到解决各种问题的办法。<br>查看其中使用方法（看不懂英文就用翻译一句一句看呗，其实我也是这么看过来的），会发现这一句These steps are covered by <a href=\"http://gaearon.github.io/react-hot-loader/getstarted/\" target=\"_blank\" rel=\"noopener\">the walkthrough</a>（这里应该是1版本的写法）。<br>根据这里的步骤，先是安装react-hot-loader，然后是server.js，提供有事例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我的路径 myapp/src/config/server.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.config'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express()</span><br><span class=\"line\"><span class=\"keyword\">var</span> compiler = webpack(config)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"built_in\">require</span>(<span class=\"string\">'webpack-dev-middleware'</span>)(compiler, &#123;</span><br><span class=\"line\">  publicPath: config.output.publicPath</span><br><span class=\"line\">&#125;))</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"built_in\">require</span>(<span class=\"string\">'webpack-hot-middleware'</span>)(compiler))</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'*'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  res.sendFile(path.join(__dirname, <span class=\"string\">'../index.html'</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.error(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Listening at http://localhost:3000/'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>需要安装express，另外需要修改<code>res.sendFile(path.join(__dirname, &#39;../index.html&#39;))</code>这里的路径，还有端口。<br>接着修改webpack的配置文件，在入口配置项前面添加，<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">  app: [</span><br><span class=\"line\">  <span class=\"string\">'webpack-dev-server/client?http://0.0.0.0:3000'</span>, <span class=\"comment\">// WebpackDevServer host and port</span></span><br><span class=\"line\">  <span class=\"string\">'webpack/hot/only-dev-server'</span>, <span class=\"comment\">// \"only\" prevents reload on syntax errors</span></span><br><span class=\"line\">  path.join(src, <span class=\"string\">'app.js'</span>)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个应该是1版本的写法，而我这里安装的是3版本，导致页面会多次刷新。下面是3版本，具体参看<a href=\"https://github.com/gaearon/react-hot-boilerplate/tree/next\" target=\"_blank\" rel=\"noopener\">事例</a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">    app: [</span><br><span class=\"line\">      <span class=\"string\">'react-hot-loader/patch'</span>,</span><br><span class=\"line\">      <span class=\"string\">'webpack-hot-middleware/client'</span>,</span><br><span class=\"line\">      path.join(src, <span class=\"string\">'app.js'</span>)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure></p>\n<p>接着是在oader中添加react-hot，按照官网是将react-hot添加在babel前面即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loaders: [&#123;</span><br><span class=\"line\">  test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">  include: src,</span><br><span class=\"line\">  loaders: [<span class=\"string\">'react-hot'</span>, <span class=\"string\">'babel'</span>]</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>但是在我这里报错了，报错提示还算明显，大致就是将react-hot-loader/babel添加到babel的plugins中，于是修改<code>myapp/.babelrc</code>解决。同样是1和3的区别<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"presets\"</span>: [<span class=\"string\">\"es2015\"</span>, <span class=\"string\">\"react\"</span>, <span class=\"string\">\"stage-0\"</span>],</span><br><span class=\"line\">  <span class=\"attr\">\"plugins\"</span>: [<span class=\"string\">\"react-hot-loader/babel\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后一步，是webpack中添加plugins<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>1版本到这里就结束了，3版本是这样的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// myapp/src/app.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; AppContainer &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-hot-loader'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'./Hello'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./app.scss'</span></span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">    &lt;AppContainer&gt;</span><br><span class=\"line\">      &lt;Hello /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/AppContainer&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">    document.getElementById('app')</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">if (module.hot) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  module.hot.accept('./</span>Hello<span class=\"string\">', () =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">    // If you use Webpack 2 in ES modules mode, you can</span></span><br><span class=\"line\"><span class=\"string\">    // use &lt;App /&gt; here rather than require() a &lt;NextApp /&gt;.</span></span><br><span class=\"line\"><span class=\"string\">    const NextApp = require('</span>./Hello<span class=\"string\">').default</span></span><br><span class=\"line\"><span class=\"string\">    ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"string\">      &lt;AppContainer&gt;</span></span><br><span class=\"line\"><span class=\"string\">         &lt;NextApp /&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/AppContainer&gt;,</span></span><br><span class=\"line\"><span class=\"string\">      document.getElementById('</span>app<span class=\"string\">')</span></span><br><span class=\"line\"><span class=\"string\">    )</span></span><br><span class=\"line\"><span class=\"string\">  &#125;)</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// myapp/src/Hello.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Layout</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;h1&gt;Hello, world!!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这里有个小坑，改变app.js文件中的内容并不会刷新，需要手动刷新页面。</p>\n<p>启动就是<code>node src/config/server.js</code>，可以将其写入到package.json文件中<code>&quot;script&quot;: {&quot;start&quot;: &quot;node src/config/server.js&quot;}</code></p>\n<p>最后遇到一个小坑，在HTML文件引用入口文件中，地址应该是webpack配置中的<code>output.publicPath/[name].js</code>，如<code>&lt;script src=&quot;/static/app.js&quot;&gt;&lt;/script&gt;</code>。引用不到，或者路径错误会将html文件作为js文件引入，报错。<br>至此，在之后的编写中就不需要一遍又一遍的<code>webpack --config ****</code></p>\n<hr>\n<p>11.18补充</p>\n<p>分离打包：<br>在入口文件中添加要分离的模块：(这里将react和react-dom打包到vendor中)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">    app: [</span><br><span class=\"line\">      <span class=\"string\">'react-hot-loader/patch'</span>,</span><br><span class=\"line\">      <span class=\"string\">'webpack-hot-middleware/client'</span>,</span><br><span class=\"line\">      path.join(src, <span class=\"string\">'index.js'</span>)</span><br><span class=\"line\">    ],</span><br><span class=\"line\">+    <span class=\"comment\">// 打包分离</span></span><br><span class=\"line\">+    vendor: [</span><br><span class=\"line\">+      <span class=\"string\">'react'</span>,</span><br><span class=\"line\">+      <span class=\"string\">'react-dom'</span></span><br><span class=\"line\">+    ]</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure></p>\n<p>增加CommonsChunkPlugin插件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  plugins: [</span><br><span class=\"line\">+    <span class=\"comment\">// 分离打包</span></span><br><span class=\"line\">+    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">+      names: [<span class=\"string\">'vendor'</span>]</span><br><span class=\"line\">+    &#125;),</span><br><span class=\"line\">    <span class=\"comment\">// 热加载</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class=\"line\">  ]</span><br></pre></td></tr></table></figure></p>\n<p>分离打包后，两个app.js和vendor.js都需要引入。</p>\n"},{"title":"从零开始搭建React(3)","date":"2016-11-15T16:00:00.000Z","comments":1,"_content":"\n相信学习React的都是有过一定了解的，React页面都是一个个组件构成的，所以写React也就是写一个个组件的过程。  \n目前，从写法上来说React组件主要有两种写法，一种是函数式(Functional)组件，一种是继承类(Class)组件：\n```javascript\n// Functional\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>\n}\n// ES6下更多情况会写成这样，其实就是一段返回一段jsx的函数\nconst Welcome = (props) => {\n  return (\n    <h1>Hello, {props.name}</h1>\n  )\n}\nexport default Welcome\n\n// Class\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n// ES6下一般为方便导入加入下面\nexport default Welcom\n```\n按照React组件的功能可以分为有状态组件和无状态组件。无状态组件一般使用函数式组件即可。  \n我的建议是，如果不清楚是用哪一种写法去编写组件，可以先使用函数式组件。在编写过程中如若发现需要使用state或者组件生命周期，再将此组件改成继承类组件。下面是一个比较完整的继承类组件架子：\n```javascript\nclass MyComponent extends Component {\n    // 构造函数\n  constructor (props) {\n    super(props)\n    // 设置state\n    this.state = {\n      ...\n    }\n    // 定义 eventHandler\n    this.handleClick = this.handleClick.bind(this)\n  }\n\n  // 生命周期方法\n  componentWillMount () {}\n  componentDidMount () {}\n  componentWillReceiveProps () {}\n  componentWillUpdate () {}\n  componentWillUnmount () {}\n\n  // handlers\n  handleClick() {\n    this.setState({\n      ...\n    })\n  }\n\n  render() {\n    // 这里是组件的内容\n    return (\n        <div onClick={this.handleClick}>\n        </div>\n      )\n  }\n}\n\nMyComponent.defaultProps = {}\nMyComponent.propTypes = {}\n\nexport default MyComponent\n```\n    需要注意点：\n      无论哪种写法，return中必须被一个标签包裹，这是jsx语法要求的。\n      函数式组件也可以设置defaultProps和propTypes。\n      函数式组件中不能访问this。\n      可以声明变量值为jsx，如：let a = <div></div>","source":"_posts/从零搭建React(3).md","raw":"---\ntitle: 从零开始搭建React(3)\ndate: 2016-11-16\ntags: [JavaScript, React, Webpack]\ncategories: \n- React\ncomments: true\n---\n\n相信学习React的都是有过一定了解的，React页面都是一个个组件构成的，所以写React也就是写一个个组件的过程。  \n目前，从写法上来说React组件主要有两种写法，一种是函数式(Functional)组件，一种是继承类(Class)组件：\n```javascript\n// Functional\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>\n}\n// ES6下更多情况会写成这样，其实就是一段返回一段jsx的函数\nconst Welcome = (props) => {\n  return (\n    <h1>Hello, {props.name}</h1>\n  )\n}\nexport default Welcome\n\n// Class\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n// ES6下一般为方便导入加入下面\nexport default Welcom\n```\n按照React组件的功能可以分为有状态组件和无状态组件。无状态组件一般使用函数式组件即可。  \n我的建议是，如果不清楚是用哪一种写法去编写组件，可以先使用函数式组件。在编写过程中如若发现需要使用state或者组件生命周期，再将此组件改成继承类组件。下面是一个比较完整的继承类组件架子：\n```javascript\nclass MyComponent extends Component {\n    // 构造函数\n  constructor (props) {\n    super(props)\n    // 设置state\n    this.state = {\n      ...\n    }\n    // 定义 eventHandler\n    this.handleClick = this.handleClick.bind(this)\n  }\n\n  // 生命周期方法\n  componentWillMount () {}\n  componentDidMount () {}\n  componentWillReceiveProps () {}\n  componentWillUpdate () {}\n  componentWillUnmount () {}\n\n  // handlers\n  handleClick() {\n    this.setState({\n      ...\n    })\n  }\n\n  render() {\n    // 这里是组件的内容\n    return (\n        <div onClick={this.handleClick}>\n        </div>\n      )\n  }\n}\n\nMyComponent.defaultProps = {}\nMyComponent.propTypes = {}\n\nexport default MyComponent\n```\n    需要注意点：\n      无论哪种写法，return中必须被一个标签包裹，这是jsx语法要求的。\n      函数式组件也可以设置defaultProps和propTypes。\n      函数式组件中不能访问this。\n      可以声明变量值为jsx，如：let a = <div></div>","slug":"从零搭建React(3)","published":1,"updated":"2017-12-28T03:47:32.465Z","layout":"post","photos":[],"link":"","_id":"cjks5i9iv002zvmti4e3alwck","content":"<p>相信学习React的都是有过一定了解的，React页面都是一个个组件构成的，所以写React也就是写一个个组件的过程。<br>目前，从写法上来说React组件主要有两种写法，一种是函数式(Functional)组件，一种是继承类(Class)组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Functional</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ES6下更多情况会写成这样，其实就是一段返回一段jsx的函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Welcome = <span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;h1&gt;Hello, &#123;props.name&#125;&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Welcome</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ Class</span></span><br><span class=\"line\"><span class=\"regexp\">class Welcome extends React.Component &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  render() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/</span>h1&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ES6下一般为方便导入加入下面</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Welcom</span><br></pre></td></tr></table></figure></p>\n<p>按照React组件的功能可以分为有状态组件和无状态组件。无状态组件一般使用函数式组件即可。<br>我的建议是，如果不清楚是用哪一种写法去编写组件，可以先使用函数式组件。在编写过程中如若发现需要使用state或者组件生命周期，再将此组件改成继承类组件。下面是一个比较完整的继承类组件架子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">    <span class=\"comment\">// 设置state</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 定义 eventHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 生命周期方法</span></span><br><span class=\"line\">  componentWillMount () &#123;&#125;</span><br><span class=\"line\">  componentDidMount () &#123;&#125;</span><br><span class=\"line\">  componentWillReceiveProps () &#123;&#125;</span><br><span class=\"line\">  componentWillUpdate () &#123;&#125;</span><br><span class=\"line\">  componentWillUnmount () &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// handlers</span></span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里是组件的内容</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">MyComponent.defaultProps = &#123;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">MyComponent.propTypes = &#123;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default MyComponent</span></span><br></pre></td></tr></table></figure></p>\n<pre><code>需要注意点：\n  无论哪种写法，return中必须被一个标签包裹，这是jsx语法要求的。\n  函数式组件也可以设置defaultProps和propTypes。\n  函数式组件中不能访问this。\n  可以声明变量值为jsx，如：let a = &lt;div&gt;&lt;/div&gt;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>相信学习React的都是有过一定了解的，React页面都是一个个组件构成的，所以写React也就是写一个个组件的过程。<br>目前，从写法上来说React组件主要有两种写法，一种是函数式(Functional)组件，一种是继承类(Class)组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Functional</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ES6下更多情况会写成这样，其实就是一段返回一段jsx的函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Welcome = <span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;h1&gt;Hello, &#123;props.name&#125;&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">export default Welcome</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ Class</span></span><br><span class=\"line\"><span class=\"regexp\">class Welcome extends React.Component &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  render() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/</span>h1&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ES6下一般为方便导入加入下面</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Welcom</span><br></pre></td></tr></table></figure></p>\n<p>按照React组件的功能可以分为有状态组件和无状态组件。无状态组件一般使用函数式组件即可。<br>我的建议是，如果不清楚是用哪一种写法去编写组件，可以先使用函数式组件。在编写过程中如若发现需要使用state或者组件生命周期，再将此组件改成继承类组件。下面是一个比较完整的继承类组件架子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">    <span class=\"comment\">// 设置state</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 定义 eventHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 生命周期方法</span></span><br><span class=\"line\">  componentWillMount () &#123;&#125;</span><br><span class=\"line\">  componentDidMount () &#123;&#125;</span><br><span class=\"line\">  componentWillReceiveProps () &#123;&#125;</span><br><span class=\"line\">  componentWillUpdate () &#123;&#125;</span><br><span class=\"line\">  componentWillUnmount () &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// handlers</span></span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里是组件的内容</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">MyComponent.defaultProps = &#123;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">MyComponent.propTypes = &#123;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default MyComponent</span></span><br></pre></td></tr></table></figure></p>\n<pre><code>需要注意点：\n  无论哪种写法，return中必须被一个标签包裹，这是jsx语法要求的。\n  函数式组件也可以设置defaultProps和propTypes。\n  函数式组件中不能访问this。\n  可以声明变量值为jsx，如：let a = &lt;div&gt;&lt;/div&gt;\n</code></pre>"},{"title":"函数节流","date":"2016-07-27T16:00:00.000Z","comments":1,"_content":"\n[From](http://imweb.io/topic/577aa790ea7bb9b760c7adc3)\n\n函数节流：常用于onresize,scroll,mousemove,mousehover等连续触发的事件(隔断时间触发一次)。\n\n方法：\n\n\teg.\n```javascript \n\t\twindow.onscroll = function() {\n\t\t\tconsole.log('scoll滑动');\n\t\t\tthrottle(count);\n\t\t};\n\n\t\tfunction count() {\n\t\t\tconsole.log('函数调用');\n\t\t}\n\n\t\tfunction throttle(method, context) {\n\t\t\t// 如果连续触发就会方法会被清除，所以只会执行最后一次\n\t\t\tclearTimeout(method.tId);\n\t\t\tmethod.tId = setTimeout(function() {\n\t\t\t\tmethod.call(context);\n\t\t\t}, 300);\n\t\t}\n\n\t// eg.\n\t\tvar time = +new Date(); // 隐式转换，相当于new Date().getTime()\n\t\tfunction count() {\n\t\t\tconsole.log('函数调用：' + (+new Date() - time));\n\t\t}\n\n\n\t\t// 到达mustRun毫秒一定执行\n\t\tvar throttle = function(fn, delay, mustRun) {\n\t\t\tvar timer = null,\n\t\t\t\t\tprevious = null;\n\n\t\t\treturn function() {\n\t\t\t\tvar now = +new Date(),\n\t\t\t\t\t\tcontext = this,\n\t\t\t\t\t\targs = arguments;\n\t\t\t\t// 闭包，只有在第一次执行时，previous==null，会被赋值为now\n\t\t\t\tif(!previous) previous = now;\n\t\t\t\tvar remaining = now - previous;\n\t\t\t\tif(mustRun && remaining >= mustRun){\n\t\t\t\t\tfn.apply(context, args);\n\t\t\t\t\tprevious = now;\n\t\t\t\t} else {\n\t\t\t\t\tcleaerTimeout(timer);\n\t\t\t\t\ttimer = setTimeout(function() {\n\t\t\t\t\t\tfn.apply(context, args);\n\t\t\t\t\t}, delay);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\twindow.onscroll = throttle(count, 500, 1000);\n```","source":"_posts/函数节流.md","raw":"---\ntitle: 函数节流\ndate: 2016-07-28\ntags: JavaScript\ncategories: \n- JavaScript\ncomments: true\n---\n\n[From](http://imweb.io/topic/577aa790ea7bb9b760c7adc3)\n\n函数节流：常用于onresize,scroll,mousemove,mousehover等连续触发的事件(隔断时间触发一次)。\n\n方法：\n\n\teg.\n```javascript \n\t\twindow.onscroll = function() {\n\t\t\tconsole.log('scoll滑动');\n\t\t\tthrottle(count);\n\t\t};\n\n\t\tfunction count() {\n\t\t\tconsole.log('函数调用');\n\t\t}\n\n\t\tfunction throttle(method, context) {\n\t\t\t// 如果连续触发就会方法会被清除，所以只会执行最后一次\n\t\t\tclearTimeout(method.tId);\n\t\t\tmethod.tId = setTimeout(function() {\n\t\t\t\tmethod.call(context);\n\t\t\t}, 300);\n\t\t}\n\n\t// eg.\n\t\tvar time = +new Date(); // 隐式转换，相当于new Date().getTime()\n\t\tfunction count() {\n\t\t\tconsole.log('函数调用：' + (+new Date() - time));\n\t\t}\n\n\n\t\t// 到达mustRun毫秒一定执行\n\t\tvar throttle = function(fn, delay, mustRun) {\n\t\t\tvar timer = null,\n\t\t\t\t\tprevious = null;\n\n\t\t\treturn function() {\n\t\t\t\tvar now = +new Date(),\n\t\t\t\t\t\tcontext = this,\n\t\t\t\t\t\targs = arguments;\n\t\t\t\t// 闭包，只有在第一次执行时，previous==null，会被赋值为now\n\t\t\t\tif(!previous) previous = now;\n\t\t\t\tvar remaining = now - previous;\n\t\t\t\tif(mustRun && remaining >= mustRun){\n\t\t\t\t\tfn.apply(context, args);\n\t\t\t\t\tprevious = now;\n\t\t\t\t} else {\n\t\t\t\t\tcleaerTimeout(timer);\n\t\t\t\t\ttimer = setTimeout(function() {\n\t\t\t\t\t\tfn.apply(context, args);\n\t\t\t\t\t}, delay);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\twindow.onscroll = throttle(count, 500, 1000);\n```","slug":"函数节流","published":1,"updated":"2017-12-28T03:47:32.465Z","layout":"post","photos":[],"link":"","_id":"cjks5i9ix0033vmtirr7714a0","content":"<p><a href=\"http://imweb.io/topic/577aa790ea7bb9b760c7adc3\" target=\"_blank\" rel=\"noopener\">From</a></p>\n<p>函数节流：常用于onresize,scroll,mousemove,mousehover等连续触发的事件(隔断时间触发一次)。</p>\n<p>方法：</p>\n<pre><code>eg.\n</code></pre><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"built_in\">window</span>.onscroll = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'scoll滑动'</span>);</span><br><span class=\"line\">\t\tthrottle(count);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'函数调用'</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">method, context</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果连续触发就会方法会被清除，所以只会执行最后一次</span></span><br><span class=\"line\">\t\tclearTimeout(method.tId);</span><br><span class=\"line\">\t\tmethod.tId = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\tmethod.call(context);</span><br><span class=\"line\">\t\t&#125;, <span class=\"number\">300</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// eg.</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> time = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); <span class=\"comment\">// 隐式转换，相当于new Date().getTime()</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'函数调用：'</span> + (+<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - time));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 到达mustRun毫秒一定执行</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn, delay, mustRun</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>,</span><br><span class=\"line\">\t\t\t\tprevious = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</span><br><span class=\"line\">\t\t\t\t\tcontext = <span class=\"keyword\">this</span>,</span><br><span class=\"line\">\t\t\t\t\targs = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 闭包，只有在第一次执行时，previous==null，会被赋值为now</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!previous) previous = now;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> remaining = now - previous;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(mustRun &amp;&amp; remaining &gt;= mustRun)&#123;</span><br><span class=\"line\">\t\t\t\tfn.apply(context, args);</span><br><span class=\"line\">\t\t\t\tprevious = now;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tcleaerTimeout(timer);</span><br><span class=\"line\">\t\t\t\ttimer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\tfn.apply(context, args);</span><br><span class=\"line\">\t\t\t\t&#125;, delay);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">window</span>.onscroll = throttle(count, <span class=\"number\">500</span>, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://imweb.io/topic/577aa790ea7bb9b760c7adc3\" target=\"_blank\" rel=\"noopener\">From</a></p>\n<p>函数节流：常用于onresize,scroll,mousemove,mousehover等连续触发的事件(隔断时间触发一次)。</p>\n<p>方法：</p>\n<pre><code>eg.\n</code></pre><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"built_in\">window</span>.onscroll = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'scoll滑动'</span>);</span><br><span class=\"line\">\t\tthrottle(count);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'函数调用'</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">method, context</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果连续触发就会方法会被清除，所以只会执行最后一次</span></span><br><span class=\"line\">\t\tclearTimeout(method.tId);</span><br><span class=\"line\">\t\tmethod.tId = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\tmethod.call(context);</span><br><span class=\"line\">\t\t&#125;, <span class=\"number\">300</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// eg.</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> time = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); <span class=\"comment\">// 隐式转换，相当于new Date().getTime()</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'函数调用：'</span> + (+<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - time));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 到达mustRun毫秒一定执行</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn, delay, mustRun</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>,</span><br><span class=\"line\">\t\t\t\tprevious = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</span><br><span class=\"line\">\t\t\t\t\tcontext = <span class=\"keyword\">this</span>,</span><br><span class=\"line\">\t\t\t\t\targs = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 闭包，只有在第一次执行时，previous==null，会被赋值为now</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!previous) previous = now;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> remaining = now - previous;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(mustRun &amp;&amp; remaining &gt;= mustRun)&#123;</span><br><span class=\"line\">\t\t\t\tfn.apply(context, args);</span><br><span class=\"line\">\t\t\t\tprevious = now;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tcleaerTimeout(timer);</span><br><span class=\"line\">\t\t\t\ttimer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\tfn.apply(context, args);</span><br><span class=\"line\">\t\t\t\t&#125;, delay);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">window</span>.onscroll = throttle(count, <span class=\"number\">500</span>, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>"},{"title":"初次selenium","date":"2018-06-20T16:00:00.000Z","comments":1,"_content":"\nselenium是一个浏览器自动化的工具，通过编程可以实现对浏览器的自动控制，常常被用于自动化测试、爬虫等等。因为selenium支持多种语言，所以选择自己常用的语言，很容易就可以上手。\n\n在是用selenium之前，需要安装`webdriver`，并将其加入到环境变量中。不同版本的浏览器，对应不同的webdriver，所以在下载之前，需要先查看安装的浏览器是什么版本。\n\n我按照我的习惯，选择了JavaScript和chrome，[这里](http://seleniumhq.github.io/selenium/docs/api/javascript/index.html)是对应的API文档。\n\n既然要控制浏览器，首先肯定需要一个控制浏览器对象，在这里被称为`WebDriver`，我们更常用的是`ThenableWebDriver`。因为我们操作是需要等待浏览器执行的，所以大部分都是异步操作，而`ThenableWebDriver`，使得我们不必每一步都去调用then，然后在then的回调中执行。  \n文档中是这样写的：\n\n```javascript\n// A thenable wrapper around a IWebDriver instance that allows commands to be issued directly instead of having to repeatedly call then:\n\nlet driver = new Builder().build();\ndriver.then(d => d.get(url));  // You can do this...\ndriver.get(url);               // ...or this\n```\n\n上面代码中，我们通过`Builder`对象来生成一个`ThenableWebDriver`实例，我理解的是这样`Builder`可以帮我们直接处理好一些配置和环境变量，比如我们想要使用chrome，只需要执行`new Builder().forBrowser('chrome').build()`就可以了。所以我们第一步要做的，一般都是通过`Builder`来生成一个`ThenableWebDriver`实例。\n\n我们可以从API文档中看到`ThenableWebDriver`的所有实例方法，其中`get`方法未打开某个链接，之后我们可以通过`findElement`和`By`对象中的静态方法返回某个元素的`WebElement`对象实例，通过`WebElement`实例的`click`、`sendKeys`等方法执行某些操作，等等。\n\n另外，还有`ThenableWebDriver`的实例方法`wait`也是比较常用的，比如登录跳转，可以通过等待URL变成其他值，再进行接下来的操作。这样可以调用`lib/until`中的静态方法`urlContains`来进行判断。\n\n```javascript\n// 这里是个简单的签到功能\n(async function () {\n  // 配置我们要启动的chrome，这里主要是配置成headless模式（无界面），这样也可以用于Linux\n  const chromeOption = new Options()\n  chromeOption.headless().windowSize({width: 800, height: 600})\n  // 之前没有添加这个参数一直报错\n  chromeOption.addArguments('--no-sandbox')\n  // 获得ThenableWebDriver实例\n  const driver = await new Builder().forBrowser('chrome').setChromeOptions(chromeOption).build()\n  try {\n    // 打开签到的网页\n    await driver.get('https://www.cordcloud.me/auth/login')\n    // 找到相应的元素，并通过sendKeys输入用户名，密码，点击登录\n    await driver.findElement(By.id('email')).sendKeys('username')\n    await driver.findElement(By.id('passwd')).sendKeys('password')\n    await driver.findElement(By.id('login')).click()\n    // 等待跳转，跳转后的新地址包含user，也可以用完整的url进行判断\n    await driver.wait(until.urlContains('user'))\n    // 签到按钮，点击\n    const btn = await driver.findElement(By.id('checkin'))\n    btn.click()\n  } catch (error) {\n    console.log(error)\n  }\n})()\n```\n\n上面只是最简单的selenium的一个应用，还可以使用`WebElement`实例方法`getText`进行简单的爬虫，可以配合`node-schedule`进行每日定时任务，配合`foreve`守护进程等等。\n","source":"_posts/初次selenium.md","raw":"---\ntitle: 初次selenium\ndate: 2018-06-21\ntags: [JavaScript]\ncategories:\n- JavaScript\ncomments: true\n---\n\nselenium是一个浏览器自动化的工具，通过编程可以实现对浏览器的自动控制，常常被用于自动化测试、爬虫等等。因为selenium支持多种语言，所以选择自己常用的语言，很容易就可以上手。\n\n在是用selenium之前，需要安装`webdriver`，并将其加入到环境变量中。不同版本的浏览器，对应不同的webdriver，所以在下载之前，需要先查看安装的浏览器是什么版本。\n\n我按照我的习惯，选择了JavaScript和chrome，[这里](http://seleniumhq.github.io/selenium/docs/api/javascript/index.html)是对应的API文档。\n\n既然要控制浏览器，首先肯定需要一个控制浏览器对象，在这里被称为`WebDriver`，我们更常用的是`ThenableWebDriver`。因为我们操作是需要等待浏览器执行的，所以大部分都是异步操作，而`ThenableWebDriver`，使得我们不必每一步都去调用then，然后在then的回调中执行。  \n文档中是这样写的：\n\n```javascript\n// A thenable wrapper around a IWebDriver instance that allows commands to be issued directly instead of having to repeatedly call then:\n\nlet driver = new Builder().build();\ndriver.then(d => d.get(url));  // You can do this...\ndriver.get(url);               // ...or this\n```\n\n上面代码中，我们通过`Builder`对象来生成一个`ThenableWebDriver`实例，我理解的是这样`Builder`可以帮我们直接处理好一些配置和环境变量，比如我们想要使用chrome，只需要执行`new Builder().forBrowser('chrome').build()`就可以了。所以我们第一步要做的，一般都是通过`Builder`来生成一个`ThenableWebDriver`实例。\n\n我们可以从API文档中看到`ThenableWebDriver`的所有实例方法，其中`get`方法未打开某个链接，之后我们可以通过`findElement`和`By`对象中的静态方法返回某个元素的`WebElement`对象实例，通过`WebElement`实例的`click`、`sendKeys`等方法执行某些操作，等等。\n\n另外，还有`ThenableWebDriver`的实例方法`wait`也是比较常用的，比如登录跳转，可以通过等待URL变成其他值，再进行接下来的操作。这样可以调用`lib/until`中的静态方法`urlContains`来进行判断。\n\n```javascript\n// 这里是个简单的签到功能\n(async function () {\n  // 配置我们要启动的chrome，这里主要是配置成headless模式（无界面），这样也可以用于Linux\n  const chromeOption = new Options()\n  chromeOption.headless().windowSize({width: 800, height: 600})\n  // 之前没有添加这个参数一直报错\n  chromeOption.addArguments('--no-sandbox')\n  // 获得ThenableWebDriver实例\n  const driver = await new Builder().forBrowser('chrome').setChromeOptions(chromeOption).build()\n  try {\n    // 打开签到的网页\n    await driver.get('https://www.cordcloud.me/auth/login')\n    // 找到相应的元素，并通过sendKeys输入用户名，密码，点击登录\n    await driver.findElement(By.id('email')).sendKeys('username')\n    await driver.findElement(By.id('passwd')).sendKeys('password')\n    await driver.findElement(By.id('login')).click()\n    // 等待跳转，跳转后的新地址包含user，也可以用完整的url进行判断\n    await driver.wait(until.urlContains('user'))\n    // 签到按钮，点击\n    const btn = await driver.findElement(By.id('checkin'))\n    btn.click()\n  } catch (error) {\n    console.log(error)\n  }\n})()\n```\n\n上面只是最简单的selenium的一个应用，还可以使用`WebElement`实例方法`getText`进行简单的爬虫，可以配合`node-schedule`进行每日定时任务，配合`foreve`守护进程等等。\n","slug":"初次selenium","published":1,"updated":"2018-06-21T06:29:38.915Z","layout":"post","photos":[],"link":"","_id":"cjks5i9iy0036vmti4ejbn2ny","content":"<p>selenium是一个浏览器自动化的工具，通过编程可以实现对浏览器的自动控制，常常被用于自动化测试、爬虫等等。因为selenium支持多种语言，所以选择自己常用的语言，很容易就可以上手。</p>\n<p>在是用selenium之前，需要安装<code>webdriver</code>，并将其加入到环境变量中。不同版本的浏览器，对应不同的webdriver，所以在下载之前，需要先查看安装的浏览器是什么版本。</p>\n<p>我按照我的习惯，选择了JavaScript和chrome，<a href=\"http://seleniumhq.github.io/selenium/docs/api/javascript/index.html\" target=\"_blank\" rel=\"noopener\">这里</a>是对应的API文档。</p>\n<p>既然要控制浏览器，首先肯定需要一个控制浏览器对象，在这里被称为<code>WebDriver</code>，我们更常用的是<code>ThenableWebDriver</code>。因为我们操作是需要等待浏览器执行的，所以大部分都是异步操作，而<code>ThenableWebDriver</code>，使得我们不必每一步都去调用then，然后在then的回调中执行。<br>文档中是这样写的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A thenable wrapper around a IWebDriver instance that allows commands to be issued directly instead of having to repeatedly call then:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> driver = <span class=\"keyword\">new</span> Builder().build();</span><br><span class=\"line\">driver.then(<span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d.get(url));  <span class=\"comment\">// You can do this...</span></span><br><span class=\"line\">driver.get(url);               <span class=\"comment\">// ...or this</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，我们通过<code>Builder</code>对象来生成一个<code>ThenableWebDriver</code>实例，我理解的是这样<code>Builder</code>可以帮我们直接处理好一些配置和环境变量，比如我们想要使用chrome，只需要执行<code>new Builder().forBrowser(&#39;chrome&#39;).build()</code>就可以了。所以我们第一步要做的，一般都是通过<code>Builder</code>来生成一个<code>ThenableWebDriver</code>实例。</p>\n<p>我们可以从API文档中看到<code>ThenableWebDriver</code>的所有实例方法，其中<code>get</code>方法未打开某个链接，之后我们可以通过<code>findElement</code>和<code>By</code>对象中的静态方法返回某个元素的<code>WebElement</code>对象实例，通过<code>WebElement</code>实例的<code>click</code>、<code>sendKeys</code>等方法执行某些操作，等等。</p>\n<p>另外，还有<code>ThenableWebDriver</code>的实例方法<code>wait</code>也是比较常用的，比如登录跳转，可以通过等待URL变成其他值，再进行接下来的操作。这样可以调用<code>lib/until</code>中的静态方法<code>urlContains</code>来进行判断。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里是个简单的签到功能</span></span><br><span class=\"line\">(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 配置我们要启动的chrome，这里主要是配置成headless模式（无界面），这样也可以用于Linux</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> chromeOption = <span class=\"keyword\">new</span> Options()</span><br><span class=\"line\">  chromeOption.headless().windowSize(&#123;<span class=\"attr\">width</span>: <span class=\"number\">800</span>, <span class=\"attr\">height</span>: <span class=\"number\">600</span>&#125;)</span><br><span class=\"line\">  <span class=\"comment\">// 之前没有添加这个参数一直报错</span></span><br><span class=\"line\">  chromeOption.addArguments(<span class=\"string\">'--no-sandbox'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 获得ThenableWebDriver实例</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> driver = <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> Builder().forBrowser(<span class=\"string\">'chrome'</span>).setChromeOptions(chromeOption).build()</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 打开签到的网页</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> driver.get(<span class=\"string\">'https://www.cordcloud.me/auth/login'</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 找到相应的元素，并通过sendKeys输入用户名，密码，点击登录</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> driver.findElement(By.id(<span class=\"string\">'email'</span>)).sendKeys(<span class=\"string\">'username'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> driver.findElement(By.id(<span class=\"string\">'passwd'</span>)).sendKeys(<span class=\"string\">'password'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> driver.findElement(By.id(<span class=\"string\">'login'</span>)).click()</span><br><span class=\"line\">    <span class=\"comment\">// 等待跳转，跳转后的新地址包含user，也可以用完整的url进行判断</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> driver.wait(until.urlContains(<span class=\"string\">'user'</span>))</span><br><span class=\"line\">    <span class=\"comment\">// 签到按钮，点击</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> btn = <span class=\"keyword\">await</span> driver.findElement(By.id(<span class=\"string\">'checkin'</span>))</span><br><span class=\"line\">    btn.click()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<p>上面只是最简单的selenium的一个应用，还可以使用<code>WebElement</code>实例方法<code>getText</code>进行简单的爬虫，可以配合<code>node-schedule</code>进行每日定时任务，配合<code>foreve</code>守护进程等等。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>selenium是一个浏览器自动化的工具，通过编程可以实现对浏览器的自动控制，常常被用于自动化测试、爬虫等等。因为selenium支持多种语言，所以选择自己常用的语言，很容易就可以上手。</p>\n<p>在是用selenium之前，需要安装<code>webdriver</code>，并将其加入到环境变量中。不同版本的浏览器，对应不同的webdriver，所以在下载之前，需要先查看安装的浏览器是什么版本。</p>\n<p>我按照我的习惯，选择了JavaScript和chrome，<a href=\"http://seleniumhq.github.io/selenium/docs/api/javascript/index.html\" target=\"_blank\" rel=\"noopener\">这里</a>是对应的API文档。</p>\n<p>既然要控制浏览器，首先肯定需要一个控制浏览器对象，在这里被称为<code>WebDriver</code>，我们更常用的是<code>ThenableWebDriver</code>。因为我们操作是需要等待浏览器执行的，所以大部分都是异步操作，而<code>ThenableWebDriver</code>，使得我们不必每一步都去调用then，然后在then的回调中执行。<br>文档中是这样写的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A thenable wrapper around a IWebDriver instance that allows commands to be issued directly instead of having to repeatedly call then:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> driver = <span class=\"keyword\">new</span> Builder().build();</span><br><span class=\"line\">driver.then(<span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d.get(url));  <span class=\"comment\">// You can do this...</span></span><br><span class=\"line\">driver.get(url);               <span class=\"comment\">// ...or this</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，我们通过<code>Builder</code>对象来生成一个<code>ThenableWebDriver</code>实例，我理解的是这样<code>Builder</code>可以帮我们直接处理好一些配置和环境变量，比如我们想要使用chrome，只需要执行<code>new Builder().forBrowser(&#39;chrome&#39;).build()</code>就可以了。所以我们第一步要做的，一般都是通过<code>Builder</code>来生成一个<code>ThenableWebDriver</code>实例。</p>\n<p>我们可以从API文档中看到<code>ThenableWebDriver</code>的所有实例方法，其中<code>get</code>方法未打开某个链接，之后我们可以通过<code>findElement</code>和<code>By</code>对象中的静态方法返回某个元素的<code>WebElement</code>对象实例，通过<code>WebElement</code>实例的<code>click</code>、<code>sendKeys</code>等方法执行某些操作，等等。</p>\n<p>另外，还有<code>ThenableWebDriver</code>的实例方法<code>wait</code>也是比较常用的，比如登录跳转，可以通过等待URL变成其他值，再进行接下来的操作。这样可以调用<code>lib/until</code>中的静态方法<code>urlContains</code>来进行判断。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里是个简单的签到功能</span></span><br><span class=\"line\">(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 配置我们要启动的chrome，这里主要是配置成headless模式（无界面），这样也可以用于Linux</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> chromeOption = <span class=\"keyword\">new</span> Options()</span><br><span class=\"line\">  chromeOption.headless().windowSize(&#123;<span class=\"attr\">width</span>: <span class=\"number\">800</span>, <span class=\"attr\">height</span>: <span class=\"number\">600</span>&#125;)</span><br><span class=\"line\">  <span class=\"comment\">// 之前没有添加这个参数一直报错</span></span><br><span class=\"line\">  chromeOption.addArguments(<span class=\"string\">'--no-sandbox'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 获得ThenableWebDriver实例</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> driver = <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> Builder().forBrowser(<span class=\"string\">'chrome'</span>).setChromeOptions(chromeOption).build()</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 打开签到的网页</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> driver.get(<span class=\"string\">'https://www.cordcloud.me/auth/login'</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 找到相应的元素，并通过sendKeys输入用户名，密码，点击登录</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> driver.findElement(By.id(<span class=\"string\">'email'</span>)).sendKeys(<span class=\"string\">'username'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> driver.findElement(By.id(<span class=\"string\">'passwd'</span>)).sendKeys(<span class=\"string\">'password'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> driver.findElement(By.id(<span class=\"string\">'login'</span>)).click()</span><br><span class=\"line\">    <span class=\"comment\">// 等待跳转，跳转后的新地址包含user，也可以用完整的url进行判断</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> driver.wait(until.urlContains(<span class=\"string\">'user'</span>))</span><br><span class=\"line\">    <span class=\"comment\">// 签到按钮，点击</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> btn = <span class=\"keyword\">await</span> driver.findElement(By.id(<span class=\"string\">'checkin'</span>))</span><br><span class=\"line\">    btn.click()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<p>上面只是最简单的selenium的一个应用，还可以使用<code>WebElement</code>实例方法<code>getText</code>进行简单的爬虫，可以配合<code>node-schedule</code>进行每日定时任务，配合<code>foreve</code>守护进程等等。</p>\n"},{"title":"利用Github+Hexo搭建博客过程","date":"2016-06-09T14:11:35.000Z","comments":1,"_content":"\n　　有阵子没有静下心来做点什么了，希望通过博客，可以让自己多静下心来做些东西，学习下技术，记录一下过程。\n　　因为最近一直在学习和使用Github，希望通过Github来建立自己的博客，并且还能刷下自己Github上提交的贡献-.-\n　　总得过程还是比较容易的，因为自己有使用Github，电脑上也安装配置有nodejs，也看过markdown的一些语法，所以搭建起来，实现基本功能并没有花费多少时间。\n　　第一步，安装nodejs和Git。\n　　第二步，安装Hexo,和其他的包一样，通过`npm install-g hexo`来安装。<!--more-->\n　　第三步，创建一个用于存放Hexo的文件夹，在该文件夹目录下执行hexo init。\n　　第四步，执行`hexo g`(等同于`hexo generate`)生成静态页面，执行`hexo s`(等同于`hexo server`)启动本地服务进行预览，这样浏览器里可以输入`http://localhost:4000`进行访问。我第一次访问的时候，因为4000端口被占用，页面打不开，关闭占用端口后，正常。\n　　第五步，配置博客。在Hexo目录配置文件_config.yml中可以配置诸如标题、副标题、作者、语言、主题、部署等等配置。\n　　第六步，配置主题。搜索Hexo主题会有很多，并且都有使用说明。一般流程就是通过git clone复制到自己的目录下，在Hexo目录下的_config.yml文件中配置`theme`属性，之后就是主题配置文件(位于themes/*/_config.yml)进行个性化配置。\n  \n　　之后，就是把博客放到Github上去了。\n　　首先是在个人GIthub上建立新的仓库，仓库名为`username.github.io`，比如我的Github帐号是[PFanz](http://github.com/PFanz),仓库名就是`PFanz.github.io`。\n　　在Hexo配置文件_config.yml中配置`deploy`中各项，比如：\n```\ndeploy:\n  type: git\n  repo: https://github.com/PFanz/PFanz.github.io.git\n  branch: master\n```\n　　然后执行命令`npm install hexo-deployer-git --save`，便可以通过`username.github.io`访问到该博客。\n　　写博客可以通过命令`hexo new\"titleName\"`，在Hexo目录下`source/_posts`新建文件titleName.md，也可以自己手动建立。手动建立的话，需要自己加入头\n```\n---\ntitle: titleName\ndate: 2016-06-09 22:11:35\ntags: 标签\ncategories: \n- 分类名称\n---\n  ```\n  \n　　每次部署按一下三步\n```\nhexo clean\nhexo g\nhexo d\n```\n  \n  \n\n---\n　　虽然说基本功能已经搭建，感觉还有不少地方值得去探索，以实现更个性化，更漂亮的博客。","source":"_posts/利用Github+Hexo搭建博客过程.md","raw":"---\ntitle: 利用Github+Hexo搭建博客过程\ndate: 2016-06-09 22:11:35\ntags: Hexo\ncategories: \n- 杂记\ncomments: true\n---\n\n　　有阵子没有静下心来做点什么了，希望通过博客，可以让自己多静下心来做些东西，学习下技术，记录一下过程。\n　　因为最近一直在学习和使用Github，希望通过Github来建立自己的博客，并且还能刷下自己Github上提交的贡献-.-\n　　总得过程还是比较容易的，因为自己有使用Github，电脑上也安装配置有nodejs，也看过markdown的一些语法，所以搭建起来，实现基本功能并没有花费多少时间。\n　　第一步，安装nodejs和Git。\n　　第二步，安装Hexo,和其他的包一样，通过`npm install-g hexo`来安装。<!--more-->\n　　第三步，创建一个用于存放Hexo的文件夹，在该文件夹目录下执行hexo init。\n　　第四步，执行`hexo g`(等同于`hexo generate`)生成静态页面，执行`hexo s`(等同于`hexo server`)启动本地服务进行预览，这样浏览器里可以输入`http://localhost:4000`进行访问。我第一次访问的时候，因为4000端口被占用，页面打不开，关闭占用端口后，正常。\n　　第五步，配置博客。在Hexo目录配置文件_config.yml中可以配置诸如标题、副标题、作者、语言、主题、部署等等配置。\n　　第六步，配置主题。搜索Hexo主题会有很多，并且都有使用说明。一般流程就是通过git clone复制到自己的目录下，在Hexo目录下的_config.yml文件中配置`theme`属性，之后就是主题配置文件(位于themes/*/_config.yml)进行个性化配置。\n  \n　　之后，就是把博客放到Github上去了。\n　　首先是在个人GIthub上建立新的仓库，仓库名为`username.github.io`，比如我的Github帐号是[PFanz](http://github.com/PFanz),仓库名就是`PFanz.github.io`。\n　　在Hexo配置文件_config.yml中配置`deploy`中各项，比如：\n```\ndeploy:\n  type: git\n  repo: https://github.com/PFanz/PFanz.github.io.git\n  branch: master\n```\n　　然后执行命令`npm install hexo-deployer-git --save`，便可以通过`username.github.io`访问到该博客。\n　　写博客可以通过命令`hexo new\"titleName\"`，在Hexo目录下`source/_posts`新建文件titleName.md，也可以自己手动建立。手动建立的话，需要自己加入头\n```\n---\ntitle: titleName\ndate: 2016-06-09 22:11:35\ntags: 标签\ncategories: \n- 分类名称\n---\n  ```\n  \n　　每次部署按一下三步\n```\nhexo clean\nhexo g\nhexo d\n```\n  \n  \n\n---\n　　虽然说基本功能已经搭建，感觉还有不少地方值得去探索，以实现更个性化，更漂亮的博客。","slug":"利用Github+Hexo搭建博客过程","published":1,"updated":"2017-12-28T03:47:32.465Z","layout":"post","photos":[],"link":"","_id":"cjks5i9j0003avmticuh120hm","content":"<p>　　有阵子没有静下心来做点什么了，希望通过博客，可以让自己多静下心来做些东西，学习下技术，记录一下过程。<br>　　因为最近一直在学习和使用Github，希望通过Github来建立自己的博客，并且还能刷下自己Github上提交的贡献-.-<br>　　总得过程还是比较容易的，因为自己有使用Github，电脑上也安装配置有nodejs，也看过markdown的一些语法，所以搭建起来，实现基本功能并没有花费多少时间。<br>　　第一步，安装nodejs和Git。<br>　　第二步，安装Hexo,和其他的包一样，通过<code>npm install-g hexo</code>来安装。<a id=\"more\"></a><br>　　第三步，创建一个用于存放Hexo的文件夹，在该文件夹目录下执行hexo init。<br>　　第四步，执行<code>hexo g</code>(等同于<code>hexo generate</code>)生成静态页面，执行<code>hexo s</code>(等同于<code>hexo server</code>)启动本地服务进行预览，这样浏览器里可以输入<code>http://localhost:4000</code>进行访问。我第一次访问的时候，因为4000端口被占用，页面打不开，关闭占用端口后，正常。<br>　　第五步，配置博客。在Hexo目录配置文件_config.yml中可以配置诸如标题、副标题、作者、语言、主题、部署等等配置。<br>　　第六步，配置主题。搜索Hexo主题会有很多，并且都有使用说明。一般流程就是通过git clone复制到自己的目录下，在Hexo目录下的_config.yml文件中配置<code>theme</code>属性，之后就是主题配置文件(位于themes/*/_config.yml)进行个性化配置。</p>\n<p>　　之后，就是把博客放到Github上去了。<br>　　首先是在个人GIthub上建立新的仓库，仓库名为<code>username.github.io</code>，比如我的Github帐号是<a href=\"http://github.com/PFanz\" target=\"_blank\" rel=\"noopener\">PFanz</a>,仓库名就是<code>PFanz.github.io</code>。<br>　　在Hexo配置文件_config.yml中配置<code>deploy</code>中各项，比如：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">deploy</span>:</span><br><span class=\"line\">  <span class=\"attribute\">type</span>: git</span><br><span class=\"line\">  <span class=\"attribute\">repo</span>: <span class=\"attribute\">https</span>:<span class=\"comment\">//github.com/PFanz/PFanz.github.io.git</span></span><br><span class=\"line\">  <span class=\"attribute\">branch</span>: master</span><br></pre></td></tr></table></figure></p>\n<p>　　然后执行命令<code>npm install hexo-deployer-git --save</code>，便可以通过<code>username.github.io</code>访问到该博客。<br>　　写博客可以通过命令<code>hexo new&quot;titleName&quot;</code>，在Hexo目录下<code>source/_posts</code>新建文件titleName.md，也可以自己手动建立。手动建立的话，需要自己加入头<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">titleName</span></span><br><span class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2016</span><span class=\"bullet\">-06</span><span class=\"bullet\">-09</span> <span class=\"number\">22</span><span class=\"string\">:11:35</span></span><br><span class=\"line\"><span class=\"attr\">tags:</span> <span class=\"string\">标签</span></span><br><span class=\"line\"><span class=\"attr\">categories:</span> </span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">分类名称</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure></p>\n<p>　　每次部署按一下三步<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">hexo clean</span></span><br><span class=\"line\"><span class=\"attribute\">hexo g</span></span><br><span class=\"line\"><span class=\"attribute\">hexo d</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>　　虽然说基本功能已经搭建，感觉还有不少地方值得去探索，以实现更个性化，更漂亮的博客。</p>\n","site":{"data":{}},"excerpt":"<p>　　有阵子没有静下心来做点什么了，希望通过博客，可以让自己多静下心来做些东西，学习下技术，记录一下过程。<br>　　因为最近一直在学习和使用Github，希望通过Github来建立自己的博客，并且还能刷下自己Github上提交的贡献-.-<br>　　总得过程还是比较容易的，因为自己有使用Github，电脑上也安装配置有nodejs，也看过markdown的一些语法，所以搭建起来，实现基本功能并没有花费多少时间。<br>　　第一步，安装nodejs和Git。<br>　　第二步，安装Hexo,和其他的包一样，通过<code>npm install-g hexo</code>来安装。","more":"<br>　　第三步，创建一个用于存放Hexo的文件夹，在该文件夹目录下执行hexo init。<br>　　第四步，执行<code>hexo g</code>(等同于<code>hexo generate</code>)生成静态页面，执行<code>hexo s</code>(等同于<code>hexo server</code>)启动本地服务进行预览，这样浏览器里可以输入<code>http://localhost:4000</code>进行访问。我第一次访问的时候，因为4000端口被占用，页面打不开，关闭占用端口后，正常。<br>　　第五步，配置博客。在Hexo目录配置文件_config.yml中可以配置诸如标题、副标题、作者、语言、主题、部署等等配置。<br>　　第六步，配置主题。搜索Hexo主题会有很多，并且都有使用说明。一般流程就是通过git clone复制到自己的目录下，在Hexo目录下的_config.yml文件中配置<code>theme</code>属性，之后就是主题配置文件(位于themes/*/_config.yml)进行个性化配置。</p>\n<p>　　之后，就是把博客放到Github上去了。<br>　　首先是在个人GIthub上建立新的仓库，仓库名为<code>username.github.io</code>，比如我的Github帐号是<a href=\"http://github.com/PFanz\" target=\"_blank\" rel=\"noopener\">PFanz</a>,仓库名就是<code>PFanz.github.io</code>。<br>　　在Hexo配置文件_config.yml中配置<code>deploy</code>中各项，比如：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">deploy</span>:</span><br><span class=\"line\">  <span class=\"attribute\">type</span>: git</span><br><span class=\"line\">  <span class=\"attribute\">repo</span>: <span class=\"attribute\">https</span>:<span class=\"comment\">//github.com/PFanz/PFanz.github.io.git</span></span><br><span class=\"line\">  <span class=\"attribute\">branch</span>: master</span><br></pre></td></tr></table></figure></p>\n<p>　　然后执行命令<code>npm install hexo-deployer-git --save</code>，便可以通过<code>username.github.io</code>访问到该博客。<br>　　写博客可以通过命令<code>hexo new&quot;titleName&quot;</code>，在Hexo目录下<code>source/_posts</code>新建文件titleName.md，也可以自己手动建立。手动建立的话，需要自己加入头<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">titleName</span></span><br><span class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2016</span><span class=\"bullet\">-06</span><span class=\"bullet\">-09</span> <span class=\"number\">22</span><span class=\"string\">:11:35</span></span><br><span class=\"line\"><span class=\"attr\">tags:</span> <span class=\"string\">标签</span></span><br><span class=\"line\"><span class=\"attr\">categories:</span> </span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">分类名称</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure></p>\n<p>　　每次部署按一下三步<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">hexo clean</span></span><br><span class=\"line\"><span class=\"attribute\">hexo g</span></span><br><span class=\"line\"><span class=\"attribute\">hexo d</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>　　虽然说基本功能已经搭建，感觉还有不少地方值得去探索，以实现更个性化，更漂亮的博客。</p>"},{"title":"前端技术栈","date":"2016-10-08T16:00:00.000Z","comments":1,"_content":"\n浏览器环境IE6~8 IE9+ Chrome Firefox Safari Opera Edge\t\t\t\t持续学习\n\nHTTP协议URI Cache Session Cookie Request Response\t\t\t\t\t持续学习\n\nHTMLW3C HTML4.01 HTML5 DOM 语义化\t\t\t\t\t\t\t\t\t\t\t\t\t持续学习\n\nCSSCSS1~3 选择器 盒模型 Flex 媒体检测 响应式 渲染引擎\t\t\t\t\t媒体检测，响应式，渲染引擎\n\nJavaScriptEcmaScript3~5~6 Lexical-scope prototype-chain AJAX js引擎\n\n编辑器Emacs Vim WebStorm Atom Sublime-Text\t\t\t\t\t\t\t\t\t学习WebStorm\n\n发布部署合并 压缩 单元测试 Node.js Grunt Gulp Yeoman Phantom JSLint\n\n框架类库jQuery Zepto UnderScore Backbone Knockout React AngularJS\n\n模块管理CommonJS Webpack\n\nUI框架BootStrap SemanticUI jQueryUI Foundation\n\n推送技术WebSocket 轮询 长连接\n\n跨域技术iframe JSONP CORS\n\n数据可视化D3 Echarts HighCharts Canvas\n\n异步编程Promise $.Deferred Generator\n\nCSS预处理器LESS SASS Stylus\n\n客户端模板Handlebars Haml Jade Mustache\n\n相关语言CoffeeScript TypeScript Dart WebAssembly\n\nWebApp/PCReact-native ionic\n\n环境：nodejs (Node.js)\n包管理：npm (https://www.npmjs.com/)\n框架：react/vue (A JavaScript library for building user interfaces, vue.js)\n架构：redux (rackt/redux · GitHub)\n打包：webpack (webpack module bundler)\n构建：gulp (gulp.js - the streaming build system)\n编译：babel (Babel 路 The compiler for writing next generation JavaScript)\n合并请求：htmlone (https://www.npmjs.com/package/gulp-htmlone)\n\t预处理器：sass (Sass: Syntactically Awesome Style Sheets)\n\t后处理器：postCSS (postcss/postcss · GitHub)\n\t自动前缀：autoprefixer (postcss/autoprefixer · GitHub)\n\t适配方案：lib-flexible&px2rem (amfe/lib-flexible · GitHubhttps://www.npmjs.com/package/postcss-px2rem)\n框架调试工具：vue-devtools/react-devtools(https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpdhttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)\n开发服务器：这个随便，主要是配合hot-loader：(gaearon/react-hot-loader · GitHubvuejs/vue-hot-reload-api · GitHub) \n\n浏览器\n渲染引擎、JavaScript引擎\nHTML/JavaScript/CSS三支柱\n编辑器\n编译任务\n编译工具\n打包、调试、质量\n测试\nJS基础类库\nJS类库\nUI框架\nCSS预处理器\n模板\n现代化\n安全/模式\n中间语言\n跨平台解决方案","source":"_posts/前端技术栈.md","raw":"---\ntitle: 前端技术栈\ndate: 2016-10-09\ntags: [前端, 汇总]\ncategories: \n- 杂记\ncomments: true\n---\n\n浏览器环境IE6~8 IE9+ Chrome Firefox Safari Opera Edge\t\t\t\t持续学习\n\nHTTP协议URI Cache Session Cookie Request Response\t\t\t\t\t持续学习\n\nHTMLW3C HTML4.01 HTML5 DOM 语义化\t\t\t\t\t\t\t\t\t\t\t\t\t持续学习\n\nCSSCSS1~3 选择器 盒模型 Flex 媒体检测 响应式 渲染引擎\t\t\t\t\t媒体检测，响应式，渲染引擎\n\nJavaScriptEcmaScript3~5~6 Lexical-scope prototype-chain AJAX js引擎\n\n编辑器Emacs Vim WebStorm Atom Sublime-Text\t\t\t\t\t\t\t\t\t学习WebStorm\n\n发布部署合并 压缩 单元测试 Node.js Grunt Gulp Yeoman Phantom JSLint\n\n框架类库jQuery Zepto UnderScore Backbone Knockout React AngularJS\n\n模块管理CommonJS Webpack\n\nUI框架BootStrap SemanticUI jQueryUI Foundation\n\n推送技术WebSocket 轮询 长连接\n\n跨域技术iframe JSONP CORS\n\n数据可视化D3 Echarts HighCharts Canvas\n\n异步编程Promise $.Deferred Generator\n\nCSS预处理器LESS SASS Stylus\n\n客户端模板Handlebars Haml Jade Mustache\n\n相关语言CoffeeScript TypeScript Dart WebAssembly\n\nWebApp/PCReact-native ionic\n\n环境：nodejs (Node.js)\n包管理：npm (https://www.npmjs.com/)\n框架：react/vue (A JavaScript library for building user interfaces, vue.js)\n架构：redux (rackt/redux · GitHub)\n打包：webpack (webpack module bundler)\n构建：gulp (gulp.js - the streaming build system)\n编译：babel (Babel 路 The compiler for writing next generation JavaScript)\n合并请求：htmlone (https://www.npmjs.com/package/gulp-htmlone)\n\t预处理器：sass (Sass: Syntactically Awesome Style Sheets)\n\t后处理器：postCSS (postcss/postcss · GitHub)\n\t自动前缀：autoprefixer (postcss/autoprefixer · GitHub)\n\t适配方案：lib-flexible&px2rem (amfe/lib-flexible · GitHubhttps://www.npmjs.com/package/postcss-px2rem)\n框架调试工具：vue-devtools/react-devtools(https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpdhttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)\n开发服务器：这个随便，主要是配合hot-loader：(gaearon/react-hot-loader · GitHubvuejs/vue-hot-reload-api · GitHub) \n\n浏览器\n渲染引擎、JavaScript引擎\nHTML/JavaScript/CSS三支柱\n编辑器\n编译任务\n编译工具\n打包、调试、质量\n测试\nJS基础类库\nJS类库\nUI框架\nCSS预处理器\n模板\n现代化\n安全/模式\n中间语言\n跨平台解决方案","slug":"前端技术栈","published":1,"updated":"2017-12-28T03:47:32.466Z","layout":"post","photos":[],"link":"","_id":"cjks5i9j1003dvmtif2e2825h","content":"<p>浏览器环境IE6~8 IE9+ Chrome Firefox Safari Opera Edge                持续学习</p>\n<p>HTTP协议URI Cache Session Cookie Request Response                    持续学习</p>\n<p>HTMLW3C HTML4.01 HTML5 DOM 语义化                                                    持续学习</p>\n<p>CSSCSS1~3 选择器 盒模型 Flex 媒体检测 响应式 渲染引擎                    媒体检测，响应式，渲染引擎</p>\n<p>JavaScriptEcmaScript3~5~6 Lexical-scope prototype-chain AJAX js引擎</p>\n<p>编辑器Emacs Vim WebStorm Atom Sublime-Text                                    学习WebStorm</p>\n<p>发布部署合并 压缩 单元测试 Node.js Grunt Gulp Yeoman Phantom JSLint</p>\n<p>框架类库jQuery Zepto UnderScore Backbone Knockout React AngularJS</p>\n<p>模块管理CommonJS Webpack</p>\n<p>UI框架BootStrap SemanticUI jQueryUI Foundation</p>\n<p>推送技术WebSocket 轮询 长连接</p>\n<p>跨域技术iframe JSONP CORS</p>\n<p>数据可视化D3 Echarts HighCharts Canvas</p>\n<p>异步编程Promise $.Deferred Generator</p>\n<p>CSS预处理器LESS SASS Stylus</p>\n<p>客户端模板Handlebars Haml Jade Mustache</p>\n<p>相关语言CoffeeScript TypeScript Dart WebAssembly</p>\n<p>WebApp/PCReact-native ionic</p>\n<p>环境：nodejs (Node.js)<br>包管理：npm (<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/</a>)<br>框架：react/vue (A JavaScript library for building user interfaces, vue.js)<br>架构：redux (rackt/redux · GitHub)<br>打包：webpack (webpack module bundler)<br>构建：gulp (gulp.js - the streaming build system)<br>编译：babel (Babel 路 The compiler for writing next generation JavaScript)<br>合并请求：htmlone (<a href=\"https://www.npmjs.com/package/gulp-htmlone\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/gulp-htmlone</a>)<br>    预处理器：sass (Sass: Syntactically Awesome Style Sheets)<br>    后处理器：postCSS (postcss/postcss · GitHub)<br>    自动前缀：autoprefixer (postcss/autoprefixer · GitHub)<br>    适配方案：lib-flexible&amp;px2rem (amfe/lib-flexible · GitHub<a href=\"https://www.npmjs.com/package/postcss-px2rem\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/postcss-px2rem</a>)<br>框架调试工具：vue-devtools/react-devtools(<a href=\"https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpdhttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi\" target=\"_blank\" rel=\"noopener\">https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpdhttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi</a>)<br>开发服务器：这个随便，主要是配合hot-loader：(gaearon/react-hot-loader · GitHubvuejs/vue-hot-reload-api · GitHub) </p>\n<p>浏览器<br>渲染引擎、JavaScript引擎<br>HTML/JavaScript/CSS三支柱<br>编辑器<br>编译任务<br>编译工具<br>打包、调试、质量<br>测试<br>JS基础类库<br>JS类库<br>UI框架<br>CSS预处理器<br>模板<br>现代化<br>安全/模式<br>中间语言<br>跨平台解决方案</p>\n","site":{"data":{}},"excerpt":"","more":"<p>浏览器环境IE6~8 IE9+ Chrome Firefox Safari Opera Edge                持续学习</p>\n<p>HTTP协议URI Cache Session Cookie Request Response                    持续学习</p>\n<p>HTMLW3C HTML4.01 HTML5 DOM 语义化                                                    持续学习</p>\n<p>CSSCSS1~3 选择器 盒模型 Flex 媒体检测 响应式 渲染引擎                    媒体检测，响应式，渲染引擎</p>\n<p>JavaScriptEcmaScript3~5~6 Lexical-scope prototype-chain AJAX js引擎</p>\n<p>编辑器Emacs Vim WebStorm Atom Sublime-Text                                    学习WebStorm</p>\n<p>发布部署合并 压缩 单元测试 Node.js Grunt Gulp Yeoman Phantom JSLint</p>\n<p>框架类库jQuery Zepto UnderScore Backbone Knockout React AngularJS</p>\n<p>模块管理CommonJS Webpack</p>\n<p>UI框架BootStrap SemanticUI jQueryUI Foundation</p>\n<p>推送技术WebSocket 轮询 长连接</p>\n<p>跨域技术iframe JSONP CORS</p>\n<p>数据可视化D3 Echarts HighCharts Canvas</p>\n<p>异步编程Promise $.Deferred Generator</p>\n<p>CSS预处理器LESS SASS Stylus</p>\n<p>客户端模板Handlebars Haml Jade Mustache</p>\n<p>相关语言CoffeeScript TypeScript Dart WebAssembly</p>\n<p>WebApp/PCReact-native ionic</p>\n<p>环境：nodejs (Node.js)<br>包管理：npm (<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/</a>)<br>框架：react/vue (A JavaScript library for building user interfaces, vue.js)<br>架构：redux (rackt/redux · GitHub)<br>打包：webpack (webpack module bundler)<br>构建：gulp (gulp.js - the streaming build system)<br>编译：babel (Babel 路 The compiler for writing next generation JavaScript)<br>合并请求：htmlone (<a href=\"https://www.npmjs.com/package/gulp-htmlone\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/gulp-htmlone</a>)<br>    预处理器：sass (Sass: Syntactically Awesome Style Sheets)<br>    后处理器：postCSS (postcss/postcss · GitHub)<br>    自动前缀：autoprefixer (postcss/autoprefixer · GitHub)<br>    适配方案：lib-flexible&amp;px2rem (amfe/lib-flexible · GitHub<a href=\"https://www.npmjs.com/package/postcss-px2rem\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/postcss-px2rem</a>)<br>框架调试工具：vue-devtools/react-devtools(<a href=\"https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpdhttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi\" target=\"_blank\" rel=\"noopener\">https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpdhttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi</a>)<br>开发服务器：这个随便，主要是配合hot-loader：(gaearon/react-hot-loader · GitHubvuejs/vue-hot-reload-api · GitHub) </p>\n<p>浏览器<br>渲染引擎、JavaScript引擎<br>HTML/JavaScript/CSS三支柱<br>编辑器<br>编译任务<br>编译工具<br>打包、调试、质量<br>测试<br>JS基础类库<br>JS类库<br>UI框架<br>CSS预处理器<br>模板<br>现代化<br>安全/模式<br>中间语言<br>跨平台解决方案</p>\n"},{"title":"微信小程序上线","date":"2017-06-08T16:00:00.000Z","comments":1,"_content":"\n微信小程序即将上线，对遇到的问题做个总结。\n\n首先要做到的肯定是微信小程序的文档，主要包括设计、配置、组件、API这些，碰到问题或新的需求要先在这里找解决方案，要注意的是有一些甚至是没办法实现的。小程序开发最大的不同是无法操作DOM，页面上所有的展示以及效果只能通过数据变化来体现，也就是视图层通过数据层控制。\n\n对于新闻类型的应用，新闻列表样式种类可以分出那么几类，通过条件判断可以进行展示。但是对于新闻详情页这种图文混合、位置不定的样式，小程序目前的应对方式比较麻烦，这里借助了开源的[wxParse](https://github.com/icindy/wxParse)。因为小程序的视图展示只能通过数据层来控制，没办法将包含标签的数据直接展示出来，wxParse可以将HTML字符串解析成类似Dom节点信息的对象，再将此对象解析成小程序的展示。这个应该算是小程序的一个缺陷吧。\n\n图集详情页是一个轮播图，包含多张图片，每张图片有不同的介绍，但是标题是不变的。这里如果直接使用swiper组件，会导致标题会跟着滑动。其实这里的介绍用的是一个字段，每次翻页改变该字段的内容，就可以实现图片的轮播，介绍的变动。\n\n新闻列表已读置灰，这个功能在Web中是很常见的，一个`：visited`就可以搞定。但是在小程序中，CSS选择器支持也被去掉了很大一部分，伪类选择器仅支持`::after`和`::before`。在部分组件上使用了`hover-class`属性实现hover的样式，并不存在`visited-class`属性，毕竟在小程序中连a标签都没有。  \n视图层可以通过数据层控制，只需要将阅读过的新闻保存在数据中即可。需要做的是，用view标签加tap方法模拟navigator标签，这样在跳转时候，我们便可以对数据层进行操作。有了这些数据，展示也就没太大问题了。\n\n在小程序的图片image组件中提供了`binderror`属性，该属性在图片加载失败的时候会触发，但是没有办法控制DOM，意味着即使图片加载失败，也不能直接修改src属性。感觉这个方法存在很是鸡肋，但是想要实现加载失败显示默认图片还是要肯定还是要通过这个方法来解决的。  \n解决方法就是在数据层找到错误的src，替换成默认图片地址，根据数据层结构的不同，应该有不同的方式。比如新闻列表中，我是将图片位于新闻列表的顺序位置保存在image组件中，这样可以拿到在新闻列表数据的index，不用遍历整个列表。\n\n最后需要注意的应该就是小程序在开发过程中可以使用http，但是在上线时就要换成https，并且同时支持https服务器需要同时支持TLS 1.0、1.1、1.2版本，因为部分手机兼容问题。\n\n小程序开发相对来说是很快捷的，但是有部分功能实现起来不是特别直接，比如HTML字符串转义的问题，图片加载错误问题，在实现过程中感觉就像是为老版本浏览器做着各种hack。  \n微信小程序并没有之前宣传的那么火热，站在用户角度来说影响不大，作为开发者，简历上多了一项技能，并且据说支付宝小程序也即将上线。","source":"_posts/小程序上线.md","raw":"---\ntitle: 微信小程序上线\ndate: 2017-06-09\ntags: [微信小程序, 项目经验]\ncategories:\n- JavaScript\ncomments: true\n---\n\n微信小程序即将上线，对遇到的问题做个总结。\n\n首先要做到的肯定是微信小程序的文档，主要包括设计、配置、组件、API这些，碰到问题或新的需求要先在这里找解决方案，要注意的是有一些甚至是没办法实现的。小程序开发最大的不同是无法操作DOM，页面上所有的展示以及效果只能通过数据变化来体现，也就是视图层通过数据层控制。\n\n对于新闻类型的应用，新闻列表样式种类可以分出那么几类，通过条件判断可以进行展示。但是对于新闻详情页这种图文混合、位置不定的样式，小程序目前的应对方式比较麻烦，这里借助了开源的[wxParse](https://github.com/icindy/wxParse)。因为小程序的视图展示只能通过数据层来控制，没办法将包含标签的数据直接展示出来，wxParse可以将HTML字符串解析成类似Dom节点信息的对象，再将此对象解析成小程序的展示。这个应该算是小程序的一个缺陷吧。\n\n图集详情页是一个轮播图，包含多张图片，每张图片有不同的介绍，但是标题是不变的。这里如果直接使用swiper组件，会导致标题会跟着滑动。其实这里的介绍用的是一个字段，每次翻页改变该字段的内容，就可以实现图片的轮播，介绍的变动。\n\n新闻列表已读置灰，这个功能在Web中是很常见的，一个`：visited`就可以搞定。但是在小程序中，CSS选择器支持也被去掉了很大一部分，伪类选择器仅支持`::after`和`::before`。在部分组件上使用了`hover-class`属性实现hover的样式，并不存在`visited-class`属性，毕竟在小程序中连a标签都没有。  \n视图层可以通过数据层控制，只需要将阅读过的新闻保存在数据中即可。需要做的是，用view标签加tap方法模拟navigator标签，这样在跳转时候，我们便可以对数据层进行操作。有了这些数据，展示也就没太大问题了。\n\n在小程序的图片image组件中提供了`binderror`属性，该属性在图片加载失败的时候会触发，但是没有办法控制DOM，意味着即使图片加载失败，也不能直接修改src属性。感觉这个方法存在很是鸡肋，但是想要实现加载失败显示默认图片还是要肯定还是要通过这个方法来解决的。  \n解决方法就是在数据层找到错误的src，替换成默认图片地址，根据数据层结构的不同，应该有不同的方式。比如新闻列表中，我是将图片位于新闻列表的顺序位置保存在image组件中，这样可以拿到在新闻列表数据的index，不用遍历整个列表。\n\n最后需要注意的应该就是小程序在开发过程中可以使用http，但是在上线时就要换成https，并且同时支持https服务器需要同时支持TLS 1.0、1.1、1.2版本，因为部分手机兼容问题。\n\n小程序开发相对来说是很快捷的，但是有部分功能实现起来不是特别直接，比如HTML字符串转义的问题，图片加载错误问题，在实现过程中感觉就像是为老版本浏览器做着各种hack。  \n微信小程序并没有之前宣传的那么火热，站在用户角度来说影响不大，作为开发者，简历上多了一项技能，并且据说支付宝小程序也即将上线。","slug":"小程序上线","published":1,"updated":"2017-12-28T03:47:32.466Z","layout":"post","photos":[],"link":"","_id":"cjks5i9j2003hvmti5wggrw47","content":"<p>微信小程序即将上线，对遇到的问题做个总结。</p>\n<p>首先要做到的肯定是微信小程序的文档，主要包括设计、配置、组件、API这些，碰到问题或新的需求要先在这里找解决方案，要注意的是有一些甚至是没办法实现的。小程序开发最大的不同是无法操作DOM，页面上所有的展示以及效果只能通过数据变化来体现，也就是视图层通过数据层控制。</p>\n<p>对于新闻类型的应用，新闻列表样式种类可以分出那么几类，通过条件判断可以进行展示。但是对于新闻详情页这种图文混合、位置不定的样式，小程序目前的应对方式比较麻烦，这里借助了开源的<a href=\"https://github.com/icindy/wxParse\" target=\"_blank\" rel=\"noopener\">wxParse</a>。因为小程序的视图展示只能通过数据层来控制，没办法将包含标签的数据直接展示出来，wxParse可以将HTML字符串解析成类似Dom节点信息的对象，再将此对象解析成小程序的展示。这个应该算是小程序的一个缺陷吧。</p>\n<p>图集详情页是一个轮播图，包含多张图片，每张图片有不同的介绍，但是标题是不变的。这里如果直接使用swiper组件，会导致标题会跟着滑动。其实这里的介绍用的是一个字段，每次翻页改变该字段的内容，就可以实现图片的轮播，介绍的变动。</p>\n<p>新闻列表已读置灰，这个功能在Web中是很常见的，一个<code>：visited</code>就可以搞定。但是在小程序中，CSS选择器支持也被去掉了很大一部分，伪类选择器仅支持<code>::after</code>和<code>::before</code>。在部分组件上使用了<code>hover-class</code>属性实现hover的样式，并不存在<code>visited-class</code>属性，毕竟在小程序中连a标签都没有。<br>视图层可以通过数据层控制，只需要将阅读过的新闻保存在数据中即可。需要做的是，用view标签加tap方法模拟navigator标签，这样在跳转时候，我们便可以对数据层进行操作。有了这些数据，展示也就没太大问题了。</p>\n<p>在小程序的图片image组件中提供了<code>binderror</code>属性，该属性在图片加载失败的时候会触发，但是没有办法控制DOM，意味着即使图片加载失败，也不能直接修改src属性。感觉这个方法存在很是鸡肋，但是想要实现加载失败显示默认图片还是要肯定还是要通过这个方法来解决的。<br>解决方法就是在数据层找到错误的src，替换成默认图片地址，根据数据层结构的不同，应该有不同的方式。比如新闻列表中，我是将图片位于新闻列表的顺序位置保存在image组件中，这样可以拿到在新闻列表数据的index，不用遍历整个列表。</p>\n<p>最后需要注意的应该就是小程序在开发过程中可以使用http，但是在上线时就要换成https，并且同时支持https服务器需要同时支持TLS 1.0、1.1、1.2版本，因为部分手机兼容问题。</p>\n<p>小程序开发相对来说是很快捷的，但是有部分功能实现起来不是特别直接，比如HTML字符串转义的问题，图片加载错误问题，在实现过程中感觉就像是为老版本浏览器做着各种hack。<br>微信小程序并没有之前宣传的那么火热，站在用户角度来说影响不大，作为开发者，简历上多了一项技能，并且据说支付宝小程序也即将上线。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>微信小程序即将上线，对遇到的问题做个总结。</p>\n<p>首先要做到的肯定是微信小程序的文档，主要包括设计、配置、组件、API这些，碰到问题或新的需求要先在这里找解决方案，要注意的是有一些甚至是没办法实现的。小程序开发最大的不同是无法操作DOM，页面上所有的展示以及效果只能通过数据变化来体现，也就是视图层通过数据层控制。</p>\n<p>对于新闻类型的应用，新闻列表样式种类可以分出那么几类，通过条件判断可以进行展示。但是对于新闻详情页这种图文混合、位置不定的样式，小程序目前的应对方式比较麻烦，这里借助了开源的<a href=\"https://github.com/icindy/wxParse\" target=\"_blank\" rel=\"noopener\">wxParse</a>。因为小程序的视图展示只能通过数据层来控制，没办法将包含标签的数据直接展示出来，wxParse可以将HTML字符串解析成类似Dom节点信息的对象，再将此对象解析成小程序的展示。这个应该算是小程序的一个缺陷吧。</p>\n<p>图集详情页是一个轮播图，包含多张图片，每张图片有不同的介绍，但是标题是不变的。这里如果直接使用swiper组件，会导致标题会跟着滑动。其实这里的介绍用的是一个字段，每次翻页改变该字段的内容，就可以实现图片的轮播，介绍的变动。</p>\n<p>新闻列表已读置灰，这个功能在Web中是很常见的，一个<code>：visited</code>就可以搞定。但是在小程序中，CSS选择器支持也被去掉了很大一部分，伪类选择器仅支持<code>::after</code>和<code>::before</code>。在部分组件上使用了<code>hover-class</code>属性实现hover的样式，并不存在<code>visited-class</code>属性，毕竟在小程序中连a标签都没有。<br>视图层可以通过数据层控制，只需要将阅读过的新闻保存在数据中即可。需要做的是，用view标签加tap方法模拟navigator标签，这样在跳转时候，我们便可以对数据层进行操作。有了这些数据，展示也就没太大问题了。</p>\n<p>在小程序的图片image组件中提供了<code>binderror</code>属性，该属性在图片加载失败的时候会触发，但是没有办法控制DOM，意味着即使图片加载失败，也不能直接修改src属性。感觉这个方法存在很是鸡肋，但是想要实现加载失败显示默认图片还是要肯定还是要通过这个方法来解决的。<br>解决方法就是在数据层找到错误的src，替换成默认图片地址，根据数据层结构的不同，应该有不同的方式。比如新闻列表中，我是将图片位于新闻列表的顺序位置保存在image组件中，这样可以拿到在新闻列表数据的index，不用遍历整个列表。</p>\n<p>最后需要注意的应该就是小程序在开发过程中可以使用http，但是在上线时就要换成https，并且同时支持https服务器需要同时支持TLS 1.0、1.1、1.2版本，因为部分手机兼容问题。</p>\n<p>小程序开发相对来说是很快捷的，但是有部分功能实现起来不是特别直接，比如HTML字符串转义的问题，图片加载错误问题，在实现过程中感觉就像是为老版本浏览器做着各种hack。<br>微信小程序并没有之前宣传的那么火热，站在用户角度来说影响不大，作为开发者，简历上多了一项技能，并且据说支付宝小程序也即将上线。</p>\n"},{"title":"微信分享绝对是个坑","date":"2016-08-07T16:00:00.000Z","comments":1,"_content":"\n没想到碰到的第一个大坑竟然是这种问题，原以为一个微信分享，不就是看着微信开发者文档，然后写几个配置参数就可以完成的么？就算开发者文档比较麻烦，像这种常用的功能不是应该公司早就封装好，拿来配置几个参数搞定的事情么！\n\n-----\n\n### 0.先上结论吧\n目前我发现的比较好的解决办法是使用官方的(分享组件)[http://open.mobile.qq.com/api/component/share],但是安卓下微信分享手机QQ方向会有问题。微信分享QQ方向，标题使用的是title标签，描述是链接地址，图标使用的是页面第一个img标签内容(尺寸应该是大于等于300*300)。所以可以使用`div display:none;`包含img标签。  \n\tps:应该是微信API有问题，以后可能会被修复。\n\n### 1.公司封装\n在我项目开始不久前，另一个前端根据新的微信JS-SDK封装了分享方法，正好拿过来使用。使用还是挺方便的，只需要在引入插件前面定义全局对象即可。\n```javascript\nvar weChatShare = {\n\t\t\t\"title\" : '分享标题',    // 分享标题,建议主标题一行 18个字符以内 \n\t\t\t\"desc\"  : '分享描述',    // 分享描述，建议描述最多两行 36个字符以内 \n\t\t\t\"img\"   : '分享图标url', // 分享图标,200*200\n\t\t}\n```\n结果发现只有标题和描述，图标没有出来。手机QQ分享微信标题、描述、图片都没有出来。只能放弃。\n\n后来查看代码，封装的挺基本的，一个生成随机字符串作为生成签名的函数，一个ajax请求根据随机字符串、链接从后台获取签名(签名获取后台方法可以参看微信JS-SDK)，然后就是通过配置调用微信JS-SDK了。只是因为微信调用中配置`imgUrl`写错成了`img`导致图片没有出来。而手机QQ因为这些是微信的接口，手机QQ分享当然出不来了。当然，这都是后来再回头看的，项目期间时间紧，就一直在赶着找现成的方法。\n\n### 2.微信旧的API\n就是WeixinJSBridge这个对象，应该是已经不再推荐使用，但是还是可以生效的。因为是旧的嘛，我也没有太去了解。代码也就不贴了，直接忽略掉吧。  \n结果就是图片出来了，但是微信分享QQ以及QQ分享微信还是不够正常。\n\n### 3.找正常项目\n自己公司的基本上是找不到所谓正常的项目了，只能找其他公司的页面了。看了一遍，严格意义上的正常好像没有，不是QQ分享没有，就是微信分享QQ图片有问题，然后在滴滴的分享代码里找到这么一句`if(mqq !== undefined)`。然后顺着发现了`mqq.data.setShareInfo`。通过搜索这个方法名，发现了[腾讯移动WEB开发平台](http://open.mobile.qq.com/api/mqq/index)。好吧，承认自己蠢，QQ分享当然是应该找QQ的API，微信的API当然不管用了。\n\n### 4.分享组件\n期间又经过了自己的一系列的尝试，不停的add、commit、push，最终无意间发现了[这个](http://open.mobile.qq.com/api/component/share)，竟然有封装好的组件，但是[腾讯移动WEB开发平台](http://open.mobile.qq.com/api/mqq/index)中的手机QQ下没有，微信下没有，竟然是藏在首页的热门API标签下的分享中，这里写的API不应该就是API吗，为什么是组件？我怎么知道这里的『API』会和文档中的API不同呢？  \n使用该组件后，IOS上一切正常，安卓下微信分享QQ无效。\n\n### 5.图片隐藏法\n如果没有调用API，分享的时候会选取页面中第一个img标签中的图片作为图标，所以可以是用`div display:none;`包含图标地址img标签使用。经测试，不要使用太小的图片，200 * 200的图片，微信分享会无法显示，会跳过继续寻找下一个图片作为图标。没有测试太多，300 * 300的应该是比较合适的尺寸。","source":"_posts/微信分享绝对是个坑.md","raw":"---\ntitle: 微信分享绝对是个坑\ndate: 2016-08-08\ntags: [JavaScript, H5, 微信分享]\ncategories: \n- H5\ncomments: true\n---\n\n没想到碰到的第一个大坑竟然是这种问题，原以为一个微信分享，不就是看着微信开发者文档，然后写几个配置参数就可以完成的么？就算开发者文档比较麻烦，像这种常用的功能不是应该公司早就封装好，拿来配置几个参数搞定的事情么！\n\n-----\n\n### 0.先上结论吧\n目前我发现的比较好的解决办法是使用官方的(分享组件)[http://open.mobile.qq.com/api/component/share],但是安卓下微信分享手机QQ方向会有问题。微信分享QQ方向，标题使用的是title标签，描述是链接地址，图标使用的是页面第一个img标签内容(尺寸应该是大于等于300*300)。所以可以使用`div display:none;`包含img标签。  \n\tps:应该是微信API有问题，以后可能会被修复。\n\n### 1.公司封装\n在我项目开始不久前，另一个前端根据新的微信JS-SDK封装了分享方法，正好拿过来使用。使用还是挺方便的，只需要在引入插件前面定义全局对象即可。\n```javascript\nvar weChatShare = {\n\t\t\t\"title\" : '分享标题',    // 分享标题,建议主标题一行 18个字符以内 \n\t\t\t\"desc\"  : '分享描述',    // 分享描述，建议描述最多两行 36个字符以内 \n\t\t\t\"img\"   : '分享图标url', // 分享图标,200*200\n\t\t}\n```\n结果发现只有标题和描述，图标没有出来。手机QQ分享微信标题、描述、图片都没有出来。只能放弃。\n\n后来查看代码，封装的挺基本的，一个生成随机字符串作为生成签名的函数，一个ajax请求根据随机字符串、链接从后台获取签名(签名获取后台方法可以参看微信JS-SDK)，然后就是通过配置调用微信JS-SDK了。只是因为微信调用中配置`imgUrl`写错成了`img`导致图片没有出来。而手机QQ因为这些是微信的接口，手机QQ分享当然出不来了。当然，这都是后来再回头看的，项目期间时间紧，就一直在赶着找现成的方法。\n\n### 2.微信旧的API\n就是WeixinJSBridge这个对象，应该是已经不再推荐使用，但是还是可以生效的。因为是旧的嘛，我也没有太去了解。代码也就不贴了，直接忽略掉吧。  \n结果就是图片出来了，但是微信分享QQ以及QQ分享微信还是不够正常。\n\n### 3.找正常项目\n自己公司的基本上是找不到所谓正常的项目了，只能找其他公司的页面了。看了一遍，严格意义上的正常好像没有，不是QQ分享没有，就是微信分享QQ图片有问题，然后在滴滴的分享代码里找到这么一句`if(mqq !== undefined)`。然后顺着发现了`mqq.data.setShareInfo`。通过搜索这个方法名，发现了[腾讯移动WEB开发平台](http://open.mobile.qq.com/api/mqq/index)。好吧，承认自己蠢，QQ分享当然是应该找QQ的API，微信的API当然不管用了。\n\n### 4.分享组件\n期间又经过了自己的一系列的尝试，不停的add、commit、push，最终无意间发现了[这个](http://open.mobile.qq.com/api/component/share)，竟然有封装好的组件，但是[腾讯移动WEB开发平台](http://open.mobile.qq.com/api/mqq/index)中的手机QQ下没有，微信下没有，竟然是藏在首页的热门API标签下的分享中，这里写的API不应该就是API吗，为什么是组件？我怎么知道这里的『API』会和文档中的API不同呢？  \n使用该组件后，IOS上一切正常，安卓下微信分享QQ无效。\n\n### 5.图片隐藏法\n如果没有调用API，分享的时候会选取页面中第一个img标签中的图片作为图标，所以可以是用`div display:none;`包含图标地址img标签使用。经测试，不要使用太小的图片，200 * 200的图片，微信分享会无法显示，会跳过继续寻找下一个图片作为图标。没有测试太多，300 * 300的应该是比较合适的尺寸。","slug":"微信分享绝对是个坑","published":1,"updated":"2017-12-28T03:47:32.467Z","layout":"post","photos":[],"link":"","_id":"cjks5i9j5003kvmtiweuhvg58","content":"<p>没想到碰到的第一个大坑竟然是这种问题，原以为一个微信分享，不就是看着微信开发者文档，然后写几个配置参数就可以完成的么？就算开发者文档比较麻烦，像这种常用的功能不是应该公司早就封装好，拿来配置几个参数搞定的事情么！</p>\n<hr>\n<h3 id=\"0-先上结论吧\"><a href=\"#0-先上结论吧\" class=\"headerlink\" title=\"0.先上结论吧\"></a>0.先上结论吧</h3><p>目前我发现的比较好的解决办法是使用官方的(分享组件)[<a href=\"http://open.mobile.qq.com/api/component/share],但是安卓下微信分享手机QQ方向会有问题。微信分享QQ方向，标题使用的是title标签，描述是链接地址，图标使用的是页面第一个img标签内容(尺寸应该是大于等于300*300)。所以可以使用`div\" target=\"_blank\" rel=\"noopener\">http://open.mobile.qq.com/api/component/share],但是安卓下微信分享手机QQ方向会有问题。微信分享QQ方向，标题使用的是title标签，描述是链接地址，图标使用的是页面第一个img标签内容(尺寸应该是大于等于300*300)。所以可以使用`div</a> display:none;`包含img标签。<br>    ps:应该是微信API有问题，以后可能会被修复。</p>\n<h3 id=\"1-公司封装\"><a href=\"#1-公司封装\" class=\"headerlink\" title=\"1.公司封装\"></a>1.公司封装</h3><p>在我项目开始不久前，另一个前端根据新的微信JS-SDK封装了分享方法，正好拿过来使用。使用还是挺方便的，只需要在引入插件前面定义全局对象即可。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> weChatShare = &#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"title\"</span> : <span class=\"string\">'分享标题'</span>,    <span class=\"comment\">// 分享标题,建议主标题一行 18个字符以内 </span></span><br><span class=\"line\">\t\t\t<span class=\"string\">\"desc\"</span>  : <span class=\"string\">'分享描述'</span>,    <span class=\"comment\">// 分享描述，建议描述最多两行 36个字符以内 </span></span><br><span class=\"line\">\t\t\t<span class=\"string\">\"img\"</span>   : <span class=\"string\">'分享图标url'</span>, <span class=\"comment\">// 分享图标,200*200</span></span><br><span class=\"line\">\t\t&#125;</span><br></pre></td></tr></table></figure></p>\n<p>结果发现只有标题和描述，图标没有出来。手机QQ分享微信标题、描述、图片都没有出来。只能放弃。</p>\n<p>后来查看代码，封装的挺基本的，一个生成随机字符串作为生成签名的函数，一个ajax请求根据随机字符串、链接从后台获取签名(签名获取后台方法可以参看微信JS-SDK)，然后就是通过配置调用微信JS-SDK了。只是因为微信调用中配置<code>imgUrl</code>写错成了<code>img</code>导致图片没有出来。而手机QQ因为这些是微信的接口，手机QQ分享当然出不来了。当然，这都是后来再回头看的，项目期间时间紧，就一直在赶着找现成的方法。</p>\n<h3 id=\"2-微信旧的API\"><a href=\"#2-微信旧的API\" class=\"headerlink\" title=\"2.微信旧的API\"></a>2.微信旧的API</h3><p>就是WeixinJSBridge这个对象，应该是已经不再推荐使用，但是还是可以生效的。因为是旧的嘛，我也没有太去了解。代码也就不贴了，直接忽略掉吧。<br>结果就是图片出来了，但是微信分享QQ以及QQ分享微信还是不够正常。</p>\n<h3 id=\"3-找正常项目\"><a href=\"#3-找正常项目\" class=\"headerlink\" title=\"3.找正常项目\"></a>3.找正常项目</h3><p>自己公司的基本上是找不到所谓正常的项目了，只能找其他公司的页面了。看了一遍，严格意义上的正常好像没有，不是QQ分享没有，就是微信分享QQ图片有问题，然后在滴滴的分享代码里找到这么一句<code>if(mqq !== undefined)</code>。然后顺着发现了<code>mqq.data.setShareInfo</code>。通过搜索这个方法名，发现了<a href=\"http://open.mobile.qq.com/api/mqq/index\" target=\"_blank\" rel=\"noopener\">腾讯移动WEB开发平台</a>。好吧，承认自己蠢，QQ分享当然是应该找QQ的API，微信的API当然不管用了。</p>\n<h3 id=\"4-分享组件\"><a href=\"#4-分享组件\" class=\"headerlink\" title=\"4.分享组件\"></a>4.分享组件</h3><p>期间又经过了自己的一系列的尝试，不停的add、commit、push，最终无意间发现了<a href=\"http://open.mobile.qq.com/api/component/share\" target=\"_blank\" rel=\"noopener\">这个</a>，竟然有封装好的组件，但是<a href=\"http://open.mobile.qq.com/api/mqq/index\" target=\"_blank\" rel=\"noopener\">腾讯移动WEB开发平台</a>中的手机QQ下没有，微信下没有，竟然是藏在首页的热门API标签下的分享中，这里写的API不应该就是API吗，为什么是组件？我怎么知道这里的『API』会和文档中的API不同呢？<br>使用该组件后，IOS上一切正常，安卓下微信分享QQ无效。</p>\n<h3 id=\"5-图片隐藏法\"><a href=\"#5-图片隐藏法\" class=\"headerlink\" title=\"5.图片隐藏法\"></a>5.图片隐藏法</h3><p>如果没有调用API，分享的时候会选取页面中第一个img标签中的图片作为图标，所以可以是用<code>div display:none;</code>包含图标地址img标签使用。经测试，不要使用太小的图片，200 <em> 200的图片，微信分享会无法显示，会跳过继续寻找下一个图片作为图标。没有测试太多，300 </em> 300的应该是比较合适的尺寸。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>没想到碰到的第一个大坑竟然是这种问题，原以为一个微信分享，不就是看着微信开发者文档，然后写几个配置参数就可以完成的么？就算开发者文档比较麻烦，像这种常用的功能不是应该公司早就封装好，拿来配置几个参数搞定的事情么！</p>\n<hr>\n<h3 id=\"0-先上结论吧\"><a href=\"#0-先上结论吧\" class=\"headerlink\" title=\"0.先上结论吧\"></a>0.先上结论吧</h3><p>目前我发现的比较好的解决办法是使用官方的(分享组件)[<a href=\"http://open.mobile.qq.com/api/component/share],但是安卓下微信分享手机QQ方向会有问题。微信分享QQ方向，标题使用的是title标签，描述是链接地址，图标使用的是页面第一个img标签内容(尺寸应该是大于等于300*300)。所以可以使用`div\" target=\"_blank\" rel=\"noopener\">http://open.mobile.qq.com/api/component/share],但是安卓下微信分享手机QQ方向会有问题。微信分享QQ方向，标题使用的是title标签，描述是链接地址，图标使用的是页面第一个img标签内容(尺寸应该是大于等于300*300)。所以可以使用`div</a> display:none;`包含img标签。<br>    ps:应该是微信API有问题，以后可能会被修复。</p>\n<h3 id=\"1-公司封装\"><a href=\"#1-公司封装\" class=\"headerlink\" title=\"1.公司封装\"></a>1.公司封装</h3><p>在我项目开始不久前，另一个前端根据新的微信JS-SDK封装了分享方法，正好拿过来使用。使用还是挺方便的，只需要在引入插件前面定义全局对象即可。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> weChatShare = &#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"title\"</span> : <span class=\"string\">'分享标题'</span>,    <span class=\"comment\">// 分享标题,建议主标题一行 18个字符以内 </span></span><br><span class=\"line\">\t\t\t<span class=\"string\">\"desc\"</span>  : <span class=\"string\">'分享描述'</span>,    <span class=\"comment\">// 分享描述，建议描述最多两行 36个字符以内 </span></span><br><span class=\"line\">\t\t\t<span class=\"string\">\"img\"</span>   : <span class=\"string\">'分享图标url'</span>, <span class=\"comment\">// 分享图标,200*200</span></span><br><span class=\"line\">\t\t&#125;</span><br></pre></td></tr></table></figure></p>\n<p>结果发现只有标题和描述，图标没有出来。手机QQ分享微信标题、描述、图片都没有出来。只能放弃。</p>\n<p>后来查看代码，封装的挺基本的，一个生成随机字符串作为生成签名的函数，一个ajax请求根据随机字符串、链接从后台获取签名(签名获取后台方法可以参看微信JS-SDK)，然后就是通过配置调用微信JS-SDK了。只是因为微信调用中配置<code>imgUrl</code>写错成了<code>img</code>导致图片没有出来。而手机QQ因为这些是微信的接口，手机QQ分享当然出不来了。当然，这都是后来再回头看的，项目期间时间紧，就一直在赶着找现成的方法。</p>\n<h3 id=\"2-微信旧的API\"><a href=\"#2-微信旧的API\" class=\"headerlink\" title=\"2.微信旧的API\"></a>2.微信旧的API</h3><p>就是WeixinJSBridge这个对象，应该是已经不再推荐使用，但是还是可以生效的。因为是旧的嘛，我也没有太去了解。代码也就不贴了，直接忽略掉吧。<br>结果就是图片出来了，但是微信分享QQ以及QQ分享微信还是不够正常。</p>\n<h3 id=\"3-找正常项目\"><a href=\"#3-找正常项目\" class=\"headerlink\" title=\"3.找正常项目\"></a>3.找正常项目</h3><p>自己公司的基本上是找不到所谓正常的项目了，只能找其他公司的页面了。看了一遍，严格意义上的正常好像没有，不是QQ分享没有，就是微信分享QQ图片有问题，然后在滴滴的分享代码里找到这么一句<code>if(mqq !== undefined)</code>。然后顺着发现了<code>mqq.data.setShareInfo</code>。通过搜索这个方法名，发现了<a href=\"http://open.mobile.qq.com/api/mqq/index\" target=\"_blank\" rel=\"noopener\">腾讯移动WEB开发平台</a>。好吧，承认自己蠢，QQ分享当然是应该找QQ的API，微信的API当然不管用了。</p>\n<h3 id=\"4-分享组件\"><a href=\"#4-分享组件\" class=\"headerlink\" title=\"4.分享组件\"></a>4.分享组件</h3><p>期间又经过了自己的一系列的尝试，不停的add、commit、push，最终无意间发现了<a href=\"http://open.mobile.qq.com/api/component/share\" target=\"_blank\" rel=\"noopener\">这个</a>，竟然有封装好的组件，但是<a href=\"http://open.mobile.qq.com/api/mqq/index\" target=\"_blank\" rel=\"noopener\">腾讯移动WEB开发平台</a>中的手机QQ下没有，微信下没有，竟然是藏在首页的热门API标签下的分享中，这里写的API不应该就是API吗，为什么是组件？我怎么知道这里的『API』会和文档中的API不同呢？<br>使用该组件后，IOS上一切正常，安卓下微信分享QQ无效。</p>\n<h3 id=\"5-图片隐藏法\"><a href=\"#5-图片隐藏法\" class=\"headerlink\" title=\"5.图片隐藏法\"></a>5.图片隐藏法</h3><p>如果没有调用API，分享的时候会选取页面中第一个img标签中的图片作为图标，所以可以是用<code>div display:none;</code>包含图标地址img标签使用。经测试，不要使用太小的图片，200 <em> 200的图片，微信分享会无法显示，会跳过继续寻找下一个图片作为图标。没有测试太多，300 </em> 300的应该是比较合适的尺寸。</p>\n"},{"title":"微信小程序","date":"2017-05-22T16:00:00.000Z","comments":1,"_content":"\n从微信小程序正式发布到现在已经过去了几个月了，发布前所有人仿佛发现了金矿的入口，早早地做好能做的一切准备等待着入口的开启，当所有人争前恐后地进入矿洞以后，收获却是寥寥无几。目前，我用过的小程序一个是开发者所用的小程序示例，一个是提供免费来推广的摩拜单车。  \n在小程序整体推广情况不容乐观的情况下，现在更多的开发应该属于防御性质的，毕竟小程序开发成本还是有很大优势的。（为了推广小程序，微信又提供了附近的小程序、与公众号关联等形式，但是在我感觉还是有些鸡肋。）\n\n这次环球网小程序的开发，页面包括两个tab页、两个新闻列表页和两种详情页，功能简单，熟悉小程序的组件和API很快就可以完成。关于小程序配置、组件、API的使用，可以在官网查看，这里主要拿手机web站（手机环球网）和小程序（环球网精选新闻）做个比较。\n\n首先需要注意的是，小程序作为微信下面的功能，不仅仅是提供了开发使用的组件、API等，另外还有一套设计。这套设计不是强制要求的，但是可以使得整个小程序给人更规范好用的感觉，所以开发前推荐大家好好阅读下这份[指南](https://mp.weixin.qq.com/debug/wxadoc/design/index.html?t=2017118)。\n\n#### Web三剑客\nWXML类似于HTML，可以称为一种模板引擎，包括数据绑定、循环、条件、复用等功能，标签数量减少，并提供了封装好的组件。标签数量的减少好处在于不需要记忆那么多标签，与HTML添加更多标签语义化相反，可能是因为小程序并不需要爬虫，并且可以保证能正常加载css吧（现在加载不到css的情况也确实很少发生）。  \nWXSS在CSS的功能上添加了一些适合微信（移动端）的尺寸，以及导入功能，选择器减少了一些，其他变化不大。  \nJS方面主要是不存在了DOM的操作等，这样就限制了很多功能的实现，使得小程序更加简洁、高性能。也就是几乎所有的JS里操作的都是数据，通过数据绑定再反应到页面上，这和现在流行的前端框架思路是一致的，只是小程序完全限制死了。\n\n#### 生命周期\n也是和几乎所有的前端框架一样，小程序也提供有生命周期，生命周期功能主要是为我们提供对程序干预的时机。这个功能是很重要的，通过生命周期监听程序不同时期，不需要提前将所有数据获取，也给了我们对数据在不同时期执行不同操作的机会。\n\n#### 用到的组件\n下拉刷新、无限加载功能的实现，小程序中配置一个回调函数即可完成，请求限流也不需要自己再去管理。轮播图使用了统一的样式，只需要一些数据和简单的配置项。  \n在手机环球网中的开发中，这些功能都是我重新造的轮子，好处在于我更清楚里面的实现，可以自己添加诸如延迟加载等功能，坏处是用了比较长的时间，性能方面也比较一般。  \n小程序中的组件就相当于别人造好的轮子，更加规范，也不需要花费时间去寻找，这样开发效率自然提升上去。问题是因为限制了JS对DOM的操作，只能使用小程序封装好的组件。\n\n#### 转义问题\n在开发环球网的小程序时，碰到的最大问题就是新闻详情页。新闻详情页样式不那么固定，图片、段落、加粗等位置不同，所以一般都是直接存储HTML字符串的，但是微信小程序中没有提供转义标签字符串的功能。  \n想到的解决方案是自己解析HTML字符串，转换成一段段内容保存在数组，再通过循环在WXML中输出，这样能解析的是块级元素，如果是行内元素可能需要在数据中再嵌套数组。  \n在github上有开源项目[wxParse](https://github.com/icindy/wxParse)，专门用来将HTML字符串转成小程序中的数据。  \n在wxParse中首先做得是将HTML字符串解析成类似于DOM树的对象,类似下面这样\n```JavaScript\n{\n \"node\": \"contents\",\n \"nodes\": [\n  {\n   \"node\": \"element\",\n   \"tag\": \"p\",\n   \"tagType\": \"block\",\n   \"nodes\": [\n    {\n     \"node\": \"element\",\n     \"tag\": \"img\",\n     \"tagType\": \"inline\",\n     \"attr\": {\n      \"src\": \"http://a1.huanqiu.cn/images/221f8e78dbee0f7446b2093b0d7b9502.jpg\"\n     },\n     \"imgIndex\": 0,\n     \"from\": \"contents\"\n    }\n   ]\n  },\n  {\n   \"node\": \"element\",\n   \"tag\": \"p\",\n   \"tagType\": \"block\",\n   \"nodes\": [\n    {\n     \"node\": \"text\",\n     \"text\": \"从黄土高坡到雪域高原，从西北边陲到云贵高原，他风雪兼程，几乎走遍全国14个集中连片特困地区。他对贫困群众念兹在兹、心有牵挂。\",\n     \"textArray\": [\n      {\n       \"node\": \"text\",\n       \"text\": \"从黄土高坡到雪域高原，从西北边陲到云贵高原，他风雪兼程，几乎走遍全国14个集中连片特困地区。他对贫困群众念兹在兹、心有牵挂。\"\n      }\n     ]\n    }\n   ]\n  }\n  ...\n}\n```\n然后通过循环判断，使用WXML中的模板和设置一定的样式模拟不同的HTML标签。  \nps：看小程序的开发Q&A，小程序应该是有计划添加对WXML中的合法标签的转义的。\n\n#### 总结\n小程序对界面和功能上都有很多限制，大多数情况下的都是对配置、组件、API的使用，以及直接对数据的操作。最重要的概念理解可能就是数据绑定，通过数据的修改反应到界面上，这也是目前大多数前端框架所用的方式，方便状态的维护。  \n对前端来说，小程序开发是简单的，不需要考虑兼容性问题，也不能封装需要修改DOM的组件。\n","source":"_posts/微信小程序初体验.md","raw":"---\ntitle: 微信小程序\ndate: 2017-05-23\ntags: [微信小程序, 项目经验]\ncategories:\n- JavaScript\ncomments: true\n---\n\n从微信小程序正式发布到现在已经过去了几个月了，发布前所有人仿佛发现了金矿的入口，早早地做好能做的一切准备等待着入口的开启，当所有人争前恐后地进入矿洞以后，收获却是寥寥无几。目前，我用过的小程序一个是开发者所用的小程序示例，一个是提供免费来推广的摩拜单车。  \n在小程序整体推广情况不容乐观的情况下，现在更多的开发应该属于防御性质的，毕竟小程序开发成本还是有很大优势的。（为了推广小程序，微信又提供了附近的小程序、与公众号关联等形式，但是在我感觉还是有些鸡肋。）\n\n这次环球网小程序的开发，页面包括两个tab页、两个新闻列表页和两种详情页，功能简单，熟悉小程序的组件和API很快就可以完成。关于小程序配置、组件、API的使用，可以在官网查看，这里主要拿手机web站（手机环球网）和小程序（环球网精选新闻）做个比较。\n\n首先需要注意的是，小程序作为微信下面的功能，不仅仅是提供了开发使用的组件、API等，另外还有一套设计。这套设计不是强制要求的，但是可以使得整个小程序给人更规范好用的感觉，所以开发前推荐大家好好阅读下这份[指南](https://mp.weixin.qq.com/debug/wxadoc/design/index.html?t=2017118)。\n\n#### Web三剑客\nWXML类似于HTML，可以称为一种模板引擎，包括数据绑定、循环、条件、复用等功能，标签数量减少，并提供了封装好的组件。标签数量的减少好处在于不需要记忆那么多标签，与HTML添加更多标签语义化相反，可能是因为小程序并不需要爬虫，并且可以保证能正常加载css吧（现在加载不到css的情况也确实很少发生）。  \nWXSS在CSS的功能上添加了一些适合微信（移动端）的尺寸，以及导入功能，选择器减少了一些，其他变化不大。  \nJS方面主要是不存在了DOM的操作等，这样就限制了很多功能的实现，使得小程序更加简洁、高性能。也就是几乎所有的JS里操作的都是数据，通过数据绑定再反应到页面上，这和现在流行的前端框架思路是一致的，只是小程序完全限制死了。\n\n#### 生命周期\n也是和几乎所有的前端框架一样，小程序也提供有生命周期，生命周期功能主要是为我们提供对程序干预的时机。这个功能是很重要的，通过生命周期监听程序不同时期，不需要提前将所有数据获取，也给了我们对数据在不同时期执行不同操作的机会。\n\n#### 用到的组件\n下拉刷新、无限加载功能的实现，小程序中配置一个回调函数即可完成，请求限流也不需要自己再去管理。轮播图使用了统一的样式，只需要一些数据和简单的配置项。  \n在手机环球网中的开发中，这些功能都是我重新造的轮子，好处在于我更清楚里面的实现，可以自己添加诸如延迟加载等功能，坏处是用了比较长的时间，性能方面也比较一般。  \n小程序中的组件就相当于别人造好的轮子，更加规范，也不需要花费时间去寻找，这样开发效率自然提升上去。问题是因为限制了JS对DOM的操作，只能使用小程序封装好的组件。\n\n#### 转义问题\n在开发环球网的小程序时，碰到的最大问题就是新闻详情页。新闻详情页样式不那么固定，图片、段落、加粗等位置不同，所以一般都是直接存储HTML字符串的，但是微信小程序中没有提供转义标签字符串的功能。  \n想到的解决方案是自己解析HTML字符串，转换成一段段内容保存在数组，再通过循环在WXML中输出，这样能解析的是块级元素，如果是行内元素可能需要在数据中再嵌套数组。  \n在github上有开源项目[wxParse](https://github.com/icindy/wxParse)，专门用来将HTML字符串转成小程序中的数据。  \n在wxParse中首先做得是将HTML字符串解析成类似于DOM树的对象,类似下面这样\n```JavaScript\n{\n \"node\": \"contents\",\n \"nodes\": [\n  {\n   \"node\": \"element\",\n   \"tag\": \"p\",\n   \"tagType\": \"block\",\n   \"nodes\": [\n    {\n     \"node\": \"element\",\n     \"tag\": \"img\",\n     \"tagType\": \"inline\",\n     \"attr\": {\n      \"src\": \"http://a1.huanqiu.cn/images/221f8e78dbee0f7446b2093b0d7b9502.jpg\"\n     },\n     \"imgIndex\": 0,\n     \"from\": \"contents\"\n    }\n   ]\n  },\n  {\n   \"node\": \"element\",\n   \"tag\": \"p\",\n   \"tagType\": \"block\",\n   \"nodes\": [\n    {\n     \"node\": \"text\",\n     \"text\": \"从黄土高坡到雪域高原，从西北边陲到云贵高原，他风雪兼程，几乎走遍全国14个集中连片特困地区。他对贫困群众念兹在兹、心有牵挂。\",\n     \"textArray\": [\n      {\n       \"node\": \"text\",\n       \"text\": \"从黄土高坡到雪域高原，从西北边陲到云贵高原，他风雪兼程，几乎走遍全国14个集中连片特困地区。他对贫困群众念兹在兹、心有牵挂。\"\n      }\n     ]\n    }\n   ]\n  }\n  ...\n}\n```\n然后通过循环判断，使用WXML中的模板和设置一定的样式模拟不同的HTML标签。  \nps：看小程序的开发Q&A，小程序应该是有计划添加对WXML中的合法标签的转义的。\n\n#### 总结\n小程序对界面和功能上都有很多限制，大多数情况下的都是对配置、组件、API的使用，以及直接对数据的操作。最重要的概念理解可能就是数据绑定，通过数据的修改反应到界面上，这也是目前大多数前端框架所用的方式，方便状态的维护。  \n对前端来说，小程序开发是简单的，不需要考虑兼容性问题，也不能封装需要修改DOM的组件。\n","slug":"微信小程序初体验","published":1,"updated":"2017-12-28T03:47:32.467Z","layout":"post","photos":[],"link":"","_id":"cjks5i9j6003ovmtid6dme1xx","content":"<p>从微信小程序正式发布到现在已经过去了几个月了，发布前所有人仿佛发现了金矿的入口，早早地做好能做的一切准备等待着入口的开启，当所有人争前恐后地进入矿洞以后，收获却是寥寥无几。目前，我用过的小程序一个是开发者所用的小程序示例，一个是提供免费来推广的摩拜单车。<br>在小程序整体推广情况不容乐观的情况下，现在更多的开发应该属于防御性质的，毕竟小程序开发成本还是有很大优势的。（为了推广小程序，微信又提供了附近的小程序、与公众号关联等形式，但是在我感觉还是有些鸡肋。）</p>\n<p>这次环球网小程序的开发，页面包括两个tab页、两个新闻列表页和两种详情页，功能简单，熟悉小程序的组件和API很快就可以完成。关于小程序配置、组件、API的使用，可以在官网查看，这里主要拿手机web站（手机环球网）和小程序（环球网精选新闻）做个比较。</p>\n<p>首先需要注意的是，小程序作为微信下面的功能，不仅仅是提供了开发使用的组件、API等，另外还有一套设计。这套设计不是强制要求的，但是可以使得整个小程序给人更规范好用的感觉，所以开发前推荐大家好好阅读下这份<a href=\"https://mp.weixin.qq.com/debug/wxadoc/design/index.html?t=2017118\" target=\"_blank\" rel=\"noopener\">指南</a>。</p>\n<h4 id=\"Web三剑客\"><a href=\"#Web三剑客\" class=\"headerlink\" title=\"Web三剑客\"></a>Web三剑客</h4><p>WXML类似于HTML，可以称为一种模板引擎，包括数据绑定、循环、条件、复用等功能，标签数量减少，并提供了封装好的组件。标签数量的减少好处在于不需要记忆那么多标签，与HTML添加更多标签语义化相反，可能是因为小程序并不需要爬虫，并且可以保证能正常加载css吧（现在加载不到css的情况也确实很少发生）。<br>WXSS在CSS的功能上添加了一些适合微信（移动端）的尺寸，以及导入功能，选择器减少了一些，其他变化不大。<br>JS方面主要是不存在了DOM的操作等，这样就限制了很多功能的实现，使得小程序更加简洁、高性能。也就是几乎所有的JS里操作的都是数据，通过数据绑定再反应到页面上，这和现在流行的前端框架思路是一致的，只是小程序完全限制死了。</p>\n<h4 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h4><p>也是和几乎所有的前端框架一样，小程序也提供有生命周期，生命周期功能主要是为我们提供对程序干预的时机。这个功能是很重要的，通过生命周期监听程序不同时期，不需要提前将所有数据获取，也给了我们对数据在不同时期执行不同操作的机会。</p>\n<h4 id=\"用到的组件\"><a href=\"#用到的组件\" class=\"headerlink\" title=\"用到的组件\"></a>用到的组件</h4><p>下拉刷新、无限加载功能的实现，小程序中配置一个回调函数即可完成，请求限流也不需要自己再去管理。轮播图使用了统一的样式，只需要一些数据和简单的配置项。<br>在手机环球网中的开发中，这些功能都是我重新造的轮子，好处在于我更清楚里面的实现，可以自己添加诸如延迟加载等功能，坏处是用了比较长的时间，性能方面也比较一般。<br>小程序中的组件就相当于别人造好的轮子，更加规范，也不需要花费时间去寻找，这样开发效率自然提升上去。问题是因为限制了JS对DOM的操作，只能使用小程序封装好的组件。</p>\n<h4 id=\"转义问题\"><a href=\"#转义问题\" class=\"headerlink\" title=\"转义问题\"></a>转义问题</h4><p>在开发环球网的小程序时，碰到的最大问题就是新闻详情页。新闻详情页样式不那么固定，图片、段落、加粗等位置不同，所以一般都是直接存储HTML字符串的，但是微信小程序中没有提供转义标签字符串的功能。<br>想到的解决方案是自己解析HTML字符串，转换成一段段内容保存在数组，再通过循环在WXML中输出，这样能解析的是块级元素，如果是行内元素可能需要在数据中再嵌套数组。<br>在github上有开源项目<a href=\"https://github.com/icindy/wxParse\" target=\"_blank\" rel=\"noopener\">wxParse</a>，专门用来将HTML字符串转成小程序中的数据。<br>在wxParse中首先做得是将HTML字符串解析成类似于DOM树的对象,类似下面这样<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"string\">\"node\"</span>: <span class=\"string\">\"contents\"</span>,</span><br><span class=\"line\"> <span class=\"string\">\"nodes\"</span>: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"string\">\"node\"</span>: <span class=\"string\">\"element\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"tag\"</span>: <span class=\"string\">\"p\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"tagType\"</span>: <span class=\"string\">\"block\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"nodes\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     <span class=\"string\">\"node\"</span>: <span class=\"string\">\"element\"</span>,</span><br><span class=\"line\">     <span class=\"string\">\"tag\"</span>: <span class=\"string\">\"img\"</span>,</span><br><span class=\"line\">     <span class=\"string\">\"tagType\"</span>: <span class=\"string\">\"inline\"</span>,</span><br><span class=\"line\">     <span class=\"string\">\"attr\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"src\"</span>: <span class=\"string\">\"http://a1.huanqiu.cn/images/221f8e78dbee0f7446b2093b0d7b9502.jpg\"</span></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     <span class=\"string\">\"imgIndex\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">     <span class=\"string\">\"from\"</span>: <span class=\"string\">\"contents\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"string\">\"node\"</span>: <span class=\"string\">\"element\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"tag\"</span>: <span class=\"string\">\"p\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"tagType\"</span>: <span class=\"string\">\"block\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"nodes\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     <span class=\"string\">\"node\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">     <span class=\"string\">\"text\"</span>: <span class=\"string\">\"从黄土高坡到雪域高原，从西北边陲到云贵高原，他风雪兼程，几乎走遍全国14个集中连片特困地区。他对贫困群众念兹在兹、心有牵挂。\"</span>,</span><br><span class=\"line\">     <span class=\"string\">\"textArray\"</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">       <span class=\"string\">\"node\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">       <span class=\"string\">\"text\"</span>: <span class=\"string\">\"从黄土高坡到雪域高原，从西北边陲到云贵高原，他风雪兼程，几乎走遍全国14个集中连片特困地区。他对贫困群众念兹在兹、心有牵挂。\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">     ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后通过循环判断，使用WXML中的模板和设置一定的样式模拟不同的HTML标签。<br>ps：看小程序的开发Q&amp;A，小程序应该是有计划添加对WXML中的合法标签的转义的。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>小程序对界面和功能上都有很多限制，大多数情况下的都是对配置、组件、API的使用，以及直接对数据的操作。最重要的概念理解可能就是数据绑定，通过数据的修改反应到界面上，这也是目前大多数前端框架所用的方式，方便状态的维护。<br>对前端来说，小程序开发是简单的，不需要考虑兼容性问题，也不能封装需要修改DOM的组件。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>从微信小程序正式发布到现在已经过去了几个月了，发布前所有人仿佛发现了金矿的入口，早早地做好能做的一切准备等待着入口的开启，当所有人争前恐后地进入矿洞以后，收获却是寥寥无几。目前，我用过的小程序一个是开发者所用的小程序示例，一个是提供免费来推广的摩拜单车。<br>在小程序整体推广情况不容乐观的情况下，现在更多的开发应该属于防御性质的，毕竟小程序开发成本还是有很大优势的。（为了推广小程序，微信又提供了附近的小程序、与公众号关联等形式，但是在我感觉还是有些鸡肋。）</p>\n<p>这次环球网小程序的开发，页面包括两个tab页、两个新闻列表页和两种详情页，功能简单，熟悉小程序的组件和API很快就可以完成。关于小程序配置、组件、API的使用，可以在官网查看，这里主要拿手机web站（手机环球网）和小程序（环球网精选新闻）做个比较。</p>\n<p>首先需要注意的是，小程序作为微信下面的功能，不仅仅是提供了开发使用的组件、API等，另外还有一套设计。这套设计不是强制要求的，但是可以使得整个小程序给人更规范好用的感觉，所以开发前推荐大家好好阅读下这份<a href=\"https://mp.weixin.qq.com/debug/wxadoc/design/index.html?t=2017118\" target=\"_blank\" rel=\"noopener\">指南</a>。</p>\n<h4 id=\"Web三剑客\"><a href=\"#Web三剑客\" class=\"headerlink\" title=\"Web三剑客\"></a>Web三剑客</h4><p>WXML类似于HTML，可以称为一种模板引擎，包括数据绑定、循环、条件、复用等功能，标签数量减少，并提供了封装好的组件。标签数量的减少好处在于不需要记忆那么多标签，与HTML添加更多标签语义化相反，可能是因为小程序并不需要爬虫，并且可以保证能正常加载css吧（现在加载不到css的情况也确实很少发生）。<br>WXSS在CSS的功能上添加了一些适合微信（移动端）的尺寸，以及导入功能，选择器减少了一些，其他变化不大。<br>JS方面主要是不存在了DOM的操作等，这样就限制了很多功能的实现，使得小程序更加简洁、高性能。也就是几乎所有的JS里操作的都是数据，通过数据绑定再反应到页面上，这和现在流行的前端框架思路是一致的，只是小程序完全限制死了。</p>\n<h4 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h4><p>也是和几乎所有的前端框架一样，小程序也提供有生命周期，生命周期功能主要是为我们提供对程序干预的时机。这个功能是很重要的，通过生命周期监听程序不同时期，不需要提前将所有数据获取，也给了我们对数据在不同时期执行不同操作的机会。</p>\n<h4 id=\"用到的组件\"><a href=\"#用到的组件\" class=\"headerlink\" title=\"用到的组件\"></a>用到的组件</h4><p>下拉刷新、无限加载功能的实现，小程序中配置一个回调函数即可完成，请求限流也不需要自己再去管理。轮播图使用了统一的样式，只需要一些数据和简单的配置项。<br>在手机环球网中的开发中，这些功能都是我重新造的轮子，好处在于我更清楚里面的实现，可以自己添加诸如延迟加载等功能，坏处是用了比较长的时间，性能方面也比较一般。<br>小程序中的组件就相当于别人造好的轮子，更加规范，也不需要花费时间去寻找，这样开发效率自然提升上去。问题是因为限制了JS对DOM的操作，只能使用小程序封装好的组件。</p>\n<h4 id=\"转义问题\"><a href=\"#转义问题\" class=\"headerlink\" title=\"转义问题\"></a>转义问题</h4><p>在开发环球网的小程序时，碰到的最大问题就是新闻详情页。新闻详情页样式不那么固定，图片、段落、加粗等位置不同，所以一般都是直接存储HTML字符串的，但是微信小程序中没有提供转义标签字符串的功能。<br>想到的解决方案是自己解析HTML字符串，转换成一段段内容保存在数组，再通过循环在WXML中输出，这样能解析的是块级元素，如果是行内元素可能需要在数据中再嵌套数组。<br>在github上有开源项目<a href=\"https://github.com/icindy/wxParse\" target=\"_blank\" rel=\"noopener\">wxParse</a>，专门用来将HTML字符串转成小程序中的数据。<br>在wxParse中首先做得是将HTML字符串解析成类似于DOM树的对象,类似下面这样<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"string\">\"node\"</span>: <span class=\"string\">\"contents\"</span>,</span><br><span class=\"line\"> <span class=\"string\">\"nodes\"</span>: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"string\">\"node\"</span>: <span class=\"string\">\"element\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"tag\"</span>: <span class=\"string\">\"p\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"tagType\"</span>: <span class=\"string\">\"block\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"nodes\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     <span class=\"string\">\"node\"</span>: <span class=\"string\">\"element\"</span>,</span><br><span class=\"line\">     <span class=\"string\">\"tag\"</span>: <span class=\"string\">\"img\"</span>,</span><br><span class=\"line\">     <span class=\"string\">\"tagType\"</span>: <span class=\"string\">\"inline\"</span>,</span><br><span class=\"line\">     <span class=\"string\">\"attr\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"src\"</span>: <span class=\"string\">\"http://a1.huanqiu.cn/images/221f8e78dbee0f7446b2093b0d7b9502.jpg\"</span></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     <span class=\"string\">\"imgIndex\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">     <span class=\"string\">\"from\"</span>: <span class=\"string\">\"contents\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"string\">\"node\"</span>: <span class=\"string\">\"element\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"tag\"</span>: <span class=\"string\">\"p\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"tagType\"</span>: <span class=\"string\">\"block\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"nodes\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     <span class=\"string\">\"node\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">     <span class=\"string\">\"text\"</span>: <span class=\"string\">\"从黄土高坡到雪域高原，从西北边陲到云贵高原，他风雪兼程，几乎走遍全国14个集中连片特困地区。他对贫困群众念兹在兹、心有牵挂。\"</span>,</span><br><span class=\"line\">     <span class=\"string\">\"textArray\"</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">       <span class=\"string\">\"node\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">       <span class=\"string\">\"text\"</span>: <span class=\"string\">\"从黄土高坡到雪域高原，从西北边陲到云贵高原，他风雪兼程，几乎走遍全国14个集中连片特困地区。他对贫困群众念兹在兹、心有牵挂。\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">     ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后通过循环判断，使用WXML中的模板和设置一定的样式模拟不同的HTML标签。<br>ps：看小程序的开发Q&amp;A，小程序应该是有计划添加对WXML中的合法标签的转义的。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>小程序对界面和功能上都有很多限制，大多数情况下的都是对配置、组件、API的使用，以及直接对数据的操作。最重要的概念理解可能就是数据绑定，通过数据的修改反应到界面上，这也是目前大多数前端框架所用的方式，方便状态的维护。<br>对前端来说，小程序开发是简单的，不需要考虑兼容性问题，也不能封装需要修改DOM的组件。</p>\n"},{"title":"我的第一个Hexo博客","date":"2016-06-09T14:11:35.000Z","_content":"\n  希望自己以后能在这个博客里，留下自己成长的点滴，不管之后会获得什么样的工作，不管以后时间是怎样。\n","source":"_posts/我的首个Hexo博客.md","raw":"---\ntitle: 我的第一个Hexo博客\ndate: 2016-06-09 22:11:35\ntags: \ncategories: \n- 杂记\n---\n\n  希望自己以后能在这个博客里，留下自己成长的点滴，不管之后会获得什么样的工作，不管以后时间是怎样。\n","slug":"我的首个Hexo博客","published":1,"updated":"2017-12-28T03:47:32.467Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjks5i9j8003rvmti5tx27sgr","content":"<p>  希望自己以后能在这个博客里，留下自己成长的点滴，不管之后会获得什么样的工作，不管以后时间是怎样。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>  希望自己以后能在这个博客里，留下自己成长的点滴，不管之后会获得什么样的工作，不管以后时间是怎样。</p>\n"},{"title":"批量移动QQ邮箱文件夹","date":"2017-03-13T16:00:00.000Z","comments":1,"_content":"\n在使用QQ企业邮箱中，设置了错误的收件规则，导致收件箱所有邮件移动到了自定义文件夹中。手动去移回这些邮件，没有找到响应的批量处理，一次只能移动一页，这样下来有170+页，是个麻烦事。\n\n第一个想到的方法是查看API，发现每次移动调用的参数是这样的\n```\n&location=mail_list\n\n&mailid=ZC0513-BHmnKHGM8D_6qBtDH4Lae7f\n&mailid=ZL0513-ss~T6rNM2RbTpRZO~VGRf7f\n... ...\n&mailid=ZL0514-l~qc1YzCN_g_zX4mtbd3B7f\n\n&mailaction=mail_move\n\n&destfolderid=1\n\n&t=mail_mgr2\n\n&resp_charset=UTF8\n\n&ef=js\n\n&sid=-IELu_LevHO0lyR8,2\n```\n试着调用一次，发现失败了。为了节约时间，采用了模拟点击的方法来实现批量移动。\n\n我们要实现的功能挺简单的，点击全选按钮，触发移动到里面的收件箱按钮。  \nQQ邮箱网页版是多个iframe嵌套实现的，也正是因为这样的iframe嵌套结构，使我们能够在邮件再次加载的时候我们的js代码还存在环境中，(这样是不是意味着对某个网页进行批量操作时，操作如果会刷新页面，可以使用iframe嵌套来创造程序运行的环境呢？)我们用的到主要是邮件这个ifame。  \niframe的操作主要包括一个top，一个parent。每个iframe相当于一个window对象，通过iframe的name可以访问响应的iframe。在chrome浏览器的console中是可以切换当前代码在哪个iframe下执行的。![iframe](/images/iframe.png)  \n我们需要操作iframe位于mainFrame中，如果将执行代码放在mainFrame中\n```JavaScript\nfunction move () {\n    window.getTop().selectAll(true,document);getTop().checkAll('mailid',document);\n    document.querySelectorAll('#selmContainer')[1].querySelector('.txtflow').click()\n    document.querySelector('[title=' + folder + ']').click()\n  }\n```\n这样在每次移动邮件后，mainFrame重新加载，move函数就会丢失，我们无法使用循环来实现。所以可以将执行代码放在top中，所有的window、document都需要指定为mainFrame下的window和document。\n```JavaScript\n\nfunction moveMail (folder, pages) {\n  function move () {\n    mainFrame.window.getTop().selectAll(true,mainFrame.document);getTop().checkAll('mailid',mainFrame.document);\n    mainFrame.document.querySelectorAll('#selmContainer')[1].querySelector('.txtflow').click()\n    mainFrame.document.querySelector('[title=' + folder + ']').click()\n  }\n\n  for(var i = 0; i < pages; i++) {\n    setTimeout(move, (i + 1) * 3000);\n  }\n}\n```\nps:  mainFrame.window === mainFrame\n","source":"_posts/批量移动QQ邮箱文件夹.md","raw":"---\ntitle: 批量移动QQ邮箱文件夹\ndate: 2017-03-14\ntags: JavaScript\ncategories:\n- JavaScript\ncomments: true\n---\n\n在使用QQ企业邮箱中，设置了错误的收件规则，导致收件箱所有邮件移动到了自定义文件夹中。手动去移回这些邮件，没有找到响应的批量处理，一次只能移动一页，这样下来有170+页，是个麻烦事。\n\n第一个想到的方法是查看API，发现每次移动调用的参数是这样的\n```\n&location=mail_list\n\n&mailid=ZC0513-BHmnKHGM8D_6qBtDH4Lae7f\n&mailid=ZL0513-ss~T6rNM2RbTpRZO~VGRf7f\n... ...\n&mailid=ZL0514-l~qc1YzCN_g_zX4mtbd3B7f\n\n&mailaction=mail_move\n\n&destfolderid=1\n\n&t=mail_mgr2\n\n&resp_charset=UTF8\n\n&ef=js\n\n&sid=-IELu_LevHO0lyR8,2\n```\n试着调用一次，发现失败了。为了节约时间，采用了模拟点击的方法来实现批量移动。\n\n我们要实现的功能挺简单的，点击全选按钮，触发移动到里面的收件箱按钮。  \nQQ邮箱网页版是多个iframe嵌套实现的，也正是因为这样的iframe嵌套结构，使我们能够在邮件再次加载的时候我们的js代码还存在环境中，(这样是不是意味着对某个网页进行批量操作时，操作如果会刷新页面，可以使用iframe嵌套来创造程序运行的环境呢？)我们用的到主要是邮件这个ifame。  \niframe的操作主要包括一个top，一个parent。每个iframe相当于一个window对象，通过iframe的name可以访问响应的iframe。在chrome浏览器的console中是可以切换当前代码在哪个iframe下执行的。![iframe](/images/iframe.png)  \n我们需要操作iframe位于mainFrame中，如果将执行代码放在mainFrame中\n```JavaScript\nfunction move () {\n    window.getTop().selectAll(true,document);getTop().checkAll('mailid',document);\n    document.querySelectorAll('#selmContainer')[1].querySelector('.txtflow').click()\n    document.querySelector('[title=' + folder + ']').click()\n  }\n```\n这样在每次移动邮件后，mainFrame重新加载，move函数就会丢失，我们无法使用循环来实现。所以可以将执行代码放在top中，所有的window、document都需要指定为mainFrame下的window和document。\n```JavaScript\n\nfunction moveMail (folder, pages) {\n  function move () {\n    mainFrame.window.getTop().selectAll(true,mainFrame.document);getTop().checkAll('mailid',mainFrame.document);\n    mainFrame.document.querySelectorAll('#selmContainer')[1].querySelector('.txtflow').click()\n    mainFrame.document.querySelector('[title=' + folder + ']').click()\n  }\n\n  for(var i = 0; i < pages; i++) {\n    setTimeout(move, (i + 1) * 3000);\n  }\n}\n```\nps:  mainFrame.window === mainFrame\n","slug":"批量移动QQ邮箱文件夹","published":1,"updated":"2018-01-04T10:00:37.762Z","layout":"post","photos":[],"link":"","_id":"cjks5i9ja003vvmtiugxqc12l","content":"<p>在使用QQ企业邮箱中，设置了错误的收件规则，导致收件箱所有邮件移动到了自定义文件夹中。手动去移回这些邮件，没有找到响应的批量处理，一次只能移动一页，这样下来有170+页，是个麻烦事。</p>\n<p>第一个想到的方法是查看API，发现每次移动调用的参数是这样的<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;<span class=\"attribute\">location</span>=mail_list</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;<span class=\"attribute\">mailid</span>=ZC0513-BHmnKHGM8D_6qBtDH4Lae7f</span><br><span class=\"line\">&amp;<span class=\"attribute\">mailid</span>=ZL0513-ss~T6rNM2RbTpRZO~VGRf7f</span><br><span class=\"line\"><span class=\"built_in\">..</span>. <span class=\"built_in\">..</span>.</span><br><span class=\"line\">&amp;<span class=\"attribute\">mailid</span>=ZL0514-l~qc1YzCN_g_zX4mtbd3B7f</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;<span class=\"attribute\">mailaction</span>=mail_move</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;<span class=\"attribute\">destfolderid</span>=1</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;<span class=\"attribute\">t</span>=mail_mgr2</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;<span class=\"attribute\">resp_charset</span>=UTF8</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;<span class=\"attribute\">ef</span>=js</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;<span class=\"attribute\">sid</span>=-IELu_LevHO0lyR8,2</span><br></pre></td></tr></table></figure></p>\n<p>试着调用一次，发现失败了。为了节约时间，采用了模拟点击的方法来实现批量移动。</p>\n<p>我们要实现的功能挺简单的，点击全选按钮，触发移动到里面的收件箱按钮。<br>QQ邮箱网页版是多个iframe嵌套实现的，也正是因为这样的iframe嵌套结构，使我们能够在邮件再次加载的时候我们的js代码还存在环境中，(这样是不是意味着对某个网页进行批量操作时，操作如果会刷新页面，可以使用iframe嵌套来创造程序运行的环境呢？)我们用的到主要是邮件这个ifame。<br>iframe的操作主要包括一个top，一个parent。每个iframe相当于一个window对象，通过iframe的name可以访问响应的iframe。在chrome浏览器的console中是可以切换当前代码在哪个iframe下执行的。<img src=\"/images/iframe.png\" alt=\"iframe\"><br>我们需要操作iframe位于mainFrame中，如果将执行代码放在mainFrame中<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">move</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.getTop().selectAll(<span class=\"literal\">true</span>,<span class=\"built_in\">document</span>);getTop().checkAll(<span class=\"string\">'mailid'</span>,<span class=\"built_in\">document</span>);</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'#selmContainer'</span>)[<span class=\"number\">1</span>].querySelector(<span class=\"string\">'.txtflow'</span>).click()</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'[title='</span> + folder + <span class=\"string\">']'</span>).click()</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样在每次移动邮件后，mainFrame重新加载，move函数就会丢失，我们无法使用循环来实现。所以可以将执行代码放在top中，所有的window、document都需要指定为mainFrame下的window和document。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">moveMail</span> (<span class=\"params\">folder, pages</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">move</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    mainFrame.window.getTop().selectAll(<span class=\"literal\">true</span>,mainFrame.document);getTop().checkAll(<span class=\"string\">'mailid'</span>,mainFrame.document);</span><br><span class=\"line\">    mainFrame.document.querySelectorAll(<span class=\"string\">'#selmContainer'</span>)[<span class=\"number\">1</span>].querySelector(<span class=\"string\">'.txtflow'</span>).click()</span><br><span class=\"line\">    mainFrame.document.querySelector(<span class=\"string\">'[title='</span> + folder + <span class=\"string\">']'</span>).click()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; pages; i++) &#123;</span><br><span class=\"line\">    setTimeout(move, (i + <span class=\"number\">1</span>) * <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ps:  mainFrame.window === mainFrame</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在使用QQ企业邮箱中，设置了错误的收件规则，导致收件箱所有邮件移动到了自定义文件夹中。手动去移回这些邮件，没有找到响应的批量处理，一次只能移动一页，这样下来有170+页，是个麻烦事。</p>\n<p>第一个想到的方法是查看API，发现每次移动调用的参数是这样的<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;<span class=\"attribute\">location</span>=mail_list</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;<span class=\"attribute\">mailid</span>=ZC0513-BHmnKHGM8D_6qBtDH4Lae7f</span><br><span class=\"line\">&amp;<span class=\"attribute\">mailid</span>=ZL0513-ss~T6rNM2RbTpRZO~VGRf7f</span><br><span class=\"line\"><span class=\"built_in\">..</span>. <span class=\"built_in\">..</span>.</span><br><span class=\"line\">&amp;<span class=\"attribute\">mailid</span>=ZL0514-l~qc1YzCN_g_zX4mtbd3B7f</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;<span class=\"attribute\">mailaction</span>=mail_move</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;<span class=\"attribute\">destfolderid</span>=1</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;<span class=\"attribute\">t</span>=mail_mgr2</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;<span class=\"attribute\">resp_charset</span>=UTF8</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;<span class=\"attribute\">ef</span>=js</span><br><span class=\"line\"></span><br><span class=\"line\">&amp;<span class=\"attribute\">sid</span>=-IELu_LevHO0lyR8,2</span><br></pre></td></tr></table></figure></p>\n<p>试着调用一次，发现失败了。为了节约时间，采用了模拟点击的方法来实现批量移动。</p>\n<p>我们要实现的功能挺简单的，点击全选按钮，触发移动到里面的收件箱按钮。<br>QQ邮箱网页版是多个iframe嵌套实现的，也正是因为这样的iframe嵌套结构，使我们能够在邮件再次加载的时候我们的js代码还存在环境中，(这样是不是意味着对某个网页进行批量操作时，操作如果会刷新页面，可以使用iframe嵌套来创造程序运行的环境呢？)我们用的到主要是邮件这个ifame。<br>iframe的操作主要包括一个top，一个parent。每个iframe相当于一个window对象，通过iframe的name可以访问响应的iframe。在chrome浏览器的console中是可以切换当前代码在哪个iframe下执行的。<img src=\"/images/iframe.png\" alt=\"iframe\"><br>我们需要操作iframe位于mainFrame中，如果将执行代码放在mainFrame中<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">move</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.getTop().selectAll(<span class=\"literal\">true</span>,<span class=\"built_in\">document</span>);getTop().checkAll(<span class=\"string\">'mailid'</span>,<span class=\"built_in\">document</span>);</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'#selmContainer'</span>)[<span class=\"number\">1</span>].querySelector(<span class=\"string\">'.txtflow'</span>).click()</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'[title='</span> + folder + <span class=\"string\">']'</span>).click()</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样在每次移动邮件后，mainFrame重新加载，move函数就会丢失，我们无法使用循环来实现。所以可以将执行代码放在top中，所有的window、document都需要指定为mainFrame下的window和document。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">moveMail</span> (<span class=\"params\">folder, pages</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">move</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    mainFrame.window.getTop().selectAll(<span class=\"literal\">true</span>,mainFrame.document);getTop().checkAll(<span class=\"string\">'mailid'</span>,mainFrame.document);</span><br><span class=\"line\">    mainFrame.document.querySelectorAll(<span class=\"string\">'#selmContainer'</span>)[<span class=\"number\">1</span>].querySelector(<span class=\"string\">'.txtflow'</span>).click()</span><br><span class=\"line\">    mainFrame.document.querySelector(<span class=\"string\">'[title='</span> + folder + <span class=\"string\">']'</span>).click()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; pages; i++) &#123;</span><br><span class=\"line\">    setTimeout(move, (i + <span class=\"number\">1</span>) * <span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ps:  mainFrame.window === mainFrame</p>\n"},{"title":"移动端input光标问题","date":"2018-01-03T16:00:00.000Z","comments":1,"_content":"\n碰到个比较奇怪的问题\n\n需求是input按344格式填写手机号，就像这样1** **** ****\n\n首先，input通过设置`type=\"number\"`或`type=\"tel\"`，以及`pattern=\"[0-9]\"`可以实现调起键盘为数字键盘。\n\n之后就是处理格式问题，移动端可以直接监听input事件，对输入进行替换。\n\n```JavaScript\n// 将非数字全部替换掉\nlet phone = $mobileI.val()\nphone = phone.replace(/[^0-9]/g, '')\n// 分组成344，并且加上' '\nvar temp = []\ntemp[0] = phone.slice(0, 3)\ntemp[1] = phone.slice(3, 7)\ntemp[2] = phone.slice(7)\nif (temp[2].length > 0) {\n  temp[1] += ' '\n  temp[0] += ' '\n} else if (temp[1].length > 0) {\n  temp[0] += ' '\n}\n// 将格式化好的手机号填入输入框\n$mobileI.val(temp.join(''))\n```\n\n在移动端却会出现问题，在添加空格的情况下，光标会在最后一个字母前面。\n\n![光标位置](/images/input_phone.jpg)\n\n通过selectionStart获取光标没有问题，通过设置selectionStart也没办法解决问题。\n\n经过一系列测试，发现如果使用keyup事件调用，并不会出现这种情况，使用input事件才会这样。并且如果使用input事件调用，在keyup中检查selectionStart属性，会发现比keyup中的值小。所以这应该是移动端浏览器的bug。\n\n我自己手机发现安卓下，chrome、UC、夸克都会有这个问题，QQ浏览器正常。\n\n解决办法，input改为keyup，或者通过setTimeout将$mobileI赋值改成异步等方法。\n","source":"_posts/移动端input光标问题.md","raw":"---\ntitle: 移动端input光标问题\ndate: 2018-01-04\ntags: JavaScript\ncategories:\n- JavaScript\ncomments: true\n---\n\n碰到个比较奇怪的问题\n\n需求是input按344格式填写手机号，就像这样1** **** ****\n\n首先，input通过设置`type=\"number\"`或`type=\"tel\"`，以及`pattern=\"[0-9]\"`可以实现调起键盘为数字键盘。\n\n之后就是处理格式问题，移动端可以直接监听input事件，对输入进行替换。\n\n```JavaScript\n// 将非数字全部替换掉\nlet phone = $mobileI.val()\nphone = phone.replace(/[^0-9]/g, '')\n// 分组成344，并且加上' '\nvar temp = []\ntemp[0] = phone.slice(0, 3)\ntemp[1] = phone.slice(3, 7)\ntemp[2] = phone.slice(7)\nif (temp[2].length > 0) {\n  temp[1] += ' '\n  temp[0] += ' '\n} else if (temp[1].length > 0) {\n  temp[0] += ' '\n}\n// 将格式化好的手机号填入输入框\n$mobileI.val(temp.join(''))\n```\n\n在移动端却会出现问题，在添加空格的情况下，光标会在最后一个字母前面。\n\n![光标位置](/images/input_phone.jpg)\n\n通过selectionStart获取光标没有问题，通过设置selectionStart也没办法解决问题。\n\n经过一系列测试，发现如果使用keyup事件调用，并不会出现这种情况，使用input事件才会这样。并且如果使用input事件调用，在keyup中检查selectionStart属性，会发现比keyup中的值小。所以这应该是移动端浏览器的bug。\n\n我自己手机发现安卓下，chrome、UC、夸克都会有这个问题，QQ浏览器正常。\n\n解决办法，input改为keyup，或者通过setTimeout将$mobileI赋值改成异步等方法。\n","slug":"移动端input光标问题","published":1,"updated":"2018-01-04T09:59:51.167Z","layout":"post","photos":[],"link":"","_id":"cjks5i9jb003yvmti1rn4s893","content":"<p>碰到个比较奇怪的问题</p>\n<p>需求是input按344格式填写手机号，就像这样1<strong> **</strong> <em>**</em></p>\n<p>首先，input通过设置<code>type=&quot;number&quot;</code>或<code>type=&quot;tel&quot;</code>，以及<code>pattern=&quot;[0-9]&quot;</code>可以实现调起键盘为数字键盘。</p>\n<p>之后就是处理格式问题，移动端可以直接监听input事件，对输入进行替换。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将非数字全部替换掉</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> phone = $mobileI.val()</span><br><span class=\"line\">phone = phone.replace(<span class=\"regexp\">/[^0-9]/g</span>, <span class=\"string\">''</span>)</span><br><span class=\"line\"><span class=\"comment\">// 分组成344，并且加上' '</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> temp = []</span><br><span class=\"line\">temp[<span class=\"number\">0</span>] = phone.slice(<span class=\"number\">0</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">temp[<span class=\"number\">1</span>] = phone.slice(<span class=\"number\">3</span>, <span class=\"number\">7</span>)</span><br><span class=\"line\">temp[<span class=\"number\">2</span>] = phone.slice(<span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (temp[<span class=\"number\">2</span>].length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  temp[<span class=\"number\">1</span>] += <span class=\"string\">' '</span></span><br><span class=\"line\">  temp[<span class=\"number\">0</span>] += <span class=\"string\">' '</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (temp[<span class=\"number\">1</span>].length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  temp[<span class=\"number\">0</span>] += <span class=\"string\">' '</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将格式化好的手机号填入输入框</span></span><br><span class=\"line\">$mobileI.val(temp.join(<span class=\"string\">''</span>))</span><br></pre></td></tr></table></figure>\n<p>在移动端却会出现问题，在添加空格的情况下，光标会在最后一个字母前面。</p>\n<p><img src=\"/images/input_phone.jpg\" alt=\"光标位置\"></p>\n<p>通过selectionStart获取光标没有问题，通过设置selectionStart也没办法解决问题。</p>\n<p>经过一系列测试，发现如果使用keyup事件调用，并不会出现这种情况，使用input事件才会这样。并且如果使用input事件调用，在keyup中检查selectionStart属性，会发现比keyup中的值小。所以这应该是移动端浏览器的bug。</p>\n<p>我自己手机发现安卓下，chrome、UC、夸克都会有这个问题，QQ浏览器正常。</p>\n<p>解决办法，input改为keyup，或者通过setTimeout将$mobileI赋值改成异步等方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>碰到个比较奇怪的问题</p>\n<p>需求是input按344格式填写手机号，就像这样1<strong> **</strong> <em>**</em></p>\n<p>首先，input通过设置<code>type=&quot;number&quot;</code>或<code>type=&quot;tel&quot;</code>，以及<code>pattern=&quot;[0-9]&quot;</code>可以实现调起键盘为数字键盘。</p>\n<p>之后就是处理格式问题，移动端可以直接监听input事件，对输入进行替换。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将非数字全部替换掉</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> phone = $mobileI.val()</span><br><span class=\"line\">phone = phone.replace(<span class=\"regexp\">/[^0-9]/g</span>, <span class=\"string\">''</span>)</span><br><span class=\"line\"><span class=\"comment\">// 分组成344，并且加上' '</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> temp = []</span><br><span class=\"line\">temp[<span class=\"number\">0</span>] = phone.slice(<span class=\"number\">0</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">temp[<span class=\"number\">1</span>] = phone.slice(<span class=\"number\">3</span>, <span class=\"number\">7</span>)</span><br><span class=\"line\">temp[<span class=\"number\">2</span>] = phone.slice(<span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (temp[<span class=\"number\">2</span>].length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  temp[<span class=\"number\">1</span>] += <span class=\"string\">' '</span></span><br><span class=\"line\">  temp[<span class=\"number\">0</span>] += <span class=\"string\">' '</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (temp[<span class=\"number\">1</span>].length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  temp[<span class=\"number\">0</span>] += <span class=\"string\">' '</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将格式化好的手机号填入输入框</span></span><br><span class=\"line\">$mobileI.val(temp.join(<span class=\"string\">''</span>))</span><br></pre></td></tr></table></figure>\n<p>在移动端却会出现问题，在添加空格的情况下，光标会在最后一个字母前面。</p>\n<p><img src=\"/images/input_phone.jpg\" alt=\"光标位置\"></p>\n<p>通过selectionStart获取光标没有问题，通过设置selectionStart也没办法解决问题。</p>\n<p>经过一系列测试，发现如果使用keyup事件调用，并不会出现这种情况，使用input事件才会这样。并且如果使用input事件调用，在keyup中检查selectionStart属性，会发现比keyup中的值小。所以这应该是移动端浏览器的bug。</p>\n<p>我自己手机发现安卓下，chrome、UC、夸克都会有这个问题，QQ浏览器正常。</p>\n<p>解决办法，input改为keyup，或者通过setTimeout将$mobileI赋值改成异步等方法。</p>\n"},{"title":"起点大事件H5学习","date":"2016-08-09T16:00:00.000Z","comments":1,"_content":"\n[起点大事记 - 515粉丝节](http://m.qidian.com/ploy/20160515/qd/mockup/index.html)\n\n##### 0. js整体代码\n通过自执行函数返回两个对象，Common对象主要包含通用的分享代码，QDHISTORY对象(项目逻辑方法)包含页面主要逻辑，诸如init、loading、pagePlay、musicPlay、events(绑定事件)、JS动画等等。在页面</body>前引入后，标签script中调用。\n\n##### 1. 打开页面，第一个就是碰到的就是自动跳转。  \n代码很简单，只是对屏幕宽度的判断，大于600就显示静态页二维码。\n```javascript\nif(document.documentElement.clientWidth > 600) {\n  location.replace('pc.html');\n}\n```\n\n##### 2. 加载页面\n进度条，css中30s增加width动画。js中监听load事件，load事件完成后通过对进度条添加class实现width:100%过渡，修改加载标志。如果30s内加载标志还是未加载，则提示用户，并修改加载标志为失败，及时后面加载完成也不再触发load事件。  \n预加载，其实也是延迟加载。页面中img标签src属性保存在data-src中，这样就不会下载该图片，之后根据一定条件出发函数将data-src中属性写到src中。可以通过`new Image().src='图片地址'`提前下载图片。\n\n##### 3. 使用svg sprite && 使用canva\nsvg和canva虽然已经很久了，但是大量使用的貌似还不是特别多，使用svg和canva可以减少图片的使用，而且更容易添加动画，局限性主要是颜色上的限制。\n\n##### 4. css动画\ncss动画会在元素display:none和display:block的时候重新开始。一大堆令人眼花的动画，确实需要深厚的功力才能掌握。\n\n##### 5. 还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的[博客](http://www.zhangxinxu.com/wordpress/2016/06/canvas-star-noise-smoke/)吧。\n\n------\n\nps：自己能够写出来吗？ 应该是不行，即使照着临摹，动画的难度感觉也是很大，更别提烟雾、噪点等这些效果了。","source":"_posts/起点H5分析.md","raw":"---\ntitle: 起点大事件H5学习\ndate: 2016-08-10\ntags: [JavaScript, H5]\ncategories: \n- H5\ncomments: true\n---\n\n[起点大事记 - 515粉丝节](http://m.qidian.com/ploy/20160515/qd/mockup/index.html)\n\n##### 0. js整体代码\n通过自执行函数返回两个对象，Common对象主要包含通用的分享代码，QDHISTORY对象(项目逻辑方法)包含页面主要逻辑，诸如init、loading、pagePlay、musicPlay、events(绑定事件)、JS动画等等。在页面</body>前引入后，标签script中调用。\n\n##### 1. 打开页面，第一个就是碰到的就是自动跳转。  \n代码很简单，只是对屏幕宽度的判断，大于600就显示静态页二维码。\n```javascript\nif(document.documentElement.clientWidth > 600) {\n  location.replace('pc.html');\n}\n```\n\n##### 2. 加载页面\n进度条，css中30s增加width动画。js中监听load事件，load事件完成后通过对进度条添加class实现width:100%过渡，修改加载标志。如果30s内加载标志还是未加载，则提示用户，并修改加载标志为失败，及时后面加载完成也不再触发load事件。  \n预加载，其实也是延迟加载。页面中img标签src属性保存在data-src中，这样就不会下载该图片，之后根据一定条件出发函数将data-src中属性写到src中。可以通过`new Image().src='图片地址'`提前下载图片。\n\n##### 3. 使用svg sprite && 使用canva\nsvg和canva虽然已经很久了，但是大量使用的貌似还不是特别多，使用svg和canva可以减少图片的使用，而且更容易添加动画，局限性主要是颜色上的限制。\n\n##### 4. css动画\ncss动画会在元素display:none和display:block的时候重新开始。一大堆令人眼花的动画，确实需要深厚的功力才能掌握。\n\n##### 5. 还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的[博客](http://www.zhangxinxu.com/wordpress/2016/06/canvas-star-noise-smoke/)吧。\n\n------\n\nps：自己能够写出来吗？ 应该是不行，即使照着临摹，动画的难度感觉也是很大，更别提烟雾、噪点等这些效果了。","slug":"起点H5分析","published":1,"updated":"2017-12-28T03:47:32.468Z","layout":"post","photos":[],"link":"","_id":"cjks5i9jd0042vmtibo7lfyit","content":"<p><a href=\"http://m.qidian.com/ploy/20160515/qd/mockup/index.html\" target=\"_blank\" rel=\"noopener\">起点大事记 - 515粉丝节</a></p>\n<h5 id=\"0-js整体代码\"><a href=\"#0-js整体代码\" class=\"headerlink\" title=\"0. js整体代码\"></a>0. js整体代码</h5><p>通过自执行函数返回两个对象，Common对象主要包含通用的分享代码，QDHISTORY对象(项目逻辑方法)包含页面主要逻辑，诸如init、loading、pagePlay、musicPlay、events(绑定事件)、JS动画等等。在页面前引入后，标签script中调用。</p>\n<h5 id=\"1-打开页面，第一个就是碰到的就是自动跳转。\"><a href=\"#1-打开页面，第一个就是碰到的就是自动跳转。\" class=\"headerlink\" title=\"1. 打开页面，第一个就是碰到的就是自动跳转。\"></a>1. 打开页面，第一个就是碰到的就是自动跳转。</h5><p>代码很简单，只是对屏幕宽度的判断，大于600就显示静态页二维码。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">document</span>.documentElement.clientWidth &gt; <span class=\"number\">600</span>) &#123;</span><br><span class=\"line\">  location.replace(<span class=\"string\">'pc.html'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2-加载页面\"><a href=\"#2-加载页面\" class=\"headerlink\" title=\"2. 加载页面\"></a>2. 加载页面</h5><p>进度条，css中30s增加width动画。js中监听load事件，load事件完成后通过对进度条添加class实现width:100%过渡，修改加载标志。如果30s内加载标志还是未加载，则提示用户，并修改加载标志为失败，及时后面加载完成也不再触发load事件。<br>预加载，其实也是延迟加载。页面中img标签src属性保存在data-src中，这样就不会下载该图片，之后根据一定条件出发函数将data-src中属性写到src中。可以通过<code>new Image().src=&#39;图片地址&#39;</code>提前下载图片。</p>\n<h5 id=\"3-使用svg-sprite-amp-amp-使用canva\"><a href=\"#3-使用svg-sprite-amp-amp-使用canva\" class=\"headerlink\" title=\"3. 使用svg sprite &amp;&amp; 使用canva\"></a>3. 使用svg sprite &amp;&amp; 使用canva</h5><p>svg和canva虽然已经很久了，但是大量使用的貌似还不是特别多，使用svg和canva可以减少图片的使用，而且更容易添加动画，局限性主要是颜色上的限制。</p>\n<h5 id=\"4-css动画\"><a href=\"#4-css动画\" class=\"headerlink\" title=\"4. css动画\"></a>4. css动画</h5><p>css动画会在元素display:none和display:block的时候重新开始。一大堆令人眼花的动画，确实需要深厚的功力才能掌握。</p>\n<h5 id=\"5-还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的博客吧。\"><a href=\"#5-还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的博客吧。\" class=\"headerlink\" title=\"5. 还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的博客吧。\"></a>5. 还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的<a href=\"http://www.zhangxinxu.com/wordpress/2016/06/canvas-star-noise-smoke/\" target=\"_blank\" rel=\"noopener\">博客</a>吧。</h5><hr>\n<p>ps：自己能够写出来吗？ 应该是不行，即使照着临摹，动画的难度感觉也是很大，更别提烟雾、噪点等这些效果了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://m.qidian.com/ploy/20160515/qd/mockup/index.html\" target=\"_blank\" rel=\"noopener\">起点大事记 - 515粉丝节</a></p>\n<h5 id=\"0-js整体代码\"><a href=\"#0-js整体代码\" class=\"headerlink\" title=\"0. js整体代码\"></a>0. js整体代码</h5><p>通过自执行函数返回两个对象，Common对象主要包含通用的分享代码，QDHISTORY对象(项目逻辑方法)包含页面主要逻辑，诸如init、loading、pagePlay、musicPlay、events(绑定事件)、JS动画等等。在页面前引入后，标签script中调用。</p>\n<h5 id=\"1-打开页面，第一个就是碰到的就是自动跳转。\"><a href=\"#1-打开页面，第一个就是碰到的就是自动跳转。\" class=\"headerlink\" title=\"1. 打开页面，第一个就是碰到的就是自动跳转。\"></a>1. 打开页面，第一个就是碰到的就是自动跳转。</h5><p>代码很简单，只是对屏幕宽度的判断，大于600就显示静态页二维码。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">document</span>.documentElement.clientWidth &gt; <span class=\"number\">600</span>) &#123;</span><br><span class=\"line\">  location.replace(<span class=\"string\">'pc.html'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2-加载页面\"><a href=\"#2-加载页面\" class=\"headerlink\" title=\"2. 加载页面\"></a>2. 加载页面</h5><p>进度条，css中30s增加width动画。js中监听load事件，load事件完成后通过对进度条添加class实现width:100%过渡，修改加载标志。如果30s内加载标志还是未加载，则提示用户，并修改加载标志为失败，及时后面加载完成也不再触发load事件。<br>预加载，其实也是延迟加载。页面中img标签src属性保存在data-src中，这样就不会下载该图片，之后根据一定条件出发函数将data-src中属性写到src中。可以通过<code>new Image().src=&#39;图片地址&#39;</code>提前下载图片。</p>\n<h5 id=\"3-使用svg-sprite-amp-amp-使用canva\"><a href=\"#3-使用svg-sprite-amp-amp-使用canva\" class=\"headerlink\" title=\"3. 使用svg sprite &amp;&amp; 使用canva\"></a>3. 使用svg sprite &amp;&amp; 使用canva</h5><p>svg和canva虽然已经很久了，但是大量使用的貌似还不是特别多，使用svg和canva可以减少图片的使用，而且更容易添加动画，局限性主要是颜色上的限制。</p>\n<h5 id=\"4-css动画\"><a href=\"#4-css动画\" class=\"headerlink\" title=\"4. css动画\"></a>4. css动画</h5><p>css动画会在元素display:none和display:block的时候重新开始。一大堆令人眼花的动画，确实需要深厚的功力才能掌握。</p>\n<h5 id=\"5-还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的博客吧。\"><a href=\"#5-还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的博客吧。\" class=\"headerlink\" title=\"5. 还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的博客吧。\"></a>5. 还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的<a href=\"http://www.zhangxinxu.com/wordpress/2016/06/canvas-star-noise-smoke/\" target=\"_blank\" rel=\"noopener\">博客</a>吧。</h5><hr>\n<p>ps：自己能够写出来吗？ 应该是不行，即使照着临摹，动画的难度感觉也是很大，更别提烟雾、噪点等这些效果了。</p>\n"},{"title":"面向对象的javascript(继承)","date":"2016-06-21T12:33:00.000Z","comments":1,"_content":"　　继承就是从已有的类(对象)派生出新的类(对象)，新的类(对象)会拥有父类的所有属性和方法，并可以添加或修改属性和方法。\n\n--------------------\n\n### 1.类式继承(prototype模式)\n```javascript\n// 父类\nfunction SupClass() {\n\tthis.superValue = true;\n}\nSuperClass.prototype = {\n\tgetSuperValue = function() {\n\t\treturn this.superValue;\n\t}\n};\n// 子类\nfunction SubClass() {\n\tthis.subValue = false;\n}\n// 通过原型链实现继承\nSubClass.prototype = new SuperClass();\n// 修正constructor的指向\nSubClass.prototype.contructor = SubClass;\n// 子类添加公有方法\nSubClass.prototype.getSubValue = function() {}\n```\n将父类实例赋值给子类的prototype，子类就能通过原型链来访问到父类中的属性以及方法。缺点是因为子类是通过原型链继承父类的，所以多个实例化的子类中包含的父类属性和方法其实是一份，其中一个修改，其他会受到影响。另外是实例化无法传递参数。\n\n### 2.构造函数继承\n```javascript\n// 父类\nfunction SupClass(id) {\n\tthis.superValue = true;\n\tthis.id = id;\n}\nSuperClass.prototype = {\n\tgetSuperValue = function() {\n\t\treturn this.superValue;\n\t}\n};\n// 子类\nfunction SubClass(id, name) {\n\tSupClass.call(this, id);\n\tthis.name = name;\n}\n```\n通过call或apply函数修改父类中的this指向，可以实现参数的传递。缺点是只能继承构造函数中的属性(即this指向的属性和方法)，原型链得不到继承。\n\n### 3.组合继承\n```javascript\n// 父类\nfunction SupClass(id) {\n\tthis.superValue = true;\n\tthis.id = id;\n}\nSuperClass.prototype = {\n\tgetSuperValue = function() {\n\t\treturn this.superValue;\n\t}\n};\n// 子类\nfunction SubClass(id, name) {\n\t// 继承构造函数中的属性和方法\n\tSupClass.call(this, id);\n\tthis.name = name;\n}\n// 继承所有属性和方法\nSubClass.prototype = new SuperClass();\nSubClass.prototype.contructor = SubClass;\n```\n结合了类式继承和构造函数继承的优点，去除了两者的缺点。唯一的缺点就是在子类中执行了SupClass()，在子类原型中又执行了SupClass()。\n\n### 4.直接继承prototype\n```javascript\n// 同上\n... ...\n// 继承原型中的属性和方法\nSubClass.prototype = SuperClass.prototype;\nSubClass.prototype.contructor = SubClass;\n```\n既然在子类中构造函数的属性和方法已经被继承了，所以子类的原型中只需要继承父类的原型。缺点是SubClass.prototype和SupClass.prototype指向同一对象，修改会互相影响。\n\n### 5.利用空对象继承prototype\n```javascript\n// 同上\n... ...\n// 在空对象中复制一份父类的原型\nvar O = function(){};\nO.prototype = SuperClass.prototype;\n// 继承原型中的属性和方法\nSubClass.prototype = new O();\nSubClass.prototype.contructor = SubClass;\n```\n基于3.的修改，执行两次SupClass()消耗资源，执行空对象，消耗资源就会大大减少。\n\n### 6.拷贝继承\n拷贝就是将父类的属性和方法拷贝到子类中，拷贝可以是浅拷贝和深拷贝。拷贝可以实现多继承。\n\n----------------\n　　　　-------来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢","source":"_posts/面向对象的javascript(继承).md","raw":"---\ntitle: 面向对象的javascript(继承)\ndate: 2016-06-21 20:33\ntags: [JavaScript, 面向对象]\ncategories: \n- JavaScript\ncomments: true\n---\n　　继承就是从已有的类(对象)派生出新的类(对象)，新的类(对象)会拥有父类的所有属性和方法，并可以添加或修改属性和方法。\n\n--------------------\n\n### 1.类式继承(prototype模式)\n```javascript\n// 父类\nfunction SupClass() {\n\tthis.superValue = true;\n}\nSuperClass.prototype = {\n\tgetSuperValue = function() {\n\t\treturn this.superValue;\n\t}\n};\n// 子类\nfunction SubClass() {\n\tthis.subValue = false;\n}\n// 通过原型链实现继承\nSubClass.prototype = new SuperClass();\n// 修正constructor的指向\nSubClass.prototype.contructor = SubClass;\n// 子类添加公有方法\nSubClass.prototype.getSubValue = function() {}\n```\n将父类实例赋值给子类的prototype，子类就能通过原型链来访问到父类中的属性以及方法。缺点是因为子类是通过原型链继承父类的，所以多个实例化的子类中包含的父类属性和方法其实是一份，其中一个修改，其他会受到影响。另外是实例化无法传递参数。\n\n### 2.构造函数继承\n```javascript\n// 父类\nfunction SupClass(id) {\n\tthis.superValue = true;\n\tthis.id = id;\n}\nSuperClass.prototype = {\n\tgetSuperValue = function() {\n\t\treturn this.superValue;\n\t}\n};\n// 子类\nfunction SubClass(id, name) {\n\tSupClass.call(this, id);\n\tthis.name = name;\n}\n```\n通过call或apply函数修改父类中的this指向，可以实现参数的传递。缺点是只能继承构造函数中的属性(即this指向的属性和方法)，原型链得不到继承。\n\n### 3.组合继承\n```javascript\n// 父类\nfunction SupClass(id) {\n\tthis.superValue = true;\n\tthis.id = id;\n}\nSuperClass.prototype = {\n\tgetSuperValue = function() {\n\t\treturn this.superValue;\n\t}\n};\n// 子类\nfunction SubClass(id, name) {\n\t// 继承构造函数中的属性和方法\n\tSupClass.call(this, id);\n\tthis.name = name;\n}\n// 继承所有属性和方法\nSubClass.prototype = new SuperClass();\nSubClass.prototype.contructor = SubClass;\n```\n结合了类式继承和构造函数继承的优点，去除了两者的缺点。唯一的缺点就是在子类中执行了SupClass()，在子类原型中又执行了SupClass()。\n\n### 4.直接继承prototype\n```javascript\n// 同上\n... ...\n// 继承原型中的属性和方法\nSubClass.prototype = SuperClass.prototype;\nSubClass.prototype.contructor = SubClass;\n```\n既然在子类中构造函数的属性和方法已经被继承了，所以子类的原型中只需要继承父类的原型。缺点是SubClass.prototype和SupClass.prototype指向同一对象，修改会互相影响。\n\n### 5.利用空对象继承prototype\n```javascript\n// 同上\n... ...\n// 在空对象中复制一份父类的原型\nvar O = function(){};\nO.prototype = SuperClass.prototype;\n// 继承原型中的属性和方法\nSubClass.prototype = new O();\nSubClass.prototype.contructor = SubClass;\n```\n基于3.的修改，执行两次SupClass()消耗资源，执行空对象，消耗资源就会大大减少。\n\n### 6.拷贝继承\n拷贝就是将父类的属性和方法拷贝到子类中，拷贝可以是浅拷贝和深拷贝。拷贝可以实现多继承。\n\n----------------\n　　　　-------来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢","slug":"面向对象的javascript(继承)","published":1,"updated":"2017-12-28T03:47:32.468Z","layout":"post","photos":[],"link":"","_id":"cjks5i9jg0045vmtizgl5tce0","content":"<p>　　继承就是从已有的类(对象)派生出新的类(对象)，新的类(对象)会拥有父类的所有属性和方法，并可以添加或修改属性和方法。</p>\n<hr>\n<h3 id=\"1-类式继承-prototype模式\"><a href=\"#1-类式继承-prototype模式\" class=\"headerlink\" title=\"1.类式继承(prototype模式)\"></a>1.类式继承(prototype模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupClass</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.superValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperClass.prototype = &#123;</span><br><span class=\"line\">\tgetSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.superValue;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.subValue = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 通过原型链实现继承</span></span><br><span class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> SuperClass();</span><br><span class=\"line\"><span class=\"comment\">// 修正constructor的指向</span></span><br><span class=\"line\">SubClass.prototype.contructor = SubClass;</span><br><span class=\"line\"><span class=\"comment\">// 子类添加公有方法</span></span><br><span class=\"line\">SubClass.prototype.getSubValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>将父类实例赋值给子类的prototype，子类就能通过原型链来访问到父类中的属性以及方法。缺点是因为子类是通过原型链继承父类的，所以多个实例化的子类中包含的父类属性和方法其实是一份，其中一个修改，其他会受到影响。另外是实例化无法传递参数。</p>\n<h3 id=\"2-构造函数继承\"><a href=\"#2-构造函数继承\" class=\"headerlink\" title=\"2.构造函数继承\"></a>2.构造函数继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupClass</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.superValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperClass.prototype = &#123;</span><br><span class=\"line\">\tgetSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.superValue;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">id, name</span>) </span>&#123;</span><br><span class=\"line\">\tSupClass.call(<span class=\"keyword\">this</span>, id);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过call或apply函数修改父类中的this指向，可以实现参数的传递。缺点是只能继承构造函数中的属性(即this指向的属性和方法)，原型链得不到继承。</p>\n<h3 id=\"3-组合继承\"><a href=\"#3-组合继承\" class=\"headerlink\" title=\"3.组合继承\"></a>3.组合继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupClass</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.superValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperClass.prototype = &#123;</span><br><span class=\"line\">\tgetSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.superValue;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">id, name</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 继承构造函数中的属性和方法</span></span><br><span class=\"line\">\tSupClass.call(<span class=\"keyword\">this</span>, id);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 继承所有属性和方法</span></span><br><span class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> SuperClass();</span><br><span class=\"line\">SubClass.prototype.contructor = SubClass;</span><br></pre></td></tr></table></figure>\n<p>结合了类式继承和构造函数继承的优点，去除了两者的缺点。唯一的缺点就是在子类中执行了SupClass()，在子类原型中又执行了SupClass()。</p>\n<h3 id=\"4-直接继承prototype\"><a href=\"#4-直接继承prototype\" class=\"headerlink\" title=\"4.直接继承prototype\"></a>4.直接继承prototype</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 同上</span></span><br><span class=\"line\">... ...</span><br><span class=\"line\"><span class=\"comment\">// 继承原型中的属性和方法</span></span><br><span class=\"line\">SubClass.prototype = SuperClass.prototype;</span><br><span class=\"line\">SubClass.prototype.contructor = SubClass;</span><br></pre></td></tr></table></figure>\n<p>既然在子类中构造函数的属性和方法已经被继承了，所以子类的原型中只需要继承父类的原型。缺点是SubClass.prototype和SupClass.prototype指向同一对象，修改会互相影响。</p>\n<h3 id=\"5-利用空对象继承prototype\"><a href=\"#5-利用空对象继承prototype\" class=\"headerlink\" title=\"5.利用空对象继承prototype\"></a>5.利用空对象继承prototype</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 同上</span></span><br><span class=\"line\">... ...</span><br><span class=\"line\"><span class=\"comment\">// 在空对象中复制一份父类的原型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> O = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">O.prototype = SuperClass.prototype;</span><br><span class=\"line\"><span class=\"comment\">// 继承原型中的属性和方法</span></span><br><span class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> O();</span><br><span class=\"line\">SubClass.prototype.contructor = SubClass;</span><br></pre></td></tr></table></figure>\n<p>基于3.的修改，执行两次SupClass()消耗资源，执行空对象，消耗资源就会大大减少。</p>\n<h3 id=\"6-拷贝继承\"><a href=\"#6-拷贝继承\" class=\"headerlink\" title=\"6.拷贝继承\"></a>6.拷贝继承</h3><p>拷贝就是将父类的属性和方法拷贝到子类中，拷贝可以是浅拷贝和深拷贝。拷贝可以实现多继承。</p>\n<hr>\n<p>　　　　——-来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢</p>\n","site":{"data":{}},"excerpt":"","more":"<p>　　继承就是从已有的类(对象)派生出新的类(对象)，新的类(对象)会拥有父类的所有属性和方法，并可以添加或修改属性和方法。</p>\n<hr>\n<h3 id=\"1-类式继承-prototype模式\"><a href=\"#1-类式继承-prototype模式\" class=\"headerlink\" title=\"1.类式继承(prototype模式)\"></a>1.类式继承(prototype模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupClass</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.superValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperClass.prototype = &#123;</span><br><span class=\"line\">\tgetSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.superValue;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.subValue = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 通过原型链实现继承</span></span><br><span class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> SuperClass();</span><br><span class=\"line\"><span class=\"comment\">// 修正constructor的指向</span></span><br><span class=\"line\">SubClass.prototype.contructor = SubClass;</span><br><span class=\"line\"><span class=\"comment\">// 子类添加公有方法</span></span><br><span class=\"line\">SubClass.prototype.getSubValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>将父类实例赋值给子类的prototype，子类就能通过原型链来访问到父类中的属性以及方法。缺点是因为子类是通过原型链继承父类的，所以多个实例化的子类中包含的父类属性和方法其实是一份，其中一个修改，其他会受到影响。另外是实例化无法传递参数。</p>\n<h3 id=\"2-构造函数继承\"><a href=\"#2-构造函数继承\" class=\"headerlink\" title=\"2.构造函数继承\"></a>2.构造函数继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupClass</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.superValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperClass.prototype = &#123;</span><br><span class=\"line\">\tgetSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.superValue;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">id, name</span>) </span>&#123;</span><br><span class=\"line\">\tSupClass.call(<span class=\"keyword\">this</span>, id);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过call或apply函数修改父类中的this指向，可以实现参数的传递。缺点是只能继承构造函数中的属性(即this指向的属性和方法)，原型链得不到继承。</p>\n<h3 id=\"3-组合继承\"><a href=\"#3-组合继承\" class=\"headerlink\" title=\"3.组合继承\"></a>3.组合继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupClass</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.superValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperClass.prototype = &#123;</span><br><span class=\"line\">\tgetSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.superValue;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">id, name</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 继承构造函数中的属性和方法</span></span><br><span class=\"line\">\tSupClass.call(<span class=\"keyword\">this</span>, id);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 继承所有属性和方法</span></span><br><span class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> SuperClass();</span><br><span class=\"line\">SubClass.prototype.contructor = SubClass;</span><br></pre></td></tr></table></figure>\n<p>结合了类式继承和构造函数继承的优点，去除了两者的缺点。唯一的缺点就是在子类中执行了SupClass()，在子类原型中又执行了SupClass()。</p>\n<h3 id=\"4-直接继承prototype\"><a href=\"#4-直接继承prototype\" class=\"headerlink\" title=\"4.直接继承prototype\"></a>4.直接继承prototype</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 同上</span></span><br><span class=\"line\">... ...</span><br><span class=\"line\"><span class=\"comment\">// 继承原型中的属性和方法</span></span><br><span class=\"line\">SubClass.prototype = SuperClass.prototype;</span><br><span class=\"line\">SubClass.prototype.contructor = SubClass;</span><br></pre></td></tr></table></figure>\n<p>既然在子类中构造函数的属性和方法已经被继承了，所以子类的原型中只需要继承父类的原型。缺点是SubClass.prototype和SupClass.prototype指向同一对象，修改会互相影响。</p>\n<h3 id=\"5-利用空对象继承prototype\"><a href=\"#5-利用空对象继承prototype\" class=\"headerlink\" title=\"5.利用空对象继承prototype\"></a>5.利用空对象继承prototype</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 同上</span></span><br><span class=\"line\">... ...</span><br><span class=\"line\"><span class=\"comment\">// 在空对象中复制一份父类的原型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> O = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">O.prototype = SuperClass.prototype;</span><br><span class=\"line\"><span class=\"comment\">// 继承原型中的属性和方法</span></span><br><span class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> O();</span><br><span class=\"line\">SubClass.prototype.contructor = SubClass;</span><br></pre></td></tr></table></figure>\n<p>基于3.的修改，执行两次SupClass()消耗资源，执行空对象，消耗资源就会大大减少。</p>\n<h3 id=\"6-拷贝继承\"><a href=\"#6-拷贝继承\" class=\"headerlink\" title=\"6.拷贝继承\"></a>6.拷贝继承</h3><p>拷贝就是将父类的属性和方法拷贝到子类中，拷贝可以是浅拷贝和深拷贝。拷贝可以实现多继承。</p>\n<hr>\n<p>　　　　——-来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢</p>\n"},{"title":"面向对象的JavaScript(封装)","date":"2016-06-17T12:23:00.000Z","comments":1,"_content":"\n　　面向对象的基本特征：封装、继承、多态。\n　　封装就是把对象的属性和方法结合成在一些，也可以隐藏对象的属性和实现细节，所以封装后的对象一般有私有属性、私有方法、公有属性、公有方法等。\n\n--------------------\n\n### 1.最初的javascript代码是这样的\n```javascript\nfunction checkName() {\n\t\n}\nfunction checkEmail() {\n\t\n}\nfunction checkPassword() {\n\t\n}\n```\n调用时候，直接使用函数名checkName()。这样编写相当于创建多个全局变量：checkName、checkEmail、checkPassword。\n\n### 2.使用对象封装(原始模式)\n```javascript\nvar CheckObject = {\n\tcheckName: function() {\n\n\t},\n\tcheckEmail: function() {\n\n\t},\n\tcheckPassword: function() {\n\n\t}\n};\n```\n调用时，通过对象名调用，CheckObject.checkName()。缺点是只能够通过CheckObject使用，不能生成新的实例。\n\n### 3.返回新的对象(原始模式改进)\n```javascript\nvar CheckObject = function() {\n\treturn {\n\t\tcheckName: function() {\n\n\t\t},\n\t\tcheckEmail: function() {\n\n\t\t},\n\t\tcheckPassword: function() {\n\n\t\t}\n\t}\n};\n```\n调用方式\n```javascript\nvar a = CheckObject();\na.checkName();\n```\n每次调用CHeckObject都会产生新的对象，这样每个人在使用的时候互相之间不会影响，但是新生成的实例与实例之间没有关联，与CheckObject也没有关联。\n\n### 4.new操作符，能将方法中this指向新的实例(构造函数模式)\n```javascript\nvar CheckObject = function() {\n\tthis.checkName = function() {\n\n\t};\n\tthis.checkEmail = function() {\n\n\t};\n\tthis.checkPassword = function() {\n\n\t};\n};\n```\n调用方式\n```javascript\nvar a = new CheckObject();\na.checkName();\n```\n所有通过new生成的实例对象，都包含constructor属性，这个属性都会指向CheckObject。`a.constructor == CHeckObject`每个新生成的实例中都会包含checkName、checkEmail、checkPassword方法，这些方法都是相同的，可以通过原型链保存在prototype属性中，这样这些方法就只会存储一遍。\n\tps: new首先会创建一个空的对象。然后将新对象的_proto_指向调用函数的prototype属性。 最后将调用函数中的所有this指向新对象。\n\n### 5.利用prototype节省内存(prototype模式)\n```javascript\nvar CheckObject = function() {\n\t\n};\nCheckObject.prototype = {\n\tcheckName: function() {\n\n\t\treturn this;  //链式使用\n\t},\n\tcheckEmail: function() {\n\n\t\treturn this; //链式使用\n\t}，\n\tcheckPassword: function() {\n\n\t\treturn this; //链式使用\n\t}\n};\n```\n调用方法与4.相同。\n\n### 6.更像一个类\n```javascript\nvar Book = function(id, name, price) {\n\t// 私有属性  (外界不能直接访问、调用)\n\tvar num = 0;\n\t// 私有方法\n\tfunction checkId() {}\n\t// 对象公有属性  (对象可以访问、调用)\n\tthis.id = id;\n\t// 特权方法  (对象可以访问、调用，并且操作私有属性、方法)\n\tthis.getName = function() {};\n\tthis.setName = function() {};\n\tthis.getPrice = function() {};\n\tthis.setPrice = function() {};\n};\n// 类静态公有属性  (类可以访问、调用)\nBook.isChinese = true;\n// 类静态公有方法\nBook.resetTime = function() {};\nBook.prototype = {\n\t// 静态公有属性  (对象可以访问、调用，并且只保存一份)\n\tisJSBook: false,\n\t// 静态公有方法\n\tdisplay: function() {}\n};\n```\n\n### 7.利用闭包来实现\n```javascript\nvar Book = (function() {\n\t// 静态私有\n\tvar bookNum = 0;\n\tfunction checkBook() {};\n\t// 创建类\n\tfunction _book(id, name, price) {\n\t\t// 私有\n\t\tvar name,price;\n\t\tfunction checkID(){}\n\t\tthis.sayNum = function() {\n\t\t\tconsole.log(bookNum);\n\t\t};\n\t\tthis.setNum = function(number) {\n\t\t\tbookNum = number;\n\t\t};\n\t\t// 公有\n\t\tthis.id = id;\n\t\t// 特权方法\n\t\tthis.getName = function(){};\n\t\tthis.setName = function(){};\n\t\tthis.getPrice = function(){};\n\t\tthis.setPrice = function(){};\n\t}\n\t_book.prototype = {\n\t\t// 静态公有\n\t\tisJSBook: true,\n\t\tdisplay: function(){}\n\t};\n\treturn _book;\n})();\n```\n\tps: 静态私有变量只存在一份，如果通过创建类中的特权方法修改静态私有变量，所有对象实例中的此静态私有变量都会改变。(闭包)\n\t在6.中通过特权方法修改私有变量，其他对象中的私有变量，不会改变。\n\t这个，怎么理解呢？回头还需要研究下。\n\n### 8.创建对象的安全模式\n在创建实例对象的时候，如果没有使用new操作符，会造成this指向的是全局环境，在浏览器中也就是window对象。为了避免这种情况，可以使用instanceof来检测。\n```javascript\nvar Book = function(id, name, price) {\n\tif(this instanceof Book) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.price = price;\n\t} else  {\n\t\treturn new Book(id, name, price);\n\t}\n}\n```\n----------------\n　　　　-------来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢","source":"_posts/面向对象的javascript.md","raw":"---\ntitle: 面向对象的JavaScript(封装)\ndate: 2016-06-17 20:23\ntags: [JavaScript, 面向对象]\ncategories: \n- JavaScript\ncomments: true\n---\n\n　　面向对象的基本特征：封装、继承、多态。\n　　封装就是把对象的属性和方法结合成在一些，也可以隐藏对象的属性和实现细节，所以封装后的对象一般有私有属性、私有方法、公有属性、公有方法等。\n\n--------------------\n\n### 1.最初的javascript代码是这样的\n```javascript\nfunction checkName() {\n\t\n}\nfunction checkEmail() {\n\t\n}\nfunction checkPassword() {\n\t\n}\n```\n调用时候，直接使用函数名checkName()。这样编写相当于创建多个全局变量：checkName、checkEmail、checkPassword。\n\n### 2.使用对象封装(原始模式)\n```javascript\nvar CheckObject = {\n\tcheckName: function() {\n\n\t},\n\tcheckEmail: function() {\n\n\t},\n\tcheckPassword: function() {\n\n\t}\n};\n```\n调用时，通过对象名调用，CheckObject.checkName()。缺点是只能够通过CheckObject使用，不能生成新的实例。\n\n### 3.返回新的对象(原始模式改进)\n```javascript\nvar CheckObject = function() {\n\treturn {\n\t\tcheckName: function() {\n\n\t\t},\n\t\tcheckEmail: function() {\n\n\t\t},\n\t\tcheckPassword: function() {\n\n\t\t}\n\t}\n};\n```\n调用方式\n```javascript\nvar a = CheckObject();\na.checkName();\n```\n每次调用CHeckObject都会产生新的对象，这样每个人在使用的时候互相之间不会影响，但是新生成的实例与实例之间没有关联，与CheckObject也没有关联。\n\n### 4.new操作符，能将方法中this指向新的实例(构造函数模式)\n```javascript\nvar CheckObject = function() {\n\tthis.checkName = function() {\n\n\t};\n\tthis.checkEmail = function() {\n\n\t};\n\tthis.checkPassword = function() {\n\n\t};\n};\n```\n调用方式\n```javascript\nvar a = new CheckObject();\na.checkName();\n```\n所有通过new生成的实例对象，都包含constructor属性，这个属性都会指向CheckObject。`a.constructor == CHeckObject`每个新生成的实例中都会包含checkName、checkEmail、checkPassword方法，这些方法都是相同的，可以通过原型链保存在prototype属性中，这样这些方法就只会存储一遍。\n\tps: new首先会创建一个空的对象。然后将新对象的_proto_指向调用函数的prototype属性。 最后将调用函数中的所有this指向新对象。\n\n### 5.利用prototype节省内存(prototype模式)\n```javascript\nvar CheckObject = function() {\n\t\n};\nCheckObject.prototype = {\n\tcheckName: function() {\n\n\t\treturn this;  //链式使用\n\t},\n\tcheckEmail: function() {\n\n\t\treturn this; //链式使用\n\t}，\n\tcheckPassword: function() {\n\n\t\treturn this; //链式使用\n\t}\n};\n```\n调用方法与4.相同。\n\n### 6.更像一个类\n```javascript\nvar Book = function(id, name, price) {\n\t// 私有属性  (外界不能直接访问、调用)\n\tvar num = 0;\n\t// 私有方法\n\tfunction checkId() {}\n\t// 对象公有属性  (对象可以访问、调用)\n\tthis.id = id;\n\t// 特权方法  (对象可以访问、调用，并且操作私有属性、方法)\n\tthis.getName = function() {};\n\tthis.setName = function() {};\n\tthis.getPrice = function() {};\n\tthis.setPrice = function() {};\n};\n// 类静态公有属性  (类可以访问、调用)\nBook.isChinese = true;\n// 类静态公有方法\nBook.resetTime = function() {};\nBook.prototype = {\n\t// 静态公有属性  (对象可以访问、调用，并且只保存一份)\n\tisJSBook: false,\n\t// 静态公有方法\n\tdisplay: function() {}\n};\n```\n\n### 7.利用闭包来实现\n```javascript\nvar Book = (function() {\n\t// 静态私有\n\tvar bookNum = 0;\n\tfunction checkBook() {};\n\t// 创建类\n\tfunction _book(id, name, price) {\n\t\t// 私有\n\t\tvar name,price;\n\t\tfunction checkID(){}\n\t\tthis.sayNum = function() {\n\t\t\tconsole.log(bookNum);\n\t\t};\n\t\tthis.setNum = function(number) {\n\t\t\tbookNum = number;\n\t\t};\n\t\t// 公有\n\t\tthis.id = id;\n\t\t// 特权方法\n\t\tthis.getName = function(){};\n\t\tthis.setName = function(){};\n\t\tthis.getPrice = function(){};\n\t\tthis.setPrice = function(){};\n\t}\n\t_book.prototype = {\n\t\t// 静态公有\n\t\tisJSBook: true,\n\t\tdisplay: function(){}\n\t};\n\treturn _book;\n})();\n```\n\tps: 静态私有变量只存在一份，如果通过创建类中的特权方法修改静态私有变量，所有对象实例中的此静态私有变量都会改变。(闭包)\n\t在6.中通过特权方法修改私有变量，其他对象中的私有变量，不会改变。\n\t这个，怎么理解呢？回头还需要研究下。\n\n### 8.创建对象的安全模式\n在创建实例对象的时候，如果没有使用new操作符，会造成this指向的是全局环境，在浏览器中也就是window对象。为了避免这种情况，可以使用instanceof来检测。\n```javascript\nvar Book = function(id, name, price) {\n\tif(this instanceof Book) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.price = price;\n\t} else  {\n\t\treturn new Book(id, name, price);\n\t}\n}\n```\n----------------\n　　　　-------来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢","slug":"面向对象的javascript","published":1,"updated":"2017-12-28T03:47:32.468Z","layout":"post","photos":[],"link":"","_id":"cjks5i9jh0049vmtiuw3duke3","content":"<p>　　面向对象的基本特征：封装、继承、多态。<br>　　封装就是把对象的属性和方法结合成在一些，也可以隐藏对象的属性和实现细节，所以封装后的对象一般有私有属性、私有方法、公有属性、公有方法等。</p>\n<hr>\n<h3 id=\"1-最初的javascript代码是这样的\"><a href=\"#1-最初的javascript代码是这样的\" class=\"headerlink\" title=\"1.最初的javascript代码是这样的\"></a>1.最初的javascript代码是这样的</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkName</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkEmail</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkPassword</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用时候，直接使用函数名checkName()。这样编写相当于创建多个全局变量：checkName、checkEmail、checkPassword。</p>\n<h3 id=\"2-使用对象封装-原始模式\"><a href=\"#2-使用对象封装-原始模式\" class=\"headerlink\" title=\"2.使用对象封装(原始模式)\"></a>2.使用对象封装(原始模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> CheckObject = &#123;</span><br><span class=\"line\">\tcheckName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tcheckEmail: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tcheckPassword: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>调用时，通过对象名调用，CheckObject.checkName()。缺点是只能够通过CheckObject使用，不能生成新的实例。</p>\n<h3 id=\"3-返回新的对象-原始模式改进\"><a href=\"#3-返回新的对象-原始模式改进\" class=\"headerlink\" title=\"3.返回新的对象(原始模式改进)\"></a>3.返回新的对象(原始模式改进)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tcheckName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tcheckEmail: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tcheckPassword: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>调用方式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = CheckObject();</span><br><span class=\"line\">a.checkName();</span><br></pre></td></tr></table></figure></p>\n<p>每次调用CHeckObject都会产生新的对象，这样每个人在使用的时候互相之间不会影响，但是新生成的实例与实例之间没有关联，与CheckObject也没有关联。</p>\n<h3 id=\"4-new操作符，能将方法中this指向新的实例-构造函数模式\"><a href=\"#4-new操作符，能将方法中this指向新的实例-构造函数模式\" class=\"headerlink\" title=\"4.new操作符，能将方法中this指向新的实例(构造函数模式)\"></a>4.new操作符，能将方法中this指向新的实例(构造函数模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.checkName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.checkEmail = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.checkPassword = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>调用方式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> CheckObject();</span><br><span class=\"line\">a.checkName();</span><br></pre></td></tr></table></figure></p>\n<p>所有通过new生成的实例对象，都包含constructor属性，这个属性都会指向CheckObject。<code>a.constructor == CHeckObject</code>每个新生成的实例中都会包含checkName、checkEmail、checkPassword方法，这些方法都是相同的，可以通过原型链保存在prototype属性中，这样这些方法就只会存储一遍。<br>    ps: new首先会创建一个空的对象。然后将新对象的<em>proto</em>指向调用函数的prototype属性。 最后将调用函数中的所有this指向新对象。</p>\n<h3 id=\"5-利用prototype节省内存-prototype模式\"><a href=\"#5-利用prototype节省内存-prototype模式\" class=\"headerlink\" title=\"5.利用prototype节省内存(prototype模式)\"></a>5.利用prototype节省内存(prototype模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">CheckObject.prototype = &#123;</span><br><span class=\"line\">\tcheckName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  <span class=\"comment\">//链式使用</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tcheckEmail: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; <span class=\"comment\">//链式使用</span></span><br><span class=\"line\">\t&#125;，</span><br><span class=\"line\">\tcheckPassword: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; <span class=\"comment\">//链式使用</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>调用方法与4.相同。</p>\n<h3 id=\"6-更像一个类\"><a href=\"#6-更像一个类\" class=\"headerlink\" title=\"6.更像一个类\"></a>6.更像一个类</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Book = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, name, price</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 私有属性  (外界不能直接访问、调用)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 私有方法</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkId</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 对象公有属性  (对象可以访问、调用)</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">\t<span class=\"comment\">// 特权方法  (对象可以访问、调用，并且操作私有属性、方法)</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.getPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.setPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 类静态公有属性  (类可以访问、调用)</span></span><br><span class=\"line\">Book.isChinese = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"comment\">// 类静态公有方法</span></span><br><span class=\"line\">Book.resetTime = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">Book.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 静态公有属性  (对象可以访问、调用，并且只保存一份)</span></span><br><span class=\"line\">\tisJSBook: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t<span class=\"comment\">// 静态公有方法</span></span><br><span class=\"line\">\tdisplay: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-利用闭包来实现\"><a href=\"#7-利用闭包来实现\" class=\"headerlink\" title=\"7.利用闭包来实现\"></a>7.利用闭包来实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Book = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 静态私有</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> bookNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkBook</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">\t<span class=\"comment\">// 创建类</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_book</span>(<span class=\"params\">id, name, price</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 私有</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> name,price;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkID</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.sayNum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(bookNum);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.setNum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">number</span>) </span>&#123;</span><br><span class=\"line\">\t\t\tbookNum = number;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 公有</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 特权方法</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.getPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.setPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t_book.prototype = &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 静态公有</span></span><br><span class=\"line\">\t\tisJSBook: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\tdisplay: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> _book;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<pre><code>ps: 静态私有变量只存在一份，如果通过创建类中的特权方法修改静态私有变量，所有对象实例中的此静态私有变量都会改变。(闭包)\n在6.中通过特权方法修改私有变量，其他对象中的私有变量，不会改变。\n这个，怎么理解呢？回头还需要研究下。\n</code></pre><h3 id=\"8-创建对象的安全模式\"><a href=\"#8-创建对象的安全模式\" class=\"headerlink\" title=\"8.创建对象的安全模式\"></a>8.创建对象的安全模式</h3><p>在创建实例对象的时候，如果没有使用new操作符，会造成this指向的是全局环境，在浏览器中也就是window对象。为了避免这种情况，可以使用instanceof来检测。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Book = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, name, price</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> Book) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.price = price;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span>  &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Book(id, name, price);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>　　　　——-来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢</p>\n","site":{"data":{}},"excerpt":"","more":"<p>　　面向对象的基本特征：封装、继承、多态。<br>　　封装就是把对象的属性和方法结合成在一些，也可以隐藏对象的属性和实现细节，所以封装后的对象一般有私有属性、私有方法、公有属性、公有方法等。</p>\n<hr>\n<h3 id=\"1-最初的javascript代码是这样的\"><a href=\"#1-最初的javascript代码是这样的\" class=\"headerlink\" title=\"1.最初的javascript代码是这样的\"></a>1.最初的javascript代码是这样的</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkName</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkEmail</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkPassword</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用时候，直接使用函数名checkName()。这样编写相当于创建多个全局变量：checkName、checkEmail、checkPassword。</p>\n<h3 id=\"2-使用对象封装-原始模式\"><a href=\"#2-使用对象封装-原始模式\" class=\"headerlink\" title=\"2.使用对象封装(原始模式)\"></a>2.使用对象封装(原始模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> CheckObject = &#123;</span><br><span class=\"line\">\tcheckName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tcheckEmail: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tcheckPassword: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>调用时，通过对象名调用，CheckObject.checkName()。缺点是只能够通过CheckObject使用，不能生成新的实例。</p>\n<h3 id=\"3-返回新的对象-原始模式改进\"><a href=\"#3-返回新的对象-原始模式改进\" class=\"headerlink\" title=\"3.返回新的对象(原始模式改进)\"></a>3.返回新的对象(原始模式改进)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tcheckName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tcheckEmail: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tcheckPassword: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>调用方式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = CheckObject();</span><br><span class=\"line\">a.checkName();</span><br></pre></td></tr></table></figure></p>\n<p>每次调用CHeckObject都会产生新的对象，这样每个人在使用的时候互相之间不会影响，但是新生成的实例与实例之间没有关联，与CheckObject也没有关联。</p>\n<h3 id=\"4-new操作符，能将方法中this指向新的实例-构造函数模式\"><a href=\"#4-new操作符，能将方法中this指向新的实例-构造函数模式\" class=\"headerlink\" title=\"4.new操作符，能将方法中this指向新的实例(构造函数模式)\"></a>4.new操作符，能将方法中this指向新的实例(构造函数模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.checkName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.checkEmail = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.checkPassword = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>调用方式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> CheckObject();</span><br><span class=\"line\">a.checkName();</span><br></pre></td></tr></table></figure></p>\n<p>所有通过new生成的实例对象，都包含constructor属性，这个属性都会指向CheckObject。<code>a.constructor == CHeckObject</code>每个新生成的实例中都会包含checkName、checkEmail、checkPassword方法，这些方法都是相同的，可以通过原型链保存在prototype属性中，这样这些方法就只会存储一遍。<br>    ps: new首先会创建一个空的对象。然后将新对象的<em>proto</em>指向调用函数的prototype属性。 最后将调用函数中的所有this指向新对象。</p>\n<h3 id=\"5-利用prototype节省内存-prototype模式\"><a href=\"#5-利用prototype节省内存-prototype模式\" class=\"headerlink\" title=\"5.利用prototype节省内存(prototype模式)\"></a>5.利用prototype节省内存(prototype模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">CheckObject.prototype = &#123;</span><br><span class=\"line\">\tcheckName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  <span class=\"comment\">//链式使用</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tcheckEmail: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; <span class=\"comment\">//链式使用</span></span><br><span class=\"line\">\t&#125;，</span><br><span class=\"line\">\tcheckPassword: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; <span class=\"comment\">//链式使用</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>调用方法与4.相同。</p>\n<h3 id=\"6-更像一个类\"><a href=\"#6-更像一个类\" class=\"headerlink\" title=\"6.更像一个类\"></a>6.更像一个类</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Book = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, name, price</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 私有属性  (外界不能直接访问、调用)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 私有方法</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkId</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 对象公有属性  (对象可以访问、调用)</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">\t<span class=\"comment\">// 特权方法  (对象可以访问、调用，并且操作私有属性、方法)</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.getPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.setPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 类静态公有属性  (类可以访问、调用)</span></span><br><span class=\"line\">Book.isChinese = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"comment\">// 类静态公有方法</span></span><br><span class=\"line\">Book.resetTime = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">Book.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 静态公有属性  (对象可以访问、调用，并且只保存一份)</span></span><br><span class=\"line\">\tisJSBook: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t<span class=\"comment\">// 静态公有方法</span></span><br><span class=\"line\">\tdisplay: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-利用闭包来实现\"><a href=\"#7-利用闭包来实现\" class=\"headerlink\" title=\"7.利用闭包来实现\"></a>7.利用闭包来实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Book = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 静态私有</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> bookNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkBook</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">\t<span class=\"comment\">// 创建类</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_book</span>(<span class=\"params\">id, name, price</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 私有</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> name,price;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkID</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.sayNum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(bookNum);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.setNum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">number</span>) </span>&#123;</span><br><span class=\"line\">\t\t\tbookNum = number;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 公有</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 特权方法</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.getPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.setPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t_book.prototype = &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 静态公有</span></span><br><span class=\"line\">\t\tisJSBook: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\tdisplay: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> _book;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<pre><code>ps: 静态私有变量只存在一份，如果通过创建类中的特权方法修改静态私有变量，所有对象实例中的此静态私有变量都会改变。(闭包)\n在6.中通过特权方法修改私有变量，其他对象中的私有变量，不会改变。\n这个，怎么理解呢？回头还需要研究下。\n</code></pre><h3 id=\"8-创建对象的安全模式\"><a href=\"#8-创建对象的安全模式\" class=\"headerlink\" title=\"8.创建对象的安全模式\"></a>8.创建对象的安全模式</h3><p>在创建实例对象的时候，如果没有使用new操作符，会造成this指向的是全局环境，在浏览器中也就是window对象。为了避免这种情况，可以使用instanceof来检测。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Book = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, name, price</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> Book) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.price = price;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span>  &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Book(id, name, price);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>　　　　——-来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjks5i9hd0000vmti7cvflihs","category_id":"cjks5i9hk0002vmtizhr4mt1u","_id":"cjks5i9hr000bvmtizx2aoojj"},{"post_id":"cjks5i9hh0001vmti17xzr3xu","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9hx000ivmti4syzqg8f"},{"post_id":"cjks5i9hq000avmtieybk5n95","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9hz000lvmticfhkcj8v"},{"post_id":"cjks5i9hl0003vmtid1h25a54","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9i1000qvmtidgb7eqhg"},{"post_id":"cjks5i9hv000gvmtim4vzb4ih","category_id":"cjks5i9hk0002vmtizhr4mt1u","_id":"cjks5i9i2000tvmtiqalv1w2n"},{"post_id":"cjks5i9hn0005vmtiztmf87ha","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9i4000yvmtimx6ltx2r"},{"post_id":"cjks5i9i0000ovmtidgwgevt7","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9i50011vmtizgcq8ubj"},{"post_id":"cjks5i9ho0006vmtiw1174lpj","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9i60015vmtiy3jb4ebw"},{"post_id":"cjks5i9hp0008vmtidnmnppyi","category_id":"cjks5i9i4000xvmtinx6vn9a4","_id":"cjks5i9i8001bvmtiuhln97nf"},{"post_id":"cjks5i9i50013vmti3kw43zue","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9ia001fvmtintdjlq0m"},{"post_id":"cjks5i9i70017vmti85wndpnx","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9ib001jvmtikjj3m89q"},{"post_id":"cjks5i9ht000dvmtievn4mtvx","category_id":"cjks5i9i60016vmtifngpreo2","_id":"cjks5i9ic001mvmti75jo5bbq"},{"post_id":"cjks5i9i80019vmtibxjjff9g","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9id001pvmtiabbr58g3"},{"post_id":"cjks5i9hx000kvmtigi1hjwol","category_id":"cjks5i9i9001cvmtidbkw1ynr","_id":"cjks5i9if001tvmtid4dd0ywd"},{"post_id":"cjks5i9ib001kvmtibnfbqbtb","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9ig001xvmti2a4f0q6s"},{"post_id":"cjks5i9ic001nvmtiham6til6","category_id":"cjks5i9hk0002vmtizhr4mt1u","_id":"cjks5i9ii0021vmti8ihi3dkd"},{"post_id":"cjks5i9i1000svmti7mquq51q","category_id":"cjks5i9ic001lvmtifpxve2mo","_id":"cjks5i9ij0023vmtirjtdlr6a"},{"post_id":"cjks5i9ie001qvmti9muyxxf5","category_id":"cjks5i9ic001lvmtifpxve2mo","_id":"cjks5i9il0028vmtifm0tbicq"},{"post_id":"cjks5i9if001uvmtitblmvq82","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9im002bvmtihgtz8fqp"},{"post_id":"cjks5i9i3000wvmti80eo3itz","category_id":"cjks5i9ic001lvmtifpxve2mo","_id":"cjks5i9io002fvmtizu0yj2gp"},{"post_id":"cjks5i9ih001yvmti2t3p94u3","category_id":"cjks5i9ic001lvmtifpxve2mo","_id":"cjks5i9ip002ivmtihq43lzrq"},{"post_id":"cjks5i9ij0022vmtik58ws1zm","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9ir002nvmtiq7bd0rag"},{"post_id":"cjks5i9i40010vmti4e4wb1re","category_id":"cjks5i9ic001lvmtifpxve2mo","_id":"cjks5i9is002qvmtiricldn8s"},{"post_id":"cjks5i9il0029vmtiub9gmjhi","category_id":"cjks5i9i9001cvmtidbkw1ynr","_id":"cjks5i9it002uvmtirbqaya60"},{"post_id":"cjks5i9i9001dvmtijdu5d7kl","category_id":"cjks5i9il0026vmti0c73qk7t","_id":"cjks5i9iv002xvmtivr8f591j"},{"post_id":"cjks5i9im002cvmtidrud360u","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9iw0031vmtidfzzrlkv"},{"post_id":"cjks5i9io002hvmtin0etoskh","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9iy0034vmti1u4j93k3"},{"post_id":"cjks5i9ia001gvmti4dv04sp7","category_id":"cjks5i9ic001lvmtifpxve2mo","_id":"cjks5i9iz0038vmti487lj2uc"},{"post_id":"cjks5i9ip002kvmti3sj6r1ru","category_id":"cjks5i9i60016vmtifngpreo2","_id":"cjks5i9j1003bvmtib6typwe2"},{"post_id":"cjks5i9ir002pvmtiil1qsuul","category_id":"cjks5i9hk0002vmtizhr4mt1u","_id":"cjks5i9j2003fvmtixgqp5tfm"},{"post_id":"cjks5i9ik0025vmtiqkwqc4wn","category_id":"cjks5i9ir002mvmti06np2yaz","_id":"cjks5i9j4003ivmti3nw7c11w"},{"post_id":"cjks5i9is002svmtir6k2ba7e","category_id":"cjks5i9ic001lvmtifpxve2mo","_id":"cjks5i9j6003mvmtif09pclv6"},{"post_id":"cjks5i9iu002wvmticng7tsqw","category_id":"cjks5i9ic001lvmtifpxve2mo","_id":"cjks5i9j7003pvmtifyaw32oe"},{"post_id":"cjks5i9iv002zvmti4e3alwck","category_id":"cjks5i9ic001lvmtifpxve2mo","_id":"cjks5i9ja003tvmti5ys2d6qk"},{"post_id":"cjks5i9ix0033vmtirr7714a0","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9jb003wvmtii6imy4qc"},{"post_id":"cjks5i9iy0036vmti4ejbn2ny","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9jd003zvmtikqm09w0q"},{"post_id":"cjks5i9j0003avmticuh120hm","category_id":"cjks5i9hk0002vmtizhr4mt1u","_id":"cjks5i9jf0043vmtiabluaiae"},{"post_id":"cjks5i9j1003dvmtif2e2825h","category_id":"cjks5i9hk0002vmtizhr4mt1u","_id":"cjks5i9jh0046vmtiojecfibe"},{"post_id":"cjks5i9j2003hvmti5wggrw47","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9ji004avmtiv8dh3t8h"},{"post_id":"cjks5i9j5003kvmtiweuhvg58","category_id":"cjks5i9i9001cvmtidbkw1ynr","_id":"cjks5i9ji004cvmtimhap47rm"},{"post_id":"cjks5i9j6003ovmtid6dme1xx","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9jj004fvmti01i6woi4"},{"post_id":"cjks5i9j8003rvmti5tx27sgr","category_id":"cjks5i9hk0002vmtizhr4mt1u","_id":"cjks5i9jj004hvmtinq279pl4"},{"post_id":"cjks5i9ja003vvmtiugxqc12l","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9jj004kvmtirobnhcfz"},{"post_id":"cjks5i9jb003yvmti1rn4s893","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9jk004mvmtifhx6oicq"},{"post_id":"cjks5i9jd0042vmtibo7lfyit","category_id":"cjks5i9i9001cvmtidbkw1ynr","_id":"cjks5i9jk004pvmti5tgyknpk"},{"post_id":"cjks5i9jg0045vmtizgl5tce0","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9jk004rvmtir277mh5s"},{"post_id":"cjks5i9jh0049vmtiuw3duke3","category_id":"cjks5i9hp0007vmtioj7jmzp9","_id":"cjks5i9jl004uvmtil2hf5iem"}],"PostTag":[{"post_id":"cjks5i9hq000avmtieybk5n95","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9hu000fvmtig1nrj9fz"},{"post_id":"cjks5i9hh0001vmti17xzr3xu","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9hx000jvmtisf3z3q4y"},{"post_id":"cjks5i9hh0001vmti17xzr3xu","tag_id":"cjks5i9hq0009vmtiqnz8u99v","_id":"cjks5i9hz000nvmtij7xnikd3"},{"post_id":"cjks5i9hl0003vmtid1h25a54","tag_id":"cjks5i9hu000evmtixiztfkbj","_id":"cjks5i9i1000rvmtiuwk0x5hn"},{"post_id":"cjks5i9i0000ovmtidgwgevt7","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9i2000vvmticn10oazk"},{"post_id":"cjks5i9hn0005vmtiztmf87ha","tag_id":"cjks5i9hu000evmtixiztfkbj","_id":"cjks5i9i4000zvmtiyf9wg3fr"},{"post_id":"cjks5i9ho0006vmtiw1174lpj","tag_id":"cjks5i9hu000evmtixiztfkbj","_id":"cjks5i9i60014vmtidpyh9v8d"},{"post_id":"cjks5i9hp0008vmtidnmnppyi","tag_id":"cjks5i9i50012vmtirrwcoyu8","_id":"cjks5i9i8001avmti92zppdbr"},{"post_id":"cjks5i9i70017vmti85wndpnx","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9ia001evmti9tccw4d0"},{"post_id":"cjks5i9i80019vmtibxjjff9g","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9ib001ivmti7vytus12"},{"post_id":"cjks5i9ht000dvmtievn4mtvx","tag_id":"cjks5i9i70018vmti0mxr2vs0","_id":"cjks5i9ie001rvmti06twxj1n"},{"post_id":"cjks5i9ht000dvmtievn4mtvx","tag_id":"cjks5i9ia001hvmtixyuf7aa2","_id":"cjks5i9ig001vvmtitio3vrfy"},{"post_id":"cjks5i9hv000gvmtim4vzb4ih","tag_id":"cjks5i9id001ovmtib5a3qc40","_id":"cjks5i9ii001zvmti6xrn8zh8"},{"post_id":"cjks5i9hx000kvmtigi1hjwol","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9il0027vmtiu2639dda"},{"post_id":"cjks5i9hx000kvmtigi1hjwol","tag_id":"cjks5i9ig001wvmtiu3c1fslz","_id":"cjks5i9im002avmtia4u0axou"},{"post_id":"cjks5i9il0029vmtiub9gmjhi","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9io002gvmtixccmfikd"},{"post_id":"cjks5i9il0029vmtiub9gmjhi","tag_id":"cjks5i9ig001wvmtiu3c1fslz","_id":"cjks5i9ip002jvmtijd3l51o3"},{"post_id":"cjks5i9i1000svmti7mquq51q","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9ir002ovmtiewwi6ijw"},{"post_id":"cjks5i9i1000svmti7mquq51q","tag_id":"cjks5i9ik0024vmtijr6y8lao","_id":"cjks5i9is002rvmtil72m55u6"},{"post_id":"cjks5i9im002cvmtidrud360u","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9it002vvmtijhnertyv"},{"post_id":"cjks5i9im002cvmtidrud360u","tag_id":"cjks5i9hq0009vmtiqnz8u99v","_id":"cjks5i9iv002yvmtircf8e7mh"},{"post_id":"cjks5i9i3000wvmti80eo3itz","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9iw0032vmtiw6eqtlmp"},{"post_id":"cjks5i9i3000wvmti80eo3itz","tag_id":"cjks5i9ik0024vmtijr6y8lao","_id":"cjks5i9iy0035vmti34tfzw8y"},{"post_id":"cjks5i9ip002kvmti3sj6r1ru","tag_id":"cjks5i9i70018vmti0mxr2vs0","_id":"cjks5i9j00039vmtid7t5rbnc"},{"post_id":"cjks5i9ip002kvmti3sj6r1ru","tag_id":"cjks5i9ia001hvmtixyuf7aa2","_id":"cjks5i9j1003cvmti5nnxmxhy"},{"post_id":"cjks5i9i40010vmti4e4wb1re","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9j2003gvmtijzp51wra"},{"post_id":"cjks5i9i40010vmti4e4wb1re","tag_id":"cjks5i9ik0024vmtijr6y8lao","_id":"cjks5i9j5003jvmtiv8hf6d4f"},{"post_id":"cjks5i9i50013vmti3kw43zue","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9j6003nvmti7yt1c5ij"},{"post_id":"cjks5i9i50013vmti3kw43zue","tag_id":"cjks5i9ik0024vmtijr6y8lao","_id":"cjks5i9j7003qvmtiol2kd3oy"},{"post_id":"cjks5i9ix0033vmtirr7714a0","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9ja003uvmtimrxhibnk"},{"post_id":"cjks5i9i9001dvmtijdu5d7kl","tag_id":"cjks5i9iw0030vmti4do8uh21","_id":"cjks5i9jb003xvmtid8jj6nex"},{"post_id":"cjks5i9iy0036vmti4ejbn2ny","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9jd0040vmti4kx3szaf"},{"post_id":"cjks5i9j0003avmticuh120hm","tag_id":"cjks5i9id001ovmtib5a3qc40","_id":"cjks5i9jf0044vmtiqy4ga2jq"},{"post_id":"cjks5i9ia001gvmti4dv04sp7","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9jh0047vmtidvw81dl4"},{"post_id":"cjks5i9ia001gvmti4dv04sp7","tag_id":"cjks5i9ik0024vmtijr6y8lao","_id":"cjks5i9ji004bvmtihqntq571"},{"post_id":"cjks5i9ib001kvmtibnfbqbtb","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9jj004dvmtidwoxvmbm"},{"post_id":"cjks5i9ib001kvmtibnfbqbtb","tag_id":"cjks5i9j2003evmtip4zab8n4","_id":"cjks5i9jj004gvmtikmsqpkvu"},{"post_id":"cjks5i9ja003vvmtiugxqc12l","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9jj004ivmtih86qd9zz"},{"post_id":"cjks5i9ic001nvmtiham6til6","tag_id":"cjks5i9id001ovmtib5a3qc40","_id":"cjks5i9jj004lvmticwl9e4zd"},{"post_id":"cjks5i9ic001nvmtiham6til6","tag_id":"cjks5i9j9003svmti935pmgqz","_id":"cjks5i9jk004nvmti2p5uebnr"},{"post_id":"cjks5i9jb003yvmti1rn4s893","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9jk004qvmtics6vtz4e"},{"post_id":"cjks5i9jd0042vmtibo7lfyit","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9jk004svmti1jxek4w1"},{"post_id":"cjks5i9jd0042vmtibo7lfyit","tag_id":"cjks5i9ig001wvmtiu3c1fslz","_id":"cjks5i9jl004vvmtiaivk97q0"},{"post_id":"cjks5i9ie001qvmti9muyxxf5","tag_id":"cjks5i9ik0024vmtijr6y8lao","_id":"cjks5i9jl004wvmtid7k7c2z8"},{"post_id":"cjks5i9ie001qvmti9muyxxf5","tag_id":"cjks5i9jh0048vmtikt061kes","_id":"cjks5i9jl004yvmtih7k66axz"},{"post_id":"cjks5i9if001uvmtitblmvq82","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9jm004zvmtiv4pv92mg"},{"post_id":"cjks5i9if001uvmtitblmvq82","tag_id":"cjks5i9jj004evmti00ibwal3","_id":"cjks5i9jm0051vmtil8kv3iih"},{"post_id":"cjks5i9if001uvmtitblmvq82","tag_id":"cjks5i9jj004jvmtiwlf8nnfz","_id":"cjks5i9jm0052vmtiarn1key3"},{"post_id":"cjks5i9ih001yvmti2t3p94u3","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9jm0053vmtixiz9swqt"},{"post_id":"cjks5i9ih001yvmti2t3p94u3","tag_id":"cjks5i9ik0024vmtijr6y8lao","_id":"cjks5i9jn0055vmtih7u1eddl"},{"post_id":"cjks5i9ih001yvmti2t3p94u3","tag_id":"cjks5i9jh0048vmtikt061kes","_id":"cjks5i9jn0056vmtiez1vb9fz"},{"post_id":"cjks5i9ij0022vmtik58ws1zm","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9jn0058vmtino4uv7vz"},{"post_id":"cjks5i9ij0022vmtik58ws1zm","tag_id":"cjks5i9ik0024vmtijr6y8lao","_id":"cjks5i9jn0059vmti7mtl5dhc"},{"post_id":"cjks5i9ik0025vmtiqkwqc4wn","tag_id":"cjks5i9jm0050vmtiaasm7yjm","_id":"cjks5i9jo005bvmtiwl6xrgkp"},{"post_id":"cjks5i9io002hvmtin0etoskh","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9jo005cvmtioiinrlqk"},{"post_id":"cjks5i9io002hvmtin0etoskh","tag_id":"cjks5i9jj004jvmtiwlf8nnfz","_id":"cjks5i9jo005evmtii7clvi1o"},{"post_id":"cjks5i9io002hvmtin0etoskh","tag_id":"cjks5i9jj004evmti00ibwal3","_id":"cjks5i9jo005fvmtia26iaqgf"},{"post_id":"cjks5i9ir002pvmtiil1qsuul","tag_id":"cjks5i9jn005avmtigxdmgkrn","_id":"cjks5i9jp005hvmtiwjxb0ota"},{"post_id":"cjks5i9ir002pvmtiil1qsuul","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9jp005ivmtid3d76aa6"},{"post_id":"cjks5i9is002svmtir6k2ba7e","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9jp005kvmti2tqcyt9i"},{"post_id":"cjks5i9is002svmtir6k2ba7e","tag_id":"cjks5i9ik0024vmtijr6y8lao","_id":"cjks5i9jp005lvmtifqiqkqao"},{"post_id":"cjks5i9is002svmtir6k2ba7e","tag_id":"cjks5i9jo005dvmtiyfjvetas","_id":"cjks5i9jq005nvmti3x9joa0i"},{"post_id":"cjks5i9iu002wvmticng7tsqw","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9jq005ovmtiofac51kr"},{"post_id":"cjks5i9iu002wvmticng7tsqw","tag_id":"cjks5i9ik0024vmtijr6y8lao","_id":"cjks5i9jr005qvmtiz66osogb"},{"post_id":"cjks5i9iu002wvmticng7tsqw","tag_id":"cjks5i9jo005dvmtiyfjvetas","_id":"cjks5i9jr005rvmtij8exfqx3"},{"post_id":"cjks5i9iv002zvmti4e3alwck","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9jr005svmtis0ypa057"},{"post_id":"cjks5i9iv002zvmti4e3alwck","tag_id":"cjks5i9ik0024vmtijr6y8lao","_id":"cjks5i9js005uvmtinngpmsw1"},{"post_id":"cjks5i9iv002zvmti4e3alwck","tag_id":"cjks5i9jo005dvmtiyfjvetas","_id":"cjks5i9js005vvmtifx2uo0a7"},{"post_id":"cjks5i9j1003dvmtif2e2825h","tag_id":"cjks5i9jp005mvmtii03z6qz0","_id":"cjks5i9js005xvmti52a6q5c7"},{"post_id":"cjks5i9j1003dvmtif2e2825h","tag_id":"cjks5i9jq005pvmtii6cv2x48","_id":"cjks5i9js005yvmtiupn7fwu9"},{"post_id":"cjks5i9j2003hvmti5wggrw47","tag_id":"cjks5i9jr005tvmtiay6drdw9","_id":"cjks5i9jt0060vmti6gcrv92c"},{"post_id":"cjks5i9j2003hvmti5wggrw47","tag_id":"cjks5i9hq0009vmtiqnz8u99v","_id":"cjks5i9jt0061vmtix0jsmkkr"},{"post_id":"cjks5i9j5003kvmtiweuhvg58","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9jt0063vmti1ilkzot1"},{"post_id":"cjks5i9j5003kvmtiweuhvg58","tag_id":"cjks5i9ig001wvmtiu3c1fslz","_id":"cjks5i9jt0064vmtiy8nkgn4i"},{"post_id":"cjks5i9j5003kvmtiweuhvg58","tag_id":"cjks5i9js005wvmtictxrtvb1","_id":"cjks5i9ju0066vmtit6r26m34"},{"post_id":"cjks5i9j6003ovmtid6dme1xx","tag_id":"cjks5i9jr005tvmtiay6drdw9","_id":"cjks5i9ju0067vmtiitp4bi9q"},{"post_id":"cjks5i9j6003ovmtid6dme1xx","tag_id":"cjks5i9hq0009vmtiqnz8u99v","_id":"cjks5i9ju0068vmtipg31430i"},{"post_id":"cjks5i9jg0045vmtizgl5tce0","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9jv0069vmtiekn4jxd6"},{"post_id":"cjks5i9jg0045vmtizgl5tce0","tag_id":"cjks5i9jt0062vmtiu8l4j4cs","_id":"cjks5i9jv006avmtivviih8qa"},{"post_id":"cjks5i9jh0049vmtiuw3duke3","tag_id":"cjks5i9hn0004vmtinpdpwaqg","_id":"cjks5i9jv006bvmtie9gb3lnu"},{"post_id":"cjks5i9jh0049vmtiuw3duke3","tag_id":"cjks5i9jt0062vmtiu8l4j4cs","_id":"cjks5i9jv006cvmtizbm8xrhv"}],"Tag":[{"name":"JavaScript","_id":"cjks5i9hn0004vmtinpdpwaqg"},{"name":"项目经验","_id":"cjks5i9hq0009vmtiqnz8u99v"},{"name":"Angular","_id":"cjks5i9hu000evmtixiztfkbj"},{"name":"CSS","_id":"cjks5i9i50012vmtirrwcoyu8"},{"name":"移动端","_id":"cjks5i9i70018vmti0mxr2vs0"},{"name":"Flutter","_id":"cjks5i9ia001hvmtixyuf7aa2"},{"name":"Hexo","_id":"cjks5i9id001ovmtib5a3qc40"},{"name":"H5","_id":"cjks5i9ig001wvmtiu3c1fslz"},{"name":"React","_id":"cjks5i9ik0024vmtijr6y8lao"},{"name":"API","_id":"cjks5i9iw0030vmti4do8uh21"},{"name":"移动Web","_id":"cjks5i9j2003evmtip4zab8n4"},{"name":"Git","_id":"cjks5i9j9003svmti935pmgqz"},{"name":"Redux","_id":"cjks5i9jh0048vmtikt061kes"},{"name":"gulp","_id":"cjks5i9jj004evmti00ibwal3"},{"name":"构建工具","_id":"cjks5i9jj004jvmtiwlf8nnfz"},{"name":"git","_id":"cjks5i9jm0050vmtiaasm7yjm"},{"name":"面试","_id":"cjks5i9jn005avmtigxdmgkrn"},{"name":"Webpack","_id":"cjks5i9jo005dvmtiyfjvetas"},{"name":"前端","_id":"cjks5i9jp005mvmtii03z6qz0"},{"name":"汇总","_id":"cjks5i9jq005pvmtii6cv2x48"},{"name":"微信小程序","_id":"cjks5i9jr005tvmtiay6drdw9"},{"name":"微信分享","_id":"cjks5i9js005wvmtictxrtvb1"},{"name":"面向对象","_id":"cjks5i9jt0062vmtiu8l4j4cs"}]}}