{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","path":"css/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/maupassant/README.md","hash":"922df2e62346508fb4af6d7d3590f5ae0d543ea3","modified":1465477346000},{"_id":"themes/maupassant/_config.yml","hash":"a0483054b88245d039e7411b442f16181323d984","modified":1465489040000},{"_id":"themes/maupassant/.travis.yml","hash":"f8da426b97088e4caa5226cff219a5d95087961f","modified":1465477346000},{"_id":"themes/maupassant/package.json","hash":"04ca87ea475f37841d3610fe5806feb8022416c3","modified":1465477346000},{"_id":"source/_posts/ES6.md","hash":"b12b262f74ab9dda6dcb2bf62088b83e14ec7c7a","modified":1480209321840},{"_id":"themes/maupassant/LICENSE","hash":"b7ea1dbb2fed3410d78bc7c125e1d80927b56981","modified":1465477346000},{"_id":"source/_posts/LICENSE","hash":"e4e4a3cb562a55cc2c5c849eb51145c502b6291e","modified":1480209321848},{"_id":"source/_posts/H5页面.md","hash":"c7b650cff420a9384a61aa26f4f074aaecbc98d3","modified":1480209321845},{"_id":"source/_posts/Promise总结.md","hash":"818ff297a09e86559157b00db61b5837248153dd","modified":1480209321856},{"_id":"source/_posts/React Docs.md","hash":"b02d3d836e44864bed12b9cfc784ad9906595f75","modified":1480209321862},{"_id":"source/_posts/React Router学习.md","hash":"f873561db22bb0442a9e8f427635f8360a7716de","modified":1480209321868},{"_id":"source/_posts/fixed移动端解决.md","hash":"10bcbef51c2b21c717b85519ea94c18afc7347a8","modified":1480209321871},{"_id":"source/_posts/redux学习.md","hash":"24b1f3f9a846fd8884d6c5231d35e1451fba9cfc","modified":1480209321891},{"_id":"source/_posts/gulp初次实践.md","hash":"699f72ad9e0e8eb8b93ed4ade8fdb7e03861052a","modified":1480209321878},{"_id":"source/_posts/redux应用于React.md","hash":"129eb4e6dc7d4d7ad95c2e50d5d8260af7bca0a9","modified":1480209321898},{"_id":"source/_posts/一次麻烦的投票.md","hash":"19fbe5e79c0c1169413e5851e1e956bd0e5194a0","modified":1480209321901},{"_id":"source/_posts/一次H5页面.md","hash":"12cd8004c46512c2aaec425de4f52dbb66486a07","modified":1471182186000},{"_id":"source/_posts/今天的面试.md","hash":"63250abab8c59ab8f032f66b3328c2b88fa5fc32","modified":1471182072000},{"_id":"source/_posts/为gulp添加更多.md","hash":"8f36d9334a3cf633874b80c99a4f2923d0b781f4","modified":1480209321906},{"_id":"source/_posts/从零搭建React(1).md","hash":"53bc57696dafa15192cfb13c108c7bb2241f9fc5","modified":1480209321919},{"_id":"source/_posts/利用Github+Hexo搭建博客过程.md","hash":"d8b7cf0b8f4f9981d4120245532dbeea1ca1a017","modified":1471182086000},{"_id":"source/_posts/函数节流.md","hash":"3604db2507725111a9fb42822396a7e55928a0cc","modified":1480209321939},{"_id":"source/_posts/从零搭建React(2).md","hash":"bdc42d3548dd898e984aa4920fee688fc47566d1","modified":1480209321926},{"_id":"source/_posts/从零搭建React(3).md","hash":"a9e7e3db824855870669ca5411660442b76957a1","modified":1480209321933},{"_id":"source/_posts/前端工具","hash":"b5d8109a0e249e89c5e044d8d34595ba5562f09f","modified":1480209321943},{"_id":"source/_posts/我的首个Hexo博客.md","hash":"ee74aea797835aaa8bfbd787f492b673d920cd9c","modified":1465481868000},{"_id":"source/_posts/前端技术栈.md","hash":"609463c473175c7ca9d80eb1039b397d30aac1a9","modified":1480209321947},{"_id":"source/_posts/起点H5分析.md","hash":"4158e23f857e2a6a63911bf592eb61a318351b9f","modified":1480209321954},{"_id":"source/_posts/微信分享绝对是个坑.md","hash":"fd8ff2dd719f3a705fb30d8fc6081bb4e5422218","modified":1480209321952},{"_id":"source/_posts/面向对象的javascript(继承).md","hash":"8d830f6bee7d80da0e5ad3a6077a8798a542ee70","modified":1471182130000},{"_id":"themes/maupassant/layout/archive.jade","hash":"d70d1ed241b1a431a2434768d02bb2de03070f70","modified":1465477346000},{"_id":"source/_posts/面向对象的javascript.md","hash":"33f590e18d0bc5b7379794a836836596ff0f1f61","modified":1471182138000},{"_id":"themes/maupassant/layout/page.jade","hash":"1e98aa785073dc1bbfe70f2863bc19fe287483b9","modified":1465477346000},{"_id":"themes/maupassant/layout/base.jade","hash":"3af9622734a458b6259a2530ea0c4d9a2b1095c8","modified":1465477346000},{"_id":"themes/maupassant/layout/index.jade","hash":"3fe1f0c5021ac696ed9846ecb1c75d285fa46708","modified":1465477346000},{"_id":"themes/maupassant/layout/post.jade","hash":"f68f483242409f501bbc8b50ff129edd981087e2","modified":1465477346000},{"_id":"themes/maupassant/layout/timeline.jade","hash":"ee1e8e4e8fdf61c6d19f1f7fe31ab50ab1465a8d","modified":1465477346000},{"_id":"themes/maupassant/languages/en.yml","hash":"6c5fc2cec7e44306d97bc7902e9765389d21c363","modified":1465477346000},{"_id":"themes/maupassant/languages/ko.yml","hash":"a454bcec60113507bc1d593a699849822386c196","modified":1465477346000},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"3cc9312fbdba4a8f8e8254804121e4724c719bcc","modified":1465477346000},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"3a50568f200b9c1258415b53727e42c6b6c7ea0b","modified":1465477346000},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"25d1d8cd8113045a7603c14af1ea1539fc6456ed","modified":1465477346000},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"41f7c09365cbd5ba1b8906191ee07bc75094185a","modified":1465477346000},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1465477346000},{"_id":"themes/maupassant/.git/config","hash":"fb9cab07ffe3866880dd7f679478429b9de1d5c3","modified":1465477346000},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"46659764e31c7866af436d98d4fabb9da122037a","modified":1465477346000},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1465477336000},{"_id":"themes/maupassant/.git/packed-refs","hash":"e3cb7fdef9a716ec7720ef1fc4fe71e6e900895e","modified":1465477346000},{"_id":"themes/maupassant/.git/index","hash":"e8a85900d2528c10ee52674c04253406d4ab1707","modified":1465477346000},{"_id":"themes/maupassant/layout/_partial/comments.jade","hash":"b3a0b0ce0642f2bfe9df94b075c0c2a083871e1b","modified":1465477346000},{"_id":"source/_posts/images/Promise_Object.png","hash":"6df0592eba8d2fdb744cadc93b50f2846d4e427d","modified":1480209321879},{"_id":"themes/maupassant/layout/_partial/footer.jade","hash":"87e096caac8e780c0894ef1844f59246f861bbe7","modified":1465477346000},{"_id":"themes/maupassant/layout/_partial/mathjax.jade","hash":"ac6e3a92bf18ab6bbd0e041b6796b295bae963ee","modified":1465477346000},{"_id":"themes/maupassant/layout/_partial/tag.jade","hash":"6145b483b271bba05ad1db7c039fe352a768215b","modified":1465477346000},{"_id":"themes/maupassant/layout/_partial/helpers.jade","hash":"9e44f6d32f2449b4109c33118f8285fa2fc7b023","modified":1465477346000},{"_id":"themes/maupassant/layout/_partial/mathjax2.jade","hash":"234a792e64ba208fa97d2f99772ece23056a53ec","modified":1465477346000},{"_id":"themes/maupassant/layout/_partial/paginator.jade","hash":"03ad0c49ae6f8a999ae35b38d08e25775f51f52a","modified":1465477346000},{"_id":"themes/maupassant/layout/_partial/post_nav.jade","hash":"b11d9e6000449838b17f508429f29ffb60f53096","modified":1465477346000},{"_id":"themes/maupassant/layout/_widget/category.jade","hash":"80271e02432ab9990c0c07d84aab155f1fb81749","modified":1465477346000},{"_id":"themes/maupassant/layout/_partial/after_footer.jade","hash":"7e69266c3d1b9d872617046ca0630998200072fd","modified":1465477346000},{"_id":"themes/maupassant/layout/_partial/totop.jade","hash":"eb91a3baf9411188c7c8130f63a674f541ca9c81","modified":1465477346000},{"_id":"themes/maupassant/layout/_widget/links.jade","hash":"2a1dd6a0e2befd073e3347347994d8dcd2047879","modified":1465477346000},{"_id":"themes/maupassant/layout/_widget/recent_comments.jade","hash":"0b9e78e7f20bc69690e05f2e0c956bded9058a84","modified":1465477346000},{"_id":"themes/maupassant/layout/_widget/tag.jade","hash":"37f236365b153fc40324391e5a602d6d50014e18","modified":1465477346000},{"_id":"themes/maupassant/layout/_widget/recent_posts.jade","hash":"770b6c41cbf7969ed33adf87eec3be6f50a0911b","modified":1465477346000},{"_id":"themes/maupassant/layout/_widget/search.jade","hash":"c5301ca7f2ec24d790fd7f35f69f8fd8acbdb725","modified":1465477346000},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"8a993c1c4ad40789d2960b682cb2130382a0f26a","modified":1465477346000},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"c77270e684a60babc1abb7353e700ecdc5a66d30","modified":1465477346000},{"_id":"themes/maupassant/source/css/style.scss","hash":"8b632f036d9674757f68acd1874a09d4ed0808a6","modified":1465526868000},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","hash":"0d142e11e27e9de1a325c32369c42254101ddd34","modified":1465477346000},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"150ab1cad40d7ae081b0896b13f7d7cbac4e6338","modified":1465477346000},{"_id":"themes/maupassant/source/js/share.js","hash":"bb6880e2e8e187b576daf326476f09b0907fbe14","modified":1465477346000},{"_id":"themes/maupassant/source/js/totop.js","hash":"15de186b089c245fe60766d509b587919f05ff23","modified":1465477346000},{"_id":"themes/maupassant/source/js/search.js","hash":"9cf2337fe9af34055782880ac27b93713d74581f","modified":1465477346000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1465477346000},{"_id":"themes/maupassant/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1465477346000},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1465477346000},{"_id":"themes/maupassant/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1465477336000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1465477346000},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"ed3bd495fd2def519dbb04f64be654bbb143a779","modified":1465477346000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1465477346000},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"86b9655a9ebbde13ac8dd5795eb4d5b539edab0f","modified":1465477336000},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"42fa41564917b44183a50c4d94bb03e1768ddad8","modified":1465477336000},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1465477336000},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1465477336000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1465477346000},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"b4ad74c989616b7395dc6c9fce9871bb1e86dfb5","modified":1465477336000},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1465477336000},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1465477336000},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1465477336000},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"8f5cebc785d2fe0fb16a1cb94260b56963d4c19b","modified":1465477346000},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1465477336000},{"_id":"themes/maupassant/.git/objects/pack/pack-b52026a5b96bac87bcf145626f1f974df99eb953.idx","hash":"8604dba41a6648019faaa92f9d5abc1b955620c7","modified":1465477346000},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1465477346000},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"ed3bd495fd2def519dbb04f64be654bbb143a779","modified":1465477346000},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"ed3bd495fd2def519dbb04f64be654bbb143a779","modified":1465477346000},{"_id":"source/_posts/images/triangles.png","hash":"9ed6e83d13b3c1ff2ec693440234a7f60b1d65cf","modified":1480209321883},{"_id":"themes/maupassant/.git/objects/pack/pack-b52026a5b96bac87bcf145626f1f974df99eb953.pack","hash":"08f0d8bee80d2751dc47b4d4d40299da007711f3","modified":1465477346000},{"_id":"public/2016/11/28/前端技术栈/index.html","hash":"7f3898c7255f8668767b96f2167b2d920d1251e8","modified":1480431093663},{"_id":"public/2016/10/31/一次麻烦的投票/index.html","hash":"80e4aab131aefbd841fb51f76a2d7228c74f2008","modified":1480431093663},{"_id":"public/2016/08/10/起点H5分析/index.html","hash":"ecc414d5bd624f585fe9551000325410de8305c2","modified":1480431093663},{"_id":"public/2016/08/08/微信分享绝对是个坑/index.html","hash":"0d47978312ee4537064e6d86eb6bec3a57ac2f5c","modified":1480431093663},{"_id":"public/2016/07/28/函数节流/index.html","hash":"58cc37bf98d9f0ef0c6dfbdbd382cab39e18d750","modified":1480431093663},{"_id":"public/2016/07/23/为gulp添加更多/index.html","hash":"b5b9b1174178f9183a82e05fc2cffd2d2dcb86b4","modified":1480431093663},{"_id":"public/2016/06/13/今天的面试/index.html","hash":"a803887d46624ac6c5966bdd4470172e947d397e","modified":1480431093663},{"_id":"public/2016/06/09/利用Github+Hexo搭建博客过程/index.html","hash":"73b729b108959dea6df7fb78dde7789d49ffb702","modified":1480431093663},{"_id":"public/2016/06/09/我的首个Hexo博客/index.html","hash":"e9f6e72d63da30a599f4563d01628486fe75315f","modified":1480431093663},{"_id":"public/archives/index.html","hash":"fafc44e5295038daa445b6d044b682918e6e82bf","modified":1480431093663},{"_id":"public/archives/page/2/index.html","hash":"7d797bfb337e1dad9ab01c3573194843107c9a24","modified":1480431093663},{"_id":"public/archives/page/3/index.html","hash":"4e2ae2e295605c873e954f28b5f2cbc1d447266d","modified":1480431093663},{"_id":"public/2016/11/28/redux学习/index.html","hash":"828b684017ad26766cb90653cc13bd461ee33fae","modified":1480431093663},{"_id":"public/2016/11/28/ES6/index.html","hash":"e756a069725951414c21fe3685e8f48cc2796cb1","modified":1480431093663},{"_id":"public/2016/11/28/React Docs/index.html","hash":"c44154eae1d1c0db8a38a3b7eece8408649059bd","modified":1480431093663},{"_id":"public/2016/11/16/从零搭建React(3)/index.html","hash":"b7d4349336a34297efc6f2e6a230cde8c73216dc","modified":1480431093663},{"_id":"public/2016/11/25/Promise总结/index.html","hash":"bb51583493cf4251bdf15771d035984bb75a1d52","modified":1480431093663},{"_id":"public/2016/11/28/gulp初次实践/index.html","hash":"64e21b1cb3309a1859f2fb5b4973cb881194adca","modified":1480431093663},{"_id":"public/2016/09/22/redux应用于React/index.html","hash":"b1eec2cb18c089785371b89b32d4260fe25aacae","modified":1480431093679},{"_id":"public/2016/08/24/React Router学习/index.html","hash":"734db740d143caf6ae1ae635b2546e280012ed1d","modified":1480431093679},{"_id":"public/2016/11/14/从零搭建React(1)/index.html","hash":"bf805b61075074992ed57c2e421604169525b69b","modified":1480431093679},{"_id":"public/2016/11/14/从零搭建React(2)/index.html","hash":"c04e4fbf5ad4de9133c4eb77689ef6e7870ddf7b","modified":1480431093679},{"_id":"public/2016/08/03/H5页面/index.html","hash":"8e194e98feb97f764bbef31533db325c4c73c33b","modified":1480431093679},{"_id":"public/2016/08/03/一次H5页面/index.html","hash":"3effc8f37062a70962b20ddbec702162ce55f91e","modified":1480431093679},{"_id":"public/2016/06/21/面向对象的javascript(继承)/index.html","hash":"505c543d207f16703f9efd5194050e1536bd495b","modified":1480431093679},{"_id":"public/2016/06/17/面向对象的javascript/index.html","hash":"dc3e359c2e9f2ccb83a9d4f069f4c7b4537fac59","modified":1480431093679},{"_id":"public/2016/07/29/fixed移动端解决/index.html","hash":"4534e3e59ec419e342326f740637eeaf03a51d51","modified":1480431093679},{"_id":"public/archives/2016/index.html","hash":"b5f4cae1e7b0cc9b986a796a80fac1f262afa5d2","modified":1480431093685},{"_id":"public/archives/2016/page/3/index.html","hash":"74d397852e5c1f9d75fa975cc2d5ef4fb639c3e7","modified":1480431093685},{"_id":"public/archives/2016/06/index.html","hash":"85b6a2a01a3635620e8a9b2ca2a8c99fc0fe1408","modified":1480431093685},{"_id":"public/archives/2016/page/2/index.html","hash":"adb555d431d14d08eafb6083017be68e2fe8bc34","modified":1480431093685},{"_id":"public/archives/2016/07/index.html","hash":"d77e16f18ab1d5a451870fc51ac0221a2ad5649b","modified":1480431093685},{"_id":"public/archives/2016/08/index.html","hash":"d6a7385e20bd3ea85da869e566050be45f5a3954","modified":1480431093685},{"_id":"public/categories/H5/index.html","hash":"0c4260a4d0643af2b297cb13d6f7b31ee336abec","modified":1480431093685},{"_id":"public/archives/2016/09/index.html","hash":"9324d3da4e708a2b7e07a7475306183c7d831991","modified":1480431093685},{"_id":"public/categories/javascript/index.html","hash":"e95d35ad34a336f76f5462fb48040f451a333f4f","modified":1480431093685},{"_id":"public/categories/杂记/index.html","hash":"72efb621fb64e2043ab1c0337097155a4f3dcc36","modified":1480431093685},{"_id":"public/archives/2016/10/index.html","hash":"2957f55c7839631e8905b7534633e706cf81f8bc","modified":1480431093685},{"_id":"public/categories/React/index.html","hash":"818e118bab4d125ca688103cfd781996e57720bf","modified":1480431093685},{"_id":"public/archives/2016/11/index.html","hash":"aca3b74c0cc9d05e8565d9476dfc98886a329594","modified":1480431093685},{"_id":"public/page/3/index.html","hash":"6c513cfc02db32960aaf5b4a8808839c45923872","modified":1480431093685},{"_id":"public/tags/javascript/index.html","hash":"b0c8c3506d23dcff5bf318fe60ca88b29c72f554","modified":1480431093685},{"_id":"public/tags/javascript-H5/index.html","hash":"ccc0130b39e3ea84bfcf486f52e0ded160dd3470","modified":1480431093685},{"_id":"public/tags/javascript-移动Web/index.html","hash":"d08c7e3b84c3930dab4e524edf87bd4acefa08fc","modified":1480431093685},{"_id":"public/tags/javascript-React/index.html","hash":"8cc13b88f048d410860b9736d668b88e384f00df","modified":1480431093685},{"_id":"public/tags/javascript-React-redux/index.html","hash":"0d57f23085c7f7f780559e3bcabeede7de9e226e","modified":1480431093685},{"_id":"public/tags/javascript-项目经验/index.html","hash":"e5e3669074aa40bad698606473ea74f9e1e07fa5","modified":1480431093685},{"_id":"public/tags/H5/index.html","hash":"18ac5b5c6aa1ca4972b48e14d48e45cc7ed08add","modified":1480431093685},{"_id":"public/tags/面试/index.html","hash":"3a5d24b1b4b85e9447e30cdbe30f479b8504b2c7","modified":1480431093685},{"_id":"public/tags/javascript-构建工具-gulp/index.html","hash":"a8d2e7d57e12776d01f7ee1fac595dcfca2a5dd7","modified":1480431093685},{"_id":"public/tags/javascript-React-Webpack/index.html","hash":"1c05872677658ff12ec7202af5dd6ddb04e2c999","modified":1480431093685},{"_id":"public/tags/Hexo/index.html","hash":"8edffdb7f79e619a2133327a7529ebc9131a4de7","modified":1480431093685},{"_id":"public/tags/搭建博客/index.html","hash":"394b2c4d88c9d27bcdc9eeadc2ac5aa7f8ef413d","modified":1480431093685},{"_id":"public/tags/javascript-H5-微信分享/index.html","hash":"54905d953cfd16f9d388bca0d6c71ed5f86568de","modified":1480431093685},{"_id":"public/tags/面向对象/index.html","hash":"74a8e4444b3b4840482030c6459a4d9a3faaf901","modified":1480431093685},{"_id":"public/index.html","hash":"820fff0b46e84fa0cce1848c4f3fbff5b00f3daf","modified":1480431093685},{"_id":"public/page/2/index.html","hash":"d30dc91fc631ec01ebc524c6e553411c0ff74157","modified":1480431093685},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1480431093685},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1480431093685},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1480431093685},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1480431093685},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1480431093685},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1480431093685},{"_id":"public/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1480431093716},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1480431093716},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1480431093716},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1480431093716},{"_id":"public/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1480431093716},{"_id":"public/js/search.js","hash":"53db2eb255dd40a412ed62ea7332ca5a22f7816f","modified":1480431093716},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1480431093716},{"_id":"public/css/style.css","hash":"5e031463c49be0e099889655aaec8538d489b43d","modified":1480431093716}],"Category":[{"name":"H5","_id":"ciw3mfvsr00030kc7l6awsews"},{"name":"javascript","_id":"ciw3mfvt700080kc724voed2f"},{"name":"杂记","_id":"ciw3mfvtn000u0kc76bg4vgoy"},{"name":"React","_id":"ciw3mfvu200130kc7wugl5782"}],"Data":[],"Page":[],"Post":[{"_content":"From [点击这里](http://mp.weixin.qq.com/s?__biz=MzAxMjA5ODQwMQ==&mid=2455058700&idx=1&sn=9361036ef5dc0c27cafb0612d495a85c)\n## ES6\n### 定义变量：let、const\n* let、const声明变量为块级作用域，var声明为函数作用域\n* let声明不具备变量提升，const声明具备\n* const用于声明常量，必须声明时赋值\n* let、const声明变量不能再次声明覆盖\n### 函数声明：箭头函数\n缘由\n\nps:\n```\n// 六种语言中的简单函数示例\nfunction (a) { return a > 0; } // JS\n[](int a) { return a > 0; }  // C++\n(lambda (a) (> a 0))  ;; Lisp\nlambda a: a > 0  # Python\na => a > 0  // C#\na -> a > 0  // Java\n```\n1. 情况一 a => a > 0   相当于 function(a) { return a > 0 }  tag:单个参数、直接返回\n2. 情况二 (a, b) => a + b  相当于 function(a, b) { return a + b }  tag:多个参数、直接返回\n3. 情况三 （a, b）=> { a + b ... }  相当于 function(a, b) { a + b ... } tag:函数体，返回需要自己写return语句\n4. 情况四  (a, b) => ({a: 'a'}) 相当于 function(a, b) { return {a: 'a'} } tab:直接返回对象，因为=>后面的{}会被理解为函数体，添加()才会被理解为对象\n\n* 箭头函数相当于匿名函数的简写\n* 箭头函数的this总是和外层函数的this指向相同。\n\teg.\n```javascript\n// ES5\nfunction Person() {\n  var self = this;\n  self.age = 0;\n\n  setInterval(function growUp() {\n  \t// this会指向windows\n  \t// 所以用self保存了this\n    self.age++;\n  }, 1000);\n}\n// ES6\nfunction Person(){\n  this.age = 0;\n\n  setInterval(() => {\n    // |this| 指向 person 对象\n    this.age++;\n  }, 1000);\n}\n\nvar person = new Person();\n```\n### for...of \n1. for...of  遍历数组,遍历字符串,对象没有该方法\n```javascript\nlet nicknames = ['di', 'boo', 'punkeye'];\nfor (let nickname of nicknames) {\n  console.log(nickname);\n}\nResult: di, boo, punkeye\n```\n2. for...in  遍历对象，数组也能够使用该方法\n```javascript\nlet nicknames = ['di', 'boo', 'punkeye'];\nnicknames.size = 3;\nfor (let nickname in nicknames) {\n  console.log(nickname); // 0 1 2 size\n}\n```\n### 类Class\n```javascript\n// ES5 定义类\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n// 相当于 ES6中\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  // 不需要添加function，方法和方法之间不能用逗号隔开\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\ntyof Point // function  说明Class只是一个语法糖\nPoint === Point.prototype.constructor // true\n```\n* new className()会自动调用constructor()\n* class定义的类只能通过new操作符，不能直接调用\n* 通过class只能定义在construtor中的共有属性，不能定义私有属性，定义的方法也都是相当于定义在prototype上的共有方法\n* 与ES5中定义在prototype不同在于不可枚举\n* 与ES5相同，所有实例共享原型。所以通过实例的__proto__属性可以为Class添加方法\n* 不存在变量提升，Class定义与ES5不同\n\n### 继承extends\n在使用extends继承时，子类的constructor中必须先调用super()方法，也就是父类的构造方法。\n\n### 对象超类\n```javascript\nvar parent = {\n  foo() {\n    console.log(\"Hello from the Parent\");\n  }\n}\n\nvar child = {\n  foo() {\n    super.foo();\n    console.log(\"Hello from the Child\");\n  }\n}\n\nObject.setPrototypeOf(child, parent); // ES6设置对象原型的方法\nchild.foo(); // Hello from the Parent\n             // Hello from the Child\n```\n### Promise\nPromise对象有三种状态：Pending、Resolved，Rejected，外界无法改变状态，状态一旦改变就不会再变。\n```javascript\nvar promise = new Promise(function(resolve, reject) {\n\t// ... some code\n\n\tif(/* 异步操作成功 */) {\n\t\tresolve(value);  // 将promise状态变为Resolved\n\t} else {\n\t\treject(error);\n\t}\n});\n\npromise.then(function(value) {\n\t// success\n}, function(error) {\n\t// failure\n})\n```\nps:\n\n一个用Promise实现Ajax操作的例子\n```javascript\nvar getJSON = function(url) {\n\tvar promise = new Promise(function(resolve, reject) {\n\t\tvar client = new XMLHttpRequest();\n\t\tclient.open('GET', url);\n\t\tclient.onreadystatechange = handler;\n\t\tclient.responseType = 'json';\n\t\tclient.setRequestHeader('Accept', 'application/json');\n\t\tclient.send();\n\n\t\tfunction handler() {\n\t\t\tif(this.readyState !== 4) {\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tif(this.status === 200) {\n\t\t\t\tresolve(this.response);\n\t\t\t} else {\n\t\t\t\treject(new Error(this.statusText));\n\t\t\t}\n\t\t};\n\t});\n\n\treturn promise;\n}\n```\n### 模板语法和分隔符\n```javascript\nlet user = 'Barret';\nconsole.log(`Hi ${user}!`); // Hi Barret\n```\n\n### 对象扩展\n```javascript\nfunction getCar(make, model, value) {\n  return {\n    // 简写变量\n    make,  // 等同于 make: make\n    model, // 等同于 model: model\n    value, // 等同于 value: value\n\n    // 属性可以使用表达式计算值\n    ['make' + make]: true,\n\n    // 忽略 `function` 关键词简写对象函数\n    depreciate() {\n      this.value -= 2500;\n    }\n  };\n}\n```\n### 对象和数组解构\n```javascript\nfunction foo() {\n  return [1,2,3];\n}\nlet arr = foo(); // [1,2,3]\n\nlet [a, b, c] = foo();\nconsole.log(a, b, c); // 1 2 3\n\nfunction bar() {\n  return {\n    x: 4,\n    y: 5,\n    z: 6\n  };\n}\nlet {x: x, y: y, z: z} = bar();\nconsole.log(x, y, z); // 4 5 6\n```\n### 迭代器\n通过[Symbol.iterator]()定义一个对象的迭代器\n```javascript\nvar arr = [11,12,13];\nvar itr = arr[Symbol.iterator]();\n\nitr.next(); // { value: 11, done: false }\nitr.next(); // { value: 12, done: false }\nitr.next(); // { value: 13, done: false }\n\nitr.next(); // { value: undefined, done: true }\n```\n\n### 扩展操作符...\n貌似只能用于参数传递\n1. 情况一 \n```javascript\nfunction foo(x,y,z) {\n  console.log(x,y,z);\n}\n\nlet arr = [1,2,3];\nfoo(...arr); // 1 2 3\n```\n2. 情况二\n```javascript\nfunction foo(...args) {\n  console.log(args);\n}\nfoo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]\n```","source":"_posts/ES6.md","raw":"From [点击这里](http://mp.weixin.qq.com/s?__biz=MzAxMjA5ODQwMQ==&mid=2455058700&idx=1&sn=9361036ef5dc0c27cafb0612d495a85c)\n## ES6\n### 定义变量：let、const\n* let、const声明变量为块级作用域，var声明为函数作用域\n* let声明不具备变量提升，const声明具备\n* const用于声明常量，必须声明时赋值\n* let、const声明变量不能再次声明覆盖\n### 函数声明：箭头函数\n缘由\n\nps:\n```\n// 六种语言中的简单函数示例\nfunction (a) { return a > 0; } // JS\n[](int a) { return a > 0; }  // C++\n(lambda (a) (> a 0))  ;; Lisp\nlambda a: a > 0  # Python\na => a > 0  // C#\na -> a > 0  // Java\n```\n1. 情况一 a => a > 0   相当于 function(a) { return a > 0 }  tag:单个参数、直接返回\n2. 情况二 (a, b) => a + b  相当于 function(a, b) { return a + b }  tag:多个参数、直接返回\n3. 情况三 （a, b）=> { a + b ... }  相当于 function(a, b) { a + b ... } tag:函数体，返回需要自己写return语句\n4. 情况四  (a, b) => ({a: 'a'}) 相当于 function(a, b) { return {a: 'a'} } tab:直接返回对象，因为=>后面的{}会被理解为函数体，添加()才会被理解为对象\n\n* 箭头函数相当于匿名函数的简写\n* 箭头函数的this总是和外层函数的this指向相同。\n\teg.\n```javascript\n// ES5\nfunction Person() {\n  var self = this;\n  self.age = 0;\n\n  setInterval(function growUp() {\n  \t// this会指向windows\n  \t// 所以用self保存了this\n    self.age++;\n  }, 1000);\n}\n// ES6\nfunction Person(){\n  this.age = 0;\n\n  setInterval(() => {\n    // |this| 指向 person 对象\n    this.age++;\n  }, 1000);\n}\n\nvar person = new Person();\n```\n### for...of \n1. for...of  遍历数组,遍历字符串,对象没有该方法\n```javascript\nlet nicknames = ['di', 'boo', 'punkeye'];\nfor (let nickname of nicknames) {\n  console.log(nickname);\n}\nResult: di, boo, punkeye\n```\n2. for...in  遍历对象，数组也能够使用该方法\n```javascript\nlet nicknames = ['di', 'boo', 'punkeye'];\nnicknames.size = 3;\nfor (let nickname in nicknames) {\n  console.log(nickname); // 0 1 2 size\n}\n```\n### 类Class\n```javascript\n// ES5 定义类\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n// 相当于 ES6中\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  // 不需要添加function，方法和方法之间不能用逗号隔开\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\ntyof Point // function  说明Class只是一个语法糖\nPoint === Point.prototype.constructor // true\n```\n* new className()会自动调用constructor()\n* class定义的类只能通过new操作符，不能直接调用\n* 通过class只能定义在construtor中的共有属性，不能定义私有属性，定义的方法也都是相当于定义在prototype上的共有方法\n* 与ES5中定义在prototype不同在于不可枚举\n* 与ES5相同，所有实例共享原型。所以通过实例的__proto__属性可以为Class添加方法\n* 不存在变量提升，Class定义与ES5不同\n\n### 继承extends\n在使用extends继承时，子类的constructor中必须先调用super()方法，也就是父类的构造方法。\n\n### 对象超类\n```javascript\nvar parent = {\n  foo() {\n    console.log(\"Hello from the Parent\");\n  }\n}\n\nvar child = {\n  foo() {\n    super.foo();\n    console.log(\"Hello from the Child\");\n  }\n}\n\nObject.setPrototypeOf(child, parent); // ES6设置对象原型的方法\nchild.foo(); // Hello from the Parent\n             // Hello from the Child\n```\n### Promise\nPromise对象有三种状态：Pending、Resolved，Rejected，外界无法改变状态，状态一旦改变就不会再变。\n```javascript\nvar promise = new Promise(function(resolve, reject) {\n\t// ... some code\n\n\tif(/* 异步操作成功 */) {\n\t\tresolve(value);  // 将promise状态变为Resolved\n\t} else {\n\t\treject(error);\n\t}\n});\n\npromise.then(function(value) {\n\t// success\n}, function(error) {\n\t// failure\n})\n```\nps:\n\n一个用Promise实现Ajax操作的例子\n```javascript\nvar getJSON = function(url) {\n\tvar promise = new Promise(function(resolve, reject) {\n\t\tvar client = new XMLHttpRequest();\n\t\tclient.open('GET', url);\n\t\tclient.onreadystatechange = handler;\n\t\tclient.responseType = 'json';\n\t\tclient.setRequestHeader('Accept', 'application/json');\n\t\tclient.send();\n\n\t\tfunction handler() {\n\t\t\tif(this.readyState !== 4) {\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tif(this.status === 200) {\n\t\t\t\tresolve(this.response);\n\t\t\t} else {\n\t\t\t\treject(new Error(this.statusText));\n\t\t\t}\n\t\t};\n\t});\n\n\treturn promise;\n}\n```\n### 模板语法和分隔符\n```javascript\nlet user = 'Barret';\nconsole.log(`Hi ${user}!`); // Hi Barret\n```\n\n### 对象扩展\n```javascript\nfunction getCar(make, model, value) {\n  return {\n    // 简写变量\n    make,  // 等同于 make: make\n    model, // 等同于 model: model\n    value, // 等同于 value: value\n\n    // 属性可以使用表达式计算值\n    ['make' + make]: true,\n\n    // 忽略 `function` 关键词简写对象函数\n    depreciate() {\n      this.value -= 2500;\n    }\n  };\n}\n```\n### 对象和数组解构\n```javascript\nfunction foo() {\n  return [1,2,3];\n}\nlet arr = foo(); // [1,2,3]\n\nlet [a, b, c] = foo();\nconsole.log(a, b, c); // 1 2 3\n\nfunction bar() {\n  return {\n    x: 4,\n    y: 5,\n    z: 6\n  };\n}\nlet {x: x, y: y, z: z} = bar();\nconsole.log(x, y, z); // 4 5 6\n```\n### 迭代器\n通过[Symbol.iterator]()定义一个对象的迭代器\n```javascript\nvar arr = [11,12,13];\nvar itr = arr[Symbol.iterator]();\n\nitr.next(); // { value: 11, done: false }\nitr.next(); // { value: 12, done: false }\nitr.next(); // { value: 13, done: false }\n\nitr.next(); // { value: undefined, done: true }\n```\n\n### 扩展操作符...\n貌似只能用于参数传递\n1. 情况一 \n```javascript\nfunction foo(x,y,z) {\n  console.log(x,y,z);\n}\n\nlet arr = [1,2,3];\nfoo(...arr); // 1 2 3\n```\n2. 情况二\n```javascript\nfunction foo(...args) {\n  console.log(args);\n}\nfoo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]\n```","slug":"ES6","published":1,"date":"2016-11-28T13:34:34.066Z","updated":"2016-11-27T01:15:21.840Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw3mfvsc00000kc78btt399q","content":"<p>From <a href=\"http://mp.weixin.qq.com/s?__biz=MzAxMjA5ODQwMQ==&amp;mid=2455058700&amp;idx=1&amp;sn=9361036ef5dc0c27cafb0612d495a85c\" target=\"_blank\" rel=\"external\">点击这里</a></p>\n<h2 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h2><h3 id=\"定义变量：let、const\"><a href=\"#定义变量：let、const\" class=\"headerlink\" title=\"定义变量：let、const\"></a>定义变量：let、const</h3><ul>\n<li>let、const声明变量为块级作用域，var声明为函数作用域</li>\n<li>let声明不具备变量提升，const声明具备</li>\n<li>const用于声明常量，必须声明时赋值</li>\n<li>let、const声明变量不能再次声明覆盖<h3 id=\"函数声明：箭头函数\"><a href=\"#函数声明：箭头函数\" class=\"headerlink\" title=\"函数声明：箭头函数\"></a>函数声明：箭头函数</h3>缘由</li>\n</ul>\n<p>ps:<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 六种语言中的简单函数示例</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(a)</span> <span class=\"comment\">&#123; return a &gt; 0; &#125;</span> <span class=\"comment\">// JS</span></span></div><div class=\"line\">[]<span class=\"params\">(int a)</span> <span class=\"comment\">&#123; return a &gt; 0; &#125;</span>  <span class=\"comment\">// C++</span></div><div class=\"line\"><span class=\"params\">(lambda (a)</span> <span class=\"params\">(&gt; a 0)</span>)  ;; Lisp</div><div class=\"line\">lambda a: a &gt; <span class=\"number\">0</span>  # Python</div><div class=\"line\">a =&gt; a &gt; <span class=\"number\">0</span>  <span class=\"comment\">// C#</span></div><div class=\"line\">a -&gt; a &gt; <span class=\"number\">0</span>  <span class=\"comment\">// Java</span></div></pre></td></tr></table></figure></p>\n<ol>\n<li>情况一 a =&gt; a &gt; 0   相当于 function(a) { return a &gt; 0 }  tag:单个参数、直接返回</li>\n<li>情况二 (a, b) =&gt; a + b  相当于 function(a, b) { return a + b }  tag:多个参数、直接返回</li>\n<li>情况三 （a, b）=&gt; { a + b … }  相当于 function(a, b) { a + b … } tag:函数体，返回需要自己写return语句</li>\n<li>情况四  (a, b) =&gt; ({a: ‘a’}) 相当于 function(a, b) { return {a: ‘a’} } tab:直接返回对象，因为=&gt;后面的{}会被理解为函数体，添加()才会被理解为对象</li>\n</ol>\n<ul>\n<li>箭头函数相当于匿名函数的简写</li>\n<li>箭头函数的this总是和外层函数的this指向相同。<br>  eg.<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</div><div class=\"line\">  self.age = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">  setInterval(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">growUp</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  \t<span class=\"comment\">// this会指向windows</span></div><div class=\"line\">  \t<span class=\"comment\">// 所以用self保存了this</span></div><div class=\"line\">    self.age++;</div><div class=\"line\">  &#125;, <span class=\"number\">1000</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// ES6</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.age = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">  setInterval(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// |this| 指向 person 对象</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.age++;</div><div class=\"line\">  &#125;, <span class=\"number\">1000</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"for…of\"><a href=\"#for…of\" class=\"headerlink\" title=\"for…of\"></a>for…of</h3><ol>\n<li><p>for…of  遍历数组,遍历字符串,对象没有该方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> nicknames = [<span class=\"string\">'di'</span>, <span class=\"string\">'boo'</span>, <span class=\"string\">'punkeye'</span>];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> nickname <span class=\"keyword\">of</span> nicknames) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(nickname);</div><div class=\"line\">&#125;</div><div class=\"line\">Result: di, boo, punkeye</div></pre></td></tr></table></figure>\n</li>\n<li><p>for…in  遍历对象，数组也能够使用该方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> nicknames = [<span class=\"string\">'di'</span>, <span class=\"string\">'boo'</span>, <span class=\"string\">'punkeye'</span>];</div><div class=\"line\">nicknames.size = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> nickname <span class=\"keyword\">in</span> nicknames) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(nickname); <span class=\"comment\">// 0 1 2 size</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"类Class\"><a href=\"#类Class\" class=\"headerlink\" title=\"类Class\"></a>类Class</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5 定义类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.x = x;</div><div class=\"line\">  <span class=\"keyword\">this</span>.y = y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Point.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 相当于 ES6中</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = x;</div><div class=\"line\">    <span class=\"keyword\">this</span>.y = y;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 不需要添加function，方法和方法之间不能用逗号隔开</span></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">tyof Point <span class=\"comment\">// function  说明Class只是一个语法糖</span></div><div class=\"line\">Point === Point.prototype.constructor <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<ul>\n<li>new className()会自动调用constructor()</li>\n<li>class定义的类只能通过new操作符，不能直接调用</li>\n<li>通过class只能定义在construtor中的共有属性，不能定义私有属性，定义的方法也都是相当于定义在prototype上的共有方法</li>\n<li>与ES5中定义在prototype不同在于不可枚举</li>\n<li>与ES5相同，所有实例共享原型。所以通过实例的<strong>proto</strong>属性可以为Class添加方法</li>\n<li>不存在变量提升，Class定义与ES5不同</li>\n</ul>\n<h3 id=\"继承extends\"><a href=\"#继承extends\" class=\"headerlink\" title=\"继承extends\"></a>继承extends</h3><p>在使用extends继承时，子类的constructor中必须先调用super()方法，也就是父类的构造方法。</p>\n<h3 id=\"对象超类\"><a href=\"#对象超类\" class=\"headerlink\" title=\"对象超类\"></a>对象超类</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> parent = &#123;</div><div class=\"line\">  foo() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello from the Parent\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> child = &#123;</div><div class=\"line\">  foo() &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.foo();</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello from the Child\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(child, parent); <span class=\"comment\">// ES6设置对象原型的方法</span></div><div class=\"line\">child.foo(); <span class=\"comment\">// Hello from the Parent</span></div><div class=\"line\">             <span class=\"comment\">// Hello from the Child</span></div></pre></td></tr></table></figure>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>Promise对象有三种状态：Pending、Resolved，Rejected，外界无法改变状态，状态一旦改变就不会再变。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// ... some code</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"comment\">/* 异步操作成功 */</span>) &#123;</div><div class=\"line\">\t\tresolve(value);  <span class=\"comment\">// 将promise状态变为Resolved</span></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\treject(error);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// success</span></div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// failure</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>ps:</p>\n<p>一个用Promise实现Ajax操作的例子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> getJSON = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> client = <span class=\"keyword\">new</span> XMLHttpRequest();</div><div class=\"line\">\t\tclient.open(<span class=\"string\">'GET'</span>, url);</div><div class=\"line\">\t\tclient.onreadystatechange = handler;</div><div class=\"line\">\t\tclient.responseType = <span class=\"string\">'json'</span>;</div><div class=\"line\">\t\tclient.setRequestHeader(<span class=\"string\">'Accept'</span>, <span class=\"string\">'application/json'</span>);</div><div class=\"line\">\t\tclient.send();</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.readyState !== <span class=\"number\">4</span>) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.status === <span class=\"number\">200</span>) &#123;</div><div class=\"line\">\t\t\t\tresolve(<span class=\"keyword\">this</span>.response);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\treject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"keyword\">this</span>.statusText));</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> promise;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"模板语法和分隔符\"><a href=\"#模板语法和分隔符\" class=\"headerlink\" title=\"模板语法和分隔符\"></a>模板语法和分隔符</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"string\">'Barret'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi <span class=\"subst\">$&#123;user&#125;</span>!`</span>); <span class=\"comment\">// Hi Barret</span></div></pre></td></tr></table></figure>\n<h3 id=\"对象扩展\"><a href=\"#对象扩展\" class=\"headerlink\" title=\"对象扩展\"></a>对象扩展</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCar</span>(<span class=\"params\">make, model, value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 简写变量</span></div><div class=\"line\">    make,  <span class=\"comment\">// 等同于 make: make</span></div><div class=\"line\">    model, <span class=\"comment\">// 等同于 model: model</span></div><div class=\"line\">    value, <span class=\"comment\">// 等同于 value: value</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 属性可以使用表达式计算值</span></div><div class=\"line\">    [<span class=\"string\">'make'</span> + make]: <span class=\"literal\">true</span>,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 忽略 `function` 关键词简写对象函数</span></div><div class=\"line\">    depreciate() &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.value -= <span class=\"number\">2500</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"对象和数组解构\"><a href=\"#对象和数组解构\" class=\"headerlink\" title=\"对象和数组解构\"></a>对象和数组解构</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> arr = foo(); <span class=\"comment\">// [1,2,3]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> [a, b, c] = foo();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a, b, c); <span class=\"comment\">// 1 2 3</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">x</span>: <span class=\"number\">4</span>,</div><div class=\"line\">    <span class=\"attr\">y</span>: <span class=\"number\">5</span>,</div><div class=\"line\">    <span class=\"attr\">z</span>: <span class=\"number\">6</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">x</span>: x, <span class=\"attr\">y</span>: y, <span class=\"attr\">z</span>: z&#125; = bar();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(x, y, z); <span class=\"comment\">// 4 5 6</span></div></pre></td></tr></table></figure>\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>通过<a href=\"\">Symbol.iterator</a>定义一个对象的迭代器<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">13</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> itr = arr[<span class=\"built_in\">Symbol</span>.iterator]();</div><div class=\"line\"></div><div class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: 11, done: false &#125;</span></div><div class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: 12, done: false &#125;</span></div><div class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: 13, done: false &#125;</span></div><div class=\"line\"></div><div class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"扩展操作符…\"><a href=\"#扩展操作符…\" class=\"headerlink\" title=\"扩展操作符…\"></a>扩展操作符…</h3><p>貌似只能用于参数传递</p>\n<ol>\n<li><p>情况一 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x,y,z</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(x,y,z);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</div><div class=\"line\">foo(...arr); <span class=\"comment\">// 1 2 3</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>情况二</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">...args</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(args);</div><div class=\"line\">&#125;</div><div class=\"line\">foo( <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>); <span class=\"comment\">// [1, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure></li>\n</ol>\n","excerpt":"","more":"<p>From <a href=\"http://mp.weixin.qq.com/s?__biz=MzAxMjA5ODQwMQ==&amp;mid=2455058700&amp;idx=1&amp;sn=9361036ef5dc0c27cafb0612d495a85c\">点击这里</a></p>\n<h2 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h2><h3 id=\"定义变量：let、const\"><a href=\"#定义变量：let、const\" class=\"headerlink\" title=\"定义变量：let、const\"></a>定义变量：let、const</h3><ul>\n<li>let、const声明变量为块级作用域，var声明为函数作用域</li>\n<li>let声明不具备变量提升，const声明具备</li>\n<li>const用于声明常量，必须声明时赋值</li>\n<li>let、const声明变量不能再次声明覆盖<h3 id=\"函数声明：箭头函数\"><a href=\"#函数声明：箭头函数\" class=\"headerlink\" title=\"函数声明：箭头函数\"></a>函数声明：箭头函数</h3>缘由</li>\n</ul>\n<p>ps:<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 六种语言中的简单函数示例</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(a)</span> <span class=\"comment\">&#123; return a &gt; 0; &#125;</span> <span class=\"comment\">// JS</span></div><div class=\"line\">[]<span class=\"params\">(int a)</span> <span class=\"comment\">&#123; return a &gt; 0; &#125;</span>  <span class=\"comment\">// C++</span></div><div class=\"line\"><span class=\"params\">(lambda (a)</span> <span class=\"params\">(&gt; a 0)</span>)  ;</span>; Lisp</div><div class=\"line\">lambda a: a &gt; <span class=\"number\">0</span>  # Python</div><div class=\"line\">a =&gt; a &gt; <span class=\"number\">0</span>  <span class=\"comment\">// C#</span></div><div class=\"line\">a -&gt; a &gt; <span class=\"number\">0</span>  <span class=\"comment\">// Java</span></div></pre></td></tr></table></figure></p>\n<ol>\n<li>情况一 a =&gt; a &gt; 0   相当于 function(a) { return a &gt; 0 }  tag:单个参数、直接返回</li>\n<li>情况二 (a, b) =&gt; a + b  相当于 function(a, b) { return a + b }  tag:多个参数、直接返回</li>\n<li>情况三 （a, b）=&gt; { a + b … }  相当于 function(a, b) { a + b … } tag:函数体，返回需要自己写return语句</li>\n<li>情况四  (a, b) =&gt; ({a: ‘a’}) 相当于 function(a, b) { return {a: ‘a’} } tab:直接返回对象，因为=&gt;后面的{}会被理解为函数体，添加()才会被理解为对象</li>\n</ol>\n<ul>\n<li>箭头函数相当于匿名函数的简写</li>\n<li>箭头函数的this总是和外层函数的this指向相同。<br>  eg.<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</div><div class=\"line\">  self.age = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">  setInterval(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">growUp</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  \t<span class=\"comment\">// this会指向windows</span></div><div class=\"line\">  \t<span class=\"comment\">// 所以用self保存了this</span></div><div class=\"line\">    self.age++;</div><div class=\"line\">  &#125;, <span class=\"number\">1000</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// ES6</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.age = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">  setInterval(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// |this| 指向 person 对象</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.age++;</div><div class=\"line\">  &#125;, <span class=\"number\">1000</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"for…of\"><a href=\"#for…of\" class=\"headerlink\" title=\"for…of\"></a>for…of</h3><ol>\n<li><p>for…of  遍历数组,遍历字符串,对象没有该方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> nicknames = [<span class=\"string\">'di'</span>, <span class=\"string\">'boo'</span>, <span class=\"string\">'punkeye'</span>];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> nickname <span class=\"keyword\">of</span> nicknames) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(nickname);</div><div class=\"line\">&#125;</div><div class=\"line\">Result: di, boo, punkeye</div></pre></td></tr></table></figure>\n</li>\n<li><p>for…in  遍历对象，数组也能够使用该方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> nicknames = [<span class=\"string\">'di'</span>, <span class=\"string\">'boo'</span>, <span class=\"string\">'punkeye'</span>];</div><div class=\"line\">nicknames.size = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> nickname <span class=\"keyword\">in</span> nicknames) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(nickname); <span class=\"comment\">// 0 1 2 size</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"类Class\"><a href=\"#类Class\" class=\"headerlink\" title=\"类Class\"></a>类Class</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5 定义类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.x = x;</div><div class=\"line\">  <span class=\"keyword\">this</span>.y = y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Point.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 相当于 ES6中</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = x;</div><div class=\"line\">    <span class=\"keyword\">this</span>.y = y;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 不需要添加function，方法和方法之间不能用逗号隔开</span></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">tyof Point <span class=\"comment\">// function  说明Class只是一个语法糖</span></div><div class=\"line\">Point === Point.prototype.constructor <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<ul>\n<li>new className()会自动调用constructor()</li>\n<li>class定义的类只能通过new操作符，不能直接调用</li>\n<li>通过class只能定义在construtor中的共有属性，不能定义私有属性，定义的方法也都是相当于定义在prototype上的共有方法</li>\n<li>与ES5中定义在prototype不同在于不可枚举</li>\n<li>与ES5相同，所有实例共享原型。所以通过实例的<strong>proto</strong>属性可以为Class添加方法</li>\n<li>不存在变量提升，Class定义与ES5不同</li>\n</ul>\n<h3 id=\"继承extends\"><a href=\"#继承extends\" class=\"headerlink\" title=\"继承extends\"></a>继承extends</h3><p>在使用extends继承时，子类的constructor中必须先调用super()方法，也就是父类的构造方法。</p>\n<h3 id=\"对象超类\"><a href=\"#对象超类\" class=\"headerlink\" title=\"对象超类\"></a>对象超类</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> parent = &#123;</div><div class=\"line\">  foo() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello from the Parent\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> child = &#123;</div><div class=\"line\">  foo() &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.foo();</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello from the Child\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(child, parent); <span class=\"comment\">// ES6设置对象原型的方法</span></div><div class=\"line\">child.foo(); <span class=\"comment\">// Hello from the Parent</span></div><div class=\"line\">             <span class=\"comment\">// Hello from the Child</span></div></pre></td></tr></table></figure>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>Promise对象有三种状态：Pending、Resolved，Rejected，外界无法改变状态，状态一旦改变就不会再变。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// ... some code</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"comment\">/* 异步操作成功 */</span>) &#123;</div><div class=\"line\">\t\tresolve(value);  <span class=\"comment\">// 将promise状态变为Resolved</span></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\treject(error);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// success</span></div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// failure</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>ps:</p>\n<p>一个用Promise实现Ajax操作的例子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> getJSON = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> client = <span class=\"keyword\">new</span> XMLHttpRequest();</div><div class=\"line\">\t\tclient.open(<span class=\"string\">'GET'</span>, url);</div><div class=\"line\">\t\tclient.onreadystatechange = handler;</div><div class=\"line\">\t\tclient.responseType = <span class=\"string\">'json'</span>;</div><div class=\"line\">\t\tclient.setRequestHeader(<span class=\"string\">'Accept'</span>, <span class=\"string\">'application/json'</span>);</div><div class=\"line\">\t\tclient.send();</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.readyState !== <span class=\"number\">4</span>) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.status === <span class=\"number\">200</span>) &#123;</div><div class=\"line\">\t\t\t\tresolve(<span class=\"keyword\">this</span>.response);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\treject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"keyword\">this</span>.statusText));</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> promise;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"模板语法和分隔符\"><a href=\"#模板语法和分隔符\" class=\"headerlink\" title=\"模板语法和分隔符\"></a>模板语法和分隔符</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"string\">'Barret'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi <span class=\"subst\">$&#123;user&#125;</span>!`</span>); <span class=\"comment\">// Hi Barret</span></div></pre></td></tr></table></figure>\n<h3 id=\"对象扩展\"><a href=\"#对象扩展\" class=\"headerlink\" title=\"对象扩展\"></a>对象扩展</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCar</span>(<span class=\"params\">make, model, value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 简写变量</span></div><div class=\"line\">    make,  <span class=\"comment\">// 等同于 make: make</span></div><div class=\"line\">    model, <span class=\"comment\">// 等同于 model: model</span></div><div class=\"line\">    value, <span class=\"comment\">// 等同于 value: value</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 属性可以使用表达式计算值</span></div><div class=\"line\">    [<span class=\"string\">'make'</span> + make]: <span class=\"literal\">true</span>,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 忽略 `function` 关键词简写对象函数</span></div><div class=\"line\">    depreciate() &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.value -= <span class=\"number\">2500</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"对象和数组解构\"><a href=\"#对象和数组解构\" class=\"headerlink\" title=\"对象和数组解构\"></a>对象和数组解构</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> arr = foo(); <span class=\"comment\">// [1,2,3]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> [a, b, c] = foo();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a, b, c); <span class=\"comment\">// 1 2 3</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">x</span>: <span class=\"number\">4</span>,</div><div class=\"line\">    <span class=\"attr\">y</span>: <span class=\"number\">5</span>,</div><div class=\"line\">    <span class=\"attr\">z</span>: <span class=\"number\">6</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">x</span>: x, <span class=\"attr\">y</span>: y, <span class=\"attr\">z</span>: z&#125; = bar();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(x, y, z); <span class=\"comment\">// 4 5 6</span></div></pre></td></tr></table></figure>\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>通过<a href=\"\">Symbol.iterator</a>定义一个对象的迭代器<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">13</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> itr = arr[<span class=\"built_in\">Symbol</span>.iterator]();</div><div class=\"line\"></div><div class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: 11, done: false &#125;</span></div><div class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: 12, done: false &#125;</span></div><div class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: 13, done: false &#125;</span></div><div class=\"line\"></div><div class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"扩展操作符…\"><a href=\"#扩展操作符…\" class=\"headerlink\" title=\"扩展操作符…\"></a>扩展操作符…</h3><p>貌似只能用于参数传递</p>\n<ol>\n<li><p>情况一 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x,y,z</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(x,y,z);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</div><div class=\"line\">foo(...arr); <span class=\"comment\">// 1 2 3</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>情况二</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">...args</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(args);</div><div class=\"line\">&#125;</div><div class=\"line\">foo( <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>); <span class=\"comment\">// [1, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"H5页面","date":"2016-08-02T16:00:00.000Z","comments":1,"_content":"\n任务：环球网-2016七夕H5页面  \n环境：swiper插件，gulp及相关常用工具。\n\n---\n\n### 适配\n使用的还是lib-flexible那套解决方案，需要查看的可以点击[这里](https://github.com/amfe/lib-flexible)  \n### 使用swiper\n使用swiper页面的控制以及滑动功能就变得非常容易，可以参见[Swiper中文网](http://www.swiper.com.cn/)，其中添加给类名添加`swiper-slide`即可表示一页。  \n在Swiper实例化中，属性`direction`可以定义横向/竖向滑动，`nextButton`可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在`onSlideChangeStart`中不能够出发`slideTo()`方法。  \nSwiper还有许多其他功能，可以参见[Swiper中文网](http://www.swiper.com.cn/)中API。\n\n### ES6的使用\nES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是`gulp-babel`。\n\n### 目录、git以及gulp相关\n目录和之前的项目目录基本相同。\n```\n.\n├── .eslintrc.json\n├── .gitignore\n├── dist\n│   ├── css\n│   ├── imgs\n│   ├── js\n│   └── libs\n├── gulpfile.js\n├── index.html\n├── node_modules\n├── package.json\n├── psd\n└── src\n    ├── ES6\n    ├── css\n    ├── imgs\n    ├── js\n    ├── libs\n    └── sass\n```\ndist目录存放合并、压缩的代码，用于上线使用。(自动生成)  \nsrc目录存放源文件。  \nnode_modules目录存放用到的node工具。(自动生成)  \npsd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。  \n相比之前增加的文件：\n\n*  .eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看[这里](https://segmentfault.com/a/1190000004468428)。\n*  .gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。\n```\n/node_modules/\n/psd/\n```\n* src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。\n\ngit开始学习使用分支处理bug、添加尝试性功能等。\n\n### 坑是用来爬的\n#### 最经典的坑——this\n在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过`fn.bind(this)`来指向想要的this，在旧版本浏览器下需要使用兼容写法。\n\n#### 省事也被坑——autoprefixer\nautoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是`remove`，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。  \nandriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。\n\n#### 没想到的坑——微信分享\n关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。  \n问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中`mqq.data.setShareInfo`可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。\n\n### 其他\n#### 自定义单选框\n自定义单选框并没有想象中的那么难，除了`<input type=\"radio\">`外，还有个label标签和after伪类。  \n设置css`[type=radio]: display: none;`，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)\n\n#### 文字居中\n要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。\n\n#### 横屏问题\n我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。\n\n### 改进\n需要改进的东西就太多太多了。 \n \n* 最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。\n* 图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。\n* 动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。","source":"_posts/H5页面.md","raw":"---\ntitle: H5页面\ndate: 2016-08-03\ntags: javascript H5\ncategories: \n- H5\ncomments: true\n---\n\n任务：环球网-2016七夕H5页面  \n环境：swiper插件，gulp及相关常用工具。\n\n---\n\n### 适配\n使用的还是lib-flexible那套解决方案，需要查看的可以点击[这里](https://github.com/amfe/lib-flexible)  \n### 使用swiper\n使用swiper页面的控制以及滑动功能就变得非常容易，可以参见[Swiper中文网](http://www.swiper.com.cn/)，其中添加给类名添加`swiper-slide`即可表示一页。  \n在Swiper实例化中，属性`direction`可以定义横向/竖向滑动，`nextButton`可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在`onSlideChangeStart`中不能够出发`slideTo()`方法。  \nSwiper还有许多其他功能，可以参见[Swiper中文网](http://www.swiper.com.cn/)中API。\n\n### ES6的使用\nES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是`gulp-babel`。\n\n### 目录、git以及gulp相关\n目录和之前的项目目录基本相同。\n```\n.\n├── .eslintrc.json\n├── .gitignore\n├── dist\n│   ├── css\n│   ├── imgs\n│   ├── js\n│   └── libs\n├── gulpfile.js\n├── index.html\n├── node_modules\n├── package.json\n├── psd\n└── src\n    ├── ES6\n    ├── css\n    ├── imgs\n    ├── js\n    ├── libs\n    └── sass\n```\ndist目录存放合并、压缩的代码，用于上线使用。(自动生成)  \nsrc目录存放源文件。  \nnode_modules目录存放用到的node工具。(自动生成)  \npsd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。  \n相比之前增加的文件：\n\n*  .eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看[这里](https://segmentfault.com/a/1190000004468428)。\n*  .gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。\n```\n/node_modules/\n/psd/\n```\n* src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。\n\ngit开始学习使用分支处理bug、添加尝试性功能等。\n\n### 坑是用来爬的\n#### 最经典的坑——this\n在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过`fn.bind(this)`来指向想要的this，在旧版本浏览器下需要使用兼容写法。\n\n#### 省事也被坑——autoprefixer\nautoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是`remove`，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。  \nandriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。\n\n#### 没想到的坑——微信分享\n关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。  \n问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中`mqq.data.setShareInfo`可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。\n\n### 其他\n#### 自定义单选框\n自定义单选框并没有想象中的那么难，除了`<input type=\"radio\">`外，还有个label标签和after伪类。  \n设置css`[type=radio]: display: none;`，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)\n\n#### 文字居中\n要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。\n\n#### 横屏问题\n我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。\n\n### 改进\n需要改进的东西就太多太多了。 \n \n* 最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。\n* 图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。\n* 动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。","slug":"H5页面","published":1,"updated":"2016-11-27T01:15:21.845Z","layout":"post","photos":[],"link":"","_id":"ciw3mfvsc00010kc77o1n4si2","content":"<p>任务：环球网-2016七夕H5页面<br>环境：swiper插件，gulp及相关常用工具。</p>\n<hr>\n<h3 id=\"适配\"><a href=\"#适配\" class=\"headerlink\" title=\"适配\"></a>适配</h3><p>使用的还是lib-flexible那套解决方案，需要查看的可以点击<a href=\"https://github.com/amfe/lib-flexible\" target=\"_blank\" rel=\"external\">这里</a>  </p>\n<h3 id=\"使用swiper\"><a href=\"#使用swiper\" class=\"headerlink\" title=\"使用swiper\"></a>使用swiper</h3><p>使用swiper页面的控制以及滑动功能就变得非常容易，可以参见<a href=\"http://www.swiper.com.cn/\" target=\"_blank\" rel=\"external\">Swiper中文网</a>，其中添加给类名添加<code>swiper-slide</code>即可表示一页。<br>在Swiper实例化中，属性<code>direction</code>可以定义横向/竖向滑动，<code>nextButton</code>可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在<code>onSlideChangeStart</code>中不能够出发<code>slideTo()</code>方法。<br>Swiper还有许多其他功能，可以参见<a href=\"http://www.swiper.com.cn/\" target=\"_blank\" rel=\"external\">Swiper中文网</a>中API。</p>\n<h3 id=\"ES6的使用\"><a href=\"#ES6的使用\" class=\"headerlink\" title=\"ES6的使用\"></a>ES6的使用</h3><p>ES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是<code>gulp-babel</code>。</p>\n<h3 id=\"目录、git以及gulp相关\"><a href=\"#目录、git以及gulp相关\" class=\"headerlink\" title=\"目录、git以及gulp相关\"></a>目录、git以及gulp相关</h3><p>目录和之前的项目目录基本相同。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── <span class=\"selector-class\">.eslintrc</span><span class=\"selector-class\">.json</span></div><div class=\"line\">├── <span class=\"selector-class\">.gitignore</span></div><div class=\"line\">├── dist</div><div class=\"line\">│   ├── css</div><div class=\"line\">│   ├── imgs</div><div class=\"line\">│   ├── js</div><div class=\"line\">│   └── libs</div><div class=\"line\">├── gulpfile<span class=\"selector-class\">.js</span></div><div class=\"line\">├── index<span class=\"selector-class\">.html</span></div><div class=\"line\">├── node_modules</div><div class=\"line\">├── package<span class=\"selector-class\">.json</span></div><div class=\"line\">├── psd</div><div class=\"line\">└── src</div><div class=\"line\">    ├── ES6</div><div class=\"line\">    ├── css</div><div class=\"line\">    ├── imgs</div><div class=\"line\">    ├── js</div><div class=\"line\">    ├── libs</div><div class=\"line\">    └── sass</div></pre></td></tr></table></figure></p>\n<p>dist目录存放合并、压缩的代码，用于上线使用。(自动生成)<br>src目录存放源文件。<br>node_modules目录存放用到的node工具。(自动生成)<br>psd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。<br>相比之前增加的文件：</p>\n<ul>\n<li>.eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看<a href=\"https://segmentfault.com/a/1190000004468428\" target=\"_blank\" rel=\"external\">这里</a>。</li>\n<li><p>.gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"regexp\">/node_modules/</span></div><div class=\"line\"><span class=\"regexp\">/psd/</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。</p>\n</li>\n</ul>\n<p>git开始学习使用分支处理bug、添加尝试性功能等。</p>\n<h3 id=\"坑是用来爬的\"><a href=\"#坑是用来爬的\" class=\"headerlink\" title=\"坑是用来爬的\"></a>坑是用来爬的</h3><h4 id=\"最经典的坑——this\"><a href=\"#最经典的坑——this\" class=\"headerlink\" title=\"最经典的坑——this\"></a>最经典的坑——this</h4><p>在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过<code>fn.bind(this)</code>来指向想要的this，在旧版本浏览器下需要使用兼容写法。</p>\n<h4 id=\"省事也被坑——autoprefixer\"><a href=\"#省事也被坑——autoprefixer\" class=\"headerlink\" title=\"省事也被坑——autoprefixer\"></a>省事也被坑——autoprefixer</h4><p>autoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是<code>remove</code>，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。<br>andriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。</p>\n<h4 id=\"没想到的坑——微信分享\"><a href=\"#没想到的坑——微信分享\" class=\"headerlink\" title=\"没想到的坑——微信分享\"></a>没想到的坑——微信分享</h4><p>关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。<br>问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中<code>mqq.data.setShareInfo</code>可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"自定义单选框\"><a href=\"#自定义单选框\" class=\"headerlink\" title=\"自定义单选框\"></a>自定义单选框</h4><p>自定义单选框并没有想象中的那么难，除了<code>&lt;input type=&quot;radio&quot;&gt;</code>外，还有个label标签和after伪类。<br>设置css<code>[type=radio]: display: none;</code>，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)</p>\n<h4 id=\"文字居中\"><a href=\"#文字居中\" class=\"headerlink\" title=\"文字居中\"></a>文字居中</h4><p>要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。</p>\n<h4 id=\"横屏问题\"><a href=\"#横屏问题\" class=\"headerlink\" title=\"横屏问题\"></a>横屏问题</h4><p>我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。</p>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>需要改进的东西就太多太多了。 </p>\n<ul>\n<li>最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。</li>\n<li>图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。</li>\n<li>动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。</li>\n</ul>\n","excerpt":"","more":"<p>任务：环球网-2016七夕H5页面<br>环境：swiper插件，gulp及相关常用工具。</p>\n<hr>\n<h3 id=\"适配\"><a href=\"#适配\" class=\"headerlink\" title=\"适配\"></a>适配</h3><p>使用的还是lib-flexible那套解决方案，需要查看的可以点击<a href=\"https://github.com/amfe/lib-flexible\">这里</a>  </p>\n<h3 id=\"使用swiper\"><a href=\"#使用swiper\" class=\"headerlink\" title=\"使用swiper\"></a>使用swiper</h3><p>使用swiper页面的控制以及滑动功能就变得非常容易，可以参见<a href=\"http://www.swiper.com.cn/\">Swiper中文网</a>，其中添加给类名添加<code>swiper-slide</code>即可表示一页。<br>在Swiper实例化中，属性<code>direction</code>可以定义横向/竖向滑动，<code>nextButton</code>可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在<code>onSlideChangeStart</code>中不能够出发<code>slideTo()</code>方法。<br>Swiper还有许多其他功能，可以参见<a href=\"http://www.swiper.com.cn/\">Swiper中文网</a>中API。</p>\n<h3 id=\"ES6的使用\"><a href=\"#ES6的使用\" class=\"headerlink\" title=\"ES6的使用\"></a>ES6的使用</h3><p>ES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是<code>gulp-babel</code>。</p>\n<h3 id=\"目录、git以及gulp相关\"><a href=\"#目录、git以及gulp相关\" class=\"headerlink\" title=\"目录、git以及gulp相关\"></a>目录、git以及gulp相关</h3><p>目录和之前的项目目录基本相同。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── <span class=\"selector-class\">.eslintrc</span><span class=\"selector-class\">.json</span></div><div class=\"line\">├── <span class=\"selector-class\">.gitignore</span></div><div class=\"line\">├── dist</div><div class=\"line\">│   ├── css</div><div class=\"line\">│   ├── imgs</div><div class=\"line\">│   ├── js</div><div class=\"line\">│   └── libs</div><div class=\"line\">├── gulpfile<span class=\"selector-class\">.js</span></div><div class=\"line\">├── index<span class=\"selector-class\">.html</span></div><div class=\"line\">├── node_modules</div><div class=\"line\">├── package<span class=\"selector-class\">.json</span></div><div class=\"line\">├── psd</div><div class=\"line\">└── src</div><div class=\"line\">    ├── ES6</div><div class=\"line\">    ├── css</div><div class=\"line\">    ├── imgs</div><div class=\"line\">    ├── js</div><div class=\"line\">    ├── libs</div><div class=\"line\">    └── sass</div></pre></td></tr></table></figure></p>\n<p>dist目录存放合并、压缩的代码，用于上线使用。(自动生成)<br>src目录存放源文件。<br>node_modules目录存放用到的node工具。(自动生成)<br>psd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。<br>相比之前增加的文件：</p>\n<ul>\n<li>.eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看<a href=\"https://segmentfault.com/a/1190000004468428\">这里</a>。</li>\n<li><p>.gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"regexp\">/node_modules/</span></div><div class=\"line\"><span class=\"regexp\">/psd/</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。</p>\n</li>\n</ul>\n<p>git开始学习使用分支处理bug、添加尝试性功能等。</p>\n<h3 id=\"坑是用来爬的\"><a href=\"#坑是用来爬的\" class=\"headerlink\" title=\"坑是用来爬的\"></a>坑是用来爬的</h3><h4 id=\"最经典的坑——this\"><a href=\"#最经典的坑——this\" class=\"headerlink\" title=\"最经典的坑——this\"></a>最经典的坑——this</h4><p>在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过<code>fn.bind(this)</code>来指向想要的this，在旧版本浏览器下需要使用兼容写法。</p>\n<h4 id=\"省事也被坑——autoprefixer\"><a href=\"#省事也被坑——autoprefixer\" class=\"headerlink\" title=\"省事也被坑——autoprefixer\"></a>省事也被坑——autoprefixer</h4><p>autoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是<code>remove</code>，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。<br>andriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。</p>\n<h4 id=\"没想到的坑——微信分享\"><a href=\"#没想到的坑——微信分享\" class=\"headerlink\" title=\"没想到的坑——微信分享\"></a>没想到的坑——微信分享</h4><p>关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。<br>问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中<code>mqq.data.setShareInfo</code>可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"自定义单选框\"><a href=\"#自定义单选框\" class=\"headerlink\" title=\"自定义单选框\"></a>自定义单选框</h4><p>自定义单选框并没有想象中的那么难，除了<code>&lt;input type=&quot;radio&quot;&gt;</code>外，还有个label标签和after伪类。<br>设置css<code>[type=radio]: display: none;</code>，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)</p>\n<h4 id=\"文字居中\"><a href=\"#文字居中\" class=\"headerlink\" title=\"文字居中\"></a>文字居中</h4><p>要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。</p>\n<h4 id=\"横屏问题\"><a href=\"#横屏问题\" class=\"headerlink\" title=\"横屏问题\"></a>横屏问题</h4><p>我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。</p>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>需要改进的东西就太多太多了。 </p>\n<ul>\n<li>最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。</li>\n<li>图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。</li>\n<li>动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。</li>\n</ul>\n"},{"title":"Promise总结","date":"2016-11-24T16:00:00.000Z","comments":1,"_content":"\n## Promise总结\n\n因为最近项目中用到了ajax，想尝试下Promise，所以看了下ES6中的[Promise](http://es6.ruanyifeng.com/#docs/promise)。\n\n一般用法：\n```javascript\n// promise表示一个Promise对象\npromise\n  .then(function (data) {\n    // success\n  })\n  .catch(function (err) {\n    // error\n  })\n```\n所以如果使用jQuery或者zepto，可以这样：\n```javascript\nvar ajaxBack = $.ajax({\n  url: '*****'\n})\n\najaxBack\n  .then(data => {\n    // 处理数据\n  })\n  .catch(error => {\n    // 处理报错\n  })\n```\n\n### 什么是Promise对象？\n\nPromise是异步编程的一种解决方案。  \n首先，我们通过chrome浏览器控制台来看一下Promise对象的样子。  \n在控制台输入`Promise`然后回车，会看到输出`function Promise() { [native code] }`。然后我们new一个Promise出来看一下，`var promise = new Promise(function(){})`，在创建Promise对象时候，必须传递一个函数，否则会报错。  \n看一下promise：  \n![Promise对象](./images/Promise_Object.png)  \n包括\\_\\_proto\\_\\_，[[PromiseStatus]]，[[PromiseValue]]三个属性，其中\\_\\_proto\\_\\_主要包括catch、then、constructor方法。所以我们对Promise的学习主要就是[[PromiseStatus]]，[[PromiseValue]]属性和catch，then方法。\n\n### Promise的三种状态\n通过[资料](http://es6.ruanyifeng.com/#docs/promise)，我们会知道Promise对象有三种状态：Pending、Resolved和Rejected。  \nPromise构造函数接受一个函数作为参数，该函数有两个参数分别为resolve和reject，我们的创建方法应该是这样`new Promise(function (resolve, reject) {})`。  \n这两个参数resolve和reject也是函数，resolve是将Promise对象的状态从Pending变成Resolved，reject是将Promise对象的状态从Pending变成Rejected。  \n如果我们执行`var promise = new Promise(function(resolve, reject){resolve()})`，会发现promise中的[[PromiseStatus]]变成了`\"resolved\"`。如果我们执行`var promise = new Promise(function(resolve, reject){resolve('执行成功')})`，会发现不仅[[PromiseStatus]]变了，[[PromiseValue]]的值变成了`“执行成功”`。(reject函数同理)\n\n    需要注意：\n      只有函数中的构造函数参数中的resolve和reject可以改变Promise对象的状态。\n      一旦Promise对象的状态改变，就会一直保持这个状态，不能再改变。\n\n### Promise的then函数和catch函数\n\nthen函数和catch函数可以理解成对Promise状态的监听函数，不同点在于监听函数需要在事件发生之前创建，而因为Promise中的状态在改变后是不能再次改变的，所以then函数和catch函数可以在Promise对象改变状态之后创建，这样的话，该函数会立即执行。  \nthen函数接受两个函数作为参数，分别是Promise状态为`Resolved`时执行和状态为`Rejected`时执行。\n```javascript\n// promise是一个Promise对象\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\nthen函数中的函数参数是[[PromiseValue]]中的值，即是Promise构造中的resolve()、reject()中的参数。\n\n另外，then函数中的方法是异步的，即使resolve立即执行，then中的函数也在同步函数执行结束之后执行：\n```javascript\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise');\n  resolve();\n});\n\npromise.then(function() {\n  console.log('Resolved.');\n});\n\nconsole.log('Hi!');\n\n// Promise\n// Hi!\n// Resolved\n```\n\ncatch函数相当于.then(null, function () {})，是在发生错误时的回调函数，reject()执行时也算是一种错误发生，所以在执行reject()时，catch中的函数也会被执行。  \n所以，最好的方式是reject()发生时候需要执行的函数定义在catch中，而不是在then的第二个参数中，这样无论是reject()还是其他错误都能够被捕获。\n```javascript\n// bad\npromise\n  .then(function(data) {\n    // success\n  }, function(err) {\n    // error\n  });\n\n// good\npromise\n  .then(function(data) { //cb\n    // success\n  })\n  .catch(function(err) {\n    // error\n  });\n```\n\n### Promise对象的嵌套\n在resolve()和reject()中传递的可以是另一个Promise对象，例如\n```javascript\nvar p1 = new Promise(function (resolve, reject) {\n  setTimeout(() => reject(new Error('fail')), 3000)\n})\n\nvar p2 = new Promise(function (resolve, reject) {\n  setTimeout(() => resolve(p1), 1000)\n})\n\np2\n  .then(result => console.log(result))\n  .catch(error => console.log(error))\n// Error: fail\n```\np1是一个Promise，3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。此时，由于p2返回的是另一个Promise，所以后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。\n\n### 其他函数\n\n#### Promise.all()\nPromise.all()将多个Promise包装成一个Promise对象，只有在包装的多个Promise都转变成`Resolved`状态，此Promise.all()才会转变成`Resolved`状态，返回值是多个Promise返回值组成的数组；如果有其中一个转变成了`Rejected`状态，则此Promise.all()变成`Rejected`状态，返回值是第一个被reject的返回值。\n\n#### Promise.race()\nPromise.race()可以理解成Promise.all()的“否命题”。  \n将多个Promise包装成一个，只要有其中一个状态变成`Resolved`，则此Promise.race()变成`Resolved`，返回值是第一个状态变成`Resolved`的值。\n\n#### Promise.resolve()\nPromise.resolve()用于将对象转换成Promise对象。\n\n    1. 参数为Promise对象，方法什么也不做，直接返回。\n    2. 参数为一个有then方法的对象，方法将对象转换成Promise对象，并立即执行then方法。例如：Promise.resolve(Object)相当于new Promise(Object.then)\n    3. 参数不是具有then方法的对象，或者不是对象，则返回一个状态为`Resolved`的Promise对象，并将此参数传递给then中的第一个参数函数。\n    4. 不带任何参数，直接返回`Resolved`的Promise对象。\n\n#### Promise.reject()\nPromise.reject()和Promise.resolve()行为一致，只是返回的默认是`Rejected`的Promise对象。\n\n#### done()\n\n#### finally()\n","source":"_posts/Promise总结.md","raw":"---\ntitle: Promise总结\ndate: 2016-11-25\ntags: javascript\ncategories: \n- javascript\ncomments: true\n---\n\n## Promise总结\n\n因为最近项目中用到了ajax，想尝试下Promise，所以看了下ES6中的[Promise](http://es6.ruanyifeng.com/#docs/promise)。\n\n一般用法：\n```javascript\n// promise表示一个Promise对象\npromise\n  .then(function (data) {\n    // success\n  })\n  .catch(function (err) {\n    // error\n  })\n```\n所以如果使用jQuery或者zepto，可以这样：\n```javascript\nvar ajaxBack = $.ajax({\n  url: '*****'\n})\n\najaxBack\n  .then(data => {\n    // 处理数据\n  })\n  .catch(error => {\n    // 处理报错\n  })\n```\n\n### 什么是Promise对象？\n\nPromise是异步编程的一种解决方案。  \n首先，我们通过chrome浏览器控制台来看一下Promise对象的样子。  \n在控制台输入`Promise`然后回车，会看到输出`function Promise() { [native code] }`。然后我们new一个Promise出来看一下，`var promise = new Promise(function(){})`，在创建Promise对象时候，必须传递一个函数，否则会报错。  \n看一下promise：  \n![Promise对象](./images/Promise_Object.png)  \n包括\\_\\_proto\\_\\_，[[PromiseStatus]]，[[PromiseValue]]三个属性，其中\\_\\_proto\\_\\_主要包括catch、then、constructor方法。所以我们对Promise的学习主要就是[[PromiseStatus]]，[[PromiseValue]]属性和catch，then方法。\n\n### Promise的三种状态\n通过[资料](http://es6.ruanyifeng.com/#docs/promise)，我们会知道Promise对象有三种状态：Pending、Resolved和Rejected。  \nPromise构造函数接受一个函数作为参数，该函数有两个参数分别为resolve和reject，我们的创建方法应该是这样`new Promise(function (resolve, reject) {})`。  \n这两个参数resolve和reject也是函数，resolve是将Promise对象的状态从Pending变成Resolved，reject是将Promise对象的状态从Pending变成Rejected。  \n如果我们执行`var promise = new Promise(function(resolve, reject){resolve()})`，会发现promise中的[[PromiseStatus]]变成了`\"resolved\"`。如果我们执行`var promise = new Promise(function(resolve, reject){resolve('执行成功')})`，会发现不仅[[PromiseStatus]]变了，[[PromiseValue]]的值变成了`“执行成功”`。(reject函数同理)\n\n    需要注意：\n      只有函数中的构造函数参数中的resolve和reject可以改变Promise对象的状态。\n      一旦Promise对象的状态改变，就会一直保持这个状态，不能再改变。\n\n### Promise的then函数和catch函数\n\nthen函数和catch函数可以理解成对Promise状态的监听函数，不同点在于监听函数需要在事件发生之前创建，而因为Promise中的状态在改变后是不能再次改变的，所以then函数和catch函数可以在Promise对象改变状态之后创建，这样的话，该函数会立即执行。  \nthen函数接受两个函数作为参数，分别是Promise状态为`Resolved`时执行和状态为`Rejected`时执行。\n```javascript\n// promise是一个Promise对象\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\nthen函数中的函数参数是[[PromiseValue]]中的值，即是Promise构造中的resolve()、reject()中的参数。\n\n另外，then函数中的方法是异步的，即使resolve立即执行，then中的函数也在同步函数执行结束之后执行：\n```javascript\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise');\n  resolve();\n});\n\npromise.then(function() {\n  console.log('Resolved.');\n});\n\nconsole.log('Hi!');\n\n// Promise\n// Hi!\n// Resolved\n```\n\ncatch函数相当于.then(null, function () {})，是在发生错误时的回调函数，reject()执行时也算是一种错误发生，所以在执行reject()时，catch中的函数也会被执行。  \n所以，最好的方式是reject()发生时候需要执行的函数定义在catch中，而不是在then的第二个参数中，这样无论是reject()还是其他错误都能够被捕获。\n```javascript\n// bad\npromise\n  .then(function(data) {\n    // success\n  }, function(err) {\n    // error\n  });\n\n// good\npromise\n  .then(function(data) { //cb\n    // success\n  })\n  .catch(function(err) {\n    // error\n  });\n```\n\n### Promise对象的嵌套\n在resolve()和reject()中传递的可以是另一个Promise对象，例如\n```javascript\nvar p1 = new Promise(function (resolve, reject) {\n  setTimeout(() => reject(new Error('fail')), 3000)\n})\n\nvar p2 = new Promise(function (resolve, reject) {\n  setTimeout(() => resolve(p1), 1000)\n})\n\np2\n  .then(result => console.log(result))\n  .catch(error => console.log(error))\n// Error: fail\n```\np1是一个Promise，3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。此时，由于p2返回的是另一个Promise，所以后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。\n\n### 其他函数\n\n#### Promise.all()\nPromise.all()将多个Promise包装成一个Promise对象，只有在包装的多个Promise都转变成`Resolved`状态，此Promise.all()才会转变成`Resolved`状态，返回值是多个Promise返回值组成的数组；如果有其中一个转变成了`Rejected`状态，则此Promise.all()变成`Rejected`状态，返回值是第一个被reject的返回值。\n\n#### Promise.race()\nPromise.race()可以理解成Promise.all()的“否命题”。  \n将多个Promise包装成一个，只要有其中一个状态变成`Resolved`，则此Promise.race()变成`Resolved`，返回值是第一个状态变成`Resolved`的值。\n\n#### Promise.resolve()\nPromise.resolve()用于将对象转换成Promise对象。\n\n    1. 参数为Promise对象，方法什么也不做，直接返回。\n    2. 参数为一个有then方法的对象，方法将对象转换成Promise对象，并立即执行then方法。例如：Promise.resolve(Object)相当于new Promise(Object.then)\n    3. 参数不是具有then方法的对象，或者不是对象，则返回一个状态为`Resolved`的Promise对象，并将此参数传递给then中的第一个参数函数。\n    4. 不带任何参数，直接返回`Resolved`的Promise对象。\n\n#### Promise.reject()\nPromise.reject()和Promise.resolve()行为一致，只是返回的默认是`Rejected`的Promise对象。\n\n#### done()\n\n#### finally()\n","slug":"Promise总结","published":1,"updated":"2016-11-27T01:15:21.856Z","layout":"post","photos":[],"link":"","_id":"ciw3mfvsr00020kc7mg5lw70m","content":"<h2 id=\"Promise总结\"><a href=\"#Promise总结\" class=\"headerlink\" title=\"Promise总结\"></a>Promise总结</h2><p>因为最近项目中用到了ajax，想尝试下Promise，所以看了下ES6中的<a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"external\">Promise</a>。</p>\n<p>一般用法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// promise表示一个Promise对象</span></div><div class=\"line\">promise</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// success</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// error</span></div><div class=\"line\">  &#125;)</div></pre></td></tr></table></figure></p>\n<p>所以如果使用jQuery或者zepto，可以这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ajaxBack = $.ajax(&#123;</div><div class=\"line\">  <span class=\"attr\">url</span>: <span class=\"string\">'*****'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">ajaxBack</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 处理数据</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 处理报错</span></div><div class=\"line\">  &#125;)</div></pre></td></tr></table></figure></p>\n<h3 id=\"什么是Promise对象？\"><a href=\"#什么是Promise对象？\" class=\"headerlink\" title=\"什么是Promise对象？\"></a>什么是Promise对象？</h3><p>Promise是异步编程的一种解决方案。<br>首先，我们通过chrome浏览器控制台来看一下Promise对象的样子。<br>在控制台输入<code>Promise</code>然后回车，会看到输出<code>function Promise() { [native code] }</code>。然后我们new一个Promise出来看一下，<code>var promise = new Promise(function(){})</code>，在创建Promise对象时候，必须传递一个函数，否则会报错。<br>看一下promise：<br><img src=\"./images/Promise_Object.png\" alt=\"Promise对象\"><br>包括__proto__，[[PromiseStatus]]，[[PromiseValue]]三个属性，其中__proto__主要包括catch、then、constructor方法。所以我们对Promise的学习主要就是[[PromiseStatus]]，[[PromiseValue]]属性和catch，then方法。</p>\n<h3 id=\"Promise的三种状态\"><a href=\"#Promise的三种状态\" class=\"headerlink\" title=\"Promise的三种状态\"></a>Promise的三种状态</h3><p>通过<a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"external\">资料</a>，我们会知道Promise对象有三种状态：Pending、Resolved和Rejected。<br>Promise构造函数接受一个函数作为参数，该函数有两个参数分别为resolve和reject，我们的创建方法应该是这样<code>new Promise(function (resolve, reject) {})</code>。<br>这两个参数resolve和reject也是函数，resolve是将Promise对象的状态从Pending变成Resolved，reject是将Promise对象的状态从Pending变成Rejected。<br>如果我们执行<code>var promise = new Promise(function(resolve, reject){resolve()})</code>，会发现promise中的[[PromiseStatus]]变成了<code>&quot;resolved&quot;</code>。如果我们执行<code>var promise = new Promise(function(resolve, reject){resolve(&#39;执行成功&#39;)})</code>，会发现不仅[[PromiseStatus]]变了，[[PromiseValue]]的值变成了<code>“执行成功”</code>。(reject函数同理)</p>\n<pre><code>需要注意：\n  只有函数中的构造函数参数中的resolve和reject可以改变Promise对象的状态。\n  一旦Promise对象的状态改变，就会一直保持这个状态，不能再改变。\n</code></pre><h3 id=\"Promise的then函数和catch函数\"><a href=\"#Promise的then函数和catch函数\" class=\"headerlink\" title=\"Promise的then函数和catch函数\"></a>Promise的then函数和catch函数</h3><p>then函数和catch函数可以理解成对Promise状态的监听函数，不同点在于监听函数需要在事件发生之前创建，而因为Promise中的状态在改变后是不能再次改变的，所以then函数和catch函数可以在Promise对象改变状态之后创建，这样的话，该函数会立即执行。<br>then函数接受两个函数作为参数，分别是Promise状态为<code>Resolved</code>时执行和状态为<code>Rejected</code>时执行。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// promise是一个Promise对象</span></div><div class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// success</span></div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// failure</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>then函数中的函数参数是[[PromiseValue]]中的值，即是Promise构造中的resolve()、reject()中的参数。</p>\n<p>另外，then函数中的方法是异步的，即使resolve立即执行，then中的函数也在同步函数执行结束之后执行：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Promise'</span>);</div><div class=\"line\">  resolve();</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved.'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi!'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Promise</span></div><div class=\"line\"><span class=\"comment\">// Hi!</span></div><div class=\"line\"><span class=\"comment\">// Resolved</span></div></pre></td></tr></table></figure></p>\n<p>catch函数相当于.then(null, function () {})，是在发生错误时的回调函数，reject()执行时也算是一种错误发生，所以在执行reject()时，catch中的函数也会被执行。<br>所以，最好的方式是reject()发生时候需要执行的函数定义在catch中，而不是在then的第二个参数中，这样无论是reject()还是其他错误都能够被捕获。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// bad</span></div><div class=\"line\">promise</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// success</span></div><div class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// error</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// good</span></div><div class=\"line\">promise</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123; <span class=\"comment\">//cb</span></div><div class=\"line\">    <span class=\"comment\">// success</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// error</span></div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"Promise对象的嵌套\"><a href=\"#Promise对象的嵌套\" class=\"headerlink\" title=\"Promise对象的嵌套\"></a>Promise对象的嵌套</h3><p>在resolve()和reject()中传递的可以是另一个Promise对象，例如<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'fail'</span>)), <span class=\"number\">3000</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(p1), <span class=\"number\">1000</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">p2</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> <span class=\"built_in\">console</span>.log(result))</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(error))</div><div class=\"line\"><span class=\"comment\">// Error: fail</span></div></pre></td></tr></table></figure></p>\n<p>p1是一个Promise，3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。此时，由于p2返回的是另一个Promise，所以后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。</p>\n<h3 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h3><h4 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h4><p>Promise.all()将多个Promise包装成一个Promise对象，只有在包装的多个Promise都转变成<code>Resolved</code>状态，此Promise.all()才会转变成<code>Resolved</code>状态，返回值是多个Promise返回值组成的数组；如果有其中一个转变成了<code>Rejected</code>状态，则此Promise.all()变成<code>Rejected</code>状态，返回值是第一个被reject的返回值。</p>\n<h4 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h4><p>Promise.race()可以理解成Promise.all()的“否命题”。<br>将多个Promise包装成一个，只要有其中一个状态变成<code>Resolved</code>，则此Promise.race()变成<code>Resolved</code>，返回值是第一个状态变成<code>Resolved</code>的值。</p>\n<h4 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h4><p>Promise.resolve()用于将对象转换成Promise对象。</p>\n<pre><code>1. 参数为Promise对象，方法什么也不做，直接返回。\n2. 参数为一个有then方法的对象，方法将对象转换成Promise对象，并立即执行then方法。例如：Promise.resolve(Object)相当于new Promise(Object.then)\n3. 参数不是具有then方法的对象，或者不是对象，则返回一个状态为`Resolved`的Promise对象，并将此参数传递给then中的第一个参数函数。\n4. 不带任何参数，直接返回`Resolved`的Promise对象。\n</code></pre><h4 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h4><p>Promise.reject()和Promise.resolve()行为一致，只是返回的默认是<code>Rejected</code>的Promise对象。</p>\n<h4 id=\"done\"><a href=\"#done\" class=\"headerlink\" title=\"done()\"></a>done()</h4><h4 id=\"finally\"><a href=\"#finally\" class=\"headerlink\" title=\"finally()\"></a>finally()</h4>","excerpt":"","more":"<h2 id=\"Promise总结\"><a href=\"#Promise总结\" class=\"headerlink\" title=\"Promise总结\"></a>Promise总结</h2><p>因为最近项目中用到了ajax，想尝试下Promise，所以看了下ES6中的<a href=\"http://es6.ruanyifeng.com/#docs/promise\">Promise</a>。</p>\n<p>一般用法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// promise表示一个Promise对象</span></div><div class=\"line\">promise</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// success</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// error</span></div><div class=\"line\">  &#125;)</div></pre></td></tr></table></figure></p>\n<p>所以如果使用jQuery或者zepto，可以这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ajaxBack = $.ajax(&#123;</div><div class=\"line\">  <span class=\"attr\">url</span>: <span class=\"string\">'*****'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">ajaxBack</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 处理数据</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 处理报错</span></div><div class=\"line\">  &#125;)</div></pre></td></tr></table></figure></p>\n<h3 id=\"什么是Promise对象？\"><a href=\"#什么是Promise对象？\" class=\"headerlink\" title=\"什么是Promise对象？\"></a>什么是Promise对象？</h3><p>Promise是异步编程的一种解决方案。<br>首先，我们通过chrome浏览器控制台来看一下Promise对象的样子。<br>在控制台输入<code>Promise</code>然后回车，会看到输出<code>function Promise() { [native code] }</code>。然后我们new一个Promise出来看一下，<code>var promise = new Promise(function(){})</code>，在创建Promise对象时候，必须传递一个函数，否则会报错。<br>看一下promise：<br><img src=\"./images/Promise_Object.png\" alt=\"Promise对象\"><br>包括__proto__，[[PromiseStatus]]，[[PromiseValue]]三个属性，其中__proto__主要包括catch、then、constructor方法。所以我们对Promise的学习主要就是[[PromiseStatus]]，[[PromiseValue]]属性和catch，then方法。</p>\n<h3 id=\"Promise的三种状态\"><a href=\"#Promise的三种状态\" class=\"headerlink\" title=\"Promise的三种状态\"></a>Promise的三种状态</h3><p>通过<a href=\"http://es6.ruanyifeng.com/#docs/promise\">资料</a>，我们会知道Promise对象有三种状态：Pending、Resolved和Rejected。<br>Promise构造函数接受一个函数作为参数，该函数有两个参数分别为resolve和reject，我们的创建方法应该是这样<code>new Promise(function (resolve, reject) {})</code>。<br>这两个参数resolve和reject也是函数，resolve是将Promise对象的状态从Pending变成Resolved，reject是将Promise对象的状态从Pending变成Rejected。<br>如果我们执行<code>var promise = new Promise(function(resolve, reject){resolve()})</code>，会发现promise中的[[PromiseStatus]]变成了<code>&quot;resolved&quot;</code>。如果我们执行<code>var promise = new Promise(function(resolve, reject){resolve(&#39;执行成功&#39;)})</code>，会发现不仅[[PromiseStatus]]变了，[[PromiseValue]]的值变成了<code>“执行成功”</code>。(reject函数同理)</p>\n<pre><code>需要注意：\n  只有函数中的构造函数参数中的resolve和reject可以改变Promise对象的状态。\n  一旦Promise对象的状态改变，就会一直保持这个状态，不能再改变。\n</code></pre><h3 id=\"Promise的then函数和catch函数\"><a href=\"#Promise的then函数和catch函数\" class=\"headerlink\" title=\"Promise的then函数和catch函数\"></a>Promise的then函数和catch函数</h3><p>then函数和catch函数可以理解成对Promise状态的监听函数，不同点在于监听函数需要在事件发生之前创建，而因为Promise中的状态在改变后是不能再次改变的，所以then函数和catch函数可以在Promise对象改变状态之后创建，这样的话，该函数会立即执行。<br>then函数接受两个函数作为参数，分别是Promise状态为<code>Resolved</code>时执行和状态为<code>Rejected</code>时执行。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// promise是一个Promise对象</span></div><div class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// success</span></div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// failure</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>then函数中的函数参数是[[PromiseValue]]中的值，即是Promise构造中的resolve()、reject()中的参数。</p>\n<p>另外，then函数中的方法是异步的，即使resolve立即执行，then中的函数也在同步函数执行结束之后执行：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Promise'</span>);</div><div class=\"line\">  resolve();</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved.'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi!'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Promise</span></div><div class=\"line\"><span class=\"comment\">// Hi!</span></div><div class=\"line\"><span class=\"comment\">// Resolved</span></div></pre></td></tr></table></figure></p>\n<p>catch函数相当于.then(null, function () {})，是在发生错误时的回调函数，reject()执行时也算是一种错误发生，所以在执行reject()时，catch中的函数也会被执行。<br>所以，最好的方式是reject()发生时候需要执行的函数定义在catch中，而不是在then的第二个参数中，这样无论是reject()还是其他错误都能够被捕获。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// bad</span></div><div class=\"line\">promise</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// success</span></div><div class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// error</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// good</span></div><div class=\"line\">promise</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123; <span class=\"comment\">//cb</span></div><div class=\"line\">    <span class=\"comment\">// success</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// error</span></div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"Promise对象的嵌套\"><a href=\"#Promise对象的嵌套\" class=\"headerlink\" title=\"Promise对象的嵌套\"></a>Promise对象的嵌套</h3><p>在resolve()和reject()中传递的可以是另一个Promise对象，例如<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'fail'</span>)), <span class=\"number\">3000</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(p1), <span class=\"number\">1000</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">p2</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> <span class=\"built_in\">console</span>.log(result))</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(error))</div><div class=\"line\"><span class=\"comment\">// Error: fail</span></div></pre></td></tr></table></figure></p>\n<p>p1是一个Promise，3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。此时，由于p2返回的是另一个Promise，所以后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。</p>\n<h3 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h3><h4 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h4><p>Promise.all()将多个Promise包装成一个Promise对象，只有在包装的多个Promise都转变成<code>Resolved</code>状态，此Promise.all()才会转变成<code>Resolved</code>状态，返回值是多个Promise返回值组成的数组；如果有其中一个转变成了<code>Rejected</code>状态，则此Promise.all()变成<code>Rejected</code>状态，返回值是第一个被reject的返回值。</p>\n<h4 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h4><p>Promise.race()可以理解成Promise.all()的“否命题”。<br>将多个Promise包装成一个，只要有其中一个状态变成<code>Resolved</code>，则此Promise.race()变成<code>Resolved</code>，返回值是第一个状态变成<code>Resolved</code>的值。</p>\n<h4 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h4><p>Promise.resolve()用于将对象转换成Promise对象。</p>\n<pre><code>1. 参数为Promise对象，方法什么也不做，直接返回。\n2. 参数为一个有then方法的对象，方法将对象转换成Promise对象，并立即执行then方法。例如：Promise.resolve(Object)相当于new Promise(Object.then)\n3. 参数不是具有then方法的对象，或者不是对象，则返回一个状态为`Resolved`的Promise对象，并将此参数传递给then中的第一个参数函数。\n4. 不带任何参数，直接返回`Resolved`的Promise对象。\n</code></pre><h4 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h4><p>Promise.reject()和Promise.resolve()行为一致，只是返回的默认是<code>Rejected</code>的Promise对象。</p>\n<h4 id=\"done\"><a href=\"#done\" class=\"headerlink\" title=\"done()\"></a>done()</h4><h4 id=\"finally\"><a href=\"#finally\" class=\"headerlink\" title=\"finally()\"></a>finally()</h4>"},{"_content":"## 安装\rReact在codepen上提供了一个Hello，World项目事例，只需打开[网站](http://codepen.io/gaearon/pen/rrpgNB?editors=0010)，即可尝试React。  \r另外还提供了一个[html文件](https://facebook.github.io/react/downloads/single-file-example.html)的Hello，World项目，项目中引用CDN的react.js、react-dom.js以及用于编译babel的babel.min.js，运行比较缓慢，只适合学习语法使用。\r\r## 创建单页面应用\r创建React应用的最好方法是单页面应用，这里是最好方法，也是可以创建多页面应用的。可以通过官方方法去创建你的应用：\r```shell\rnpm install -g create-react-app\rcreate-create-app hello-world\rcd hello-world\rnpm start\r```\r这里不涉及任何后端逻辑和数据库，可以使用任何你想用的后端。create-react-app中使用了Webpack，Babel和ESLint，但是你可以自己去配置他们。\r\r### 将React加入一个现有的应用\r使用`npm install --save react react-dom`安装React。  \r将其导入你的代码中，如：\r```javascript\rimport React from 'react';\rimport ReactDOM from 'react-dom';\r\rReactDOM.render(\r  <h1>Hello, world!</h1>,\r  document.getElementById('root')\r)\r```\r这段代码应该被包含在一个拥有id为root的HTML元素，所以你的HTML文件需要`<div id=\"root\"></div>`  \r当你使用上面方法使用React的时候，需要使用预设为es2015和react的Babel进行转化代码。使用React在生产环境的时候，设置NODE_ENV为\"production\"。\r\r### 使用ES6和JSX\r建议是用Babel将你的ES6和JSX代码转换为JavaScript代码，Babel可以有很多不同的配置，但是确保里面包含`babel-preset-react`和`babel-preset-es2015`。\r\r### 使用CDN\r如果不想使用npm，可以使用CDN\r```html\r<script src=\"https://unpkg.com/react@15/dist/react.js\"></script>\r<script src=\"https://unpkg.com/react-dom@15/dist/react-dom.js\"></script>\r```\r@后面数字可以指定版本\r```html\r<script src=\"https://unpkg.com/react@15/dist/react.min.js\"></script>\r<script src=\"https://unpkg.com/react-dom@15/dist/react-dom.min.js\"></script>\r```\r\r## JSX\r在JSX中，可以在任意地方插入JavaScript代码，只需要将JavaScript放在大括号中即可。下面的代码都是合法的：\r```jsx\rfunction formatName(user) {\r  return user.firstName + ' ' + user.lastName;\r}\r\rconst user = {\r  firstName: 'Harper',\r  lastName: 'Perez'\r};\r\rconst element = (\r  <h1>\r    Hello, {formatName(user)}!\r  </h1>\r);\r\rReactDOM.render(\r  element,\r  document.getElementById('root')\r);\r```\r将JSX代码放在小括号中，像HTML代码一样换行，可以方便阅读。\r\r#### JSX也是表达式\rJSX最后也被编译成JavaScript代码，这就以为着JSX可以赋值给一个JavaScript变量，可以作为方法的参数，可以被方法返回。\r\r#### JSX添加HTML属性\r可以用字符串设置属性，也可以通过使用{}将JavaScript表达式赋值给属性。\r\r#### 闭合JSX\r如果JSX是空的可以使用`/>`来闭合标签，如果包含其他标签，也可以使用</***>闭合。  \r虽然JSX很接近HTML，但是还是有些不同，比如属性使用小驼峰法命名，class使用className，for使用forHtml等。\r\r#### JSX防止注入攻击\r默认情况下，React DOM在渲染JSX之前会对其进行编码。\r\r#### JSX描述对象\rBabel会将JSX转化为React.createElement()形式，比如下面这样：\r```jsx\rconst element = (\r  <h1 className=\"greeting\">\r    Hello, world!\r  </h1>\r)\r```\r转化为\r```javascript\rconst element = React.createElement(\r  'h1',\r  {className: 'greeting'},\r  'Hello, world!'\r);\r```\rReact.createElement会对你的代码进行一些检查，但是本质上就是将其转化成一个对象：\r```javascript\rconst element = {\r  type: 'h1',\r  props: {\r    className: 'greeting',\r    children: 'Hello, world'\r  }\r}\r```\r\r## 组件\r将你的页面分成一个个组件，每个组件都是独立的、可以重复使用的。组件就像JavaScript中的方法，可以接受一些输入参数，返回React元素\r\r#### Funtional 和 Class 组件\r定义组件最简单的方式是使用JavaScript方法：\r```javascript\rfunction Welcome (props) {\r  return <h1>Hello, {props.name}</h1>\r}\r这个方法就是个有效的React组件，因为它接受props作为参数，并且返回了一个React元素。\r\r另外也可以使用ES6中的类(class)来定义组件：\r```javascript\rclass Welcome extends React.Component {\r  render () {\r    return <h1>Hello, {this.props.name}</h1>\r  }\r}\r```\r上面两种定义组件的方法是等价的。  \r但是Class组件能够添加一些额外的功能，我们将在下面讨论。在不需要这些额外的方法，可以使用Functional组件。\r\r#### 渲染组件\r渲染如下：\r```javascript\rfunction Welcome(props) {\r  return <h1>Hello, {props.name}</h1>;\r}\r\rconst element = <Welcome name=\"Sara\" />;\rReactDOM.render(\r  element,\r  document.getElementById('root')\r);\r```\r过程：\r  1. 调用ReactDOM.render()方法，参数为自定义组件<Welcome name=\"Sara\" />。\r  2. React调用组件Welcome，传递`{name=\"Sara\"}`作为参数。\r  3. Welcome组件返回`<h1>Hello, Sara</h1>`。\r  4. React将`<h1>Hello, Sara</h1>`更新到页面。\r\r#### 组件组合\r组件可以任意组合。  \r通常情况，React应用中在最顶端是一个`App`组件。组件必须有一个根元素，也就是所有元素都得包裹起来。\r\r#### 提取组件\r不要担心组件被拆分的太小。下面是一个对组件进行拆分的例子。  \rComment组件：  \r```javascript\rfunction Comment(props) {\r  return (\r    <div className=\"Comment\">\r      <div className=\"UserInfo\">\r        <img className=\"Avatar\"\r          src={props.author.avatarUrl}\r          alt={props.author.name}\r        />\r        <div className=\"UserInfo-name\">\r          {props.author.name}\r        </div>\r      </div>\r      <div className=\"Comment-text\">\r        {props.text}\r      </div>\r      <div className=\"Comment-date\">\r        {formatDate(props.date)}\r      </div>\r    </div>\r  );\r}\r```\r在Comment组件中，使用了`author (object)`，`text (string)`，`date (date)`来描述这个对象。这样的组件因为组合的原因是很难复用的。\r\r第一步，提取出一个`Avatar`组件：\r```javascript\rfunction Avatar(props) {\r  return (\r    <img className=\"Avatar\"\r      src={props.user.avatarUrl}\r      alt={props.user.name}\r    />\r  );\r}\r```\r这里的`Avatar`组件我们系统他更通用，所以说用了`user`而不是`author`。  \r根据组件去命名参数，而不是根据使用上下文。\r\r下一步是提取`UserInfo`组件，这里使用了上面提取的`Avatar`组件：\r```javascript\rfunction UserInfo(props) {\r  return (\r    <div className=\"UserInfo\">\r      <Avatar user={props.user} />\r      <div className=\"UserInfo-name\">\r        {props.user.name}\r      </div>\r    </div>\r  );\r}\r```\r这样，我们的`Comment`组件就成了下面的样子：\r```javascript\rfunction Comment(props) {\r  return (\r    <div className=\"Comment\">\r      <UserInfo user={props.author} />\r      <div className=\"Comment-text\">\r        {props.text}\r      </div>\r      <div className=\"Comment-date\">\r        {formatDate(props.date)}\r      </div>\r    </div>\r  );\r}\r```\r\r#### Props是只读的\r无论是Funcional还是Class组件，都是不能够修改props的。\r```javascript\r// 下面这个是纯函数，因为它没有试图改变自己的输入，并且对相同的输入会有相同的输出。\rfunction sum(a, b) {\r  return a + b;\r}\r// 下面这个不是纯函数，因为他改变了输入的值\rfunction withdraw(account, amount) {\r  account.total -= amount;\r}\r```\r通过官方这个例子，可以明白纯函数有两点，一是相同的输入就会有相同的输出，第二点是不会更改输入的参数。\r\r所有的React组件对于props参数必须像纯函数一样，也就是不会试图去修改props，并且对于相同的props会有相同的输出。  \r当然，React也提供了随时间动态变化组件的方法，state允许根据用户行为、网络反馈等改变React组件的输出形式，这并不违背React纯函数原则。\r\r## state 和 生命周期\r请看下面一段代码：\r```javascript\rconst Clock = (\r  <div>\r    <h1>Hello, world!</h1>\r    <h2>It is {new Date().toLocaleTimeString()}.</h2>\r  </div>\r);\rReactDOM.render(\r  <Clock />,\r  document.getElementById('root')\r);\r```\r这段代码只能够显示一个Hello,world!与一个生成页面的时间。如果想要时间不停的更新，就需要使用setInterval()不停的去执行。\r```javascript\r// 这样\rfunction tick() {\r  const Clock = (\r    <div>\r      <h1>Hello, world!</h1>\r      <h2>It is {new Date().toLocaleTimeString()}.</h2>\r    </div>\r  );\r  ReactDOM.render(\r    <Clock />,\r    document.getElementById('root')\r  );\r}\rsetInterval(tick, 1000);\r\r// 或者这样\rfunction Clock(props) {\r  return (\r    <div>\r      <h1>Hello, world!</h1>\r      <h2>It is {props.date.toLocaleTimeString()}.</h2>\r    </div>\r  );\r}\r\rfunction tick() {\r  ReactDOM.render(\r    <Clock date={new Date()} />,\r    document.getElementById('root')\r  );\r}\rsetInterval(tick, 1000);\r\r// 但是下面这种就是不可行的，原因在于Clock组件定义被转化成了一个对象，在之后没有发生过变化。\rconst Clock = (\r  <div>\r    <h1>Hello, world!</h1>\r    <h2>It is {new Date().toLocaleTimeString()}.</h2>\r  </div>\r);\rsetInterval(\rfunction(){\rReactDOM.render(\r  <Clock />,\r  document.getElementById('root')\r)}, 1000)\r```\r这样的代码的问题在于时间的变化应该是`Clock`组件的行为，而不应该定义在全局。  \r`state`可以帮助我们解决这个问题，state与props类似，但是更私有且被组件所控制，而不是传递过来的。\r\r#### 将Functional组件转换为Class组件\rFunctional组件是无状态组件，不能使用state，所以首先需要将Functional转化为Class组件：\r  1. 创建一个和Functional组件名相同的ES6 class继承`React.Component`\r  2. 添加空的方法`render()`\r  3. 将Functional组件中的函数主体移动`render()`方法中\r  4. 将`render()`中的`props`替换成`this.props`\r  5. 删除原来的Functional组件声明\rClass组件不仅可以使用state还可以使用生命周期函数。  \r拿上面的`Clock`组件作为事例，经过上面的转换，现在的Clock组件应该是这个样子：\r```jsx\rclass Clock extends React.Component {\r  render() {\r    return (\r      <div>\r        <h1>Hello, world!</h1>\r        <h2>It is {this.props.date.toLocaleTimeString()}.</h2>\r      </div>\r    );\r  }\r}\r```\r\r#### 为Class组件添加本地state\r还是上面的`Clock`组件：\r  1. 将`render()`中的`this.props`替换成`this.state`\r  2. 添加class构造函数(constructor)初始化this.state (Class组件总是应该将props传递给父类)\r  3. 移除`date`从组件调用的props中\r```javascript\rclass Clock extends React.Component {\r  // 这里是步骤2\r  constructor(props) {\r    // 将props传递给父类\r    super(props);\r    this.state = {date: new Date()};\r  }\r\r  render() {\r    return (\r      <div>\r        <h1>Hello, world!</h1>\r        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\r      </div>\r    );\r  }\r}\r\rReactDOM.render(\r  <Clock />,\r  document.getElementById('root')\r);\r```\r这样只是初始化了state，后面会设置定时器。","source":"_posts/React Docs.md","raw":"## 安装\rReact在codepen上提供了一个Hello，World项目事例，只需打开[网站](http://codepen.io/gaearon/pen/rrpgNB?editors=0010)，即可尝试React。  \r另外还提供了一个[html文件](https://facebook.github.io/react/downloads/single-file-example.html)的Hello，World项目，项目中引用CDN的react.js、react-dom.js以及用于编译babel的babel.min.js，运行比较缓慢，只适合学习语法使用。\r\r## 创建单页面应用\r创建React应用的最好方法是单页面应用，这里是最好方法，也是可以创建多页面应用的。可以通过官方方法去创建你的应用：\r```shell\rnpm install -g create-react-app\rcreate-create-app hello-world\rcd hello-world\rnpm start\r```\r这里不涉及任何后端逻辑和数据库，可以使用任何你想用的后端。create-react-app中使用了Webpack，Babel和ESLint，但是你可以自己去配置他们。\r\r### 将React加入一个现有的应用\r使用`npm install --save react react-dom`安装React。  \r将其导入你的代码中，如：\r```javascript\rimport React from 'react';\rimport ReactDOM from 'react-dom';\r\rReactDOM.render(\r  <h1>Hello, world!</h1>,\r  document.getElementById('root')\r)\r```\r这段代码应该被包含在一个拥有id为root的HTML元素，所以你的HTML文件需要`<div id=\"root\"></div>`  \r当你使用上面方法使用React的时候，需要使用预设为es2015和react的Babel进行转化代码。使用React在生产环境的时候，设置NODE_ENV为\"production\"。\r\r### 使用ES6和JSX\r建议是用Babel将你的ES6和JSX代码转换为JavaScript代码，Babel可以有很多不同的配置，但是确保里面包含`babel-preset-react`和`babel-preset-es2015`。\r\r### 使用CDN\r如果不想使用npm，可以使用CDN\r```html\r<script src=\"https://unpkg.com/react@15/dist/react.js\"></script>\r<script src=\"https://unpkg.com/react-dom@15/dist/react-dom.js\"></script>\r```\r@后面数字可以指定版本\r```html\r<script src=\"https://unpkg.com/react@15/dist/react.min.js\"></script>\r<script src=\"https://unpkg.com/react-dom@15/dist/react-dom.min.js\"></script>\r```\r\r## JSX\r在JSX中，可以在任意地方插入JavaScript代码，只需要将JavaScript放在大括号中即可。下面的代码都是合法的：\r```jsx\rfunction formatName(user) {\r  return user.firstName + ' ' + user.lastName;\r}\r\rconst user = {\r  firstName: 'Harper',\r  lastName: 'Perez'\r};\r\rconst element = (\r  <h1>\r    Hello, {formatName(user)}!\r  </h1>\r);\r\rReactDOM.render(\r  element,\r  document.getElementById('root')\r);\r```\r将JSX代码放在小括号中，像HTML代码一样换行，可以方便阅读。\r\r#### JSX也是表达式\rJSX最后也被编译成JavaScript代码，这就以为着JSX可以赋值给一个JavaScript变量，可以作为方法的参数，可以被方法返回。\r\r#### JSX添加HTML属性\r可以用字符串设置属性，也可以通过使用{}将JavaScript表达式赋值给属性。\r\r#### 闭合JSX\r如果JSX是空的可以使用`/>`来闭合标签，如果包含其他标签，也可以使用</***>闭合。  \r虽然JSX很接近HTML，但是还是有些不同，比如属性使用小驼峰法命名，class使用className，for使用forHtml等。\r\r#### JSX防止注入攻击\r默认情况下，React DOM在渲染JSX之前会对其进行编码。\r\r#### JSX描述对象\rBabel会将JSX转化为React.createElement()形式，比如下面这样：\r```jsx\rconst element = (\r  <h1 className=\"greeting\">\r    Hello, world!\r  </h1>\r)\r```\r转化为\r```javascript\rconst element = React.createElement(\r  'h1',\r  {className: 'greeting'},\r  'Hello, world!'\r);\r```\rReact.createElement会对你的代码进行一些检查，但是本质上就是将其转化成一个对象：\r```javascript\rconst element = {\r  type: 'h1',\r  props: {\r    className: 'greeting',\r    children: 'Hello, world'\r  }\r}\r```\r\r## 组件\r将你的页面分成一个个组件，每个组件都是独立的、可以重复使用的。组件就像JavaScript中的方法，可以接受一些输入参数，返回React元素\r\r#### Funtional 和 Class 组件\r定义组件最简单的方式是使用JavaScript方法：\r```javascript\rfunction Welcome (props) {\r  return <h1>Hello, {props.name}</h1>\r}\r这个方法就是个有效的React组件，因为它接受props作为参数，并且返回了一个React元素。\r\r另外也可以使用ES6中的类(class)来定义组件：\r```javascript\rclass Welcome extends React.Component {\r  render () {\r    return <h1>Hello, {this.props.name}</h1>\r  }\r}\r```\r上面两种定义组件的方法是等价的。  \r但是Class组件能够添加一些额外的功能，我们将在下面讨论。在不需要这些额外的方法，可以使用Functional组件。\r\r#### 渲染组件\r渲染如下：\r```javascript\rfunction Welcome(props) {\r  return <h1>Hello, {props.name}</h1>;\r}\r\rconst element = <Welcome name=\"Sara\" />;\rReactDOM.render(\r  element,\r  document.getElementById('root')\r);\r```\r过程：\r  1. 调用ReactDOM.render()方法，参数为自定义组件<Welcome name=\"Sara\" />。\r  2. React调用组件Welcome，传递`{name=\"Sara\"}`作为参数。\r  3. Welcome组件返回`<h1>Hello, Sara</h1>`。\r  4. React将`<h1>Hello, Sara</h1>`更新到页面。\r\r#### 组件组合\r组件可以任意组合。  \r通常情况，React应用中在最顶端是一个`App`组件。组件必须有一个根元素，也就是所有元素都得包裹起来。\r\r#### 提取组件\r不要担心组件被拆分的太小。下面是一个对组件进行拆分的例子。  \rComment组件：  \r```javascript\rfunction Comment(props) {\r  return (\r    <div className=\"Comment\">\r      <div className=\"UserInfo\">\r        <img className=\"Avatar\"\r          src={props.author.avatarUrl}\r          alt={props.author.name}\r        />\r        <div className=\"UserInfo-name\">\r          {props.author.name}\r        </div>\r      </div>\r      <div className=\"Comment-text\">\r        {props.text}\r      </div>\r      <div className=\"Comment-date\">\r        {formatDate(props.date)}\r      </div>\r    </div>\r  );\r}\r```\r在Comment组件中，使用了`author (object)`，`text (string)`，`date (date)`来描述这个对象。这样的组件因为组合的原因是很难复用的。\r\r第一步，提取出一个`Avatar`组件：\r```javascript\rfunction Avatar(props) {\r  return (\r    <img className=\"Avatar\"\r      src={props.user.avatarUrl}\r      alt={props.user.name}\r    />\r  );\r}\r```\r这里的`Avatar`组件我们系统他更通用，所以说用了`user`而不是`author`。  \r根据组件去命名参数，而不是根据使用上下文。\r\r下一步是提取`UserInfo`组件，这里使用了上面提取的`Avatar`组件：\r```javascript\rfunction UserInfo(props) {\r  return (\r    <div className=\"UserInfo\">\r      <Avatar user={props.user} />\r      <div className=\"UserInfo-name\">\r        {props.user.name}\r      </div>\r    </div>\r  );\r}\r```\r这样，我们的`Comment`组件就成了下面的样子：\r```javascript\rfunction Comment(props) {\r  return (\r    <div className=\"Comment\">\r      <UserInfo user={props.author} />\r      <div className=\"Comment-text\">\r        {props.text}\r      </div>\r      <div className=\"Comment-date\">\r        {formatDate(props.date)}\r      </div>\r    </div>\r  );\r}\r```\r\r#### Props是只读的\r无论是Funcional还是Class组件，都是不能够修改props的。\r```javascript\r// 下面这个是纯函数，因为它没有试图改变自己的输入，并且对相同的输入会有相同的输出。\rfunction sum(a, b) {\r  return a + b;\r}\r// 下面这个不是纯函数，因为他改变了输入的值\rfunction withdraw(account, amount) {\r  account.total -= amount;\r}\r```\r通过官方这个例子，可以明白纯函数有两点，一是相同的输入就会有相同的输出，第二点是不会更改输入的参数。\r\r所有的React组件对于props参数必须像纯函数一样，也就是不会试图去修改props，并且对于相同的props会有相同的输出。  \r当然，React也提供了随时间动态变化组件的方法，state允许根据用户行为、网络反馈等改变React组件的输出形式，这并不违背React纯函数原则。\r\r## state 和 生命周期\r请看下面一段代码：\r```javascript\rconst Clock = (\r  <div>\r    <h1>Hello, world!</h1>\r    <h2>It is {new Date().toLocaleTimeString()}.</h2>\r  </div>\r);\rReactDOM.render(\r  <Clock />,\r  document.getElementById('root')\r);\r```\r这段代码只能够显示一个Hello,world!与一个生成页面的时间。如果想要时间不停的更新，就需要使用setInterval()不停的去执行。\r```javascript\r// 这样\rfunction tick() {\r  const Clock = (\r    <div>\r      <h1>Hello, world!</h1>\r      <h2>It is {new Date().toLocaleTimeString()}.</h2>\r    </div>\r  );\r  ReactDOM.render(\r    <Clock />,\r    document.getElementById('root')\r  );\r}\rsetInterval(tick, 1000);\r\r// 或者这样\rfunction Clock(props) {\r  return (\r    <div>\r      <h1>Hello, world!</h1>\r      <h2>It is {props.date.toLocaleTimeString()}.</h2>\r    </div>\r  );\r}\r\rfunction tick() {\r  ReactDOM.render(\r    <Clock date={new Date()} />,\r    document.getElementById('root')\r  );\r}\rsetInterval(tick, 1000);\r\r// 但是下面这种就是不可行的，原因在于Clock组件定义被转化成了一个对象，在之后没有发生过变化。\rconst Clock = (\r  <div>\r    <h1>Hello, world!</h1>\r    <h2>It is {new Date().toLocaleTimeString()}.</h2>\r  </div>\r);\rsetInterval(\rfunction(){\rReactDOM.render(\r  <Clock />,\r  document.getElementById('root')\r)}, 1000)\r```\r这样的代码的问题在于时间的变化应该是`Clock`组件的行为，而不应该定义在全局。  \r`state`可以帮助我们解决这个问题，state与props类似，但是更私有且被组件所控制，而不是传递过来的。\r\r#### 将Functional组件转换为Class组件\rFunctional组件是无状态组件，不能使用state，所以首先需要将Functional转化为Class组件：\r  1. 创建一个和Functional组件名相同的ES6 class继承`React.Component`\r  2. 添加空的方法`render()`\r  3. 将Functional组件中的函数主体移动`render()`方法中\r  4. 将`render()`中的`props`替换成`this.props`\r  5. 删除原来的Functional组件声明\rClass组件不仅可以使用state还可以使用生命周期函数。  \r拿上面的`Clock`组件作为事例，经过上面的转换，现在的Clock组件应该是这个样子：\r```jsx\rclass Clock extends React.Component {\r  render() {\r    return (\r      <div>\r        <h1>Hello, world!</h1>\r        <h2>It is {this.props.date.toLocaleTimeString()}.</h2>\r      </div>\r    );\r  }\r}\r```\r\r#### 为Class组件添加本地state\r还是上面的`Clock`组件：\r  1. 将`render()`中的`this.props`替换成`this.state`\r  2. 添加class构造函数(constructor)初始化this.state (Class组件总是应该将props传递给父类)\r  3. 移除`date`从组件调用的props中\r```javascript\rclass Clock extends React.Component {\r  // 这里是步骤2\r  constructor(props) {\r    // 将props传递给父类\r    super(props);\r    this.state = {date: new Date()};\r  }\r\r  render() {\r    return (\r      <div>\r        <h1>Hello, world!</h1>\r        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\r      </div>\r    );\r  }\r}\r\rReactDOM.render(\r  <Clock />,\r  document.getElementById('root')\r);\r```\r这样只是初始化了state，后面会设置定时器。","slug":"React Docs","published":1,"date":"2016-11-28T13:34:34.119Z","updated":"2016-11-27T01:15:21.862Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw3mfvsr00050kc7jciy3eis","content":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>React在codepen上提供了一个Hello，World项目事例，只需打开<a href=\"http://codepen.io/gaearon/pen/rrpgNB?editors=0010\" target=\"_blank\" rel=\"external\">网站</a>，即可尝试React。<br>另外还提供了一个<a href=\"https://facebook.github.io/react/downloads/single-file-example.html\" target=\"_blank\" rel=\"external\">html文件</a>的Hello，World项目，项目中引用CDN的react.js、react-dom.js以及用于编译babel的babel.min.js，运行比较缓慢，只适合学习语法使用。</p>\n<h2 id=\"创建单页面应用\"><a href=\"#创建单页面应用\" class=\"headerlink\" title=\"创建单页面应用\"></a>创建单页面应用</h2><p>创建React应用的最好方法是单页面应用，这里是最好方法，也是可以创建多页面应用的。可以通过官方方法去创建你的应用：</p>\n<pre><code class=\"shell\">npm install -g create-react-app\ncreate-create-app hello-world\ncd hello-world\nnpm start\n</code></pre>\n<p>这里不涉及任何后端逻辑和数据库，可以使用任何你想用的后端。create-react-app中使用了Webpack，Babel和ESLint，但是你可以自己去配置他们。</p>\n<h3 id=\"将React加入一个现有的应用\"><a href=\"#将React加入一个现有的应用\" class=\"headerlink\" title=\"将React加入一个现有的应用\"></a>将React加入一个现有的应用</h3><p>使用<code>npm install --save react react-dom</code>安装React。<br>将其导入你的代码中，如：</p>\n<pre><code class=\"javascript\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;\n<span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;\n\nReactDOM.render(\n  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>,\n  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)\n)\n</code></pre>\n<p>这段代码应该被包含在一个拥有id为root的HTML元素，所以你的HTML文件需要<code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code><br>当你使用上面方法使用React的时候，需要使用预设为es2015和react的Babel进行转化代码。使用React在生产环境的时候，设置NODE_ENV为”production”。</p>\n<h3 id=\"使用ES6和JSX\"><a href=\"#使用ES6和JSX\" class=\"headerlink\" title=\"使用ES6和JSX\"></a>使用ES6和JSX</h3><p>建议是用Babel将你的ES6和JSX代码转换为JavaScript代码，Babel可以有很多不同的配置，但是确保里面包含<code>babel-preset-react</code>和<code>babel-preset-es2015</code>。</p>\n<h3 id=\"使用CDN\"><a href=\"#使用CDN\" class=\"headerlink\" title=\"使用CDN\"></a>使用CDN</h3><p>如果不想使用npm，可以使用CDN</p>\n<pre><code class=\"html\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react@15/dist/react.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react-dom@15/dist/react-dom.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>\n</code></pre>\n<p>@后面数字可以指定版本</p>\n<pre><code class=\"html\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react@15/dist/react.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react-dom@15/dist/react-dom.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>\n</code></pre>\n<h2 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h2><p>在JSX中，可以在任意地方插入JavaScript代码，只需要将JavaScript放在大括号中即可。下面的代码都是合法的：</p>\n<pre><code class=\"jsx\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatName</span>(<span class=\"params\">user</span>) </span>{\n  <span class=\"keyword\">return</span> user.firstName + <span class=\"string\">' '</span> + user.lastName;\n}\n\n<span class=\"keyword\">const</span> user = {\n  <span class=\"attr\">firstName</span>: <span class=\"string\">'Harper'</span>,\n  <span class=\"attr\">lastName</span>: <span class=\"string\">'Perez'</span>\n};\n\n<span class=\"keyword\">const</span> element = (\n  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>\n    Hello, {formatName(user)}!\n  <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>\n);\n\nReactDOM.render(\n  element,\n  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)\n);\n</code></pre>\n<p>将JSX代码放在小括号中，像HTML代码一样换行，可以方便阅读。</p>\n<h4 id=\"JSX也是表达式\"><a href=\"#JSX也是表达式\" class=\"headerlink\" title=\"JSX也是表达式\"></a>JSX也是表达式</h4><p>JSX最后也被编译成JavaScript代码，这就以为着JSX可以赋值给一个JavaScript变量，可以作为方法的参数，可以被方法返回。</p>\n<h4 id=\"JSX添加HTML属性\"><a href=\"#JSX添加HTML属性\" class=\"headerlink\" title=\"JSX添加HTML属性\"></a>JSX添加HTML属性</h4><p>可以用字符串设置属性，也可以通过使用{}将JavaScript表达式赋值给属性。</p>\n<h4 id=\"闭合JSX\"><a href=\"#闭合JSX\" class=\"headerlink\" title=\"闭合JSX\"></a>闭合JSX</h4><p>如果JSX是空的可以使用<code>/&gt;</code>来闭合标签，如果包含其他标签，也可以使用&lt;/<em>*</em>&gt;闭合。<br>虽然JSX很接近HTML，但是还是有些不同，比如属性使用小驼峰法命名，class使用className，for使用forHtml等。</p>\n<h4 id=\"JSX防止注入攻击\"><a href=\"#JSX防止注入攻击\" class=\"headerlink\" title=\"JSX防止注入攻击\"></a>JSX防止注入攻击</h4><p>默认情况下，React DOM在渲染JSX之前会对其进行编码。</p>\n<h4 id=\"JSX描述对象\"><a href=\"#JSX描述对象\" class=\"headerlink\" title=\"JSX描述对象\"></a>JSX描述对象</h4><p>Babel会将JSX转化为React.createElement()形式，比如下面这样：</p>\n<pre><code class=\"jsx\"><span class=\"keyword\">const</span> element = (\n  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">className</span>=<span class=\"string\">\"greeting\"</span>&gt;</span>\n    Hello, world!\n  <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>\n)\n</code></pre>\n<p>转化为</p>\n<pre><code class=\"javascript\"><span class=\"keyword\">const</span> element = React.createElement(\n  <span class=\"string\">'h1'</span>,\n  {<span class=\"attr\">className</span>: <span class=\"string\">'greeting'</span>},\n  <span class=\"string\">'Hello, world!'</span>\n);\n</code></pre>\n<p>React.createElement会对你的代码进行一些检查，但是本质上就是将其转化成一个对象：</p>\n<pre><code class=\"javascript\"><span class=\"keyword\">const</span> element = {\n  <span class=\"attr\">type</span>: <span class=\"string\">'h1'</span>,\n  <span class=\"attr\">props</span>: {\n    <span class=\"attr\">className</span>: <span class=\"string\">'greeting'</span>,\n    <span class=\"attr\">children</span>: <span class=\"string\">'Hello, world'</span>\n  }\n}\n</code></pre>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><p>将你的页面分成一个个组件，每个组件都是独立的、可以重复使用的。组件就像JavaScript中的方法，可以接受一些输入参数，返回React元素</p>\n<h4 id=\"Funtional-和-Class-组件\"><a href=\"#Funtional-和-Class-组件\" class=\"headerlink\" title=\"Funtional 和 Class 组件\"></a>Funtional 和 Class 组件</h4><p>定义组件最简单的方式是使用JavaScript方法：</p>\n<pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span> (<span class=\"params\">props</span>) </span>{\n  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, {props.name}<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>\n}\n这个方法就是个有效的React组件，因为它接受props作为参数，并且返回了一个React元素。\n\n另外也可以使用ES6中的类(<span class=\"class\"><span class=\"keyword\">class</span>)来定义组件：\n```<span class=\"title\">javascript</span>\n<span class=\"title\">class</span> <span class=\"title\">Welcome</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>{\n  render () {\n    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, {this.props.name}<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>\n  }\n}\n</code></pre>\n<p>上面两种定义组件的方法是等价的。<br>但是Class组件能够添加一些额外的功能，我们将在下面讨论。在不需要这些额外的方法，可以使用Functional组件。</p>\n<h4 id=\"渲染组件\"><a href=\"#渲染组件\" class=\"headerlink\" title=\"渲染组件\"></a>渲染组件</h4><p>渲染如下：</p>\n<pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>{\n  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, {props.name}<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;\n}\n\n<span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Welcome</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Sara\"</span> /&gt;</span>;\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);</span>\n</code></pre>\n<p>过程：</p>\n<ol>\n<li>调用ReactDOM.render()方法，参数为自定义组件<welcome name=\"Sara\">。</welcome></li>\n<li>React调用组件Welcome，传递<code>{name=&quot;Sara&quot;}</code>作为参数。</li>\n<li>Welcome组件返回<code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>。</li>\n<li>React将<code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>更新到页面。</li>\n</ol>\n<h4 id=\"组件组合\"><a href=\"#组件组合\" class=\"headerlink\" title=\"组件组合\"></a>组件组合</h4><p>组件可以任意组合。<br>通常情况，React应用中在最顶端是一个<code>App</code>组件。组件必须有一个根元素，也就是所有元素都得包裹起来。</p>\n<h4 id=\"提取组件\"><a href=\"#提取组件\" class=\"headerlink\" title=\"提取组件\"></a>提取组件</h4><p>不要担心组件被拆分的太小。下面是一个对组件进行拆分的例子。<br>Comment组件：  </p>\n<pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Comment</span>(<span class=\"params\">props</span>) </span>{\n  <span class=\"keyword\">return</span> (\n    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment\"</span>&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"UserInfo\"</span>&gt;</span>\n        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Avatar\"</span>\n          <span class=\"attr\">src</span>=<span class=\"string\">{props.author.avatarUrl}</span>\n          <span class=\"attr\">alt</span>=<span class=\"string\">{props.author.name}</span>\n        /&gt;</span>\n        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"UserInfo-name\"</span>&gt;</span>\n          {props.author.name}\n        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment-text\"</span>&gt;</span>\n        {props.text}\n      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment-date\"</span>&gt;</span>\n        {formatDate(props.date)}\n      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n  );\n}</span>\n</code></pre>\n<p>在Comment组件中，使用了<code>author (object)</code>，<code>text (string)</code>，<code>date (date)</code>来描述这个对象。这样的组件因为组合的原因是很难复用的。</p>\n<p>第一步，提取出一个<code>Avatar</code>组件：</p>\n<pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Avatar</span>(<span class=\"params\">props</span>) </span>{\n  <span class=\"keyword\">return</span> (\n    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Avatar\"</span>\n      <span class=\"attr\">src</span>=<span class=\"string\">{props.user.avatarUrl}</span>\n      <span class=\"attr\">alt</span>=<span class=\"string\">{props.user.name}</span>\n    /&gt;</span>\n  );\n}</span>\n</code></pre>\n<p>这里的<code>Avatar</code>组件我们系统他更通用，所以说用了<code>user</code>而不是<code>author</code>。<br>根据组件去命名参数，而不是根据使用上下文。</p>\n<p>下一步是提取<code>UserInfo</code>组件，这里使用了上面提取的<code>Avatar</code>组件：</p>\n<pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserInfo</span>(<span class=\"params\">props</span>) </span>{\n  <span class=\"keyword\">return</span> (\n    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"UserInfo\"</span>&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">Avatar</span> <span class=\"attr\">user</span>=<span class=\"string\">{props.user}</span> /&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"UserInfo-name\"</span>&gt;</span>\n        {props.user.name}\n      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n  );\n}</span>\n</code></pre>\n<p>这样，我们的<code>Comment</code>组件就成了下面的样子：</p>\n<pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Comment</span>(<span class=\"params\">props</span>) </span>{\n  <span class=\"keyword\">return</span> (\n    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment\"</span>&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">UserInfo</span> <span class=\"attr\">user</span>=<span class=\"string\">{props.author}</span> /&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment-text\"</span>&gt;</span>\n        {props.text}\n      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment-date\"</span>&gt;</span>\n        {formatDate(props.date)}\n      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n  );\n}</span>\n</code></pre>\n<h4 id=\"Props是只读的\"><a href=\"#Props是只读的\" class=\"headerlink\" title=\"Props是只读的\"></a>Props是只读的</h4><p>无论是Funcional还是Class组件，都是不能够修改props的。</p>\n<pre><code class=\"javascript\"><span class=\"comment\">// 下面这个是纯函数，因为它没有试图改变自己的输入，并且对相同的输入会有相同的输出。</span>\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>{\n  <span class=\"keyword\">return</span> a + b;\n}\n<span class=\"comment\">// 下面这个不是纯函数，因为他改变了输入的值</span>\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withdraw</span>(<span class=\"params\">account, amount</span>) </span>{\n  account.total -= amount;\n}\n</code></pre>\n<p>通过官方这个例子，可以明白纯函数有两点，一是相同的输入就会有相同的输出，第二点是不会更改输入的参数。</p>\n<p>所有的React组件对于props参数必须像纯函数一样，也就是不会试图去修改props，并且对于相同的props会有相同的输出。<br>当然，React也提供了随时间动态变化组件的方法，state允许根据用户行为、网络反馈等改变React组件的输出形式，这并不违背React纯函数原则。</p>\n<h2 id=\"state-和-生命周期\"><a href=\"#state-和-生命周期\" class=\"headerlink\" title=\"state 和 生命周期\"></a>state 和 生命周期</h2><p>请看下面一段代码：</p>\n<pre><code class=\"javascript\"><span class=\"keyword\">const</span> Clock = (\n  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>It is {new Date().toLocaleTimeString()}.<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>\n);\nReactDOM.render(\n  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Clock</span> /&gt;</span>,\n  document.getElementById('root')\n);</span>\n</code></pre>\n<p>这段代码只能够显示一个Hello,world!与一个生成页面的时间。如果想要时间不停的更新，就需要使用setInterval()不停的去执行。</p>\n<pre><code class=\"javascript\"><span class=\"comment\">// 这样</span>\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tick</span>(<span class=\"params\"></span>) </span>{\n  <span class=\"keyword\">const</span> Clock = (\n    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>It is {new Date().toLocaleTimeString()}.<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span>\n    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>\n  );\n  ReactDOM.render(\n    &lt;Clock /&gt;,\n    document.getElementById('root')\n  );\n}\nsetInterval(tick, 1000);\n\n// 或者这样\nfunction Clock(props) {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Hello, world!&lt;/h1&gt;\n      &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;\n    &lt;/div&gt;\n  );\n}\n\nfunction tick() {\n  ReactDOM.render(\n    &lt;Clock date={new Date()} /&gt;,\n    document.getElementById('root')\n  );\n}\nsetInterval(tick, 1000);\n\n// 但是下面这种就是不可行的，原因在于Clock组件定义被转化成了一个对象，在之后没有发生过变化。\nconst Clock = (\n  &lt;div&gt;\n    &lt;h1&gt;Hello, world!&lt;/h1&gt;\n    &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;\n  &lt;/div&gt;\n);\nsetInterval(\nfunction(){\nReactDOM.render(\n  &lt;Clock /&gt;,\n  document.getElementById('root')\n)}, 1000)\n</code></pre>\n<p>这样的代码的问题在于时间的变化应该是<code>Clock</code>组件的行为，而不应该定义在全局。<br><code>state</code>可以帮助我们解决这个问题，state与props类似，但是更私有且被组件所控制，而不是传递过来的。</p>\n<h4 id=\"将Functional组件转换为Class组件\"><a href=\"#将Functional组件转换为Class组件\" class=\"headerlink\" title=\"将Functional组件转换为Class组件\"></a>将Functional组件转换为Class组件</h4><p>Functional组件是无状态组件，不能使用state，所以首先需要将Functional转化为Class组件：</p>\n<ol>\n<li>创建一个和Functional组件名相同的ES6 class继承<code>React.Component</code></li>\n<li>添加空的方法<code>render()</code></li>\n<li>将Functional组件中的函数主体移动<code>render()</code>方法中</li>\n<li>将<code>render()</code>中的<code>props</code>替换成<code>this.props</code></li>\n<li>删除原来的Functional组件声明<br>Class组件不仅可以使用state还可以使用生命周期函数。<br>拿上面的<code>Clock</code>组件作为事例，经过上面的转换，现在的Clock组件应该是这个样子：<pre><code class=\"jsx\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>{\nrender() {\n<span class=\"keyword\">return</span> (\n <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>\n   <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span>\n   <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>It is {this.props.date.toLocaleTimeString()}.<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span>\n <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>\n);\n}\n}\n</code></pre>\n</li>\n</ol>\n<h4 id=\"为Class组件添加本地state\"><a href=\"#为Class组件添加本地state\" class=\"headerlink\" title=\"为Class组件添加本地state\"></a>为Class组件添加本地state</h4><p>还是上面的<code>Clock</code>组件：</p>\n<ol>\n<li>将<code>render()</code>中的<code>this.props</code>替换成<code>this.state</code></li>\n<li>添加class构造函数(constructor)初始化this.state (Class组件总是应该将props传递给父类)</li>\n<li><p>移除<code>date</code>从组件调用的props中<br>```javascript<br>class Clock extends React.Component {<br>// 这里是步骤2<br>constructor(props) {<br>// 将props传递给父类<br>super(props);<br>this.state = {date: new Date()};<br>}</p>\n<p>render() {<br>return (<br> <div><br>   <h1>Hello, world!</h1><br>   <h2>It is {this.state.date.toLocaleTimeString()}.</h2><br> </div><br>);<br>}<br>}</p>\n</li>\n</ol>\n<p>ReactDOM.render(<br>  <clock>,<br>  document.getElementById(‘root’)<br>);<br>```<br>这样只是初始化了state，后面会设置定时器。</clock></p>\n","excerpt":"","more":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>React在codepen上提供了一个Hello，World项目事例，只需打开<a href=\"http://codepen.io/gaearon/pen/rrpgNB?editors=0010\">网站</a>，即可尝试React。<br>另外还提供了一个<a href=\"https://facebook.github.io/react/downloads/single-file-example.html\">html文件</a>的Hello，World项目，项目中引用CDN的react.js、react-dom.js以及用于编译babel的babel.min.js，运行比较缓慢，只适合学习语法使用。</p>\n<h2 id=\"创建单页面应用\"><a href=\"#创建单页面应用\" class=\"headerlink\" title=\"创建单页面应用\"></a>创建单页面应用</h2><p>创建React应用的最好方法是单页面应用，这里是最好方法，也是可以创建多页面应用的。可以通过官方方法去创建你的应用：</p>\n<pre><code class=\"shell\">npm install -g create-react-app\ncreate-create-app hello-world\ncd hello-world\nnpm start\n</code></pre>\n<p>这里不涉及任何后端逻辑和数据库，可以使用任何你想用的后端。create-react-app中使用了Webpack，Babel和ESLint，但是你可以自己去配置他们。</p>\n<h3 id=\"将React加入一个现有的应用\"><a href=\"#将React加入一个现有的应用\" class=\"headerlink\" title=\"将React加入一个现有的应用\"></a>将React加入一个现有的应用</h3><p>使用<code>npm install --save react react-dom</code>安装React。<br>将其导入你的代码中，如：</p>\n<pre><code class=\"javascript\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;\n<span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;\n\nReactDOM.render(\n  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>,\n  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)\n)\n</code></pre>\n<p>这段代码应该被包含在一个拥有id为root的HTML元素，所以你的HTML文件需要<code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code><br>当你使用上面方法使用React的时候，需要使用预设为es2015和react的Babel进行转化代码。使用React在生产环境的时候，设置NODE_ENV为”production”。</p>\n<h3 id=\"使用ES6和JSX\"><a href=\"#使用ES6和JSX\" class=\"headerlink\" title=\"使用ES6和JSX\"></a>使用ES6和JSX</h3><p>建议是用Babel将你的ES6和JSX代码转换为JavaScript代码，Babel可以有很多不同的配置，但是确保里面包含<code>babel-preset-react</code>和<code>babel-preset-es2015</code>。</p>\n<h3 id=\"使用CDN\"><a href=\"#使用CDN\" class=\"headerlink\" title=\"使用CDN\"></a>使用CDN</h3><p>如果不想使用npm，可以使用CDN</p>\n<pre><code class=\"html\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react@15/dist/react.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react-dom@15/dist/react-dom.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>\n</code></pre>\n<p>@后面数字可以指定版本</p>\n<pre><code class=\"html\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react@15/dist/react.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react-dom@15/dist/react-dom.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>\n</code></pre>\n<h2 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h2><p>在JSX中，可以在任意地方插入JavaScript代码，只需要将JavaScript放在大括号中即可。下面的代码都是合法的：</p>\n<pre><code class=\"jsx\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatName</span>(<span class=\"params\">user</span>) </span>{\n  <span class=\"keyword\">return</span> user.firstName + <span class=\"string\">' '</span> + user.lastName;\n}\n\n<span class=\"keyword\">const</span> user = {\n  <span class=\"attr\">firstName</span>: <span class=\"string\">'Harper'</span>,\n  <span class=\"attr\">lastName</span>: <span class=\"string\">'Perez'</span>\n};\n\n<span class=\"keyword\">const</span> element = (\n  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>\n    Hello, {formatName(user)}!\n  <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>\n);\n\nReactDOM.render(\n  element,\n  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)\n);\n</code></pre>\n<p>将JSX代码放在小括号中，像HTML代码一样换行，可以方便阅读。</p>\n<h4 id=\"JSX也是表达式\"><a href=\"#JSX也是表达式\" class=\"headerlink\" title=\"JSX也是表达式\"></a>JSX也是表达式</h4><p>JSX最后也被编译成JavaScript代码，这就以为着JSX可以赋值给一个JavaScript变量，可以作为方法的参数，可以被方法返回。</p>\n<h4 id=\"JSX添加HTML属性\"><a href=\"#JSX添加HTML属性\" class=\"headerlink\" title=\"JSX添加HTML属性\"></a>JSX添加HTML属性</h4><p>可以用字符串设置属性，也可以通过使用{}将JavaScript表达式赋值给属性。</p>\n<h4 id=\"闭合JSX\"><a href=\"#闭合JSX\" class=\"headerlink\" title=\"闭合JSX\"></a>闭合JSX</h4><p>如果JSX是空的可以使用<code>/&gt;</code>来闭合标签，如果包含其他标签，也可以使用&lt;/<em>*</em>&gt;闭合。<br>虽然JSX很接近HTML，但是还是有些不同，比如属性使用小驼峰法命名，class使用className，for使用forHtml等。</p>\n<h4 id=\"JSX防止注入攻击\"><a href=\"#JSX防止注入攻击\" class=\"headerlink\" title=\"JSX防止注入攻击\"></a>JSX防止注入攻击</h4><p>默认情况下，React DOM在渲染JSX之前会对其进行编码。</p>\n<h4 id=\"JSX描述对象\"><a href=\"#JSX描述对象\" class=\"headerlink\" title=\"JSX描述对象\"></a>JSX描述对象</h4><p>Babel会将JSX转化为React.createElement()形式，比如下面这样：</p>\n<pre><code class=\"jsx\"><span class=\"keyword\">const</span> element = (\n  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">className</span>=<span class=\"string\">\"greeting\"</span>&gt;</span>\n    Hello, world!\n  <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>\n)\n</code></pre>\n<p>转化为</p>\n<pre><code class=\"javascript\"><span class=\"keyword\">const</span> element = React.createElement(\n  <span class=\"string\">'h1'</span>,\n  {<span class=\"attr\">className</span>: <span class=\"string\">'greeting'</span>},\n  <span class=\"string\">'Hello, world!'</span>\n);\n</code></pre>\n<p>React.createElement会对你的代码进行一些检查，但是本质上就是将其转化成一个对象：</p>\n<pre><code class=\"javascript\"><span class=\"keyword\">const</span> element = {\n  <span class=\"attr\">type</span>: <span class=\"string\">'h1'</span>,\n  <span class=\"attr\">props</span>: {\n    <span class=\"attr\">className</span>: <span class=\"string\">'greeting'</span>,\n    <span class=\"attr\">children</span>: <span class=\"string\">'Hello, world'</span>\n  }\n}\n</code></pre>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><p>将你的页面分成一个个组件，每个组件都是独立的、可以重复使用的。组件就像JavaScript中的方法，可以接受一些输入参数，返回React元素</p>\n<h4 id=\"Funtional-和-Class-组件\"><a href=\"#Funtional-和-Class-组件\" class=\"headerlink\" title=\"Funtional 和 Class 组件\"></a>Funtional 和 Class 组件</h4><p>定义组件最简单的方式是使用JavaScript方法：</p>\n<pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span> (<span class=\"params\">props</span>) </span>{\n  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, {props.name}<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>\n}\n这个方法就是个有效的React组件，因为它接受props作为参数，并且返回了一个React元素。\n\n另外也可以使用ES6中的类(<span class=\"class\"><span class=\"keyword\">class</span>)来定义组件：\n```<span class=\"title\">javascript</span>\n<span class=\"title\">class</span> <span class=\"title\">Welcome</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>{\n  render () {\n    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, {this.props.name}<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>\n  }\n}\n</code></pre>\n<p>上面两种定义组件的方法是等价的。<br>但是Class组件能够添加一些额外的功能，我们将在下面讨论。在不需要这些额外的方法，可以使用Functional组件。</p>\n<h4 id=\"渲染组件\"><a href=\"#渲染组件\" class=\"headerlink\" title=\"渲染组件\"></a>渲染组件</h4><p>渲染如下：</p>\n<pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>{\n  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, {props.name}<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;\n}\n\n<span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Welcome</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Sara\"</span> /&gt;</span>;\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);</span>\n</code></pre>\n<p>过程：</p>\n<ol>\n<li>调用ReactDOM.render()方法，参数为自定义组件<Welcome name=\"Sara\" />。</li>\n<li>React调用组件Welcome，传递<code>{name=&quot;Sara&quot;}</code>作为参数。</li>\n<li>Welcome组件返回<code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>。</li>\n<li>React将<code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>更新到页面。</li>\n</ol>\n<h4 id=\"组件组合\"><a href=\"#组件组合\" class=\"headerlink\" title=\"组件组合\"></a>组件组合</h4><p>组件可以任意组合。<br>通常情况，React应用中在最顶端是一个<code>App</code>组件。组件必须有一个根元素，也就是所有元素都得包裹起来。</p>\n<h4 id=\"提取组件\"><a href=\"#提取组件\" class=\"headerlink\" title=\"提取组件\"></a>提取组件</h4><p>不要担心组件被拆分的太小。下面是一个对组件进行拆分的例子。<br>Comment组件：  </p>\n<pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Comment</span>(<span class=\"params\">props</span>) </span>{\n  <span class=\"keyword\">return</span> (\n    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment\"</span>&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"UserInfo\"</span>&gt;</span>\n        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Avatar\"</span>\n          <span class=\"attr\">src</span>=<span class=\"string\">{props.author.avatarUrl}</span>\n          <span class=\"attr\">alt</span>=<span class=\"string\">{props.author.name}</span>\n        /&gt;</span>\n        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"UserInfo-name\"</span>&gt;</span>\n          {props.author.name}\n        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment-text\"</span>&gt;</span>\n        {props.text}\n      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment-date\"</span>&gt;</span>\n        {formatDate(props.date)}\n      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n  );\n}</span>\n</code></pre>\n<p>在Comment组件中，使用了<code>author (object)</code>，<code>text (string)</code>，<code>date (date)</code>来描述这个对象。这样的组件因为组合的原因是很难复用的。</p>\n<p>第一步，提取出一个<code>Avatar</code>组件：</p>\n<pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Avatar</span>(<span class=\"params\">props</span>) </span>{\n  <span class=\"keyword\">return</span> (\n    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Avatar\"</span>\n      <span class=\"attr\">src</span>=<span class=\"string\">{props.user.avatarUrl}</span>\n      <span class=\"attr\">alt</span>=<span class=\"string\">{props.user.name}</span>\n    /&gt;</span>\n  );\n}</span>\n</code></pre>\n<p>这里的<code>Avatar</code>组件我们系统他更通用，所以说用了<code>user</code>而不是<code>author</code>。<br>根据组件去命名参数，而不是根据使用上下文。</p>\n<p>下一步是提取<code>UserInfo</code>组件，这里使用了上面提取的<code>Avatar</code>组件：</p>\n<pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserInfo</span>(<span class=\"params\">props</span>) </span>{\n  <span class=\"keyword\">return</span> (\n    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"UserInfo\"</span>&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">Avatar</span> <span class=\"attr\">user</span>=<span class=\"string\">{props.user}</span> /&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"UserInfo-name\"</span>&gt;</span>\n        {props.user.name}\n      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n  );\n}</span>\n</code></pre>\n<p>这样，我们的<code>Comment</code>组件就成了下面的样子：</p>\n<pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Comment</span>(<span class=\"params\">props</span>) </span>{\n  <span class=\"keyword\">return</span> (\n    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment\"</span>&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">UserInfo</span> <span class=\"attr\">user</span>=<span class=\"string\">{props.author}</span> /&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment-text\"</span>&gt;</span>\n        {props.text}\n      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment-date\"</span>&gt;</span>\n        {formatDate(props.date)}\n      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n  );\n}</span>\n</code></pre>\n<h4 id=\"Props是只读的\"><a href=\"#Props是只读的\" class=\"headerlink\" title=\"Props是只读的\"></a>Props是只读的</h4><p>无论是Funcional还是Class组件，都是不能够修改props的。</p>\n<pre><code class=\"javascript\"><span class=\"comment\">// 下面这个是纯函数，因为它没有试图改变自己的输入，并且对相同的输入会有相同的输出。</span>\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>{\n  <span class=\"keyword\">return</span> a + b;\n}\n<span class=\"comment\">// 下面这个不是纯函数，因为他改变了输入的值</span>\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withdraw</span>(<span class=\"params\">account, amount</span>) </span>{\n  account.total -= amount;\n}\n</code></pre>\n<p>通过官方这个例子，可以明白纯函数有两点，一是相同的输入就会有相同的输出，第二点是不会更改输入的参数。</p>\n<p>所有的React组件对于props参数必须像纯函数一样，也就是不会试图去修改props，并且对于相同的props会有相同的输出。<br>当然，React也提供了随时间动态变化组件的方法，state允许根据用户行为、网络反馈等改变React组件的输出形式，这并不违背React纯函数原则。</p>\n<h2 id=\"state-和-生命周期\"><a href=\"#state-和-生命周期\" class=\"headerlink\" title=\"state 和 生命周期\"></a>state 和 生命周期</h2><p>请看下面一段代码：</p>\n<pre><code class=\"javascript\"><span class=\"keyword\">const</span> Clock = (\n  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>It is {new Date().toLocaleTimeString()}.<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>\n);\nReactDOM.render(\n  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Clock</span> /&gt;</span>,\n  document.getElementById('root')\n);</span>\n</code></pre>\n<p>这段代码只能够显示一个Hello,world!与一个生成页面的时间。如果想要时间不停的更新，就需要使用setInterval()不停的去执行。</p>\n<pre><code class=\"javascript\"><span class=\"comment\">// 这样</span>\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tick</span>(<span class=\"params\"></span>) </span>{\n  <span class=\"keyword\">const</span> Clock = (\n    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>It is {new Date().toLocaleTimeString()}.<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span>\n    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>\n  );\n  ReactDOM.render(\n    &lt;Clock /&gt;,\n    document.getElementById('root')\n  );\n}\nsetInterval(tick, 1000);\n\n// 或者这样\nfunction Clock(props) {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Hello, world!&lt;/h1&gt;\n      &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;\n    &lt;/div&gt;\n  );\n}\n\nfunction tick() {\n  ReactDOM.render(\n    &lt;Clock date={new Date()} /&gt;,\n    document.getElementById('root')\n  );\n}\nsetInterval(tick, 1000);\n\n// 但是下面这种就是不可行的，原因在于Clock组件定义被转化成了一个对象，在之后没有发生过变化。\nconst Clock = (\n  &lt;div&gt;\n    &lt;h1&gt;Hello, world!&lt;/h1&gt;\n    &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;\n  &lt;/div&gt;\n);\nsetInterval(\nfunction(){\nReactDOM.render(\n  &lt;Clock /&gt;,\n  document.getElementById('root')\n)}, 1000)\n</code></pre>\n<p>这样的代码的问题在于时间的变化应该是<code>Clock</code>组件的行为，而不应该定义在全局。<br><code>state</code>可以帮助我们解决这个问题，state与props类似，但是更私有且被组件所控制，而不是传递过来的。</p>\n<h4 id=\"将Functional组件转换为Class组件\"><a href=\"#将Functional组件转换为Class组件\" class=\"headerlink\" title=\"将Functional组件转换为Class组件\"></a>将Functional组件转换为Class组件</h4><p>Functional组件是无状态组件，不能使用state，所以首先需要将Functional转化为Class组件：</p>\n<ol>\n<li>创建一个和Functional组件名相同的ES6 class继承<code>React.Component</code></li>\n<li>添加空的方法<code>render()</code></li>\n<li>将Functional组件中的函数主体移动<code>render()</code>方法中</li>\n<li>将<code>render()</code>中的<code>props</code>替换成<code>this.props</code></li>\n<li>删除原来的Functional组件声明<br>Class组件不仅可以使用state还可以使用生命周期函数。<br>拿上面的<code>Clock</code>组件作为事例，经过上面的转换，现在的Clock组件应该是这个样子：<pre><code class=\"jsx\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>{\nrender() {\n<span class=\"keyword\">return</span> (\n <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>\n   <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span>\n   <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>It is {this.props.date.toLocaleTimeString()}.<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span>\n <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>\n);\n}\n}\n</code></pre>\n</li>\n</ol>\n<h4 id=\"为Class组件添加本地state\"><a href=\"#为Class组件添加本地state\" class=\"headerlink\" title=\"为Class组件添加本地state\"></a>为Class组件添加本地state</h4><p>还是上面的<code>Clock</code>组件：</p>\n<ol>\n<li>将<code>render()</code>中的<code>this.props</code>替换成<code>this.state</code></li>\n<li>添加class构造函数(constructor)初始化this.state (Class组件总是应该将props传递给父类)</li>\n<li><p>移除<code>date</code>从组件调用的props中<br>```javascript<br>class Clock extends React.Component {<br>// 这里是步骤2<br>constructor(props) {<br>// 将props传递给父类<br>super(props);<br>this.state = {date: new Date()};<br>}</p>\n<p>render() {<br>return (<br> <div><br>   <h1>Hello, world!</h1><br>   <h2>It is {this.state.date.toLocaleTimeString()}.</h2><br> </div><br>);<br>}<br>}</p>\n</li>\n</ol>\n<p>ReactDOM.render(<br>  <Clock />,<br>  document.getElementById(‘root’)<br>);<br>```<br>这样只是初始化了state，后面会设置定时器。</p>\n"},{"title":"React Router学习","date":"2016-08-23T16:00:00.000Z","comments":1,"_content":"\n### 0. 路由\n\n路由也就是地址，就是定义不同url访问不同页面的功能，可以实现导航、页面切换/跳转等功能。\n\n### 1. 引入\n```javascript \nimport { Router, Route, hashHistory } from 'react-router'\n```\n\n### 2. 配置\n```javascript\n<Router history={browserHistory}>\n\t<Route path=\"/\" component={Home}></Route>\n\t<Route path=\"article\" component={Article}></Route>\n</Router>\n```\n\n### 3. 通过Link实现跳转\n```javascript\n<Link to=\"/about\">About</Link>\n```\n\n### 4.1 路由嵌套(公用导航)\n```javascript\n// 路由配置\n<Router history={hashHistory}>\n  <Route path=\"/\" component={App}>\n    <Route path=\"/repos\" component={Repos}/>\n    <Route path=\"/about\" component={About}/>\n  </Route>\n</Router>\n// 页面配置(通过this.props.children调用)\n{this.props.children}\n```\n\n### 4.2 Active Links\n```javascript\n// 活动样式\n<Link to=\"/about\" activeStyle={{ color: 'red' }}>About</Link>\n// 或者 活动类名\n<li><Link to=\"/about\" activeClassName=\"active\">About</Link></li>\n```\n\n### 5. 传参\n```javascript\n// 配置\n// :userName表示匹配参数\n<Route path=\"/repos/:userName/:repoName\" component={Repo}/>\n// 跳转地址\n<Link to=\"/repos/reactjs/react-router\">React Router</Link>\n// 页面中访问参数\n{this.props.params.repoName}\n```\n\n### 6. 嵌套路由下的默认页\n```javascript\n// 需要引入react-router下的{IndexRoute}\n<Router history={hashHistory}>\n  <Route path=\"/\" component={App}>\n\n    {/* add it here, as a child of `/` */}\n    <IndexRoute component={Home}/>\n\n    <Route path=\"/repos\" component={Repos}>\n      <Route path=\"/repos/:userName/:repoName\" component={Repo}/>\n    </Route>\n    <Route path=\"/about\" component={About}/>\n  </Route>\n</Router>\n```\n\n### 7. 首页(默认页)路由地址\n```javascript\n// 直接使用Link to=\"/\"，会导致该链接总是active状态\n<Link to=\"/\"></Link>\n// 引入react-router下的{IndexLink}\n<IndexLink to=\"/\"></IndexLink>\n// 还可以使用属性 onlyActiveOnIndex\n<Link to=\"/\" activeClassName=\"active\" onlyActiveOnIndex={true}>Home</Link>\n```\n### 8. 更好的地址browserHistory\n```javascript\n// 引入\nimport { browserHistory } from 'react-router'\n// 配置\n<Router history={browserHistory}>\n  {/* ... */}\n</Router>\n// 其他方面没有变化\n```\n\n### 9. 路由跳转\n```javascript\n// 使用browserHistory\nbrowserHistory.push(path)\n// 或者使用上下文 context\n\t// 定义对象\n\tcontextType: {\n\t\trouter: React.PropTypes.object\n\t},\n\t// 调用跳转\n\tthis.context.router.push(path)\n```\n\n### 10. 路由钩子\n每个路由都有Enter和Leave钩子，触发onEnter和onLeave。\n\nps:   \n　　[阮一峰老师](http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu)  \n　　[github](https://github.com/reactjs/react-router)","source":"_posts/React Router学习.md","raw":"---\ntitle: React Router学习\ndate: 2016-08-24\ntags: javascript React\ncategories: \n- javascript\ncomments: true\n---\n\n### 0. 路由\n\n路由也就是地址，就是定义不同url访问不同页面的功能，可以实现导航、页面切换/跳转等功能。\n\n### 1. 引入\n```javascript \nimport { Router, Route, hashHistory } from 'react-router'\n```\n\n### 2. 配置\n```javascript\n<Router history={browserHistory}>\n\t<Route path=\"/\" component={Home}></Route>\n\t<Route path=\"article\" component={Article}></Route>\n</Router>\n```\n\n### 3. 通过Link实现跳转\n```javascript\n<Link to=\"/about\">About</Link>\n```\n\n### 4.1 路由嵌套(公用导航)\n```javascript\n// 路由配置\n<Router history={hashHistory}>\n  <Route path=\"/\" component={App}>\n    <Route path=\"/repos\" component={Repos}/>\n    <Route path=\"/about\" component={About}/>\n  </Route>\n</Router>\n// 页面配置(通过this.props.children调用)\n{this.props.children}\n```\n\n### 4.2 Active Links\n```javascript\n// 活动样式\n<Link to=\"/about\" activeStyle={{ color: 'red' }}>About</Link>\n// 或者 活动类名\n<li><Link to=\"/about\" activeClassName=\"active\">About</Link></li>\n```\n\n### 5. 传参\n```javascript\n// 配置\n// :userName表示匹配参数\n<Route path=\"/repos/:userName/:repoName\" component={Repo}/>\n// 跳转地址\n<Link to=\"/repos/reactjs/react-router\">React Router</Link>\n// 页面中访问参数\n{this.props.params.repoName}\n```\n\n### 6. 嵌套路由下的默认页\n```javascript\n// 需要引入react-router下的{IndexRoute}\n<Router history={hashHistory}>\n  <Route path=\"/\" component={App}>\n\n    {/* add it here, as a child of `/` */}\n    <IndexRoute component={Home}/>\n\n    <Route path=\"/repos\" component={Repos}>\n      <Route path=\"/repos/:userName/:repoName\" component={Repo}/>\n    </Route>\n    <Route path=\"/about\" component={About}/>\n  </Route>\n</Router>\n```\n\n### 7. 首页(默认页)路由地址\n```javascript\n// 直接使用Link to=\"/\"，会导致该链接总是active状态\n<Link to=\"/\"></Link>\n// 引入react-router下的{IndexLink}\n<IndexLink to=\"/\"></IndexLink>\n// 还可以使用属性 onlyActiveOnIndex\n<Link to=\"/\" activeClassName=\"active\" onlyActiveOnIndex={true}>Home</Link>\n```\n### 8. 更好的地址browserHistory\n```javascript\n// 引入\nimport { browserHistory } from 'react-router'\n// 配置\n<Router history={browserHistory}>\n  {/* ... */}\n</Router>\n// 其他方面没有变化\n```\n\n### 9. 路由跳转\n```javascript\n// 使用browserHistory\nbrowserHistory.push(path)\n// 或者使用上下文 context\n\t// 定义对象\n\tcontextType: {\n\t\trouter: React.PropTypes.object\n\t},\n\t// 调用跳转\n\tthis.context.router.push(path)\n```\n\n### 10. 路由钩子\n每个路由都有Enter和Leave钩子，触发onEnter和onLeave。\n\nps:   \n　　[阮一峰老师](http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu)  \n　　[github](https://github.com/reactjs/react-router)","slug":"React Router学习","published":1,"updated":"2016-11-27T01:15:21.868Z","layout":"post","photos":[],"link":"","_id":"ciw3mfvsr00060kc7hqqteqzw","content":"<h3 id=\"0-路由\"><a href=\"#0-路由\" class=\"headerlink\" title=\"0. 路由\"></a>0. 路由</h3><p>路由也就是地址，就是定义不同url访问不同页面的功能，可以实现导航、页面切换/跳转等功能。</p>\n<h3 id=\"1-引入\"><a href=\"#1-引入\" class=\"headerlink\" title=\"1. 引入\"></a>1. 引入</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; Router, Route, hashHistory &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router'</span></div></pre></td></tr></table></figure>\n<h3 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Router history=&#123;browserHistory&#125;&gt;</div><div class=\"line\">\t<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;Home&#125;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></div><div class=\"line\">\t&lt;Route path=<span class=\"string\">\"article\"</span> component=&#123;Article&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></div><div class=\"line\">&lt;<span class=\"regexp\">/Router&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"3-通过Link实现跳转\"><a href=\"#3-通过Link实现跳转\" class=\"headerlink\" title=\"3. 通过Link实现跳转\"></a>3. 通过Link实现跳转</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Link to=<span class=\"string\">\"/about\"</span>&gt;About&lt;<span class=\"regexp\">/Link&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-1-路由嵌套-公用导航\"><a href=\"#4-1-路由嵌套-公用导航\" class=\"headerlink\" title=\"4.1 路由嵌套(公用导航)\"></a>4.1 路由嵌套(公用导航)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 路由配置</span></div><div class=\"line\">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;App&#125;</span>&gt;</span></span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/repos\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;Repos&#125;/</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/about\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;About&#125;/</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></div><div class=\"line\">// 页面配置(通过this.props.children调用)</div><div class=\"line\">&#123;this.props.children&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-2-Active-Links\"><a href=\"#4-2-Active-Links\" class=\"headerlink\" title=\"4.2 Active Links\"></a>4.2 Active Links</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 活动样式</div><div class=\"line\">&lt;Link to=\"/about\" activeStyle=&#123;&#123; color: 'red' &#125;&#125;&gt;About&lt;/Link&gt;</div><div class=\"line\">// 或者 活动类名</div><div class=\"line\">&lt;li&gt;&lt;Link to=\"/about\" activeClassName=\"active\"&gt;About&lt;/Link&gt;&lt;/li&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"5-传参\"><a href=\"#5-传参\" class=\"headerlink\" title=\"5. 传参\"></a>5. 传参</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 配置</div><div class=\"line\">// :userName表示匹配参数</div><div class=\"line\">&lt;Route path=\"/repos/:userName/:repoName\" component=&#123;Repo&#125;/&gt;</div><div class=\"line\">// 跳转地址</div><div class=\"line\">&lt;Link to=\"/repos/reactjs/react-router\"&gt;React Router&lt;/Link&gt;</div><div class=\"line\">// 页面中访问参数</div><div class=\"line\">&#123;this.props.params.repoName&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"6-嵌套路由下的默认页\"><a href=\"#6-嵌套路由下的默认页\" class=\"headerlink\" title=\"6. 嵌套路由下的默认页\"></a>6. 嵌套路由下的默认页</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 需要引入react-router下的&#123;IndexRoute&#125;</span></div><div class=\"line\">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class=\"line\">  &lt;Route path=\"/\" component=&#123;App&#125;&gt;</div><div class=\"line\"></div><div class=\"line\">    &#123;/* add it here, as a child of `/` */&#125;</div><div class=\"line\">    &lt;IndexRoute component=&#123;Home&#125;/&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;Route path=\"/repos\" component=&#123;Repos&#125;&gt;</div><div class=\"line\">      &lt;Route path=\"/repos/:userName/:repoName\" component=&#123;Repo&#125;/&gt;</div><div class=\"line\">    &lt;/Route&gt;</div><div class=\"line\">    &lt;Route path=\"/about\" component=&#123;About&#125;/&gt;</div><div class=\"line\">  &lt;/Route&gt;</div><div class=\"line\">&lt;/Router&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"7-首页-默认页-路由地址\"><a href=\"#7-首页-默认页-路由地址\" class=\"headerlink\" title=\"7. 首页(默认页)路由地址\"></a>7. 首页(默认页)路由地址</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 直接使用Link to=\"/\"，会导致该链接总是active状态</span></div><div class=\"line\">&lt;Link to=<span class=\"string\">\"/\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></div><div class=\"line\"><span class=\"comment\">// 引入react-router下的&#123;IndexLink&#125;</span></div><div class=\"line\">&lt;IndexLink to=<span class=\"string\">\"/\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">IndexLink</span>&gt;</span></span></div><div class=\"line\"><span class=\"comment\">// 还可以使用属性 onlyActiveOnIndex</span></div><div class=\"line\">&lt;Link to=<span class=\"string\">\"/\"</span> activeClassName=<span class=\"string\">\"active\"</span> onlyActiveOnIndex=&#123;<span class=\"literal\">true</span>&#125;&gt;Home&lt;<span class=\"regexp\">/Link&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"8-更好的地址browserHistory\"><a href=\"#8-更好的地址browserHistory\" class=\"headerlink\" title=\"8. 更好的地址browserHistory\"></a>8. 更好的地址browserHistory</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 引入</div><div class=\"line\">import &#123; browserHistory &#125; from 'react-router'</div><div class=\"line\">// 配置</div><div class=\"line\">&lt;Router history=&#123;browserHistory&#125;&gt;</div><div class=\"line\">  &#123;/* ... */&#125;</div><div class=\"line\">&lt;/Router&gt;</div><div class=\"line\">// 其他方面没有变化</div></pre></td></tr></table></figure>\n<h3 id=\"9-路由跳转\"><a href=\"#9-路由跳转\" class=\"headerlink\" title=\"9. 路由跳转\"></a>9. 路由跳转</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 使用browserHistory</span></div><div class=\"line\">browserHistory.push(path)</div><div class=\"line\"><span class=\"comment\">// 或者使用上下文 context</span></div><div class=\"line\">\t<span class=\"comment\">// 定义对象</span></div><div class=\"line\">\tcontextType: &#123;</div><div class=\"line\">\t\t<span class=\"attr\">router</span>: React.PropTypes.object</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">// 调用跳转</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.context.router.push(path)</div></pre></td></tr></table></figure>\n<h3 id=\"10-路由钩子\"><a href=\"#10-路由钩子\" class=\"headerlink\" title=\"10. 路由钩子\"></a>10. 路由钩子</h3><p>每个路由都有Enter和Leave钩子，触发onEnter和onLeave。</p>\n<p>ps:<br>　　<a href=\"http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu\" target=\"_blank\" rel=\"external\">阮一峰老师</a><br>　　<a href=\"https://github.com/reactjs/react-router\" target=\"_blank\" rel=\"external\">github</a></p>\n","excerpt":"","more":"<h3 id=\"0-路由\"><a href=\"#0-路由\" class=\"headerlink\" title=\"0. 路由\"></a>0. 路由</h3><p>路由也就是地址，就是定义不同url访问不同页面的功能，可以实现导航、页面切换/跳转等功能。</p>\n<h3 id=\"1-引入\"><a href=\"#1-引入\" class=\"headerlink\" title=\"1. 引入\"></a>1. 引入</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; Router, Route, hashHistory &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router'</span></div></pre></td></tr></table></figure>\n<h3 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Router history=&#123;browserHistory&#125;&gt;</div><div class=\"line\">\t<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;Home&#125;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></div><div class=\"line\">\t&lt;Route path=<span class=\"string\">\"article\"</span> component=&#123;Article&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></div><div class=\"line\">&lt;<span class=\"regexp\">/Router&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"3-通过Link实现跳转\"><a href=\"#3-通过Link实现跳转\" class=\"headerlink\" title=\"3. 通过Link实现跳转\"></a>3. 通过Link实现跳转</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Link to=<span class=\"string\">\"/about\"</span>&gt;About&lt;<span class=\"regexp\">/Link&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-1-路由嵌套-公用导航\"><a href=\"#4-1-路由嵌套-公用导航\" class=\"headerlink\" title=\"4.1 路由嵌套(公用导航)\"></a>4.1 路由嵌套(公用导航)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 路由配置</span></div><div class=\"line\">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;App&#125;</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/repos\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;Repos&#125;/</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/about\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;About&#125;/</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></div><div class=\"line\">// 页面配置(通过this.props.children调用)</div><div class=\"line\">&#123;this.props.children&#125;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-2-Active-Links\"><a href=\"#4-2-Active-Links\" class=\"headerlink\" title=\"4.2 Active Links\"></a>4.2 Active Links</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 活动样式</div><div class=\"line\">&lt;Link to=\"/about\" activeStyle=&#123;&#123; color: 'red' &#125;&#125;&gt;About&lt;/Link&gt;</div><div class=\"line\">// 或者 活动类名</div><div class=\"line\">&lt;li&gt;&lt;Link to=\"/about\" activeClassName=\"active\"&gt;About&lt;/Link&gt;&lt;/li&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"5-传参\"><a href=\"#5-传参\" class=\"headerlink\" title=\"5. 传参\"></a>5. 传参</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 配置</div><div class=\"line\">// :userName表示匹配参数</div><div class=\"line\">&lt;Route path=\"/repos/:userName/:repoName\" component=&#123;Repo&#125;/&gt;</div><div class=\"line\">// 跳转地址</div><div class=\"line\">&lt;Link to=\"/repos/reactjs/react-router\"&gt;React Router&lt;/Link&gt;</div><div class=\"line\">// 页面中访问参数</div><div class=\"line\">&#123;this.props.params.repoName&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"6-嵌套路由下的默认页\"><a href=\"#6-嵌套路由下的默认页\" class=\"headerlink\" title=\"6. 嵌套路由下的默认页\"></a>6. 嵌套路由下的默认页</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 需要引入react-router下的&#123;IndexRoute&#125;</span></div><div class=\"line\">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class=\"line\">  &lt;Route path=\"/\" component=&#123;App&#125;&gt;</div><div class=\"line\"></div><div class=\"line\">    &#123;/* add it here, as a child of `/` */&#125;</div><div class=\"line\">    &lt;IndexRoute component=&#123;Home&#125;/&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;Route path=\"/repos\" component=&#123;Repos&#125;&gt;</div><div class=\"line\">      &lt;Route path=\"/repos/:userName/:repoName\" component=&#123;Repo&#125;/&gt;</div><div class=\"line\">    &lt;/Route&gt;</div><div class=\"line\">    &lt;Route path=\"/about\" component=&#123;About&#125;/&gt;</div><div class=\"line\">  &lt;/Route&gt;</div><div class=\"line\">&lt;/Router&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"7-首页-默认页-路由地址\"><a href=\"#7-首页-默认页-路由地址\" class=\"headerlink\" title=\"7. 首页(默认页)路由地址\"></a>7. 首页(默认页)路由地址</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 直接使用Link to=\"/\"，会导致该链接总是active状态</span></div><div class=\"line\">&lt;Link to=<span class=\"string\">\"/\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></div><div class=\"line\"><span class=\"comment\">// 引入react-router下的&#123;IndexLink&#125;</span></div><div class=\"line\">&lt;IndexLink to=<span class=\"string\">\"/\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">IndexLink</span>&gt;</span></span></div><div class=\"line\"><span class=\"comment\">// 还可以使用属性 onlyActiveOnIndex</span></div><div class=\"line\">&lt;Link to=<span class=\"string\">\"/\"</span> activeClassName=<span class=\"string\">\"active\"</span> onlyActiveOnIndex=&#123;<span class=\"literal\">true</span>&#125;&gt;Home&lt;<span class=\"regexp\">/Link&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"8-更好的地址browserHistory\"><a href=\"#8-更好的地址browserHistory\" class=\"headerlink\" title=\"8. 更好的地址browserHistory\"></a>8. 更好的地址browserHistory</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 引入</div><div class=\"line\">import &#123; browserHistory &#125; from 'react-router'</div><div class=\"line\">// 配置</div><div class=\"line\">&lt;Router history=&#123;browserHistory&#125;&gt;</div><div class=\"line\">  &#123;/* ... */&#125;</div><div class=\"line\">&lt;/Router&gt;</div><div class=\"line\">// 其他方面没有变化</div></pre></td></tr></table></figure>\n<h3 id=\"9-路由跳转\"><a href=\"#9-路由跳转\" class=\"headerlink\" title=\"9. 路由跳转\"></a>9. 路由跳转</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 使用browserHistory</span></div><div class=\"line\">browserHistory.push(path)</div><div class=\"line\"><span class=\"comment\">// 或者使用上下文 context</span></div><div class=\"line\">\t<span class=\"comment\">// 定义对象</span></div><div class=\"line\">\tcontextType: &#123;</div><div class=\"line\">\t\t<span class=\"attr\">router</span>: React.PropTypes.object</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">// 调用跳转</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.context.router.push(path)</div></pre></td></tr></table></figure>\n<h3 id=\"10-路由钩子\"><a href=\"#10-路由钩子\" class=\"headerlink\" title=\"10. 路由钩子\"></a>10. 路由钩子</h3><p>每个路由都有Enter和Leave钩子，触发onEnter和onLeave。</p>\n<p>ps:<br>　　<a href=\"http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu\">阮一峰老师</a><br>　　<a href=\"https://github.com/reactjs/react-router\">github</a></p>\n"},{"title":"fixed移动端解决","date":"2016-07-28T16:00:00.000Z","comments":1,"_content":"\nFrom [here](http://efe.baidu.com/blog/mobile-fixed-layout/)\n\n### fixed移动端解决\n\n主要是IOS上的。\n\n\t思路：滚动内容在标签中，固定标签的位置。\n\n1. 将所有非fixed定位的，也就是需要滚动的元素用block标签包裹。\n2. fixed定位的元素给fixed或者absolute都可以。\n3. 包裹标签绝对定位在fixed和边界中间，`overflow-y: scroll`。\n4. 标签内滚动不流畅，给包裹标签增加`-webkit-overflow-scrolling: touch;`\n\n```html\n<body class=\"layout-scroll-fixed\">\n    <!-- fixed定位的头部 -->\n    <header>\n        \n    </header>\n    \n    <!-- 可以滚动的区域 -->\n    <main>\n        <div class=\"content\">\n        <!-- 内容在这里... -->\n        </div>\n    </main>\n    \n    <!-- fixed定位的底部 -->\n    <footer>\n        <input type=\"text\" placeholder=\"Footer...\"/>\n        <button class=\"submit\">提交</button>\n    </footer>\n</body>\n```\n\n```css\nheader, footer, main {\n    display: block;\n}\n\nheader {\n    position: fixed;  /* fixed、absolute都可以 */\n    height: 50px;\n    left: 0;\n    right: 0;\n    top: 0;\n}\n\nfooter {\n    position: fixed;\n    height: 34px;\n    left: 0;\n    right: 0;\n    bottom: 0;\n}\n\nmain {\n    /* main绝对定位，进行内部滚动 */\n    position: absolute;\n    top: 50px;\n    bottom: 34px;\n    /* 使之可以滚动 */\n    overflow-y: scroll;\n    /* 增加该属性，可以增加弹性 */\n    -webkit-overflow-scrolling: touch;\n}\n\nmain .content {\n    height: 2000px;\n}\n```\n\nFrom [here](http://imweb.io/topic/577e64a47c99347163ec0b10)\n\n### 图片高度占位\n给图片提供一个容器，设置高度为0，根据图片比例使用padding-top设置百分值。\n```css\n.img-wrap{\n    position: relative;\n    height: 0;\n    padding-top: 50%；// 图片宽度的一半\n}\n.img{\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n```","source":"_posts/fixed移动端解决.md","raw":"---\ntitle: fixed移动端解决\ndate: 2016-07-29\ntags: javascript 移动Web\ncategories: \n- javascript\ncomments: true\n---\n\nFrom [here](http://efe.baidu.com/blog/mobile-fixed-layout/)\n\n### fixed移动端解决\n\n主要是IOS上的。\n\n\t思路：滚动内容在标签中，固定标签的位置。\n\n1. 将所有非fixed定位的，也就是需要滚动的元素用block标签包裹。\n2. fixed定位的元素给fixed或者absolute都可以。\n3. 包裹标签绝对定位在fixed和边界中间，`overflow-y: scroll`。\n4. 标签内滚动不流畅，给包裹标签增加`-webkit-overflow-scrolling: touch;`\n\n```html\n<body class=\"layout-scroll-fixed\">\n    <!-- fixed定位的头部 -->\n    <header>\n        \n    </header>\n    \n    <!-- 可以滚动的区域 -->\n    <main>\n        <div class=\"content\">\n        <!-- 内容在这里... -->\n        </div>\n    </main>\n    \n    <!-- fixed定位的底部 -->\n    <footer>\n        <input type=\"text\" placeholder=\"Footer...\"/>\n        <button class=\"submit\">提交</button>\n    </footer>\n</body>\n```\n\n```css\nheader, footer, main {\n    display: block;\n}\n\nheader {\n    position: fixed;  /* fixed、absolute都可以 */\n    height: 50px;\n    left: 0;\n    right: 0;\n    top: 0;\n}\n\nfooter {\n    position: fixed;\n    height: 34px;\n    left: 0;\n    right: 0;\n    bottom: 0;\n}\n\nmain {\n    /* main绝对定位，进行内部滚动 */\n    position: absolute;\n    top: 50px;\n    bottom: 34px;\n    /* 使之可以滚动 */\n    overflow-y: scroll;\n    /* 增加该属性，可以增加弹性 */\n    -webkit-overflow-scrolling: touch;\n}\n\nmain .content {\n    height: 2000px;\n}\n```\n\nFrom [here](http://imweb.io/topic/577e64a47c99347163ec0b10)\n\n### 图片高度占位\n给图片提供一个容器，设置高度为0，根据图片比例使用padding-top设置百分值。\n```css\n.img-wrap{\n    position: relative;\n    height: 0;\n    padding-top: 50%；// 图片宽度的一半\n}\n.img{\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n```","slug":"fixed移动端解决","published":1,"updated":"2016-11-27T01:15:21.871Z","layout":"post","photos":[],"link":"","_id":"ciw3mfvsr00070kc73gzz189a","content":"<p>From <a href=\"http://efe.baidu.com/blog/mobile-fixed-layout/\" target=\"_blank\" rel=\"external\">here</a></p>\n<h3 id=\"fixed移动端解决\"><a href=\"#fixed移动端解决\" class=\"headerlink\" title=\"fixed移动端解决\"></a>fixed移动端解决</h3><p>主要是IOS上的。</p>\n<pre><code>思路：滚动内容在标签中，固定标签的位置。\n</code></pre><ol>\n<li>将所有非fixed定位的，也就是需要滚动的元素用block标签包裹。</li>\n<li>fixed定位的元素给fixed或者absolute都可以。</li>\n<li>包裹标签绝对定位在fixed和边界中间，<code>overflow-y: scroll</code>。</li>\n<li>标签内滚动不流畅，给包裹标签增加<code>-webkit-overflow-scrolling: touch;</code></li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">class</span>=<span class=\"string\">\"layout-scroll-fixed\"</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- fixed定位的头部 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">        </div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">&lt;!-- 可以滚动的区域 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span></div><div class=\"line\">        <span class=\"comment\">&lt;!-- 内容在这里... --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">&lt;!-- fixed定位的底部 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Footer...\"</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"submit\"</span>&gt;</span>提交<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">header</span>, <span class=\"selector-tag\">footer</span>, <span class=\"selector-tag\">main</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">display</span>: block;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">header</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">position</span>: fixed;  <span class=\"comment\">/* fixed、absolute都可以 */</span></div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">footer</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">position</span>: fixed;</div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">34px</span>;</div><div class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">main</span> &#123;</div><div class=\"line\">    <span class=\"comment\">/* main绝对定位，进行内部滚动 */</span></div><div class=\"line\">    <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">34px</span>;</div><div class=\"line\">    <span class=\"comment\">/* 使之可以滚动 */</span></div><div class=\"line\">    <span class=\"attribute\">overflow-y</span>: scroll;</div><div class=\"line\">    <span class=\"comment\">/* 增加该属性，可以增加弹性 */</span></div><div class=\"line\">    <span class=\"attribute\">-webkit-overflow-scrolling</span>: touch;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">main</span> <span class=\"selector-class\">.content</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">2000px</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>From <a href=\"http://imweb.io/topic/577e64a47c99347163ec0b10\" target=\"_blank\" rel=\"external\">here</a></p>\n<h3 id=\"图片高度占位\"><a href=\"#图片高度占位\" class=\"headerlink\" title=\"图片高度占位\"></a>图片高度占位</h3><p>给图片提供一个容器，设置高度为0，根据图片比例使用padding-top设置百分值。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.img-wrap</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">position</span>: relative;</div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">padding-top</span>: <span class=\"number\">50%</span>；// 图片宽度的一半</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.img</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>From <a href=\"http://efe.baidu.com/blog/mobile-fixed-layout/\">here</a></p>\n<h3 id=\"fixed移动端解决\"><a href=\"#fixed移动端解决\" class=\"headerlink\" title=\"fixed移动端解决\"></a>fixed移动端解决</h3><p>主要是IOS上的。</p>\n<pre><code>思路：滚动内容在标签中，固定标签的位置。\n</code></pre><ol>\n<li>将所有非fixed定位的，也就是需要滚动的元素用block标签包裹。</li>\n<li>fixed定位的元素给fixed或者absolute都可以。</li>\n<li>包裹标签绝对定位在fixed和边界中间，<code>overflow-y: scroll</code>。</li>\n<li>标签内滚动不流畅，给包裹标签增加<code>-webkit-overflow-scrolling: touch;</code></li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">class</span>=<span class=\"string\">\"layout-scroll-fixed\"</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- fixed定位的头部 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">        </div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">&lt;!-- 可以滚动的区域 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span></div><div class=\"line\">        <span class=\"comment\">&lt;!-- 内容在这里... --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">&lt;!-- fixed定位的底部 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Footer...\"</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"submit\"</span>&gt;</span>提交<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">header</span>, <span class=\"selector-tag\">footer</span>, <span class=\"selector-tag\">main</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">display</span>: block;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">header</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">position</span>: fixed;  <span class=\"comment\">/* fixed、absolute都可以 */</span></div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">footer</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">position</span>: fixed;</div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">34px</span>;</div><div class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">main</span> &#123;</div><div class=\"line\">    <span class=\"comment\">/* main绝对定位，进行内部滚动 */</span></div><div class=\"line\">    <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">34px</span>;</div><div class=\"line\">    <span class=\"comment\">/* 使之可以滚动 */</span></div><div class=\"line\">    <span class=\"attribute\">overflow-y</span>: scroll;</div><div class=\"line\">    <span class=\"comment\">/* 增加该属性，可以增加弹性 */</span></div><div class=\"line\">    <span class=\"attribute\">-webkit-overflow-scrolling</span>: touch;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">main</span> <span class=\"selector-class\">.content</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">2000px</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>From <a href=\"http://imweb.io/topic/577e64a47c99347163ec0b10\">here</a></p>\n<h3 id=\"图片高度占位\"><a href=\"#图片高度占位\" class=\"headerlink\" title=\"图片高度占位\"></a>图片高度占位</h3><p>给图片提供一个容器，设置高度为0，根据图片比例使用padding-top设置百分值。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.img-wrap</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">position</span>: relative;</div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">padding-top</span>: <span class=\"number\">50%</span>；// 图片宽度的一半</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.img</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"_content":"action: 规定动作以及数据\nreducer: 如何更新action中的数据。接受旧的action、state,返回新的。(state)\nstore: 调用reducer更改action中的数据\n\n定义action\naction一般形式：\nfunction addTodo(data) {\n\treturn {\n\t\ttype: type,\t\t\t\t\t\t\t// type属性是必须的\n\t\tdata: data\t\t\t\t\t\t\t// 其他属性，任意定义，保存数据\n\t}\n}\n\nreducer一般形式：\nfunction todos(state = [], action) {\t\t// 参数state,action state给默认值\n  switch (action.type) {\t\t\t\t\t\t\t\t// 对action进行switch判断\n    case ADD_TODO:\n      return [\n        ...state,\n        {\n          text: action.text,\n          completed: false\n        }\n      ]\n    case COMPLETE_TODO:\n      return [\n\n      ]\n    default:\n      return state\n  }\n}\n\n// 通过redux提供的combineReducers方法将多个reducer结合\nconst todoApp = combineReducers({\t\t\t\t\t\t\n  visibilityFilter,\n  todos\n})\nexport default todoApp;\n\nstore通过redux提供的createStore方法传递reducer方法作为参数去创建。\nlet store = createStore(todoApp) // todoApp为reducer\n\nreact-redux的Provider组件通过store属性传递。\n<Provider store={store}>\n  <App />\n</Provider>\n\n组件中通过react-redux的connect方法，将store映射到props上。\nfunction select(state) {\n  return {\n    visibleTodos: ...\n    visibilityFilter: ... \n  };\n}\nexport default connect(select)(App);  // App为组件名，select方法在connect中调用，会将store的getState()传递过去。te()值\n\n组件中通过connect传递过来的props中的dispatch方法更改\nconst { dispatch } = this.props \t// this.props为调用connect后自动传递god了的的。\ndispatch(completeTodo(index))\t\t\t// dispatch调用某action\n\n中间件\n\n// 中间件由三个嵌套的函数构成（会依次调用）：\n// 1) 第一层向其余两层提供分发函数和 getState 函数\n//    （因为你的中间件或 action creator 可能需要从 state 中读取数据）\n// 2) 第二层提供 next 函数，它允许你显式的将处理过的输入传递给下一个中间件或 Redux\n//    （这样 Redux 才能调用所有 reducer)。\n// 3) 第三层提供从上一个中间件或从 dispatch 传递来的 action，\n//     这个 action 可以调用下一个中间件（让 action 继续流动) 或者\n//     以想要的方式处理 action。\n\nvar thunkMiddleware = function ({ dispatch, getState }) {\n  // console.log('Enter thunkMiddleware');\n  return function(next) {\n    // console.log('Function \"next\" provided:', next);\n    return function (action) {\n      // console.log('Handling action:', action);\n      return typeof action === 'function' ?\n          action(dispatch, getState) :\n          next(action)\n    }\n  }\n}\n\n调用中间件\nimport { createStore, combineReducers, applyMiddleware } from 'redux'\nconst finalCreateStore = applyMiddleware(thunkMiddleware)(createStore)\n\n###\n\nFrom [Here](http://div.io/topic/1309?utm_source=tuicool&utm_medium=referral)\n首先，设计state\n```javascript\nlet state = {\n  todos: [{\n    id: 123,\n    text: 'todo item',\n    status: false\n  }],\n  activeFilter: SHOW_ALL\n}\n```\n设计action常量\n```javascript\n//ActionTypes.js 真正改动了数据的 actionType 在这里\nexport const ADD_ITEM = 'ADD_ITEM'\nexport const DELETE_ITEM = 'DELETE_ITEM'\nexport const DELETE_ITEMS = 'DELETE_ITEMS'\nexport const UPDATE_ITEM = 'UPDATE_ITEM'\nexport const UPDATE_ITEMS = 'UPDATE_ITEMS'\n\n//API.js 服务端接口统一放这里\nexport const API_TODOS = '/todos'\n\n//SocketTypes.js websocket 也触发了某个 action 改变了 state，单独放这里\nexport const SERVER_UPDATE = 'SERVER_UPDATE'\n\n//KeyCode.js 键盘的回车键与取消键对应的编码\nexport const ENTER_KEY = 13\nexport const ESCAPE_KEY = 27\n\n//FilterTypes.js 只是筛选数据，没有改变 state 的过滤 action 的常量\nexport const FILTER_ITEMS = 'FILTER_ITEMS'\nexport const SHOW_ALL = 'SHOW_ALL'\nexport const SHOW_ACTIVE = 'SHOW_ACTIVE'\nexport const SHOW_COMPLETED = 'SHOW_COMPLETED'\n```\n开始写actionCreaetor\n```javascript\n//index.js\nimport * as types from '../constants/ActionTypes'\nexport function addItem(text) {\n  return { type: types.ADD_ITEM, text }\n}\nexport function deleteItem(id) {\n  return { type: types.DELETE_ITEM, id }\n}\nexport function updateItem(data) {\n  return { type: types.UPDATE_ITEM, data }\n}\nexport function deleteItems(query) {\n  return { type: types.DELETE_ITEMS, query }\n}\nexport function updateItems(data) {\n  return { type: types.UPDATE_ITEMS, data }\n}\n```\nreducer\n```javacript\n//index.js\nimport * as types from '../constants/ActionTypes'\nexport function addItem(text) {\n  return { type: types.ADD_ITEM, text }\n}\nexport function deleteItem(id) {\n  return { type: types.DELETE_ITEM, id }\n}\nexport function updateItem(data) {\n  return { type: types.UPDATE_ITEM, data }\n}\nexport function deleteItems(query) {\n  return { type: types.DELETE_ITEMS, query }\n}\nexport function updateItems(data) {\n  return { type: types.UPDATE_ITEMS, data }\n}\n\n```\n\n###\n\nFrom [Here](https://github.com/kenberkeley/redux-simple-tutorial)\nstate是应用的状态，store是state的管理器,唯一的 (state == store.getState())\nstrore包括getState()、 dispatch(action)、 subscribe(listener)、 replaceReducer(nextReducer)\naction就是普通对象，用于规定数据格式。\nreducer用来更新state,根据action type修改state，返回新的state。","source":"_posts/redux学习.md","raw":"action: 规定动作以及数据\nreducer: 如何更新action中的数据。接受旧的action、state,返回新的。(state)\nstore: 调用reducer更改action中的数据\n\n定义action\naction一般形式：\nfunction addTodo(data) {\n\treturn {\n\t\ttype: type,\t\t\t\t\t\t\t// type属性是必须的\n\t\tdata: data\t\t\t\t\t\t\t// 其他属性，任意定义，保存数据\n\t}\n}\n\nreducer一般形式：\nfunction todos(state = [], action) {\t\t// 参数state,action state给默认值\n  switch (action.type) {\t\t\t\t\t\t\t\t// 对action进行switch判断\n    case ADD_TODO:\n      return [\n        ...state,\n        {\n          text: action.text,\n          completed: false\n        }\n      ]\n    case COMPLETE_TODO:\n      return [\n\n      ]\n    default:\n      return state\n  }\n}\n\n// 通过redux提供的combineReducers方法将多个reducer结合\nconst todoApp = combineReducers({\t\t\t\t\t\t\n  visibilityFilter,\n  todos\n})\nexport default todoApp;\n\nstore通过redux提供的createStore方法传递reducer方法作为参数去创建。\nlet store = createStore(todoApp) // todoApp为reducer\n\nreact-redux的Provider组件通过store属性传递。\n<Provider store={store}>\n  <App />\n</Provider>\n\n组件中通过react-redux的connect方法，将store映射到props上。\nfunction select(state) {\n  return {\n    visibleTodos: ...\n    visibilityFilter: ... \n  };\n}\nexport default connect(select)(App);  // App为组件名，select方法在connect中调用，会将store的getState()传递过去。te()值\n\n组件中通过connect传递过来的props中的dispatch方法更改\nconst { dispatch } = this.props \t// this.props为调用connect后自动传递god了的的。\ndispatch(completeTodo(index))\t\t\t// dispatch调用某action\n\n中间件\n\n// 中间件由三个嵌套的函数构成（会依次调用）：\n// 1) 第一层向其余两层提供分发函数和 getState 函数\n//    （因为你的中间件或 action creator 可能需要从 state 中读取数据）\n// 2) 第二层提供 next 函数，它允许你显式的将处理过的输入传递给下一个中间件或 Redux\n//    （这样 Redux 才能调用所有 reducer)。\n// 3) 第三层提供从上一个中间件或从 dispatch 传递来的 action，\n//     这个 action 可以调用下一个中间件（让 action 继续流动) 或者\n//     以想要的方式处理 action。\n\nvar thunkMiddleware = function ({ dispatch, getState }) {\n  // console.log('Enter thunkMiddleware');\n  return function(next) {\n    // console.log('Function \"next\" provided:', next);\n    return function (action) {\n      // console.log('Handling action:', action);\n      return typeof action === 'function' ?\n          action(dispatch, getState) :\n          next(action)\n    }\n  }\n}\n\n调用中间件\nimport { createStore, combineReducers, applyMiddleware } from 'redux'\nconst finalCreateStore = applyMiddleware(thunkMiddleware)(createStore)\n\n###\n\nFrom [Here](http://div.io/topic/1309?utm_source=tuicool&utm_medium=referral)\n首先，设计state\n```javascript\nlet state = {\n  todos: [{\n    id: 123,\n    text: 'todo item',\n    status: false\n  }],\n  activeFilter: SHOW_ALL\n}\n```\n设计action常量\n```javascript\n//ActionTypes.js 真正改动了数据的 actionType 在这里\nexport const ADD_ITEM = 'ADD_ITEM'\nexport const DELETE_ITEM = 'DELETE_ITEM'\nexport const DELETE_ITEMS = 'DELETE_ITEMS'\nexport const UPDATE_ITEM = 'UPDATE_ITEM'\nexport const UPDATE_ITEMS = 'UPDATE_ITEMS'\n\n//API.js 服务端接口统一放这里\nexport const API_TODOS = '/todos'\n\n//SocketTypes.js websocket 也触发了某个 action 改变了 state，单独放这里\nexport const SERVER_UPDATE = 'SERVER_UPDATE'\n\n//KeyCode.js 键盘的回车键与取消键对应的编码\nexport const ENTER_KEY = 13\nexport const ESCAPE_KEY = 27\n\n//FilterTypes.js 只是筛选数据，没有改变 state 的过滤 action 的常量\nexport const FILTER_ITEMS = 'FILTER_ITEMS'\nexport const SHOW_ALL = 'SHOW_ALL'\nexport const SHOW_ACTIVE = 'SHOW_ACTIVE'\nexport const SHOW_COMPLETED = 'SHOW_COMPLETED'\n```\n开始写actionCreaetor\n```javascript\n//index.js\nimport * as types from '../constants/ActionTypes'\nexport function addItem(text) {\n  return { type: types.ADD_ITEM, text }\n}\nexport function deleteItem(id) {\n  return { type: types.DELETE_ITEM, id }\n}\nexport function updateItem(data) {\n  return { type: types.UPDATE_ITEM, data }\n}\nexport function deleteItems(query) {\n  return { type: types.DELETE_ITEMS, query }\n}\nexport function updateItems(data) {\n  return { type: types.UPDATE_ITEMS, data }\n}\n```\nreducer\n```javacript\n//index.js\nimport * as types from '../constants/ActionTypes'\nexport function addItem(text) {\n  return { type: types.ADD_ITEM, text }\n}\nexport function deleteItem(id) {\n  return { type: types.DELETE_ITEM, id }\n}\nexport function updateItem(data) {\n  return { type: types.UPDATE_ITEM, data }\n}\nexport function deleteItems(query) {\n  return { type: types.DELETE_ITEMS, query }\n}\nexport function updateItems(data) {\n  return { type: types.UPDATE_ITEMS, data }\n}\n\n```\n\n###\n\nFrom [Here](https://github.com/kenberkeley/redux-simple-tutorial)\nstate是应用的状态，store是state的管理器,唯一的 (state == store.getState())\nstrore包括getState()、 dispatch(action)、 subscribe(listener)、 replaceReducer(nextReducer)\naction就是普通对象，用于规定数据格式。\nreducer用来更新state,根据action type修改state，返回新的state。","slug":"redux学习","published":1,"date":"2016-11-28T13:34:34.129Z","updated":"2016-11-27T01:15:21.891Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw3mfvt7000b0kc72q3k0qdg","content":"<p>action: 规定动作以及数据<br>reducer: 如何更新action中的数据。接受旧的action、state,返回新的。(state)<br>store: 调用reducer更改action中的数据</p>\n<p>定义action<br>action一般形式：<br>function addTodo(data) {<br>    return {<br>        type: type,                            // type属性是必须的<br>        data: data                            // 其他属性，任意定义，保存数据<br>    }<br>}</p>\n<p>reducer一般形式：<br>function todos(state = [], action) {        // 参数state,action state给默认值<br>  switch (action.type) {                                // 对action进行switch判断<br>    case ADD_TODO:<br>      return [<br>        …state,<br>        {<br>          text: action.text,<br>          completed: false<br>        }<br>      ]<br>    case COMPLETE_TODO:<br>      return [</p>\n<pre><code>  ]\ndefault:\n  return state\n</code></pre><p>  }<br>}</p>\n<p>// 通过redux提供的combineReducers方法将多个reducer结合<br>const todoApp = combineReducers({<br>  visibilityFilter,<br>  todos<br>})<br>export default todoApp;</p>\n<p>store通过redux提供的createStore方法传递reducer方法作为参数去创建。<br>let store = createStore(todoApp) // todoApp为reducer</p>\n<p>react-redux的Provider组件通过store属性传递。</p>\n<provider store=\"{store}\"><br>  <app><br></app></provider>\n\n<p>组件中通过react-redux的connect方法，将store映射到props上。<br>function select(state) {<br>  return {<br>    visibleTodos: …<br>    visibilityFilter: …<br>  };<br>}<br>export default connect(select)(App);  // App为组件名，select方法在connect中调用，会将store的getState()传递过去。te()值</p>\n<p>组件中通过connect传递过来的props中的dispatch方法更改<br>const { dispatch } = this.props     // this.props为调用connect后自动传递god了的的。<br>dispatch(completeTodo(index))            // dispatch调用某action</p>\n<p>中间件</p>\n<p>// 中间件由三个嵌套的函数构成（会依次调用）：<br>// 1) 第一层向其余两层提供分发函数和 getState 函数<br>//    （因为你的中间件或 action creator 可能需要从 state 中读取数据）<br>// 2) 第二层提供 next 函数，它允许你显式的将处理过的输入传递给下一个中间件或 Redux<br>//    （这样 Redux 才能调用所有 reducer)。<br>// 3) 第三层提供从上一个中间件或从 dispatch 传递来的 action，<br>//     这个 action 可以调用下一个中间件（让 action 继续流动) 或者<br>//     以想要的方式处理 action。</p>\n<p>var thunkMiddleware = function ({ dispatch, getState }) {<br>  // console.log(‘Enter thunkMiddleware’);<br>  return function(next) {<br>    // console.log(‘Function “next” provided:’, next);<br>    return function (action) {<br>      // console.log(‘Handling action:’, action);<br>      return typeof action === ‘function’ ?<br>          action(dispatch, getState) :<br>          next(action)<br>    }<br>  }<br>}</p>\n<p>调用中间件<br>import { createStore, combineReducers, applyMiddleware } from ‘redux’<br>const finalCreateStore = applyMiddleware(thunkMiddleware)(createStore)</p>\n<p>###</p>\n<p>From <a href=\"http://div.io/topic/1309?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"external\">Here</a><br>首先，设计state<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> state = &#123;</div><div class=\"line\">  <span class=\"attr\">todos</span>: [&#123;</div><div class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">123</span>,</div><div class=\"line\">    <span class=\"attr\">text</span>: <span class=\"string\">'todo item'</span>,</div><div class=\"line\">    <span class=\"attr\">status</span>: <span class=\"literal\">false</span></div><div class=\"line\">  &#125;],</div><div class=\"line\">  <span class=\"attr\">activeFilter</span>: SHOW_ALL</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>设计action常量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//ActionTypes.js 真正改动了数据的 actionType 在这里</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ADD_ITEM = <span class=\"string\">'ADD_ITEM'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DELETE_ITEM = <span class=\"string\">'DELETE_ITEM'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DELETE_ITEMS = <span class=\"string\">'DELETE_ITEMS'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> UPDATE_ITEM = <span class=\"string\">'UPDATE_ITEM'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> UPDATE_ITEMS = <span class=\"string\">'UPDATE_ITEMS'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//API.js 服务端接口统一放这里</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> API_TODOS = <span class=\"string\">'/todos'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//SocketTypes.js websocket 也触发了某个 action 改变了 state，单独放这里</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SERVER_UPDATE = <span class=\"string\">'SERVER_UPDATE'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//KeyCode.js 键盘的回车键与取消键对应的编码</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ENTER_KEY = <span class=\"number\">13</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ESCAPE_KEY = <span class=\"number\">27</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//FilterTypes.js 只是筛选数据，没有改变 state 的过滤 action 的常量</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> FILTER_ITEMS = <span class=\"string\">'FILTER_ITEMS'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_ALL = <span class=\"string\">'SHOW_ALL'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_ACTIVE = <span class=\"string\">'SHOW_ACTIVE'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_COMPLETED = <span class=\"string\">'SHOW_COMPLETED'</span></div></pre></td></tr></table></figure></p>\n<p>开始写actionCreaetor<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//index.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> types <span class=\"keyword\">from</span> <span class=\"string\">'../constants/ActionTypes'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addItem</span>(<span class=\"params\">text</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.ADD_ITEM, text &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deleteItem</span>(<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.DELETE_ITEM, id &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateItem</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.UPDATE_ITEM, data &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deleteItems</span>(<span class=\"params\">query</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.DELETE_ITEMS, query &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateItems</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.UPDATE_ITEMS, data &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>reducer<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">//index.js</div><div class=\"line\">import * as types from &apos;../constants/ActionTypes&apos;</div><div class=\"line\">export function addItem(text) &#123;</div><div class=\"line\">  return &#123; type: types.ADD_ITEM, text &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">export function deleteItem(id) &#123;</div><div class=\"line\">  return &#123; type: types.DELETE_ITEM, id &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">export function updateItem(data) &#123;</div><div class=\"line\">  return &#123; type: types.UPDATE_ITEM, data &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">export function deleteItems(query) &#123;</div><div class=\"line\">  return &#123; type: types.DELETE_ITEMS, query &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">export function updateItems(data) &#123;</div><div class=\"line\">  return &#123; type: types.UPDATE_ITEMS, data &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>###</p>\n<p>From <a href=\"https://github.com/kenberkeley/redux-simple-tutorial\" target=\"_blank\" rel=\"external\">Here</a><br>state是应用的状态，store是state的管理器,唯一的 (state == store.getState())<br>strore包括getState()、 dispatch(action)、 subscribe(listener)、 replaceReducer(nextReducer)<br>action就是普通对象，用于规定数据格式。<br>reducer用来更新state,根据action type修改state，返回新的state。</p>\n","excerpt":"","more":"<p>action: 规定动作以及数据<br>reducer: 如何更新action中的数据。接受旧的action、state,返回新的。(state)<br>store: 调用reducer更改action中的数据</p>\n<p>定义action<br>action一般形式：<br>function addTodo(data) {<br>    return {<br>        type: type,                            // type属性是必须的<br>        data: data                            // 其他属性，任意定义，保存数据<br>    }<br>}</p>\n<p>reducer一般形式：<br>function todos(state = [], action) {        // 参数state,action state给默认值<br>  switch (action.type) {                                // 对action进行switch判断<br>    case ADD_TODO:<br>      return [<br>        …state,<br>        {<br>          text: action.text,<br>          completed: false<br>        }<br>      ]<br>    case COMPLETE_TODO:<br>      return [</p>\n<pre><code>  ]\ndefault:\n  return state\n</code></pre><p>  }<br>}</p>\n<p>// 通过redux提供的combineReducers方法将多个reducer结合<br>const todoApp = combineReducers({<br>  visibilityFilter,<br>  todos<br>})<br>export default todoApp;</p>\n<p>store通过redux提供的createStore方法传递reducer方法作为参数去创建。<br>let store = createStore(todoApp) // todoApp为reducer</p>\n<p>react-redux的Provider组件通过store属性传递。</p>\n<Provider store={store}><br>  <App /><br></Provider>\n\n<p>组件中通过react-redux的connect方法，将store映射到props上。<br>function select(state) {<br>  return {<br>    visibleTodos: …<br>    visibilityFilter: …<br>  };<br>}<br>export default connect(select)(App);  // App为组件名，select方法在connect中调用，会将store的getState()传递过去。te()值</p>\n<p>组件中通过connect传递过来的props中的dispatch方法更改<br>const { dispatch } = this.props     // this.props为调用connect后自动传递god了的的。<br>dispatch(completeTodo(index))            // dispatch调用某action</p>\n<p>中间件</p>\n<p>// 中间件由三个嵌套的函数构成（会依次调用）：<br>// 1) 第一层向其余两层提供分发函数和 getState 函数<br>//    （因为你的中间件或 action creator 可能需要从 state 中读取数据）<br>// 2) 第二层提供 next 函数，它允许你显式的将处理过的输入传递给下一个中间件或 Redux<br>//    （这样 Redux 才能调用所有 reducer)。<br>// 3) 第三层提供从上一个中间件或从 dispatch 传递来的 action，<br>//     这个 action 可以调用下一个中间件（让 action 继续流动) 或者<br>//     以想要的方式处理 action。</p>\n<p>var thunkMiddleware = function ({ dispatch, getState }) {<br>  // console.log(‘Enter thunkMiddleware’);<br>  return function(next) {<br>    // console.log(‘Function “next” provided:’, next);<br>    return function (action) {<br>      // console.log(‘Handling action:’, action);<br>      return typeof action === ‘function’ ?<br>          action(dispatch, getState) :<br>          next(action)<br>    }<br>  }<br>}</p>\n<p>调用中间件<br>import { createStore, combineReducers, applyMiddleware } from ‘redux’<br>const finalCreateStore = applyMiddleware(thunkMiddleware)(createStore)</p>\n<p>###</p>\n<p>From <a href=\"http://div.io/topic/1309?utm_source=tuicool&amp;utm_medium=referral\">Here</a><br>首先，设计state<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> state = &#123;</div><div class=\"line\">  <span class=\"attr\">todos</span>: [&#123;</div><div class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">123</span>,</div><div class=\"line\">    <span class=\"attr\">text</span>: <span class=\"string\">'todo item'</span>,</div><div class=\"line\">    <span class=\"attr\">status</span>: <span class=\"literal\">false</span></div><div class=\"line\">  &#125;],</div><div class=\"line\">  <span class=\"attr\">activeFilter</span>: SHOW_ALL</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>设计action常量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//ActionTypes.js 真正改动了数据的 actionType 在这里</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ADD_ITEM = <span class=\"string\">'ADD_ITEM'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DELETE_ITEM = <span class=\"string\">'DELETE_ITEM'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DELETE_ITEMS = <span class=\"string\">'DELETE_ITEMS'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> UPDATE_ITEM = <span class=\"string\">'UPDATE_ITEM'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> UPDATE_ITEMS = <span class=\"string\">'UPDATE_ITEMS'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//API.js 服务端接口统一放这里</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> API_TODOS = <span class=\"string\">'/todos'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//SocketTypes.js websocket 也触发了某个 action 改变了 state，单独放这里</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SERVER_UPDATE = <span class=\"string\">'SERVER_UPDATE'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//KeyCode.js 键盘的回车键与取消键对应的编码</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ENTER_KEY = <span class=\"number\">13</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ESCAPE_KEY = <span class=\"number\">27</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//FilterTypes.js 只是筛选数据，没有改变 state 的过滤 action 的常量</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> FILTER_ITEMS = <span class=\"string\">'FILTER_ITEMS'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_ALL = <span class=\"string\">'SHOW_ALL'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_ACTIVE = <span class=\"string\">'SHOW_ACTIVE'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_COMPLETED = <span class=\"string\">'SHOW_COMPLETED'</span></div></pre></td></tr></table></figure></p>\n<p>开始写actionCreaetor<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//index.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> types <span class=\"keyword\">from</span> <span class=\"string\">'../constants/ActionTypes'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addItem</span>(<span class=\"params\">text</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.ADD_ITEM, text &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deleteItem</span>(<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.DELETE_ITEM, id &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateItem</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.UPDATE_ITEM, data &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deleteItems</span>(<span class=\"params\">query</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.DELETE_ITEMS, query &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateItems</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.UPDATE_ITEMS, data &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>reducer<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">//index.js</div><div class=\"line\">import * as types from &apos;../constants/ActionTypes&apos;</div><div class=\"line\">export function addItem(text) &#123;</div><div class=\"line\">  return &#123; type: types.ADD_ITEM, text &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">export function deleteItem(id) &#123;</div><div class=\"line\">  return &#123; type: types.DELETE_ITEM, id &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">export function updateItem(data) &#123;</div><div class=\"line\">  return &#123; type: types.UPDATE_ITEM, data &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">export function deleteItems(query) &#123;</div><div class=\"line\">  return &#123; type: types.DELETE_ITEMS, query &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">export function updateItems(data) &#123;</div><div class=\"line\">  return &#123; type: types.UPDATE_ITEMS, data &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>###</p>\n<p>From <a href=\"https://github.com/kenberkeley/redux-simple-tutorial\">Here</a><br>state是应用的状态，store是state的管理器,唯一的 (state == store.getState())<br>strore包括getState()、 dispatch(action)、 subscribe(listener)、 replaceReducer(nextReducer)<br>action就是普通对象，用于规定数据格式。<br>reducer用来更新state,根据action type修改state，返回新的state。</p>\n"},{"_content":"gulp是前端构建工具，通过一系列gulp插件，可以实现实时监控、格式化代码、合并代码、压缩代码、测试功能等功能。\n\n------\n\n前提：node环境，会使用基本命令行\n\n------\n\n### 全局安装gulp\n```\nsudo npm install -g gulp\n```\nWindows环境下不需要sudo命令\n\n### 项目搭建\n#### 第一步，包管理文件 package.json\n通过cd命令进入项目目录，执行`npm init`，之后可以一路的回车来创建`package.json`文件。关于此配置文件的内容挺简单的，可以自己看下，然后搜索下。\n#### 第二步，寻找、安装所需要的插件\n项目目录安装gulp，并写入配置文件package.json中。\n```\nnpm install --save-dev gulp\n```\n这样会把gulp的依赖写入到package.json文件中。\n\n#### 添加需要的各个gulp插件\n比如这里我用到了gulp-clean-css用于css压缩、gulp-uglify用于js压缩、gulp-watch用于文件监控、gulp-sass用于sass编译。\n安装各插件(方法相同)\n```\nnpm install --save-dev gulp-uglify\n```\n#### 第三步，配置gulp任务\n在项目目录下创建文件`gulpfile.js`，用于编写gulp任务。\ngulp基础语法比较简单，管道方式也很容易理解。\n这里我的项目目录如下：\n```\n├── dist\n│   ├── css\n│   ├── img\n│   └── js\n├── gulpfile.js\n├── index.html\n├── node_modules\n│   ├── eruda\n│   ├── gulp\n│   ├── gulp-clean-css\n│   ├── gulp-sass\n│   ├── gulp-uglify\n├── package.json\n└── src\n    ├── css\n    ├── img\n    ├── js\n    ├── libs\n    └── sass\n```\n其中src文件夹中是源文件，\ndist文件夹下是项目用到的压缩后的js、css文件。\n\ngulp任务配置文件gulpfile.js如下：\n```javascript\nvar gulp = require('gulp'),\n\t\tcleanCSS = require('gulp-clean-css'),\n\t\tuglify = require('gulp-uglify'),\n\t\twatch = require('gulp-watch'),\n\t\tsass = require('gulp-sass');\n\ngulp.task('default', function() {\n\t// 默认任务代码\n});\n\n// 压缩文件\ngulp.task('minfile', function() {\n\t// sass\n\tgulp.src('src/sass/*.scss')\n\t\t.pipe(sass())\n\t\t.pipe(gulp.dest('src/css'))\n\t\t.pipe(cleanCSS())\n\t\t.pipe(gulp.dest('dist/css'));\n\t// js\n\tgulp.src('src/js/*.js')\n\t\t.pipe(uglify())\n\t\t.pipe(gulp.dest('dist/js'));\n\t// img\n\tgulp.src('src/img/*')\n\t\t.pipe(gulp.dest('dist/img'));\n});\n\n// 监听\ngulp.task('watchFile', ['minfile'], function() {\n\tgulp.watch('src/**/*', ['minfile']);\n});\n\ngulp.task('default', ['minfile', 'watchFile']);\n```\ngulp API只有五个：task，src，dest，watch和run。\ntask用于定义任务；src用于表示源文件路径；dest用于输出，写入新文件；watch用于监听文件变化；run用于执行任务。\nps:上面的pipe表示管道。\n#### 第四步，开启任务\n项目目录下，执行`gulp`即可。之后就可以开始编写代码了。\n\n---------\n\n第一次对gulp的尝试，也是第一次对构建工具的尝试，其中只是用到了一些最简单也是最常用的插件，给我的感觉就是省去了每次手动编译、压缩等操作，这次使用就像一次Hello World。","source":"_posts/gulp初次实践.md","raw":"gulp是前端构建工具，通过一系列gulp插件，可以实现实时监控、格式化代码、合并代码、压缩代码、测试功能等功能。\n\n------\n\n前提：node环境，会使用基本命令行\n\n------\n\n### 全局安装gulp\n```\nsudo npm install -g gulp\n```\nWindows环境下不需要sudo命令\n\n### 项目搭建\n#### 第一步，包管理文件 package.json\n通过cd命令进入项目目录，执行`npm init`，之后可以一路的回车来创建`package.json`文件。关于此配置文件的内容挺简单的，可以自己看下，然后搜索下。\n#### 第二步，寻找、安装所需要的插件\n项目目录安装gulp，并写入配置文件package.json中。\n```\nnpm install --save-dev gulp\n```\n这样会把gulp的依赖写入到package.json文件中。\n\n#### 添加需要的各个gulp插件\n比如这里我用到了gulp-clean-css用于css压缩、gulp-uglify用于js压缩、gulp-watch用于文件监控、gulp-sass用于sass编译。\n安装各插件(方法相同)\n```\nnpm install --save-dev gulp-uglify\n```\n#### 第三步，配置gulp任务\n在项目目录下创建文件`gulpfile.js`，用于编写gulp任务。\ngulp基础语法比较简单，管道方式也很容易理解。\n这里我的项目目录如下：\n```\n├── dist\n│   ├── css\n│   ├── img\n│   └── js\n├── gulpfile.js\n├── index.html\n├── node_modules\n│   ├── eruda\n│   ├── gulp\n│   ├── gulp-clean-css\n│   ├── gulp-sass\n│   ├── gulp-uglify\n├── package.json\n└── src\n    ├── css\n    ├── img\n    ├── js\n    ├── libs\n    └── sass\n```\n其中src文件夹中是源文件，\ndist文件夹下是项目用到的压缩后的js、css文件。\n\ngulp任务配置文件gulpfile.js如下：\n```javascript\nvar gulp = require('gulp'),\n\t\tcleanCSS = require('gulp-clean-css'),\n\t\tuglify = require('gulp-uglify'),\n\t\twatch = require('gulp-watch'),\n\t\tsass = require('gulp-sass');\n\ngulp.task('default', function() {\n\t// 默认任务代码\n});\n\n// 压缩文件\ngulp.task('minfile', function() {\n\t// sass\n\tgulp.src('src/sass/*.scss')\n\t\t.pipe(sass())\n\t\t.pipe(gulp.dest('src/css'))\n\t\t.pipe(cleanCSS())\n\t\t.pipe(gulp.dest('dist/css'));\n\t// js\n\tgulp.src('src/js/*.js')\n\t\t.pipe(uglify())\n\t\t.pipe(gulp.dest('dist/js'));\n\t// img\n\tgulp.src('src/img/*')\n\t\t.pipe(gulp.dest('dist/img'));\n});\n\n// 监听\ngulp.task('watchFile', ['minfile'], function() {\n\tgulp.watch('src/**/*', ['minfile']);\n});\n\ngulp.task('default', ['minfile', 'watchFile']);\n```\ngulp API只有五个：task，src，dest，watch和run。\ntask用于定义任务；src用于表示源文件路径；dest用于输出，写入新文件；watch用于监听文件变化；run用于执行任务。\nps:上面的pipe表示管道。\n#### 第四步，开启任务\n项目目录下，执行`gulp`即可。之后就可以开始编写代码了。\n\n---------\n\n第一次对gulp的尝试，也是第一次对构建工具的尝试，其中只是用到了一些最简单也是最常用的插件，给我的感觉就是省去了每次手动编译、压缩等操作，这次使用就像一次Hello World。","slug":"gulp初次实践","published":1,"date":"2016-11-28T13:34:34.093Z","updated":"2016-11-27T01:15:21.878Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw3mfvt7000d0kc708q03v5h","content":"<p>gulp是前端构建工具，通过一系列gulp插件，可以实现实时监控、格式化代码、合并代码、压缩代码、测试功能等功能。</p>\n<hr>\n<p>前提：node环境，会使用基本命令行</p>\n<hr>\n<h3 id=\"全局安装gulp\"><a href=\"#全局安装gulp\" class=\"headerlink\" title=\"全局安装gulp\"></a>全局安装gulp</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo npm <span class=\"keyword\">install</span> -g gulp</div></pre></td></tr></table></figure>\n<p>Windows环境下不需要sudo命令</p>\n<h3 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h3><h4 id=\"第一步，包管理文件-package-json\"><a href=\"#第一步，包管理文件-package-json\" class=\"headerlink\" title=\"第一步，包管理文件 package.json\"></a>第一步，包管理文件 package.json</h4><p>通过cd命令进入项目目录，执行<code>npm init</code>，之后可以一路的回车来创建<code>package.json</code>文件。关于此配置文件的内容挺简单的，可以自己看下，然后搜索下。</p>\n<h4 id=\"第二步，寻找、安装所需要的插件\"><a href=\"#第二步，寻找、安装所需要的插件\" class=\"headerlink\" title=\"第二步，寻找、安装所需要的插件\"></a>第二步，寻找、安装所需要的插件</h4><p>项目目录安装gulp，并写入配置文件package.json中。<br><figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install --<span class=\"built_in\">save</span>-<span class=\"built_in\">dev</span> gulp</div></pre></td></tr></table></figure></p>\n<p>这样会把gulp的依赖写入到package.json文件中。</p>\n<h4 id=\"添加需要的各个gulp插件\"><a href=\"#添加需要的各个gulp插件\" class=\"headerlink\" title=\"添加需要的各个gulp插件\"></a>添加需要的各个gulp插件</h4><p>比如这里我用到了gulp-clean-css用于css压缩、gulp-uglify用于js压缩、gulp-watch用于文件监控、gulp-sass用于sass编译。<br>安装各插件(方法相同)<br><figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install --<span class=\"built_in\">save</span>-<span class=\"built_in\">dev</span> gulp-uglify</div></pre></td></tr></table></figure></p>\n<h4 id=\"第三步，配置gulp任务\"><a href=\"#第三步，配置gulp任务\" class=\"headerlink\" title=\"第三步，配置gulp任务\"></a>第三步，配置gulp任务</h4><p>在项目目录下创建文件<code>gulpfile.js</code>，用于编写gulp任务。<br>gulp基础语法比较简单，管道方式也很容易理解。<br>这里我的项目目录如下：<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── dist</div><div class=\"line\">│   ├── css</div><div class=\"line\">│   ├── <span class=\"selector-tag\">img</span></div><div class=\"line\">│   └── js</div><div class=\"line\">├── gulpfile<span class=\"selector-class\">.js</span></div><div class=\"line\">├── index<span class=\"selector-class\">.html</span></div><div class=\"line\">├── node_modules</div><div class=\"line\">│   ├── eruda</div><div class=\"line\">│   ├── gulp</div><div class=\"line\">│   ├── gulp-clean-css</div><div class=\"line\">│   ├── gulp-sass</div><div class=\"line\">│   ├── gulp-uglify</div><div class=\"line\">├── package<span class=\"selector-class\">.json</span></div><div class=\"line\">└── src</div><div class=\"line\">    ├── css</div><div class=\"line\">    ├── <span class=\"selector-tag\">img</span></div><div class=\"line\">    ├── js</div><div class=\"line\">    ├── libs</div><div class=\"line\">    └── sass</div></pre></td></tr></table></figure></p>\n<p>其中src文件夹中是源文件，<br>dist文件夹下是项目用到的压缩后的js、css文件。</p>\n<p>gulp任务配置文件gulpfile.js如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>),</div><div class=\"line\">\t\tcleanCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-clean-css'</span>),</div><div class=\"line\">\t\tuglify = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-uglify'</span>),</div><div class=\"line\">\t\twatch = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-watch'</span>),</div><div class=\"line\">\t\tsass = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-sass'</span>);</div><div class=\"line\"></div><div class=\"line\">gulp.task(<span class=\"string\">'default'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 默认任务代码</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 压缩文件</span></div><div class=\"line\">gulp.task(<span class=\"string\">'minfile'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// sass</span></div><div class=\"line\">\tgulp.src(<span class=\"string\">'src/sass/*.scss'</span>)</div><div class=\"line\">\t\t.pipe(sass())</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'src/css'</span>))</div><div class=\"line\">\t\t.pipe(cleanCSS())</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/css'</span>));</div><div class=\"line\">\t<span class=\"comment\">// js</span></div><div class=\"line\">\tgulp.src(<span class=\"string\">'src/js/*.js'</span>)</div><div class=\"line\">\t\t.pipe(uglify())</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/js'</span>));</div><div class=\"line\">\t<span class=\"comment\">// img</span></div><div class=\"line\">\tgulp.src(<span class=\"string\">'src/img/*'</span>)</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/img'</span>));</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 监听</span></div><div class=\"line\">gulp.task(<span class=\"string\">'watchFile'</span>, [<span class=\"string\">'minfile'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tgulp.watch(<span class=\"string\">'src/**/*'</span>, [<span class=\"string\">'minfile'</span>]);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">gulp.task(<span class=\"string\">'default'</span>, [<span class=\"string\">'minfile'</span>, <span class=\"string\">'watchFile'</span>]);</div></pre></td></tr></table></figure></p>\n<p>gulp API只有五个：task，src，dest，watch和run。<br>task用于定义任务；src用于表示源文件路径；dest用于输出，写入新文件；watch用于监听文件变化；run用于执行任务。<br>ps:上面的pipe表示管道。</p>\n<h4 id=\"第四步，开启任务\"><a href=\"#第四步，开启任务\" class=\"headerlink\" title=\"第四步，开启任务\"></a>第四步，开启任务</h4><p>项目目录下，执行<code>gulp</code>即可。之后就可以开始编写代码了。</p>\n<hr>\n<p>第一次对gulp的尝试，也是第一次对构建工具的尝试，其中只是用到了一些最简单也是最常用的插件，给我的感觉就是省去了每次手动编译、压缩等操作，这次使用就像一次Hello World。</p>\n","excerpt":"","more":"<p>gulp是前端构建工具，通过一系列gulp插件，可以实现实时监控、格式化代码、合并代码、压缩代码、测试功能等功能。</p>\n<hr>\n<p>前提：node环境，会使用基本命令行</p>\n<hr>\n<h3 id=\"全局安装gulp\"><a href=\"#全局安装gulp\" class=\"headerlink\" title=\"全局安装gulp\"></a>全局安装gulp</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo npm <span class=\"keyword\">install</span> -g gulp</div></pre></td></tr></table></figure>\n<p>Windows环境下不需要sudo命令</p>\n<h3 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h3><h4 id=\"第一步，包管理文件-package-json\"><a href=\"#第一步，包管理文件-package-json\" class=\"headerlink\" title=\"第一步，包管理文件 package.json\"></a>第一步，包管理文件 package.json</h4><p>通过cd命令进入项目目录，执行<code>npm init</code>，之后可以一路的回车来创建<code>package.json</code>文件。关于此配置文件的内容挺简单的，可以自己看下，然后搜索下。</p>\n<h4 id=\"第二步，寻找、安装所需要的插件\"><a href=\"#第二步，寻找、安装所需要的插件\" class=\"headerlink\" title=\"第二步，寻找、安装所需要的插件\"></a>第二步，寻找、安装所需要的插件</h4><p>项目目录安装gulp，并写入配置文件package.json中。<br><figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install --<span class=\"built_in\">save</span>-<span class=\"built_in\">dev</span> gulp</div></pre></td></tr></table></figure></p>\n<p>这样会把gulp的依赖写入到package.json文件中。</p>\n<h4 id=\"添加需要的各个gulp插件\"><a href=\"#添加需要的各个gulp插件\" class=\"headerlink\" title=\"添加需要的各个gulp插件\"></a>添加需要的各个gulp插件</h4><p>比如这里我用到了gulp-clean-css用于css压缩、gulp-uglify用于js压缩、gulp-watch用于文件监控、gulp-sass用于sass编译。<br>安装各插件(方法相同)<br><figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install --<span class=\"built_in\">save</span>-<span class=\"built_in\">dev</span> gulp-uglify</div></pre></td></tr></table></figure></p>\n<h4 id=\"第三步，配置gulp任务\"><a href=\"#第三步，配置gulp任务\" class=\"headerlink\" title=\"第三步，配置gulp任务\"></a>第三步，配置gulp任务</h4><p>在项目目录下创建文件<code>gulpfile.js</code>，用于编写gulp任务。<br>gulp基础语法比较简单，管道方式也很容易理解。<br>这里我的项目目录如下：<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── dist</div><div class=\"line\">│   ├── css</div><div class=\"line\">│   ├── <span class=\"selector-tag\">img</span></div><div class=\"line\">│   └── js</div><div class=\"line\">├── gulpfile<span class=\"selector-class\">.js</span></div><div class=\"line\">├── index<span class=\"selector-class\">.html</span></div><div class=\"line\">├── node_modules</div><div class=\"line\">│   ├── eruda</div><div class=\"line\">│   ├── gulp</div><div class=\"line\">│   ├── gulp-clean-css</div><div class=\"line\">│   ├── gulp-sass</div><div class=\"line\">│   ├── gulp-uglify</div><div class=\"line\">├── package<span class=\"selector-class\">.json</span></div><div class=\"line\">└── src</div><div class=\"line\">    ├── css</div><div class=\"line\">    ├── <span class=\"selector-tag\">img</span></div><div class=\"line\">    ├── js</div><div class=\"line\">    ├── libs</div><div class=\"line\">    └── sass</div></pre></td></tr></table></figure></p>\n<p>其中src文件夹中是源文件，<br>dist文件夹下是项目用到的压缩后的js、css文件。</p>\n<p>gulp任务配置文件gulpfile.js如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>),</div><div class=\"line\">\t\tcleanCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-clean-css'</span>),</div><div class=\"line\">\t\tuglify = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-uglify'</span>),</div><div class=\"line\">\t\twatch = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-watch'</span>),</div><div class=\"line\">\t\tsass = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-sass'</span>);</div><div class=\"line\"></div><div class=\"line\">gulp.task(<span class=\"string\">'default'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 默认任务代码</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 压缩文件</span></div><div class=\"line\">gulp.task(<span class=\"string\">'minfile'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// sass</span></div><div class=\"line\">\tgulp.src(<span class=\"string\">'src/sass/*.scss'</span>)</div><div class=\"line\">\t\t.pipe(sass())</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'src/css'</span>))</div><div class=\"line\">\t\t.pipe(cleanCSS())</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/css'</span>));</div><div class=\"line\">\t<span class=\"comment\">// js</span></div><div class=\"line\">\tgulp.src(<span class=\"string\">'src/js/*.js'</span>)</div><div class=\"line\">\t\t.pipe(uglify())</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/js'</span>));</div><div class=\"line\">\t<span class=\"comment\">// img</span></div><div class=\"line\">\tgulp.src(<span class=\"string\">'src/img/*'</span>)</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/img'</span>));</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 监听</span></div><div class=\"line\">gulp.task(<span class=\"string\">'watchFile'</span>, [<span class=\"string\">'minfile'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tgulp.watch(<span class=\"string\">'src/**/*'</span>, [<span class=\"string\">'minfile'</span>]);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">gulp.task(<span class=\"string\">'default'</span>, [<span class=\"string\">'minfile'</span>, <span class=\"string\">'watchFile'</span>]);</div></pre></td></tr></table></figure></p>\n<p>gulp API只有五个：task，src，dest，watch和run。<br>task用于定义任务；src用于表示源文件路径；dest用于输出，写入新文件；watch用于监听文件变化；run用于执行任务。<br>ps:上面的pipe表示管道。</p>\n<h4 id=\"第四步，开启任务\"><a href=\"#第四步，开启任务\" class=\"headerlink\" title=\"第四步，开启任务\"></a>第四步，开启任务</h4><p>项目目录下，执行<code>gulp</code>即可。之后就可以开始编写代码了。</p>\n<hr>\n<p>第一次对gulp的尝试，也是第一次对构建工具的尝试，其中只是用到了一些最简单也是最常用的插件，给我的感觉就是省去了每次手动编译、压缩等操作，这次使用就像一次Hello World。</p>\n"},{"title":"redux应用于React","date":"2016-09-21T16:00:00.000Z","comments":1,"_content":"\n### Redux应用于React  \n\n　　不知道有多少人和我一样，redux的文档看了一遍又一遍，各种教程翻来翻去，还是不知道在自己的React项目中该如何加入redux。  \n　　经过这段时间，总算有些入门的感觉，明白大致的编写流程。  \n　　对于在React项目中使用redux，首先需要理解`展示型组件和容器型组件`。  \n　　简单来说，展示型组件用于对展示页面，数据通过`props`获得，只有容器型组件与redux交道。一般情况下，容器型组件通过redux的`connect`函数获得state，以及action，然后调用展示型组件并通过`props`传递所需要的state和action。展示型组件需要修改state就通过容器型组件传递过来的action调用。  \neg\n```jsx\n// Login.js  Login组件 (此为容器组件)\n\n// 通过connect传递state中的userData和user action\n@connect(\n  ({userData}) => ({userData}),\n  require('ACTION/user').default\n)\nexport default class Login extends Component {\n\trender() {\n\t\treturn (\n        <div className=\"login-content\">\n      \t\t<div className=\"login\">\n            <p className=\"login-close\"><Link to=\"user\">&times;</Link></p>\n            {/* 调用LoginForm组件，并把user action中的login方法通过props传递给LoginForm组件 */}\n            <LoginForm\n              toLogin = { this.props.login }\n            >\n            </LoginForm>\n          </div>\n        </div>\n\t\t\t);\n\t}\n}\n```\n\n```jsx\n// LoginForm.js  LoginForm组件 (此为展示组件)\n\nexport default class LoginForm extends Component {\n  \n  constructor (props) {\n    super(props);\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    let username = this.refs.username.value;\n    let password = this.refs.password.value;\n    // 对输入的处理\n    if(username == '' || password == '') {\n      return alert('请输入用户名和密码');\n    }\n    // 调用redux action来修改state\n    return this.props.toLogin(username, password);\n  }\n\n  render() {\n\t\treturn (\n        <div className=\"login-form\">\n          <from>\n            <input className=\"username-input\" type=\"text\" placeholder=\"用户名\"\n              ref=\"username\"\n            />\n            <input className=\"password-input\" type=\"password\" placeholder=\"密码\"\n              ref=\"password\"\n            />\n            <submit className=\"submit-btn\" onClick={ this.handleClick }>进入头条</submit>\n          </from>\n        </div>\n\t\t\t);\n\t}\n}\n```\n\n#####\n\n关于action, reducer, store的编写，需要明白这个流程：\n\n\t1. dispatch()用于触发action，参数为具体action(actionCreate其实也是产生一个action)。\n\t2. 当有action被触发时，就会去store中查询注册的reducer(通过action.type查找),并执行该reducer返回新的state。\n\n所以我们需要做的：\n\n\t1. 编写reducer，参数为(initstate, action)，(一般样式为switch(action.type))。\n\t2. 合并reducer，主要目的是可以将reducer分成多个编写，更方便管理和理解。\n\t3. 编写store，注册reducer到store中，这里一般都会添加redux的中间件。\n\tps:\n\t应该是最先编写action，包括action type常量定义，可以用于action create和reducer；action create函数；action dispatch函数。函数位置具体怎么分，各有所爱吧。","source":"_posts/redux应用于React.md","raw":"---\ntitle: redux应用于React\ndate: 2016-09-22\ntags: javascript React redux\ncategories: \n- javascript\ncomments: true\n---\n\n### Redux应用于React  \n\n　　不知道有多少人和我一样，redux的文档看了一遍又一遍，各种教程翻来翻去，还是不知道在自己的React项目中该如何加入redux。  \n　　经过这段时间，总算有些入门的感觉，明白大致的编写流程。  \n　　对于在React项目中使用redux，首先需要理解`展示型组件和容器型组件`。  \n　　简单来说，展示型组件用于对展示页面，数据通过`props`获得，只有容器型组件与redux交道。一般情况下，容器型组件通过redux的`connect`函数获得state，以及action，然后调用展示型组件并通过`props`传递所需要的state和action。展示型组件需要修改state就通过容器型组件传递过来的action调用。  \neg\n```jsx\n// Login.js  Login组件 (此为容器组件)\n\n// 通过connect传递state中的userData和user action\n@connect(\n  ({userData}) => ({userData}),\n  require('ACTION/user').default\n)\nexport default class Login extends Component {\n\trender() {\n\t\treturn (\n        <div className=\"login-content\">\n      \t\t<div className=\"login\">\n            <p className=\"login-close\"><Link to=\"user\">&times;</Link></p>\n            {/* 调用LoginForm组件，并把user action中的login方法通过props传递给LoginForm组件 */}\n            <LoginForm\n              toLogin = { this.props.login }\n            >\n            </LoginForm>\n          </div>\n        </div>\n\t\t\t);\n\t}\n}\n```\n\n```jsx\n// LoginForm.js  LoginForm组件 (此为展示组件)\n\nexport default class LoginForm extends Component {\n  \n  constructor (props) {\n    super(props);\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    let username = this.refs.username.value;\n    let password = this.refs.password.value;\n    // 对输入的处理\n    if(username == '' || password == '') {\n      return alert('请输入用户名和密码');\n    }\n    // 调用redux action来修改state\n    return this.props.toLogin(username, password);\n  }\n\n  render() {\n\t\treturn (\n        <div className=\"login-form\">\n          <from>\n            <input className=\"username-input\" type=\"text\" placeholder=\"用户名\"\n              ref=\"username\"\n            />\n            <input className=\"password-input\" type=\"password\" placeholder=\"密码\"\n              ref=\"password\"\n            />\n            <submit className=\"submit-btn\" onClick={ this.handleClick }>进入头条</submit>\n          </from>\n        </div>\n\t\t\t);\n\t}\n}\n```\n\n#####\n\n关于action, reducer, store的编写，需要明白这个流程：\n\n\t1. dispatch()用于触发action，参数为具体action(actionCreate其实也是产生一个action)。\n\t2. 当有action被触发时，就会去store中查询注册的reducer(通过action.type查找),并执行该reducer返回新的state。\n\n所以我们需要做的：\n\n\t1. 编写reducer，参数为(initstate, action)，(一般样式为switch(action.type))。\n\t2. 合并reducer，主要目的是可以将reducer分成多个编写，更方便管理和理解。\n\t3. 编写store，注册reducer到store中，这里一般都会添加redux的中间件。\n\tps:\n\t应该是最先编写action，包括action type常量定义，可以用于action create和reducer；action create函数；action dispatch函数。函数位置具体怎么分，各有所爱吧。","slug":"redux应用于React","published":1,"updated":"2016-11-27T01:15:21.898Z","layout":"post","photos":[],"link":"","_id":"ciw3mfvt7000g0kc7pue7z6nk","content":"<h3 id=\"Redux应用于React\"><a href=\"#Redux应用于React\" class=\"headerlink\" title=\"Redux应用于React\"></a>Redux应用于React</h3><p>　　不知道有多少人和我一样，redux的文档看了一遍又一遍，各种教程翻来翻去，还是不知道在自己的React项目中该如何加入redux。<br>　　经过这段时间，总算有些入门的感觉，明白大致的编写流程。<br>　　对于在React项目中使用redux，首先需要理解<code>展示型组件和容器型组件</code>。<br>　　简单来说，展示型组件用于对展示页面，数据通过<code>props</code>获得，只有容器型组件与redux交道。一般情况下，容器型组件通过redux的<code>connect</code>函数获得state，以及action，然后调用展示型组件并通过<code>props</code>传递所需要的state和action。展示型组件需要修改state就通过容器型组件传递过来的action调用。<br>eg<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Login.js  Login组件 (此为容器组件)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 通过connect传递state中的userData和user action</span></div><div class=\"line\">@connect(</div><div class=\"line\">  <span class=\"function\">(<span class=\"params\">&#123;userData&#125;</span>) =&gt;</span> (&#123;userData&#125;),</div><div class=\"line\">  <span class=\"built_in\">require</span>(<span class=\"string\">'ACTION/user'</span>).default</div><div class=\"line\">)</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Login</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">\trender() &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> (</div><div class=\"line\">        <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"login-content\"</span>&gt;</span></span></div><div class=\"line\">      \t\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"login\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">className</span>=<span class=\"string\">\"login-close\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"user\"</span>&gt;</span>&amp;times;<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">            &#123;/* 调用LoginForm组件，并把user action中的login方法通过props传递给LoginForm组件 */&#125;</div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">LoginForm</span></span></div><div class=\"line\">              <span class=\"attr\">toLogin</span> = <span class=\"string\">&#123;</span> <span class=\"attr\">this.props.login</span> &#125;</div><div class=\"line\">            &gt;</div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">LoginForm</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t\t\t);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// LoginForm.js  LoginForm组件 (此为展示组件)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginForm</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">constructor</span> (props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleClick() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> username = <span class=\"keyword\">this</span>.refs.username.value;</div><div class=\"line\">    <span class=\"keyword\">let</span> password = <span class=\"keyword\">this</span>.refs.password.value;</div><div class=\"line\">    <span class=\"comment\">// 对输入的处理</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(username == <span class=\"string\">''</span> || password == <span class=\"string\">''</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> alert(<span class=\"string\">'请输入用户名和密码'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 调用redux action来修改state</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.toLogin(username, password);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> (</div><div class=\"line\">        &lt;div className=\"login-form\"&gt;</div><div class=\"line\">          &lt;from&gt;</div><div class=\"line\">            &lt;input className=\"username-input\" type=\"text\" placeholder=\"用户名\"</div><div class=\"line\">              ref=\"username\"</div><div class=\"line\">            /&gt;</div><div class=\"line\">            &lt;input className=\"password-input\" type=\"password\" placeholder=\"密码\"</div><div class=\"line\">              ref=\"password\"</div><div class=\"line\">            /&gt;</div><div class=\"line\">            &lt;submit className=\"submit-btn\" onClick=&#123; this.handleClick &#125;&gt;进入头条&lt;/submit&gt;</div><div class=\"line\">          &lt;/from&gt;</div><div class=\"line\">        &lt;/div&gt;</div><div class=\"line\">\t\t\t);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>#####</p>\n<p>关于action, reducer, store的编写，需要明白这个流程：</p>\n<pre><code>1. dispatch()用于触发action，参数为具体action(actionCreate其实也是产生一个action)。\n2. 当有action被触发时，就会去store中查询注册的reducer(通过action.type查找),并执行该reducer返回新的state。\n</code></pre><p>所以我们需要做的：</p>\n<pre><code>1. 编写reducer，参数为(initstate, action)，(一般样式为switch(action.type))。\n2. 合并reducer，主要目的是可以将reducer分成多个编写，更方便管理和理解。\n3. 编写store，注册reducer到store中，这里一般都会添加redux的中间件。\nps:\n应该是最先编写action，包括action type常量定义，可以用于action create和reducer；action create函数；action dispatch函数。函数位置具体怎么分，各有所爱吧。\n</code></pre>","excerpt":"","more":"<h3 id=\"Redux应用于React\"><a href=\"#Redux应用于React\" class=\"headerlink\" title=\"Redux应用于React\"></a>Redux应用于React</h3><p>　　不知道有多少人和我一样，redux的文档看了一遍又一遍，各种教程翻来翻去，还是不知道在自己的React项目中该如何加入redux。<br>　　经过这段时间，总算有些入门的感觉，明白大致的编写流程。<br>　　对于在React项目中使用redux，首先需要理解<code>展示型组件和容器型组件</code>。<br>　　简单来说，展示型组件用于对展示页面，数据通过<code>props</code>获得，只有容器型组件与redux交道。一般情况下，容器型组件通过redux的<code>connect</code>函数获得state，以及action，然后调用展示型组件并通过<code>props</code>传递所需要的state和action。展示型组件需要修改state就通过容器型组件传递过来的action调用。<br>eg<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Login.js  Login组件 (此为容器组件)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 通过connect传递state中的userData和user action</span></div><div class=\"line\">@connect(</div><div class=\"line\">  <span class=\"function\">(<span class=\"params\">&#123;userData&#125;</span>) =&gt;</span> (&#123;userData&#125;),</div><div class=\"line\">  <span class=\"built_in\">require</span>(<span class=\"string\">'ACTION/user'</span>).default</div><div class=\"line\">)</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Login</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">\trender() &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> (</div><div class=\"line\">        <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"login-content\"</span>&gt;</span></div><div class=\"line\">      \t\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"login\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">className</span>=<span class=\"string\">\"login-close\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"user\"</span>&gt;</span>&amp;times;<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">            &#123;/* 调用LoginForm组件，并把user action中的login方法通过props传递给LoginForm组件 */&#125;</div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">LoginForm</span></div><div class=\"line\">              <span class=\"attr\">toLogin</span> = <span class=\"string\">&#123;</span> <span class=\"attr\">this.props.login</span> &#125;</div><div class=\"line\">            &gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">LoginForm</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">\t\t\t);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// LoginForm.js  LoginForm组件 (此为展示组件)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginForm</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">constructor</span> (props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleClick() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> username = <span class=\"keyword\">this</span>.refs.username.value;</div><div class=\"line\">    <span class=\"keyword\">let</span> password = <span class=\"keyword\">this</span>.refs.password.value;</div><div class=\"line\">    <span class=\"comment\">// 对输入的处理</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(username == <span class=\"string\">''</span> || password == <span class=\"string\">''</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> alert(<span class=\"string\">'请输入用户名和密码'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 调用redux action来修改state</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.toLogin(username, password);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> (</div><div class=\"line\">        &lt;div className=\"login-form\"&gt;</div><div class=\"line\">          &lt;from&gt;</div><div class=\"line\">            &lt;input className=\"username-input\" type=\"text\" placeholder=\"用户名\"</div><div class=\"line\">              ref=\"username\"</div><div class=\"line\">            /&gt;</div><div class=\"line\">            &lt;input className=\"password-input\" type=\"password\" placeholder=\"密码\"</div><div class=\"line\">              ref=\"password\"</div><div class=\"line\">            /&gt;</div><div class=\"line\">            &lt;submit className=\"submit-btn\" onClick=&#123; this.handleClick &#125;&gt;进入头条&lt;/submit&gt;</div><div class=\"line\">          &lt;/from&gt;</div><div class=\"line\">        &lt;/div&gt;</div><div class=\"line\">\t\t\t);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>#####</p>\n<p>关于action, reducer, store的编写，需要明白这个流程：</p>\n<pre><code>1. dispatch()用于触发action，参数为具体action(actionCreate其实也是产生一个action)。\n2. 当有action被触发时，就会去store中查询注册的reducer(通过action.type查找),并执行该reducer返回新的state。\n</code></pre><p>所以我们需要做的：</p>\n<pre><code>1. 编写reducer，参数为(initstate, action)，(一般样式为switch(action.type))。\n2. 合并reducer，主要目的是可以将reducer分成多个编写，更方便管理和理解。\n3. 编写store，注册reducer到store中，这里一般都会添加redux的中间件。\nps:\n应该是最先编写action，包括action type常量定义，可以用于action create和reducer；action create函数；action dispatch函数。函数位置具体怎么分，各有所爱吧。\n</code></pre>"},{"title":"一次麻烦的投票","date":"2016-10-30T16:00:00.000Z","comments":1,"_content":"\n刚开始接到任务只是一个将一个之前的页面进行修改，没想到遇到了各种问题。  \n\n### 1. 三角形照片以及遮盖层。\n三角形的实现网上面试题、技术贴也常看到，第一反应就是使用border来实现三角形。使用border来实现三角形还是很方便的。只需要根据三角形的各边给4个border不同的值即可实现。但是这种方法更多的是单色的三角形图标，好像没办法实现三角形照片。只能另找他法。  \n搜索下找到了变换方法，使用的是rotate和skew。需要两层div，先是外层div旋转45度，然后里层div沿X、Y轴倾斜相同度数，就可以生成一个菱形，如果遮住一半即可生成三角形。图片呢，就是放在内层div中，然后在旋转-45度并且倾斜负的里层div旋转度数，使得形成图片正常方形。如下：\n```html\n<div class=\"row\">\n  <div class=\"a\">\n    <div class=\"b\">\n      <img src=\"\" alt=\"\">\n      <div class=\"cover\"></div>\n    </div>\n  </div>\n</div>\n```\n```css\n.a {\n  float: left;\n  transform: rotate(45deg);\n}\n.b {\n  width: 217.1px;\n  height: 217.1px;\n  transform: skew(10deg, 10deg);\n  background: #000;\n}\n```\n.row是用来遮盖菱形上或下半部分形成三角形，img标签和.cover使用绝对定位相对于.row，使得正好将三角形覆盖，.cover中的内容使用margin以及width，使内容正好居中。效果如下：\n<img src=\"images/triangles.png\" alt=\"\">\n\n实现的缺点是IE8即以下不兼容，并且绝对定位因为变换不是特别好调整位置，最后是选择上传图片直接使用三角形图片，IE8以下使用另一套绝对定位，但是遮盖层还是会方形显示。\n\n### 2. 投票功能\n投票系统主要两个麻烦，一个是跨域问题，一个是投票的限制问题。因为投票系统是西安部门进行开发的，是刚开发不久的系统，而且是个问卷系统，并没有充分考虑投票这方面的限制，以及投票成功的反馈。投票的限制前端可以做的应该就是使用localstorage或者cookie来进行一部分限制，更多限制应该还是后端来做支持。跨域问题，GET方法可以使用jsonp很容易解决，但是对于POST就不是特别清晰，我们这边后端做限制的支持，就将投票也改成了GET请求。  \n其实这里的反馈并不怎么好，网速慢的话可能会造成点击没有任何反馈。所以就前端点击，直接投票技术+1，并且投票的心形变成红色，然后请求后端。如果发生错误，提示刷新页面就可以重新投票。","source":"_posts/一次麻烦的投票.md","raw":"---\ntitle: 一次麻烦的投票\ndate: 2016-10-31\ntags: javascript 项目经验\ncategories:\n- javascript\ncomments: true\n---\n\n刚开始接到任务只是一个将一个之前的页面进行修改，没想到遇到了各种问题。  \n\n### 1. 三角形照片以及遮盖层。\n三角形的实现网上面试题、技术贴也常看到，第一反应就是使用border来实现三角形。使用border来实现三角形还是很方便的。只需要根据三角形的各边给4个border不同的值即可实现。但是这种方法更多的是单色的三角形图标，好像没办法实现三角形照片。只能另找他法。  \n搜索下找到了变换方法，使用的是rotate和skew。需要两层div，先是外层div旋转45度，然后里层div沿X、Y轴倾斜相同度数，就可以生成一个菱形，如果遮住一半即可生成三角形。图片呢，就是放在内层div中，然后在旋转-45度并且倾斜负的里层div旋转度数，使得形成图片正常方形。如下：\n```html\n<div class=\"row\">\n  <div class=\"a\">\n    <div class=\"b\">\n      <img src=\"\" alt=\"\">\n      <div class=\"cover\"></div>\n    </div>\n  </div>\n</div>\n```\n```css\n.a {\n  float: left;\n  transform: rotate(45deg);\n}\n.b {\n  width: 217.1px;\n  height: 217.1px;\n  transform: skew(10deg, 10deg);\n  background: #000;\n}\n```\n.row是用来遮盖菱形上或下半部分形成三角形，img标签和.cover使用绝对定位相对于.row，使得正好将三角形覆盖，.cover中的内容使用margin以及width，使内容正好居中。效果如下：\n<img src=\"images/triangles.png\" alt=\"\">\n\n实现的缺点是IE8即以下不兼容，并且绝对定位因为变换不是特别好调整位置，最后是选择上传图片直接使用三角形图片，IE8以下使用另一套绝对定位，但是遮盖层还是会方形显示。\n\n### 2. 投票功能\n投票系统主要两个麻烦，一个是跨域问题，一个是投票的限制问题。因为投票系统是西安部门进行开发的，是刚开发不久的系统，而且是个问卷系统，并没有充分考虑投票这方面的限制，以及投票成功的反馈。投票的限制前端可以做的应该就是使用localstorage或者cookie来进行一部分限制，更多限制应该还是后端来做支持。跨域问题，GET方法可以使用jsonp很容易解决，但是对于POST就不是特别清晰，我们这边后端做限制的支持，就将投票也改成了GET请求。  \n其实这里的反馈并不怎么好，网速慢的话可能会造成点击没有任何反馈。所以就前端点击，直接投票技术+1，并且投票的心形变成红色，然后请求后端。如果发生错误，提示刷新页面就可以重新投票。","slug":"一次麻烦的投票","published":1,"updated":"2016-11-27T01:15:21.901Z","layout":"post","photos":[],"link":"","_id":"ciw3mfvt7000i0kc72xi7ken2","content":"<p>刚开始接到任务只是一个将一个之前的页面进行修改，没想到遇到了各种问题。  </p>\n<h3 id=\"1-三角形照片以及遮盖层。\"><a href=\"#1-三角形照片以及遮盖层。\" class=\"headerlink\" title=\"1. 三角形照片以及遮盖层。\"></a>1. 三角形照片以及遮盖层。</h3><p>三角形的实现网上面试题、技术贴也常看到，第一反应就是使用border来实现三角形。使用border来实现三角形还是很方便的。只需要根据三角形的各边给4个border不同的值即可实现。但是这种方法更多的是单色的三角形图标，好像没办法实现三角形照片。只能另找他法。<br>搜索下找到了变换方法，使用的是rotate和skew。需要两层div，先是外层div旋转45度，然后里层div沿X、Y轴倾斜相同度数，就可以生成一个菱形，如果遮住一半即可生成三角形。图片呢，就是放在内层div中，然后在旋转-45度并且倾斜负的里层div旋转度数，使得形成图片正常方形。如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"a\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"b\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cover\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.a</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">float</span>: left;</div><div class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(45deg);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.b</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">217.1px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">217.1px</span>;</div><div class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">skew</span>(10deg, 10deg);</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#000</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>.row是用来遮盖菱形上或下半部分形成三角形，img标签和.cover使用绝对定位相对于.row，使得正好将三角形覆盖，.cover中的内容使用margin以及width，使内容正好居中。效果如下：<br><img src=\"images/triangles.png\" alt=\"\"></p>\n<p>实现的缺点是IE8即以下不兼容，并且绝对定位因为变换不是特别好调整位置，最后是选择上传图片直接使用三角形图片，IE8以下使用另一套绝对定位，但是遮盖层还是会方形显示。</p>\n<h3 id=\"2-投票功能\"><a href=\"#2-投票功能\" class=\"headerlink\" title=\"2. 投票功能\"></a>2. 投票功能</h3><p>投票系统主要两个麻烦，一个是跨域问题，一个是投票的限制问题。因为投票系统是西安部门进行开发的，是刚开发不久的系统，而且是个问卷系统，并没有充分考虑投票这方面的限制，以及投票成功的反馈。投票的限制前端可以做的应该就是使用localstorage或者cookie来进行一部分限制，更多限制应该还是后端来做支持。跨域问题，GET方法可以使用jsonp很容易解决，但是对于POST就不是特别清晰，我们这边后端做限制的支持，就将投票也改成了GET请求。<br>其实这里的反馈并不怎么好，网速慢的话可能会造成点击没有任何反馈。所以就前端点击，直接投票技术+1，并且投票的心形变成红色，然后请求后端。如果发生错误，提示刷新页面就可以重新投票。</p>\n","excerpt":"","more":"<p>刚开始接到任务只是一个将一个之前的页面进行修改，没想到遇到了各种问题。  </p>\n<h3 id=\"1-三角形照片以及遮盖层。\"><a href=\"#1-三角形照片以及遮盖层。\" class=\"headerlink\" title=\"1. 三角形照片以及遮盖层。\"></a>1. 三角形照片以及遮盖层。</h3><p>三角形的实现网上面试题、技术贴也常看到，第一反应就是使用border来实现三角形。使用border来实现三角形还是很方便的。只需要根据三角形的各边给4个border不同的值即可实现。但是这种方法更多的是单色的三角形图标，好像没办法实现三角形照片。只能另找他法。<br>搜索下找到了变换方法，使用的是rotate和skew。需要两层div，先是外层div旋转45度，然后里层div沿X、Y轴倾斜相同度数，就可以生成一个菱形，如果遮住一半即可生成三角形。图片呢，就是放在内层div中，然后在旋转-45度并且倾斜负的里层div旋转度数，使得形成图片正常方形。如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"a\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"b\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cover\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.a</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">float</span>: left;</div><div class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(45deg);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.b</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">217.1px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">217.1px</span>;</div><div class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">skew</span>(10deg, 10deg);</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#000</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>.row是用来遮盖菱形上或下半部分形成三角形，img标签和.cover使用绝对定位相对于.row，使得正好将三角形覆盖，.cover中的内容使用margin以及width，使内容正好居中。效果如下：<br><img src=\"images/triangles.png\" alt=\"\"></p>\n<p>实现的缺点是IE8即以下不兼容，并且绝对定位因为变换不是特别好调整位置，最后是选择上传图片直接使用三角形图片，IE8以下使用另一套绝对定位，但是遮盖层还是会方形显示。</p>\n<h3 id=\"2-投票功能\"><a href=\"#2-投票功能\" class=\"headerlink\" title=\"2. 投票功能\"></a>2. 投票功能</h3><p>投票系统主要两个麻烦，一个是跨域问题，一个是投票的限制问题。因为投票系统是西安部门进行开发的，是刚开发不久的系统，而且是个问卷系统，并没有充分考虑投票这方面的限制，以及投票成功的反馈。投票的限制前端可以做的应该就是使用localstorage或者cookie来进行一部分限制，更多限制应该还是后端来做支持。跨域问题，GET方法可以使用jsonp很容易解决，但是对于POST就不是特别清晰，我们这边后端做限制的支持，就将投票也改成了GET请求。<br>其实这里的反馈并不怎么好，网速慢的话可能会造成点击没有任何反馈。所以就前端点击，直接投票技术+1，并且投票的心形变成红色，然后请求后端。如果发生错误，提示刷新页面就可以重新投票。</p>\n"},{"title":"一次H5页面","date":"2016-08-02T16:00:00.000Z","comments":1,"_content":"\n任务：环球网-2016七夕H5页面  \n环境：swiper插件，gulp及相关常用工具。\n\n---\n\n### 适配\n使用的还是lib-flexible那套解决方案，需要查看的可以点击[这里](https://github.com/amfe/lib-flexible)  \n### 使用swiper\n使用swiper页面的控制以及滑动功能就变得非常容易，可以参见[Swiper中文网](http://www.swiper.com.cn/)，其中添加给类名添加`swiper-slide`即可表示一页。  \n在Swiper实例化中，属性`direction`可以定义横向/竖向滑动，`nextButton`可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在`onSlideChangeStart`中不能够出发`slideTo()`方法。  \nSwiper还有许多其他功能，可以参见[Swiper中文网](http://www.swiper.com.cn/)中API。\n\n### ES6的使用\nES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是`gulp-babel`。\n\n### 目录、git以及gulp相关\n目录和之前的项目目录基本相同。\n```\n.\n├── .eslintrc.json\n├── .gitignore\n├── dist\n│   ├── css\n│   ├── imgs\n│   ├── js\n│   └── libs\n├── gulpfile.js\n├── index.html\n├── node_modules\n├── package.json\n├── psd\n└── src\n    ├── ES6\n    ├── css\n    ├── imgs\n    ├── js\n    ├── libs\n    └── sass\n```\ndist目录存放合并、压缩的代码，用于上线使用。(自动生成)  \nsrc目录存放源文件。  \nnode_modules目录存放用到的node工具。(自动生成)  \npsd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。  \n相比之前增加的文件：\n\n*  .eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看[这里](https://segmentfault.com/a/1190000004468428)。\n*  .gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。\n```\n/node_modules/\n/psd/\n```\n* src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。\n\ngit开始学习使用分支处理bug、添加尝试性功能等。\n\n### 坑是用来爬的\n#### 最经典的坑——this\n在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过`fn.bind(this)`来指向想要的this，在旧版本浏览器下需要使用兼容写法。\n\n#### 省事也被坑——autoprefixer\nautoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是`remove`，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。  \nandriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。\n\n#### 没想到的坑——微信分享\n关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。  \n问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中`mqq.data.setShareInfo`可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。\n\n### 其他\n#### 自定义单选框\n自定义单选框并没有想象中的那么难，除了`<input type=\"radio\">`外，还有个label标签和after伪类。  \n设置css`[type=radio]: display: none;`，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)\n\n#### 文字居中\n要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。\n\n#### 横屏问题\n我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。\n\n### 改进\n需要改进的东西就太多太多了。 \n \n* 最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。\n* 图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。\n* 动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。","source":"_posts/一次H5页面.md","raw":"---\ntitle: 一次H5页面\ndate: 2016-08-03\ntags: [javascript,H5]\ncategories: \n- H5\ncomments: true\n---\n\n任务：环球网-2016七夕H5页面  \n环境：swiper插件，gulp及相关常用工具。\n\n---\n\n### 适配\n使用的还是lib-flexible那套解决方案，需要查看的可以点击[这里](https://github.com/amfe/lib-flexible)  \n### 使用swiper\n使用swiper页面的控制以及滑动功能就变得非常容易，可以参见[Swiper中文网](http://www.swiper.com.cn/)，其中添加给类名添加`swiper-slide`即可表示一页。  \n在Swiper实例化中，属性`direction`可以定义横向/竖向滑动，`nextButton`可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在`onSlideChangeStart`中不能够出发`slideTo()`方法。  \nSwiper还有许多其他功能，可以参见[Swiper中文网](http://www.swiper.com.cn/)中API。\n\n### ES6的使用\nES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是`gulp-babel`。\n\n### 目录、git以及gulp相关\n目录和之前的项目目录基本相同。\n```\n.\n├── .eslintrc.json\n├── .gitignore\n├── dist\n│   ├── css\n│   ├── imgs\n│   ├── js\n│   └── libs\n├── gulpfile.js\n├── index.html\n├── node_modules\n├── package.json\n├── psd\n└── src\n    ├── ES6\n    ├── css\n    ├── imgs\n    ├── js\n    ├── libs\n    └── sass\n```\ndist目录存放合并、压缩的代码，用于上线使用。(自动生成)  \nsrc目录存放源文件。  \nnode_modules目录存放用到的node工具。(自动生成)  \npsd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。  \n相比之前增加的文件：\n\n*  .eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看[这里](https://segmentfault.com/a/1190000004468428)。\n*  .gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。\n```\n/node_modules/\n/psd/\n```\n* src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。\n\ngit开始学习使用分支处理bug、添加尝试性功能等。\n\n### 坑是用来爬的\n#### 最经典的坑——this\n在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过`fn.bind(this)`来指向想要的this，在旧版本浏览器下需要使用兼容写法。\n\n#### 省事也被坑——autoprefixer\nautoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是`remove`，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。  \nandriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。\n\n#### 没想到的坑——微信分享\n关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。  \n问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中`mqq.data.setShareInfo`可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。\n\n### 其他\n#### 自定义单选框\n自定义单选框并没有想象中的那么难，除了`<input type=\"radio\">`外，还有个label标签和after伪类。  \n设置css`[type=radio]: display: none;`，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)\n\n#### 文字居中\n要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。\n\n#### 横屏问题\n我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。\n\n### 改进\n需要改进的东西就太多太多了。 \n \n* 最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。\n* 图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。\n* 动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。","slug":"一次H5页面","published":1,"updated":"2016-08-14T13:43:06.000Z","layout":"post","photos":[],"link":"","_id":"ciw3mfvt7000m0kc7uq6a554c","content":"<p>任务：环球网-2016七夕H5页面<br>环境：swiper插件，gulp及相关常用工具。</p>\n<hr>\n<h3 id=\"适配\"><a href=\"#适配\" class=\"headerlink\" title=\"适配\"></a>适配</h3><p>使用的还是lib-flexible那套解决方案，需要查看的可以点击<a href=\"https://github.com/amfe/lib-flexible\" target=\"_blank\" rel=\"external\">这里</a>  </p>\n<h3 id=\"使用swiper\"><a href=\"#使用swiper\" class=\"headerlink\" title=\"使用swiper\"></a>使用swiper</h3><p>使用swiper页面的控制以及滑动功能就变得非常容易，可以参见<a href=\"http://www.swiper.com.cn/\" target=\"_blank\" rel=\"external\">Swiper中文网</a>，其中添加给类名添加<code>swiper-slide</code>即可表示一页。<br>在Swiper实例化中，属性<code>direction</code>可以定义横向/竖向滑动，<code>nextButton</code>可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在<code>onSlideChangeStart</code>中不能够出发<code>slideTo()</code>方法。<br>Swiper还有许多其他功能，可以参见<a href=\"http://www.swiper.com.cn/\" target=\"_blank\" rel=\"external\">Swiper中文网</a>中API。</p>\n<h3 id=\"ES6的使用\"><a href=\"#ES6的使用\" class=\"headerlink\" title=\"ES6的使用\"></a>ES6的使用</h3><p>ES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是<code>gulp-babel</code>。</p>\n<h3 id=\"目录、git以及gulp相关\"><a href=\"#目录、git以及gulp相关\" class=\"headerlink\" title=\"目录、git以及gulp相关\"></a>目录、git以及gulp相关</h3><p>目录和之前的项目目录基本相同。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── <span class=\"selector-class\">.eslintrc</span><span class=\"selector-class\">.json</span></div><div class=\"line\">├── <span class=\"selector-class\">.gitignore</span></div><div class=\"line\">├── dist</div><div class=\"line\">│   ├── css</div><div class=\"line\">│   ├── imgs</div><div class=\"line\">│   ├── js</div><div class=\"line\">│   └── libs</div><div class=\"line\">├── gulpfile<span class=\"selector-class\">.js</span></div><div class=\"line\">├── index<span class=\"selector-class\">.html</span></div><div class=\"line\">├── node_modules</div><div class=\"line\">├── package<span class=\"selector-class\">.json</span></div><div class=\"line\">├── psd</div><div class=\"line\">└── src</div><div class=\"line\">    ├── ES6</div><div class=\"line\">    ├── css</div><div class=\"line\">    ├── imgs</div><div class=\"line\">    ├── js</div><div class=\"line\">    ├── libs</div><div class=\"line\">    └── sass</div></pre></td></tr></table></figure></p>\n<p>dist目录存放合并、压缩的代码，用于上线使用。(自动生成)<br>src目录存放源文件。<br>node_modules目录存放用到的node工具。(自动生成)<br>psd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。<br>相比之前增加的文件：</p>\n<ul>\n<li>.eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看<a href=\"https://segmentfault.com/a/1190000004468428\" target=\"_blank\" rel=\"external\">这里</a>。</li>\n<li><p>.gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"regexp\">/node_modules/</span></div><div class=\"line\"><span class=\"regexp\">/psd/</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。</p>\n</li>\n</ul>\n<p>git开始学习使用分支处理bug、添加尝试性功能等。</p>\n<h3 id=\"坑是用来爬的\"><a href=\"#坑是用来爬的\" class=\"headerlink\" title=\"坑是用来爬的\"></a>坑是用来爬的</h3><h4 id=\"最经典的坑——this\"><a href=\"#最经典的坑——this\" class=\"headerlink\" title=\"最经典的坑——this\"></a>最经典的坑——this</h4><p>在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过<code>fn.bind(this)</code>来指向想要的this，在旧版本浏览器下需要使用兼容写法。</p>\n<h4 id=\"省事也被坑——autoprefixer\"><a href=\"#省事也被坑——autoprefixer\" class=\"headerlink\" title=\"省事也被坑——autoprefixer\"></a>省事也被坑——autoprefixer</h4><p>autoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是<code>remove</code>，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。<br>andriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。</p>\n<h4 id=\"没想到的坑——微信分享\"><a href=\"#没想到的坑——微信分享\" class=\"headerlink\" title=\"没想到的坑——微信分享\"></a>没想到的坑——微信分享</h4><p>关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。<br>问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中<code>mqq.data.setShareInfo</code>可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"自定义单选框\"><a href=\"#自定义单选框\" class=\"headerlink\" title=\"自定义单选框\"></a>自定义单选框</h4><p>自定义单选框并没有想象中的那么难，除了<code>&lt;input type=&quot;radio&quot;&gt;</code>外，还有个label标签和after伪类。<br>设置css<code>[type=radio]: display: none;</code>，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)</p>\n<h4 id=\"文字居中\"><a href=\"#文字居中\" class=\"headerlink\" title=\"文字居中\"></a>文字居中</h4><p>要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。</p>\n<h4 id=\"横屏问题\"><a href=\"#横屏问题\" class=\"headerlink\" title=\"横屏问题\"></a>横屏问题</h4><p>我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。</p>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>需要改进的东西就太多太多了。 </p>\n<ul>\n<li>最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。</li>\n<li>图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。</li>\n<li>动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。</li>\n</ul>\n","excerpt":"","more":"<p>任务：环球网-2016七夕H5页面<br>环境：swiper插件，gulp及相关常用工具。</p>\n<hr>\n<h3 id=\"适配\"><a href=\"#适配\" class=\"headerlink\" title=\"适配\"></a>适配</h3><p>使用的还是lib-flexible那套解决方案，需要查看的可以点击<a href=\"https://github.com/amfe/lib-flexible\">这里</a>  </p>\n<h3 id=\"使用swiper\"><a href=\"#使用swiper\" class=\"headerlink\" title=\"使用swiper\"></a>使用swiper</h3><p>使用swiper页面的控制以及滑动功能就变得非常容易，可以参见<a href=\"http://www.swiper.com.cn/\">Swiper中文网</a>，其中添加给类名添加<code>swiper-slide</code>即可表示一页。<br>在Swiper实例化中，属性<code>direction</code>可以定义横向/竖向滑动，<code>nextButton</code>可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在<code>onSlideChangeStart</code>中不能够出发<code>slideTo()</code>方法。<br>Swiper还有许多其他功能，可以参见<a href=\"http://www.swiper.com.cn/\">Swiper中文网</a>中API。</p>\n<h3 id=\"ES6的使用\"><a href=\"#ES6的使用\" class=\"headerlink\" title=\"ES6的使用\"></a>ES6的使用</h3><p>ES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是<code>gulp-babel</code>。</p>\n<h3 id=\"目录、git以及gulp相关\"><a href=\"#目录、git以及gulp相关\" class=\"headerlink\" title=\"目录、git以及gulp相关\"></a>目录、git以及gulp相关</h3><p>目录和之前的项目目录基本相同。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── <span class=\"selector-class\">.eslintrc</span><span class=\"selector-class\">.json</span></div><div class=\"line\">├── <span class=\"selector-class\">.gitignore</span></div><div class=\"line\">├── dist</div><div class=\"line\">│   ├── css</div><div class=\"line\">│   ├── imgs</div><div class=\"line\">│   ├── js</div><div class=\"line\">│   └── libs</div><div class=\"line\">├── gulpfile<span class=\"selector-class\">.js</span></div><div class=\"line\">├── index<span class=\"selector-class\">.html</span></div><div class=\"line\">├── node_modules</div><div class=\"line\">├── package<span class=\"selector-class\">.json</span></div><div class=\"line\">├── psd</div><div class=\"line\">└── src</div><div class=\"line\">    ├── ES6</div><div class=\"line\">    ├── css</div><div class=\"line\">    ├── imgs</div><div class=\"line\">    ├── js</div><div class=\"line\">    ├── libs</div><div class=\"line\">    └── sass</div></pre></td></tr></table></figure></p>\n<p>dist目录存放合并、压缩的代码，用于上线使用。(自动生成)<br>src目录存放源文件。<br>node_modules目录存放用到的node工具。(自动生成)<br>psd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。<br>相比之前增加的文件：</p>\n<ul>\n<li>.eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看<a href=\"https://segmentfault.com/a/1190000004468428\">这里</a>。</li>\n<li><p>.gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"regexp\">/node_modules/</span></div><div class=\"line\"><span class=\"regexp\">/psd/</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。</p>\n</li>\n</ul>\n<p>git开始学习使用分支处理bug、添加尝试性功能等。</p>\n<h3 id=\"坑是用来爬的\"><a href=\"#坑是用来爬的\" class=\"headerlink\" title=\"坑是用来爬的\"></a>坑是用来爬的</h3><h4 id=\"最经典的坑——this\"><a href=\"#最经典的坑——this\" class=\"headerlink\" title=\"最经典的坑——this\"></a>最经典的坑——this</h4><p>在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过<code>fn.bind(this)</code>来指向想要的this，在旧版本浏览器下需要使用兼容写法。</p>\n<h4 id=\"省事也被坑——autoprefixer\"><a href=\"#省事也被坑——autoprefixer\" class=\"headerlink\" title=\"省事也被坑——autoprefixer\"></a>省事也被坑——autoprefixer</h4><p>autoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是<code>remove</code>，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。<br>andriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。</p>\n<h4 id=\"没想到的坑——微信分享\"><a href=\"#没想到的坑——微信分享\" class=\"headerlink\" title=\"没想到的坑——微信分享\"></a>没想到的坑——微信分享</h4><p>关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。<br>问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中<code>mqq.data.setShareInfo</code>可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"自定义单选框\"><a href=\"#自定义单选框\" class=\"headerlink\" title=\"自定义单选框\"></a>自定义单选框</h4><p>自定义单选框并没有想象中的那么难，除了<code>&lt;input type=&quot;radio&quot;&gt;</code>外，还有个label标签和after伪类。<br>设置css<code>[type=radio]: display: none;</code>，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)</p>\n<h4 id=\"文字居中\"><a href=\"#文字居中\" class=\"headerlink\" title=\"文字居中\"></a>文字居中</h4><p>要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。</p>\n<h4 id=\"横屏问题\"><a href=\"#横屏问题\" class=\"headerlink\" title=\"横屏问题\"></a>横屏问题</h4><p>我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。</p>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>需要改进的东西就太多太多了。 </p>\n<ul>\n<li>最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。</li>\n<li>图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。</li>\n<li>动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。</li>\n</ul>\n"},{"title":"今天的面试","date":"2016-06-13T14:04:00.000Z","comments":1,"_content":"　　英语教育方面公司，笔试+面试，题目类型主要包括JS基础、git操作、Linux基础。\n　　首先就把题目虐了一遍，全英文题目，幸好只是简单的output之类勉强能够理解题目内容。\n　　API不熟悉：考察了reduce、for of,这两个函数完全没用过，对于for of我只知道for in。NaN不熟悉，<!--more-->typeof NaN当时蒙逼的我竟然回答个NaN，typeof结果只有string、number、boolean、object、function、undefined，白记了。最最最蒙逼的是，`console.log(function(){} && null)`这个竟然不是考察类型转换的，感觉就像是被前面的一大堆==和===带跑了，好吧，我承认还是自己的基础问题。之后的angular就不说了，我那入门水平真不够看的。\n　　git和linux的考察就不是我能够掌控得了的了，考察了git分支的合并，git中移除某个项目不再管理。linux考察了权限，vim的基本操作。git平时都是一个人写写，提交一下，linux更是自从大二考试结束后就没再接触，哎~只能是自己的叹息。\n　　总结下来，基础方面是有些差，JS那些基础问题应该都明白的，和自己有些浮躁有关。期间几个问题挺尴尬的，一个是问到了英语水平，一个是问我JS方面的书读过几本，细细想来，好像一本完整的都没有。git和linux的问题也许情有可原，JS就是一个大问题了。","source":"_posts/今天的面试.md","raw":"---\ntitle: 今天的面试\ndate: 2016-06-13 22:04\ntags: [面试,javascript]\ncategories: \n- 杂记\ncomments: true\n---\n　　英语教育方面公司，笔试+面试，题目类型主要包括JS基础、git操作、Linux基础。\n　　首先就把题目虐了一遍，全英文题目，幸好只是简单的output之类勉强能够理解题目内容。\n　　API不熟悉：考察了reduce、for of,这两个函数完全没用过，对于for of我只知道for in。NaN不熟悉，<!--more-->typeof NaN当时蒙逼的我竟然回答个NaN，typeof结果只有string、number、boolean、object、function、undefined，白记了。最最最蒙逼的是，`console.log(function(){} && null)`这个竟然不是考察类型转换的，感觉就像是被前面的一大堆==和===带跑了，好吧，我承认还是自己的基础问题。之后的angular就不说了，我那入门水平真不够看的。\n　　git和linux的考察就不是我能够掌控得了的了，考察了git分支的合并，git中移除某个项目不再管理。linux考察了权限，vim的基本操作。git平时都是一个人写写，提交一下，linux更是自从大二考试结束后就没再接触，哎~只能是自己的叹息。\n　　总结下来，基础方面是有些差，JS那些基础问题应该都明白的，和自己有些浮躁有关。期间几个问题挺尴尬的，一个是问到了英语水平，一个是问我JS方面的书读过几本，细细想来，好像一本完整的都没有。git和linux的问题也许情有可原，JS就是一个大问题了。","slug":"今天的面试","published":1,"updated":"2016-08-14T13:41:12.000Z","layout":"post","photos":[],"link":"","_id":"ciw3mfvtn000p0kc707nwblxm","content":"<p>　　英语教育方面公司，笔试+面试，题目类型主要包括JS基础、git操作、Linux基础。<br>　　首先就把题目虐了一遍，全英文题目，幸好只是简单的output之类勉强能够理解题目内容。<br>　　API不熟悉：考察了reduce、for of,这两个函数完全没用过，对于for of我只知道for in。NaN不熟悉，<a id=\"more\"></a>typeof NaN当时蒙逼的我竟然回答个NaN，typeof结果只有string、number、boolean、object、function、undefined，白记了。最最最蒙逼的是，<code>console.log(function(){} &amp;&amp; null)</code>这个竟然不是考察类型转换的，感觉就像是被前面的一大堆==和===带跑了，好吧，我承认还是自己的基础问题。之后的angular就不说了，我那入门水平真不够看的。<br>　　git和linux的考察就不是我能够掌控得了的了，考察了git分支的合并，git中移除某个项目不再管理。linux考察了权限，vim的基本操作。git平时都是一个人写写，提交一下，linux更是自从大二考试结束后就没再接触，哎~只能是自己的叹息。<br>　　总结下来，基础方面是有些差，JS那些基础问题应该都明白的，和自己有些浮躁有关。期间几个问题挺尴尬的，一个是问到了英语水平，一个是问我JS方面的书读过几本，细细想来，好像一本完整的都没有。git和linux的问题也许情有可原，JS就是一个大问题了。</p>\n","excerpt":"<p>　　英语教育方面公司，笔试+面试，题目类型主要包括JS基础、git操作、Linux基础。<br>　　首先就把题目虐了一遍，全英文题目，幸好只是简单的output之类勉强能够理解题目内容。<br>　　API不熟悉：考察了reduce、for of,这两个函数完全没用过，对于for of我只知道for in。NaN不熟悉，","more":"typeof NaN当时蒙逼的我竟然回答个NaN，typeof结果只有string、number、boolean、object、function、undefined，白记了。最最最蒙逼的是，<code>console.log(function(){} &amp;&amp; null)</code>这个竟然不是考察类型转换的，感觉就像是被前面的一大堆==和===带跑了，好吧，我承认还是自己的基础问题。之后的angular就不说了，我那入门水平真不够看的。<br>　　git和linux的考察就不是我能够掌控得了的了，考察了git分支的合并，git中移除某个项目不再管理。linux考察了权限，vim的基本操作。git平时都是一个人写写，提交一下，linux更是自从大二考试结束后就没再接触，哎~只能是自己的叹息。<br>　　总结下来，基础方面是有些差，JS那些基础问题应该都明白的，和自己有些浮躁有关。期间几个问题挺尴尬的，一个是问到了英语水平，一个是问我JS方面的书读过几本，细细想来，好像一本完整的都没有。git和linux的问题也许情有可原，JS就是一个大问题了。</p>"},{"title":"从零开始搭建React(1)","date":"2016-11-13T16:00:00.000Z","comments":1,"_content":"\n学习React几乎绕不开Webpack，就像使用Java需要搭建环境、规划目录结构、写各种配置文件一样，这里我们也要搭建这样的一个脚手架。当然，这里只是我的简单总结，并不是什么最佳实践，只是一步步去理解这个搭建过程。  \n目录结构开始只是简单的`myapp/src`，首先肯定是安装react、react-dom、webpack，webpack官网是安装在全局的。[参见官网](http://webpack.github.io/docs/tutorials/getting-started/#welcome)  \n这时候就可以开始写webpack配置文件，在编写之前，可以安装eslint来规范代码，这里的配置文件我是写在`myapp/src/config/webpack.config.js`，最基本的样子如下（可以在官网找到各配置项表示，这里使用的是node API形式）：\n```javascript\n// webpack.config.js\nvar path = require('path')\nvar webpack = require('webpack')\n\nvar src = path.resolve(__dirname, '../../src')  // 源码目录\nvar build = path.resolve(__dirname, '../../dist')   // 编译目录\n\nmodule.exports = {\n  entry: {\n    app: path.join(src, 'app.js')\n  },\n  output: {\n    filename: '[name].js',\n    path: build,\n    publicPath: '/static/'\n  },\n  resolve: {\n    extensions: ['', '.js']\n  },\n  module: {\n    loaders: [{\n      test: /\\.js$/,\n      include: src,\n      loader: 'babel'\n    }, {\n      test: /\\.scss$/,\n      loaders: ['style', 'css', 'sass']\n    }]\n  }\n}\n```\n\n接下来就是根据loaders安装各种webpack-loader，以后随着项目的需要，这里肯定还会添加更多的webpack-loader，安装方式就是`npm install --save-dev babel-loader style-loader css-loader sass-loader`。然后，创建`myapp/src/app.js`文件用于测试我们的环境。执行`webpack --config src/config/webpack.config.js`，会发现报错`can't find module 'babel-core'`，那么就按照提示，安装babel-core，一定要学会看提示/报错信息。  \n再次执行`webpack --config src/config/webpack.config.js`(以下简称执行webpack)应该会生成`myapp/dist/app.js`文件，里面应该是只有一段webpackBootstrap以及一段空函数function(module, exports)。  \n在`src/app.js`中编写代码用于环境测试：\n```javascript\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\nReactDOM.render(\n    <h1>Hello React</h1>,\n    document.getElementById('app')\n  )\n```\n再次执行`webpack --config src/config/webpack.config.js`，发现报错Unexpected token在<h1\\>位置，显然是babel不能识别jsx格式，我们并没有配置babel的转换规则。创建`myapp/.babelrc`，一般的基础配置是，具体规则[参见官网](http://babeljs.io/docs/plugins/)。\n```json\n{\n  \"presets\": [\"es2015\", \"react\", \"stage-0\"]\n}\n```\n安装这些preset，再次执行webpack，生成编译后的文件。创建html文件：\n```html\n<!-- 我这里的路径是myapp/src/index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title></title>\n</head>\n<body>\n  <div id=\"app\"></div>\n  <script type=\"text/javascript\" src=\"../dist/app.js\"></script>\n</body>\n</html>\n```\n用浏览器打开该文件，则能看到Hello React。  \n然后测试sass文件怎么样，创建`myapp/src/app.scss`\n```sass\nh1 {\n  background: red;\n}\n```\n在`myapp/src/app.js`中引入该scss文件`import './app.scss'`  \n执行webpack，可能会报错can't find module node-sass，再次安装此模块，执行webpack刷新页面，应该会看到Hello React背景色变成红色。\n\n至此，一个最简单的webpack打包React的环境完成。虽然这个环境可以使用，但是没有好好利用webpack，也就没有提高一点我们的工作效率。","source":"_posts/从零搭建React(1).md","raw":"---\ntitle: 从零开始搭建React(1)\ndate: 2016-11-14\ntags: javascript React Webpack\ncategories: \n- React\ncomments: true\n---\n\n学习React几乎绕不开Webpack，就像使用Java需要搭建环境、规划目录结构、写各种配置文件一样，这里我们也要搭建这样的一个脚手架。当然，这里只是我的简单总结，并不是什么最佳实践，只是一步步去理解这个搭建过程。  \n目录结构开始只是简单的`myapp/src`，首先肯定是安装react、react-dom、webpack，webpack官网是安装在全局的。[参见官网](http://webpack.github.io/docs/tutorials/getting-started/#welcome)  \n这时候就可以开始写webpack配置文件，在编写之前，可以安装eslint来规范代码，这里的配置文件我是写在`myapp/src/config/webpack.config.js`，最基本的样子如下（可以在官网找到各配置项表示，这里使用的是node API形式）：\n```javascript\n// webpack.config.js\nvar path = require('path')\nvar webpack = require('webpack')\n\nvar src = path.resolve(__dirname, '../../src')  // 源码目录\nvar build = path.resolve(__dirname, '../../dist')   // 编译目录\n\nmodule.exports = {\n  entry: {\n    app: path.join(src, 'app.js')\n  },\n  output: {\n    filename: '[name].js',\n    path: build,\n    publicPath: '/static/'\n  },\n  resolve: {\n    extensions: ['', '.js']\n  },\n  module: {\n    loaders: [{\n      test: /\\.js$/,\n      include: src,\n      loader: 'babel'\n    }, {\n      test: /\\.scss$/,\n      loaders: ['style', 'css', 'sass']\n    }]\n  }\n}\n```\n\n接下来就是根据loaders安装各种webpack-loader，以后随着项目的需要，这里肯定还会添加更多的webpack-loader，安装方式就是`npm install --save-dev babel-loader style-loader css-loader sass-loader`。然后，创建`myapp/src/app.js`文件用于测试我们的环境。执行`webpack --config src/config/webpack.config.js`，会发现报错`can't find module 'babel-core'`，那么就按照提示，安装babel-core，一定要学会看提示/报错信息。  \n再次执行`webpack --config src/config/webpack.config.js`(以下简称执行webpack)应该会生成`myapp/dist/app.js`文件，里面应该是只有一段webpackBootstrap以及一段空函数function(module, exports)。  \n在`src/app.js`中编写代码用于环境测试：\n```javascript\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\nReactDOM.render(\n    <h1>Hello React</h1>,\n    document.getElementById('app')\n  )\n```\n再次执行`webpack --config src/config/webpack.config.js`，发现报错Unexpected token在<h1\\>位置，显然是babel不能识别jsx格式，我们并没有配置babel的转换规则。创建`myapp/.babelrc`，一般的基础配置是，具体规则[参见官网](http://babeljs.io/docs/plugins/)。\n```json\n{\n  \"presets\": [\"es2015\", \"react\", \"stage-0\"]\n}\n```\n安装这些preset，再次执行webpack，生成编译后的文件。创建html文件：\n```html\n<!-- 我这里的路径是myapp/src/index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title></title>\n</head>\n<body>\n  <div id=\"app\"></div>\n  <script type=\"text/javascript\" src=\"../dist/app.js\"></script>\n</body>\n</html>\n```\n用浏览器打开该文件，则能看到Hello React。  \n然后测试sass文件怎么样，创建`myapp/src/app.scss`\n```sass\nh1 {\n  background: red;\n}\n```\n在`myapp/src/app.js`中引入该scss文件`import './app.scss'`  \n执行webpack，可能会报错can't find module node-sass，再次安装此模块，执行webpack刷新页面，应该会看到Hello React背景色变成红色。\n\n至此，一个最简单的webpack打包React的环境完成。虽然这个环境可以使用，但是没有好好利用webpack，也就没有提高一点我们的工作效率。","slug":"从零搭建React(1)","published":1,"updated":"2016-11-27T01:15:21.919Z","layout":"post","photos":[],"link":"","_id":"ciw3mfvtn000s0kc7iexrfqrm","content":"<p>学习React几乎绕不开Webpack，就像使用Java需要搭建环境、规划目录结构、写各种配置文件一样，这里我们也要搭建这样的一个脚手架。当然，这里只是我的简单总结，并不是什么最佳实践，只是一步步去理解这个搭建过程。<br>目录结构开始只是简单的<code>myapp/src</code>，首先肯定是安装react、react-dom、webpack，webpack官网是安装在全局的。<a href=\"http://webpack.github.io/docs/tutorials/getting-started/#welcome\" target=\"_blank\" rel=\"external\">参见官网</a><br>这时候就可以开始写webpack配置文件，在编写之前，可以安装eslint来规范代码，这里的配置文件我是写在<code>myapp/src/config/webpack.config.js</code>，最基本的样子如下（可以在官网找到各配置项表示，这里使用的是node API形式）：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// webpack.config.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> src = path.resolve(__dirname, <span class=\"string\">'../../src'</span>)  <span class=\"comment\">// 源码目录</span></div><div class=\"line\"><span class=\"keyword\">var</span> build = path.resolve(__dirname, <span class=\"string\">'../../dist'</span>)   <span class=\"comment\">// 编译目录</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"attr\">entry</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">app</span>: path.join(src, <span class=\"string\">'app.js'</span>)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">output</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">'[name].js'</span>,</div><div class=\"line\">    <span class=\"attr\">path</span>: build,</div><div class=\"line\">    <span class=\"attr\">publicPath</span>: <span class=\"string\">'/static/'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">resolve</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">extensions</span>: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>]</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">module</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">loaders</span>: [&#123;</div><div class=\"line\">      <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>,</div><div class=\"line\">      <span class=\"attr\">include</span>: src,</div><div class=\"line\">      <span class=\"attr\">loader</span>: <span class=\"string\">'babel'</span></div><div class=\"line\">    &#125;, &#123;</div><div class=\"line\">      <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.scss$/</span>,</div><div class=\"line\">      <span class=\"attr\">loaders</span>: [<span class=\"string\">'style'</span>, <span class=\"string\">'css'</span>, <span class=\"string\">'sass'</span>]</div><div class=\"line\">    &#125;]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接下来就是根据loaders安装各种webpack-loader，以后随着项目的需要，这里肯定还会添加更多的webpack-loader，安装方式就是<code>npm install --save-dev babel-loader style-loader css-loader sass-loader</code>。然后，创建<code>myapp/src/app.js</code>文件用于测试我们的环境。执行<code>webpack --config src/config/webpack.config.js</code>，会发现报错<code>can&#39;t find module &#39;babel-core&#39;</code>，那么就按照提示，安装babel-core，一定要学会看提示/报错信息。<br>再次执行<code>webpack --config src/config/webpack.config.js</code>(以下简称执行webpack)应该会生成<code>myapp/dist/app.js</code>文件，里面应该是只有一段webpackBootstrap以及一段空函数function(module, exports)。<br>在<code>src/app.js</code>中编写代码用于环境测试：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></div><div class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello React<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>,</div><div class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>)</div><div class=\"line\">  )</div></pre></td></tr></table></figure></p>\n<p>再次执行<code>webpack --config src/config/webpack.config.js</code>，发现报错Unexpected token在<h1\\>位置，显然是babel不能识别jsx格式，我们并没有配置babel的转换规则。创建<code>myapp/.babelrc</code>，一般的基础配置是，具体规则<a href=\"http://babeljs.io/docs/plugins/\" target=\"_blank\" rel=\"external\">参见官网</a>。<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"presets\"</span>: [<span class=\"string\">\"es2015\"</span>, <span class=\"string\">\"react\"</span>, <span class=\"string\">\"stage-0\"</span>]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></h1\\></p>\n<p>安装这些preset，再次执行webpack，生成编译后的文件。创建html文件：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 我这里的路径是myapp/src/index.html --&gt;</span></div><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../dist/app.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>用浏览器打开该文件，则能看到Hello React。<br>然后测试sass文件怎么样，创建<code>myapp/src/app.scss</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">h1 &#123;</div><div class=\"line\">  background: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在<code>myapp/src/app.js</code>中引入该scss文件<code>import &#39;./app.scss&#39;</code><br>执行webpack，可能会报错can’t find module node-sass，再次安装此模块，执行webpack刷新页面，应该会看到Hello React背景色变成红色。</p>\n<p>至此，一个最简单的webpack打包React的环境完成。虽然这个环境可以使用，但是没有好好利用webpack，也就没有提高一点我们的工作效率。</p>\n","excerpt":"","more":"<p>学习React几乎绕不开Webpack，就像使用Java需要搭建环境、规划目录结构、写各种配置文件一样，这里我们也要搭建这样的一个脚手架。当然，这里只是我的简单总结，并不是什么最佳实践，只是一步步去理解这个搭建过程。<br>目录结构开始只是简单的<code>myapp/src</code>，首先肯定是安装react、react-dom、webpack，webpack官网是安装在全局的。<a href=\"http://webpack.github.io/docs/tutorials/getting-started/#welcome\">参见官网</a><br>这时候就可以开始写webpack配置文件，在编写之前，可以安装eslint来规范代码，这里的配置文件我是写在<code>myapp/src/config/webpack.config.js</code>，最基本的样子如下（可以在官网找到各配置项表示，这里使用的是node API形式）：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// webpack.config.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> src = path.resolve(__dirname, <span class=\"string\">'../../src'</span>)  <span class=\"comment\">// 源码目录</span></div><div class=\"line\"><span class=\"keyword\">var</span> build = path.resolve(__dirname, <span class=\"string\">'../../dist'</span>)   <span class=\"comment\">// 编译目录</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"attr\">entry</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">app</span>: path.join(src, <span class=\"string\">'app.js'</span>)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">output</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">'[name].js'</span>,</div><div class=\"line\">    <span class=\"attr\">path</span>: build,</div><div class=\"line\">    <span class=\"attr\">publicPath</span>: <span class=\"string\">'/static/'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">resolve</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">extensions</span>: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>]</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">module</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">loaders</span>: [&#123;</div><div class=\"line\">      <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>,</div><div class=\"line\">      <span class=\"attr\">include</span>: src,</div><div class=\"line\">      <span class=\"attr\">loader</span>: <span class=\"string\">'babel'</span></div><div class=\"line\">    &#125;, &#123;</div><div class=\"line\">      <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.scss$/</span>,</div><div class=\"line\">      <span class=\"attr\">loaders</span>: [<span class=\"string\">'style'</span>, <span class=\"string\">'css'</span>, <span class=\"string\">'sass'</span>]</div><div class=\"line\">    &#125;]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接下来就是根据loaders安装各种webpack-loader，以后随着项目的需要，这里肯定还会添加更多的webpack-loader，安装方式就是<code>npm install --save-dev babel-loader style-loader css-loader sass-loader</code>。然后，创建<code>myapp/src/app.js</code>文件用于测试我们的环境。执行<code>webpack --config src/config/webpack.config.js</code>，会发现报错<code>can&#39;t find module &#39;babel-core&#39;</code>，那么就按照提示，安装babel-core，一定要学会看提示/报错信息。<br>再次执行<code>webpack --config src/config/webpack.config.js</code>(以下简称执行webpack)应该会生成<code>myapp/dist/app.js</code>文件，里面应该是只有一段webpackBootstrap以及一段空函数function(module, exports)。<br>在<code>src/app.js</code>中编写代码用于环境测试：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></div><div class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello React<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>,</div><div class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>)</div><div class=\"line\">  )</div></pre></td></tr></table></figure></p>\n<p>再次执行<code>webpack --config src/config/webpack.config.js</code>，发现报错Unexpected token在<h1\\>位置，显然是babel不能识别jsx格式，我们并没有配置babel的转换规则。创建<code>myapp/.babelrc</code>，一般的基础配置是，具体规则<a href=\"http://babeljs.io/docs/plugins/\">参见官网</a>。<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"presets\"</span>: [<span class=\"string\">\"es2015\"</span>, <span class=\"string\">\"react\"</span>, <span class=\"string\">\"stage-0\"</span>]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>安装这些preset，再次执行webpack，生成编译后的文件。创建html文件：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 我这里的路径是myapp/src/index.html --&gt;</span></div><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../dist/app.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>用浏览器打开该文件，则能看到Hello React。<br>然后测试sass文件怎么样，创建<code>myapp/src/app.scss</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">h1 &#123;</div><div class=\"line\">  background: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在<code>myapp/src/app.js</code>中引入该scss文件<code>import &#39;./app.scss&#39;</code><br>执行webpack，可能会报错can’t find module node-sass，再次安装此模块，执行webpack刷新页面，应该会看到Hello React背景色变成红色。</p>\n<p>至此，一个最简单的webpack打包React的环境完成。虽然这个环境可以使用，但是没有好好利用webpack，也就没有提高一点我们的工作效率。</p>\n"},{"title":"为gulp添加更多","date":"2016-07-22T16:00:00.000Z","comments":1,"_content":"\n有了之前的gulp经验，使用其他gulp工具就是很简单的工作了。\n\n> ps:\t以下代码前均包含`var gulp = require('gulp')`\n\n> 类似`sass()`表示前面包含`var sass = require('gulp-sass')`\n\n--------------\n\n[gulp-autoprefixer](https://www.npmjs.com/package/gulp-autoprefixer)：应该属于css后处理工具，在编写css完成之后，会根据我们的配置自动按需添加浏览器前缀。\n\n任务事例：\n```javascript\ngulp.task('sass', function() {\n\treturn gulp.src('src/sass/*.scss')\n\t\t\t\t\t.pipe(sass())\n\t\t\t\t\t.pipe(autoprefixer('last 2 versions', 'ios 6', 'android 4'))\t//autoprefixer\n\t\t\t\t\t.pipe(gulp.dest('src/css'))\n\t\t\t\t\t.pipe(cleanCSS())\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//css压缩工具，前面介绍有\n\t\t\t\t\t.pipe(gulp.dest('dist/css'))\n});\n```\n其中`autoprefixer('...','...','...')`为简写形式，其中`last 2 versions`表示兼容所有浏览器最新两个版本。\n完整形式应该为`autoprefixer({ \n\tbrowsers: ['last 2 versions', 'ios 6'],\n\tcascade: true\n})`\n\n***\n\n[gulp-imagemin](https://www.npmjs.com/package/gulp-imagemin):图片压缩工具。\n\n任务事例：\n```javascript\ngulp.task('imageMin', function() {\n\tgulp.src('src/img/*')\n\t\t.pipe(imagemin())\n\t\t.pipe(gulp.dest('dist/img'));\n});\n```\n对于imagemin()进行图片压缩，可以结合使用`gulp-cache`对图片进行缓存。具体用法，我也没研究太懂 :joy:\n\n***\n\n[browser-sync](https://www.npmjs.com/package/browser-sync):属于综合测试的工具，可以实现页面自动刷新、多屏同步操作等功能。\n\n任务实例：\n```javascript\n//首先browser-sync的引用，官方推荐使用create()方法\nvar browserSync = require('browser-sync').create();\n\ngulp.task('serve', ['sass'], function() {\n\tbrowserSync.init({\n\t\tserver: './'\n\t});\n\n\tgulp.watch('src/sass/*.scss', ['sass']);\n\tgulp.watch('*.html').on('change', browserSync.reload);\n});\n```\n其中`server: './'`会将当前目录作为服务器访问地址<br/>\n`gulp.watch('src/sass/*.scss', ['sass'])`会监听*.scss文件，执行`sass`任务，并且实时反应到浏览器上。\n`gulp.watch('*.html').on('change', browserSync.reload)`不同之处在于，会执行reload方法，重新加载页面。\n\n--------\n\n对于工具，我觉得更多的是直接拿过来使用，而不是非要去研究清楚每个API的作用。当然，特别感兴趣的也可以尝试研究工具，甚至是自己动手去制造这些工具。","source":"_posts/为gulp添加更多.md","raw":"---\ntitle: 为gulp添加更多\ndate: 2016-07-23\ntags: javascript 构建工具 gulp\ncategories: \n- javascript\ncomments: true\n---\n\n有了之前的gulp经验，使用其他gulp工具就是很简单的工作了。\n\n> ps:\t以下代码前均包含`var gulp = require('gulp')`\n\n> 类似`sass()`表示前面包含`var sass = require('gulp-sass')`\n\n--------------\n\n[gulp-autoprefixer](https://www.npmjs.com/package/gulp-autoprefixer)：应该属于css后处理工具，在编写css完成之后，会根据我们的配置自动按需添加浏览器前缀。\n\n任务事例：\n```javascript\ngulp.task('sass', function() {\n\treturn gulp.src('src/sass/*.scss')\n\t\t\t\t\t.pipe(sass())\n\t\t\t\t\t.pipe(autoprefixer('last 2 versions', 'ios 6', 'android 4'))\t//autoprefixer\n\t\t\t\t\t.pipe(gulp.dest('src/css'))\n\t\t\t\t\t.pipe(cleanCSS())\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//css压缩工具，前面介绍有\n\t\t\t\t\t.pipe(gulp.dest('dist/css'))\n});\n```\n其中`autoprefixer('...','...','...')`为简写形式，其中`last 2 versions`表示兼容所有浏览器最新两个版本。\n完整形式应该为`autoprefixer({ \n\tbrowsers: ['last 2 versions', 'ios 6'],\n\tcascade: true\n})`\n\n***\n\n[gulp-imagemin](https://www.npmjs.com/package/gulp-imagemin):图片压缩工具。\n\n任务事例：\n```javascript\ngulp.task('imageMin', function() {\n\tgulp.src('src/img/*')\n\t\t.pipe(imagemin())\n\t\t.pipe(gulp.dest('dist/img'));\n});\n```\n对于imagemin()进行图片压缩，可以结合使用`gulp-cache`对图片进行缓存。具体用法，我也没研究太懂 :joy:\n\n***\n\n[browser-sync](https://www.npmjs.com/package/browser-sync):属于综合测试的工具，可以实现页面自动刷新、多屏同步操作等功能。\n\n任务实例：\n```javascript\n//首先browser-sync的引用，官方推荐使用create()方法\nvar browserSync = require('browser-sync').create();\n\ngulp.task('serve', ['sass'], function() {\n\tbrowserSync.init({\n\t\tserver: './'\n\t});\n\n\tgulp.watch('src/sass/*.scss', ['sass']);\n\tgulp.watch('*.html').on('change', browserSync.reload);\n});\n```\n其中`server: './'`会将当前目录作为服务器访问地址<br/>\n`gulp.watch('src/sass/*.scss', ['sass'])`会监听*.scss文件，执行`sass`任务，并且实时反应到浏览器上。\n`gulp.watch('*.html').on('change', browserSync.reload)`不同之处在于，会执行reload方法，重新加载页面。\n\n--------\n\n对于工具，我觉得更多的是直接拿过来使用，而不是非要去研究清楚每个API的作用。当然，特别感兴趣的也可以尝试研究工具，甚至是自己动手去制造这些工具。","slug":"为gulp添加更多","published":1,"updated":"2016-11-27T01:15:21.906Z","layout":"post","photos":[],"link":"","_id":"ciw3mfvtn000w0kc7pqtazkjm","content":"<p>有了之前的gulp经验，使用其他gulp工具就是很简单的工作了。</p>\n<blockquote>\n<p>ps:    以下代码前均包含<code>var gulp = require(&#39;gulp&#39;)</code></p>\n<p>类似<code>sass()</code>表示前面包含<code>var sass = require(&#39;gulp-sass&#39;)</code></p>\n</blockquote>\n<hr>\n<p><a href=\"https://www.npmjs.com/package/gulp-autoprefixer\" target=\"_blank\" rel=\"external\">gulp-autoprefixer</a>：应该属于css后处理工具，在编写css完成之后，会根据我们的配置自动按需添加浏览器前缀。</p>\n<p>任务事例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(<span class=\"string\">'sass'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'src/sass/*.scss'</span>)</div><div class=\"line\">\t\t\t\t\t.pipe(sass())</div><div class=\"line\">\t\t\t\t\t.pipe(autoprefixer(<span class=\"string\">'last 2 versions'</span>, <span class=\"string\">'ios 6'</span>, <span class=\"string\">'android 4'</span>))\t<span class=\"comment\">//autoprefixer</span></div><div class=\"line\">\t\t\t\t\t.pipe(gulp.dest(<span class=\"string\">'src/css'</span>))</div><div class=\"line\">\t\t\t\t\t.pipe(cleanCSS())\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//css压缩工具，前面介绍有</span></div><div class=\"line\">\t\t\t\t\t.pipe(gulp.dest(<span class=\"string\">'dist/css'</span>))</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>其中<code>autoprefixer(&#39;...&#39;,&#39;...&#39;,&#39;...&#39;)</code>为简写形式，其中<code>last 2 versions</code>表示兼容所有浏览器最新两个版本。<br>完整形式应该为<code>autoprefixer({ \n    browsers: [&#39;last 2 versions&#39;, &#39;ios 6&#39;],\n    cascade: true\n})</code></p>\n<hr>\n<p><a href=\"https://www.npmjs.com/package/gulp-imagemin\" target=\"_blank\" rel=\"external\">gulp-imagemin</a>:图片压缩工具。</p>\n<p>任务事例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(<span class=\"string\">'imageMin'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tgulp.src(<span class=\"string\">'src/img/*'</span>)</div><div class=\"line\">\t\t.pipe(imagemin())</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/img'</span>));</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>对于imagemin()进行图片压缩，可以结合使用<code>gulp-cache</code>对图片进行缓存。具体用法，我也没研究太懂 :joy:</p>\n<hr>\n<p><a href=\"https://www.npmjs.com/package/browser-sync\" target=\"_blank\" rel=\"external\">browser-sync</a>:属于综合测试的工具，可以实现页面自动刷新、多屏同步操作等功能。</p>\n<p>任务实例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//首先browser-sync的引用，官方推荐使用create()方法</span></div><div class=\"line\"><span class=\"keyword\">var</span> browserSync = <span class=\"built_in\">require</span>(<span class=\"string\">'browser-sync'</span>).create();</div><div class=\"line\"></div><div class=\"line\">gulp.task(<span class=\"string\">'serve'</span>, [<span class=\"string\">'sass'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tbrowserSync.init(&#123;</div><div class=\"line\">\t\t<span class=\"attr\">server</span>: <span class=\"string\">'./'</span></div><div class=\"line\">\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\tgulp.watch(<span class=\"string\">'src/sass/*.scss'</span>, [<span class=\"string\">'sass'</span>]);</div><div class=\"line\">\tgulp.watch(<span class=\"string\">'*.html'</span>).on(<span class=\"string\">'change'</span>, browserSync.reload);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>其中<code>server: &#39;./&#39;</code>会将当前目录作为服务器访问地址<br><br><code>gulp.watch(&#39;src/sass/*.scss&#39;, [&#39;sass&#39;])</code>会监听<em>.scss文件，执行<code>sass</code>任务，并且实时反应到浏览器上。<br>`gulp.watch(‘</em>.html’).on(‘change’, browserSync.reload)`不同之处在于，会执行reload方法，重新加载页面。</p>\n<hr>\n<p>对于工具，我觉得更多的是直接拿过来使用，而不是非要去研究清楚每个API的作用。当然，特别感兴趣的也可以尝试研究工具，甚至是自己动手去制造这些工具。</p>\n","excerpt":"","more":"<p>有了之前的gulp经验，使用其他gulp工具就是很简单的工作了。</p>\n<blockquote>\n<p>ps:    以下代码前均包含<code>var gulp = require(&#39;gulp&#39;)</code></p>\n<p>类似<code>sass()</code>表示前面包含<code>var sass = require(&#39;gulp-sass&#39;)</code></p>\n</blockquote>\n<hr>\n<p><a href=\"https://www.npmjs.com/package/gulp-autoprefixer\">gulp-autoprefixer</a>：应该属于css后处理工具，在编写css完成之后，会根据我们的配置自动按需添加浏览器前缀。</p>\n<p>任务事例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(<span class=\"string\">'sass'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'src/sass/*.scss'</span>)</div><div class=\"line\">\t\t\t\t\t.pipe(sass())</div><div class=\"line\">\t\t\t\t\t.pipe(autoprefixer(<span class=\"string\">'last 2 versions'</span>, <span class=\"string\">'ios 6'</span>, <span class=\"string\">'android 4'</span>))\t<span class=\"comment\">//autoprefixer</span></div><div class=\"line\">\t\t\t\t\t.pipe(gulp.dest(<span class=\"string\">'src/css'</span>))</div><div class=\"line\">\t\t\t\t\t.pipe(cleanCSS())\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//css压缩工具，前面介绍有</span></div><div class=\"line\">\t\t\t\t\t.pipe(gulp.dest(<span class=\"string\">'dist/css'</span>))</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>其中<code>autoprefixer(&#39;...&#39;,&#39;...&#39;,&#39;...&#39;)</code>为简写形式，其中<code>last 2 versions</code>表示兼容所有浏览器最新两个版本。<br>完整形式应该为<code>autoprefixer({ \n    browsers: [&#39;last 2 versions&#39;, &#39;ios 6&#39;],\n    cascade: true\n})</code></p>\n<hr>\n<p><a href=\"https://www.npmjs.com/package/gulp-imagemin\">gulp-imagemin</a>:图片压缩工具。</p>\n<p>任务事例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(<span class=\"string\">'imageMin'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tgulp.src(<span class=\"string\">'src/img/*'</span>)</div><div class=\"line\">\t\t.pipe(imagemin())</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/img'</span>));</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>对于imagemin()进行图片压缩，可以结合使用<code>gulp-cache</code>对图片进行缓存。具体用法，我也没研究太懂 :joy:</p>\n<hr>\n<p><a href=\"https://www.npmjs.com/package/browser-sync\">browser-sync</a>:属于综合测试的工具，可以实现页面自动刷新、多屏同步操作等功能。</p>\n<p>任务实例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//首先browser-sync的引用，官方推荐使用create()方法</span></div><div class=\"line\"><span class=\"keyword\">var</span> browserSync = <span class=\"built_in\">require</span>(<span class=\"string\">'browser-sync'</span>).create();</div><div class=\"line\"></div><div class=\"line\">gulp.task(<span class=\"string\">'serve'</span>, [<span class=\"string\">'sass'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tbrowserSync.init(&#123;</div><div class=\"line\">\t\t<span class=\"attr\">server</span>: <span class=\"string\">'./'</span></div><div class=\"line\">\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\tgulp.watch(<span class=\"string\">'src/sass/*.scss'</span>, [<span class=\"string\">'sass'</span>]);</div><div class=\"line\">\tgulp.watch(<span class=\"string\">'*.html'</span>).on(<span class=\"string\">'change'</span>, browserSync.reload);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>其中<code>server: &#39;./&#39;</code>会将当前目录作为服务器访问地址<br/><br><code>gulp.watch(&#39;src/sass/*.scss&#39;, [&#39;sass&#39;])</code>会监听<em>.scss文件，执行<code>sass</code>任务，并且实时反应到浏览器上。<br>`gulp.watch(‘</em>.html’).on(‘change’, browserSync.reload)`不同之处在于，会执行reload方法，重新加载页面。</p>\n<hr>\n<p>对于工具，我觉得更多的是直接拿过来使用，而不是非要去研究清楚每个API的作用。当然，特别感兴趣的也可以尝试研究工具，甚至是自己动手去制造这些工具。</p>\n"},{"title":"利用Github+Hexo搭建博客过程","date":"2016-06-09T14:11:35.000Z","comments":1,"_content":"\n　　有阵子没有静下心来做点什么了，希望通过博客，可以让自己多静下心来做些东西，学习下技术，记录一下过程。\n　　因为最近一直在学习和使用Github，希望通过Github来建立自己的博客，并且还能刷下自己Github上提交的贡献-.-\n　　总得过程还是比较容易的，因为自己有使用Github，电脑上也安装配置有nodejs，也看过markdown的一些语法，所以搭建起来，实现基本功能并没有花费多少时间。\n　　第一步，安装nodejs和Git。\n　　第二步，安装Hexo,和其他的包一样，通过`npm install-g hexo`来安装。<!--more-->\n　　第三步，创建一个用于存放Hexo的文件夹，在该文件夹目录下执行hexo init。\n　　第四步，执行`hexo g`(等同于`hexo generate`)生成静态页面，执行`hexo s`(等同于`hexo server`)启动本地服务进行预览，这样浏览器里可以输入`http://localhost:4000`进行访问。我第一次访问的时候，因为4000端口被占用，页面打不开，关闭占用端口后，正常。\n　　第五步，配置博客。在Hexo目录配置文件_config.yml中可以配置诸如标题、副标题、作者、语言、主题、部署等等配置。\n　　第六步，配置主题。搜索Hexo主题会有很多，并且都有使用说明。一般流程就是通过git clone复制到自己的目录下，在Hexo目录下的_config.yml文件中配置`theme`属性，之后就是主题配置文件(位于themes/*/_config.yml)进行个性化配置。\n  \n　　之后，就是把博客放到Github上去了。\n　　首先是在个人GIthub上建立新的仓库，仓库名为`username.github.io`，比如我的Github帐号是[PFanz](http://github.com/PFanz),仓库名就是`PFanz.github.io`。\n　　在Hexo配置文件_config.yml中配置`deploy`中各项，比如：\n```\ndeploy:\n  type: git\n  repo: https://github.com/PFanz/PFanz.github.io.git\n  branch: master\n```\n　　然后执行命令`npm install hexo-deployer-git --save`，便可以通过`username.github.io`访问到该博客。\n　　写博客可以通过命令`hexo new\"titleName\"`，在Hexo目录下`source/_posts`新建文件titleName.md，也可以自己手动建立。手动建立的话，需要自己加入头\n```\n---\ntitle: titleName\ndate: 2016-06-09 22:11:35\ntags: 标签\ncategories: \n- 分类名称\n---\n  ```\n  \n　　每次部署按一下三步\n```\nhexo clean\nhexo g\nhexo d\n```\n  \n  \n\n---\n　　虽然说基本功能已经搭建，感觉还有不少地方值得去探索，以实现更个性化，更漂亮的博客。","source":"_posts/利用Github+Hexo搭建博客过程.md","raw":"---\ntitle: 利用Github+Hexo搭建博客过程\ndate: 2016-06-09 22:11:35\ntags: [Hexo,搭建博客]\ncategories: \n- 杂记\ncomments: true\n---\n\n　　有阵子没有静下心来做点什么了，希望通过博客，可以让自己多静下心来做些东西，学习下技术，记录一下过程。\n　　因为最近一直在学习和使用Github，希望通过Github来建立自己的博客，并且还能刷下自己Github上提交的贡献-.-\n　　总得过程还是比较容易的，因为自己有使用Github，电脑上也安装配置有nodejs，也看过markdown的一些语法，所以搭建起来，实现基本功能并没有花费多少时间。\n　　第一步，安装nodejs和Git。\n　　第二步，安装Hexo,和其他的包一样，通过`npm install-g hexo`来安装。<!--more-->\n　　第三步，创建一个用于存放Hexo的文件夹，在该文件夹目录下执行hexo init。\n　　第四步，执行`hexo g`(等同于`hexo generate`)生成静态页面，执行`hexo s`(等同于`hexo server`)启动本地服务进行预览，这样浏览器里可以输入`http://localhost:4000`进行访问。我第一次访问的时候，因为4000端口被占用，页面打不开，关闭占用端口后，正常。\n　　第五步，配置博客。在Hexo目录配置文件_config.yml中可以配置诸如标题、副标题、作者、语言、主题、部署等等配置。\n　　第六步，配置主题。搜索Hexo主题会有很多，并且都有使用说明。一般流程就是通过git clone复制到自己的目录下，在Hexo目录下的_config.yml文件中配置`theme`属性，之后就是主题配置文件(位于themes/*/_config.yml)进行个性化配置。\n  \n　　之后，就是把博客放到Github上去了。\n　　首先是在个人GIthub上建立新的仓库，仓库名为`username.github.io`，比如我的Github帐号是[PFanz](http://github.com/PFanz),仓库名就是`PFanz.github.io`。\n　　在Hexo配置文件_config.yml中配置`deploy`中各项，比如：\n```\ndeploy:\n  type: git\n  repo: https://github.com/PFanz/PFanz.github.io.git\n  branch: master\n```\n　　然后执行命令`npm install hexo-deployer-git --save`，便可以通过`username.github.io`访问到该博客。\n　　写博客可以通过命令`hexo new\"titleName\"`，在Hexo目录下`source/_posts`新建文件titleName.md，也可以自己手动建立。手动建立的话，需要自己加入头\n```\n---\ntitle: titleName\ndate: 2016-06-09 22:11:35\ntags: 标签\ncategories: \n- 分类名称\n---\n  ```\n  \n　　每次部署按一下三步\n```\nhexo clean\nhexo g\nhexo d\n```\n  \n  \n\n---\n　　虽然说基本功能已经搭建，感觉还有不少地方值得去探索，以实现更个性化，更漂亮的博客。","slug":"利用Github+Hexo搭建博客过程","published":1,"updated":"2016-08-14T13:41:26.000Z","layout":"post","photos":[],"link":"","_id":"ciw3mfvtn000y0kc7w3mzyhnh","content":"<p>　　有阵子没有静下心来做点什么了，希望通过博客，可以让自己多静下心来做些东西，学习下技术，记录一下过程。<br>　　因为最近一直在学习和使用Github，希望通过Github来建立自己的博客，并且还能刷下自己Github上提交的贡献-.-<br>　　总得过程还是比较容易的，因为自己有使用Github，电脑上也安装配置有nodejs，也看过markdown的一些语法，所以搭建起来，实现基本功能并没有花费多少时间。<br>　　第一步，安装nodejs和Git。<br>　　第二步，安装Hexo,和其他的包一样，通过<code>npm install-g hexo</code>来安装。<a id=\"more\"></a><br>　　第三步，创建一个用于存放Hexo的文件夹，在该文件夹目录下执行hexo init。<br>　　第四步，执行<code>hexo g</code>(等同于<code>hexo generate</code>)生成静态页面，执行<code>hexo s</code>(等同于<code>hexo server</code>)启动本地服务进行预览，这样浏览器里可以输入<code>http://localhost:4000</code>进行访问。我第一次访问的时候，因为4000端口被占用，页面打不开，关闭占用端口后，正常。<br>　　第五步，配置博客。在Hexo目录配置文件_config.yml中可以配置诸如标题、副标题、作者、语言、主题、部署等等配置。<br>　　第六步，配置主题。搜索Hexo主题会有很多，并且都有使用说明。一般流程就是通过git clone复制到自己的目录下，在Hexo目录下的_config.yml文件中配置<code>theme</code>属性，之后就是主题配置文件(位于themes/*/_config.yml)进行个性化配置。</p>\n<p>　　之后，就是把博客放到Github上去了。<br>　　首先是在个人GIthub上建立新的仓库，仓库名为<code>username.github.io</code>，比如我的Github帐号是<a href=\"http://github.com/PFanz\" target=\"_blank\" rel=\"external\">PFanz</a>,仓库名就是<code>PFanz.github.io</code>。<br>　　在Hexo配置文件_config.yml中配置<code>deploy</code>中各项，比如：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">deploy</span>:</div><div class=\"line\">  <span class=\"attribute\">type</span>: git</div><div class=\"line\">  <span class=\"attribute\">repo</span>: <span class=\"attribute\">https</span>:<span class=\"comment\">//github.com/PFanz/PFanz.github.io.git</span></div><div class=\"line\">  <span class=\"attribute\">branch</span>: master</div></pre></td></tr></table></figure></p>\n<p>　　然后执行命令<code>npm install hexo-deployer-git --save</code>，便可以通过<code>username.github.io</code>访问到该博客。<br>　　写博客可以通过命令<code>hexo new&quot;titleName&quot;</code>，在Hexo目录下<code>source/_posts</code>新建文件titleName.md，也可以自己手动建立。手动建立的话，需要自己加入头<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">---</span></div><div class=\"line\"><span class=\"attr\">title:</span> titleName</div><div class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2016</span><span class=\"bullet\">-06</span><span class=\"bullet\">-09</span> <span class=\"number\">22</span>:<span class=\"number\">11</span>:<span class=\"number\">35</span></div><div class=\"line\"><span class=\"attr\">tags:</span> 标签</div><div class=\"line\"><span class=\"attr\">categories:</span> </div><div class=\"line\"><span class=\"bullet\">-</span> 分类名称</div><div class=\"line\"><span class=\"meta\">---</span></div></pre></td></tr></table></figure></p>\n<p>　　每次部署按一下三步<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">hexo clean</span></div><div class=\"line\">hexo g</div><div class=\"line\">hexo d</div></pre></td></tr></table></figure></p>\n<hr>\n<p>　　虽然说基本功能已经搭建，感觉还有不少地方值得去探索，以实现更个性化，更漂亮的博客。</p>\n","excerpt":"<p>　　有阵子没有静下心来做点什么了，希望通过博客，可以让自己多静下心来做些东西，学习下技术，记录一下过程。<br>　　因为最近一直在学习和使用Github，希望通过Github来建立自己的博客，并且还能刷下自己Github上提交的贡献-.-<br>　　总得过程还是比较容易的，因为自己有使用Github，电脑上也安装配置有nodejs，也看过markdown的一些语法，所以搭建起来，实现基本功能并没有花费多少时间。<br>　　第一步，安装nodejs和Git。<br>　　第二步，安装Hexo,和其他的包一样，通过<code>npm install-g hexo</code>来安装。","more":"<br>　　第三步，创建一个用于存放Hexo的文件夹，在该文件夹目录下执行hexo init。<br>　　第四步，执行<code>hexo g</code>(等同于<code>hexo generate</code>)生成静态页面，执行<code>hexo s</code>(等同于<code>hexo server</code>)启动本地服务进行预览，这样浏览器里可以输入<code>http://localhost:4000</code>进行访问。我第一次访问的时候，因为4000端口被占用，页面打不开，关闭占用端口后，正常。<br>　　第五步，配置博客。在Hexo目录配置文件_config.yml中可以配置诸如标题、副标题、作者、语言、主题、部署等等配置。<br>　　第六步，配置主题。搜索Hexo主题会有很多，并且都有使用说明。一般流程就是通过git clone复制到自己的目录下，在Hexo目录下的_config.yml文件中配置<code>theme</code>属性，之后就是主题配置文件(位于themes/*/_config.yml)进行个性化配置。</p>\n<p>　　之后，就是把博客放到Github上去了。<br>　　首先是在个人GIthub上建立新的仓库，仓库名为<code>username.github.io</code>，比如我的Github帐号是<a href=\"http://github.com/PFanz\">PFanz</a>,仓库名就是<code>PFanz.github.io</code>。<br>　　在Hexo配置文件_config.yml中配置<code>deploy</code>中各项，比如：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">deploy</span>:</div><div class=\"line\">  <span class=\"attribute\">type</span>: git</div><div class=\"line\">  <span class=\"attribute\">repo</span>: <span class=\"attribute\">https</span>:<span class=\"comment\">//github.com/PFanz/PFanz.github.io.git</span></div><div class=\"line\">  <span class=\"attribute\">branch</span>: master</div></pre></td></tr></table></figure></p>\n<p>　　然后执行命令<code>npm install hexo-deployer-git --save</code>，便可以通过<code>username.github.io</code>访问到该博客。<br>　　写博客可以通过命令<code>hexo new&quot;titleName&quot;</code>，在Hexo目录下<code>source/_posts</code>新建文件titleName.md，也可以自己手动建立。手动建立的话，需要自己加入头<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">---</span></div><div class=\"line\"><span class=\"attr\">title:</span> titleName</div><div class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2016</span><span class=\"bullet\">-06</span><span class=\"bullet\">-09</span> <span class=\"number\">22</span>:<span class=\"number\">11</span>:<span class=\"number\">35</span></div><div class=\"line\"><span class=\"attr\">tags:</span> 标签</div><div class=\"line\"><span class=\"attr\">categories:</span> </div><div class=\"line\"><span class=\"bullet\">-</span> 分类名称</div><div class=\"line\"><span class=\"meta\">---</span></div></pre></td></tr></table></figure></p>\n<p>　　每次部署按一下三步<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">hexo clean</div><div class=\"line\">hexo g</div><div class=\"line\">hexo d</span></div></pre></td></tr></table></figure></p>\n<hr>\n<p>　　虽然说基本功能已经搭建，感觉还有不少地方值得去探索，以实现更个性化，更漂亮的博客。</p>"},{"title":"函数节流","date":"2016-07-27T16:00:00.000Z","comments":1,"_content":"\n[From](http://imweb.io/topic/577aa790ea7bb9b760c7adc3)\n\n函数节流：常用于onresize,scroll,mousemove,mousehover等连续触发的事件(隔断时间触发一次)。\n\n方法：\n\n\teg.\n```javascript \n\t\twindow.onscroll = function() {\n\t\t\tconsole.log('scoll滑动');\n\t\t\tthrottle(count);\n\t\t};\n\n\t\tfunction count() {\n\t\t\tconsole.log('函数调用');\n\t\t}\n\n\t\tfunction throttle(method, context) {\n\t\t\t// 如果连续触发就会方法会被清除，所以只会执行最后一次\n\t\t\tclearTimeout(method.tId);\n\t\t\tmethod.tId = setTimeout(function() {\n\t\t\t\tmethod.call(context);\n\t\t\t}, 300);\n\t\t}\n\n\t// eg.\n\t\tvar time = +new Date(); // 隐式转换，相当于new Date().getTime()\n\t\tfunction count() {\n\t\t\tconsole.log('函数调用：' + (+new Date() - time));\n\t\t}\n\n\n\t\t// 到达mustRun毫秒一定执行\n\t\tvar throttle = function(fn, delay, mustRun) {\n\t\t\tvar timer = null,\n\t\t\t\t\tprevious = null;\n\n\t\t\treturn function() {\n\t\t\t\tvar now = +new Date(),\n\t\t\t\t\t\tcontext = this,\n\t\t\t\t\t\targs = arguments;\n\t\t\t\t// 闭包，只有在第一次执行时，previous==null，会被赋值为now\n\t\t\t\tif(!previous) previous = now;\n\t\t\t\tvar remaining = now - previous;\n\t\t\t\tif(mustRun && remaining >= mustRun){\n\t\t\t\t\tfn.apply(context, args);\n\t\t\t\t\tprevious = now;\n\t\t\t\t} else {\n\t\t\t\t\tcleaerTimeout(timer);\n\t\t\t\t\ttimer = setTimeout(function() {\n\t\t\t\t\t\tfn.apply(context, args);\n\t\t\t\t\t}, delay);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\twindow.onscroll = throttle(count, 500, 1000);\n```","source":"_posts/函数节流.md","raw":"---\ntitle: 函数节流\ndate: 2016-07-28\ntags: javascript\ncategories: \n- javascript\ncomments: true\n---\n\n[From](http://imweb.io/topic/577aa790ea7bb9b760c7adc3)\n\n函数节流：常用于onresize,scroll,mousemove,mousehover等连续触发的事件(隔断时间触发一次)。\n\n方法：\n\n\teg.\n```javascript \n\t\twindow.onscroll = function() {\n\t\t\tconsole.log('scoll滑动');\n\t\t\tthrottle(count);\n\t\t};\n\n\t\tfunction count() {\n\t\t\tconsole.log('函数调用');\n\t\t}\n\n\t\tfunction throttle(method, context) {\n\t\t\t// 如果连续触发就会方法会被清除，所以只会执行最后一次\n\t\t\tclearTimeout(method.tId);\n\t\t\tmethod.tId = setTimeout(function() {\n\t\t\t\tmethod.call(context);\n\t\t\t}, 300);\n\t\t}\n\n\t// eg.\n\t\tvar time = +new Date(); // 隐式转换，相当于new Date().getTime()\n\t\tfunction count() {\n\t\t\tconsole.log('函数调用：' + (+new Date() - time));\n\t\t}\n\n\n\t\t// 到达mustRun毫秒一定执行\n\t\tvar throttle = function(fn, delay, mustRun) {\n\t\t\tvar timer = null,\n\t\t\t\t\tprevious = null;\n\n\t\t\treturn function() {\n\t\t\t\tvar now = +new Date(),\n\t\t\t\t\t\tcontext = this,\n\t\t\t\t\t\targs = arguments;\n\t\t\t\t// 闭包，只有在第一次执行时，previous==null，会被赋值为now\n\t\t\t\tif(!previous) previous = now;\n\t\t\t\tvar remaining = now - previous;\n\t\t\t\tif(mustRun && remaining >= mustRun){\n\t\t\t\t\tfn.apply(context, args);\n\t\t\t\t\tprevious = now;\n\t\t\t\t} else {\n\t\t\t\t\tcleaerTimeout(timer);\n\t\t\t\t\ttimer = setTimeout(function() {\n\t\t\t\t\t\tfn.apply(context, args);\n\t\t\t\t\t}, delay);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\twindow.onscroll = throttle(count, 500, 1000);\n```","slug":"函数节流","published":1,"updated":"2016-11-27T01:15:21.939Z","layout":"post","photos":[],"link":"","_id":"ciw3mfvu200120kc7l7hjzywz","content":"<p><a href=\"http://imweb.io/topic/577aa790ea7bb9b760c7adc3\" target=\"_blank\" rel=\"external\">From</a></p>\n<p>函数节流：常用于onresize,scroll,mousemove,mousehover等连续触发的事件(隔断时间触发一次)。</p>\n<p>方法：</p>\n<pre><code>eg.\n</code></pre><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t<span class=\"built_in\">window</span>.onscroll = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'scoll滑动'</span>);</div><div class=\"line\">\t\tthrottle(count);</div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'函数调用'</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">method, context</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 如果连续触发就会方法会被清除，所以只会执行最后一次</span></div><div class=\"line\">\t\tclearTimeout(method.tId);</div><div class=\"line\">\t\tmethod.tId = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\tmethod.call(context);</div><div class=\"line\">\t\t&#125;, <span class=\"number\">300</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// eg.</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> time = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); <span class=\"comment\">// 隐式转换，相当于new Date().getTime()</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'函数调用：'</span> + (+<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - time));</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 到达mustRun毫秒一定执行</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn, delay, mustRun</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>,</div><div class=\"line\">\t\t\t\tprevious = <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</div><div class=\"line\">\t\t\t\t\tcontext = <span class=\"keyword\">this</span>,</div><div class=\"line\">\t\t\t\t\targs = <span class=\"built_in\">arguments</span>;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 闭包，只有在第一次执行时，previous==null，会被赋值为now</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!previous) previous = now;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> remaining = now - previous;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(mustRun &amp;&amp; remaining &gt;= mustRun)&#123;</div><div class=\"line\">\t\t\t\tfn.apply(context, args);</div><div class=\"line\">\t\t\t\tprevious = now;</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\tcleaerTimeout(timer);</div><div class=\"line\">\t\t\t\ttimer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\tfn.apply(context, args);</div><div class=\"line\">\t\t\t\t&#125;, delay);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"built_in\">window</span>.onscroll = throttle(count, <span class=\"number\">500</span>, <span class=\"number\">1000</span>);</div></pre></td></tr></table></figure>","excerpt":"","more":"<p><a href=\"http://imweb.io/topic/577aa790ea7bb9b760c7adc3\">From</a></p>\n<p>函数节流：常用于onresize,scroll,mousemove,mousehover等连续触发的事件(隔断时间触发一次)。</p>\n<p>方法：</p>\n<pre><code>eg.\n</code></pre><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t<span class=\"built_in\">window</span>.onscroll = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'scoll滑动'</span>);</div><div class=\"line\">\t\tthrottle(count);</div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'函数调用'</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">method, context</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 如果连续触发就会方法会被清除，所以只会执行最后一次</span></div><div class=\"line\">\t\tclearTimeout(method.tId);</div><div class=\"line\">\t\tmethod.tId = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\tmethod.call(context);</div><div class=\"line\">\t\t&#125;, <span class=\"number\">300</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// eg.</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> time = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); <span class=\"comment\">// 隐式转换，相当于new Date().getTime()</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'函数调用：'</span> + (+<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - time));</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 到达mustRun毫秒一定执行</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn, delay, mustRun</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>,</div><div class=\"line\">\t\t\t\tprevious = <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</div><div class=\"line\">\t\t\t\t\tcontext = <span class=\"keyword\">this</span>,</div><div class=\"line\">\t\t\t\t\targs = <span class=\"built_in\">arguments</span>;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 闭包，只有在第一次执行时，previous==null，会被赋值为now</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!previous) previous = now;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> remaining = now - previous;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(mustRun &amp;&amp; remaining &gt;= mustRun)&#123;</div><div class=\"line\">\t\t\t\tfn.apply(context, args);</div><div class=\"line\">\t\t\t\tprevious = now;</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\tcleaerTimeout(timer);</div><div class=\"line\">\t\t\t\ttimer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\tfn.apply(context, args);</div><div class=\"line\">\t\t\t\t&#125;, delay);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"built_in\">window</span>.onscroll = throttle(count, <span class=\"number\">500</span>, <span class=\"number\">1000</span>);</div></pre></td></tr></table></figure>"},{"title":"从零开始搭建React(2)","date":"2016-11-13T16:00:00.000Z","comments":1,"_content":"\n提高开发效率，我们发现前面用的最多的就是`webpack --config ***`，然后去刷新页面。解决此问题，可以使用[react-hot-loader](https://github.com/gaearon/react-hot-loader)，这应该也是我们使用github的原因，在这里我们可以找到解决各种问题的办法。  \n查看其中使用方法（看不懂英文就用翻译一句一句看呗，其实我也是这么看过来的），会发现这一句These steps are covered by [the walkthrough](http://gaearon.github.io/react-hot-loader/getstarted/)（这里应该是1版本的写法）。  \n根据这里的步骤，先是安装react-hot-loader，然后是server.js，提供有事例：\n```javascript\n// 我的路径 myapp/src/config/server.js\nvar path = require('path')\nvar webpack = require('webpack')\nvar express = require('express')\nvar config = require('./webpack.config')\n\nvar app = express()\nvar compiler = webpack(config)\n\napp.use(require('webpack-dev-middleware')(compiler, {\n  publicPath: config.output.publicPath\n}))\n\napp.use(require('webpack-hot-middleware')(compiler))\n\napp.get('*', function (req, res) {\n  res.sendFile(path.join(__dirname, '../index.html'))\n})\n\napp.listen(3000, function (err) {\n  if (err) {\n    return console.error(err)\n  }\n\n  console.log('Listening at http://localhost:3000/')\n})\n```\n需要安装express，另外需要修改`res.sendFile(path.join(__dirname, '../index.html'))`这里的路径，还有端口。  \n接着修改webpack的配置文件，在入口配置项前面添加，\n```javascript\nentry: {\n  app: [\n  'webpack-dev-server/client?http://0.0.0.0:3000', // WebpackDevServer host and port\n  'webpack/hot/only-dev-server', // \"only\" prevents reload on syntax errors\n  path.join(src, 'app.js')\n  ]\n}\n```\n这个应该是1版本的写法，而我这里安装的是3版本，导致页面会多次刷新。下面是3版本，具体参看[事例](https://github.com/gaearon/react-hot-boilerplate/tree/next)\n```javascript\nentry: {\n    app: [\n      'react-hot-loader/patch',\n      'webpack-hot-middleware/client',\n      path.join(src, 'app.js')\n    ]\n  },\n```\n接着是在oader中添加react-hot，按照官网是将react-hot添加在babel前面即可\n```javascript\nloaders: [{\n  test: /\\.js$/,\n  include: src,\n  loaders: ['react-hot', 'babel']\n}]\n```\n但是在我这里报错了，报错提示还算明显，大致就是将react-hot-loader/babel添加到babel的plugins中，于是修改`myapp/.babelrc`解决。同样是1和3的区别\n```json\n{\n  \"presets\": [\"es2015\", \"react\", \"stage-0\"],\n  \"plugins\": [\"react-hot-loader/babel\"]\n}\n```\n最后一步，是webpack中添加plugins\n```javascript\nplugins: [\n  new webpack.HotModuleReplacementPlugin()\n]\n```\n1版本到这里就结束了，3版本是这样的\n```javascript\n// myapp/src/app.js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport { AppContainer } from 'react-hot-loader'\nimport Hello from './Hello'\nimport './app.scss'\n\nReactDOM.render(\n    <AppContainer>\n      <Hello />\n    </AppContainer>,\n    document.getElementById('app')\n  )\n\nif (module.hot) {\n  module.hot.accept('./Hello', () => {\n    // If you use Webpack 2 in ES modules mode, you can\n    // use <App /> here rather than require() a <NextApp />.\n    const NextApp = require('./Hello').default\n    ReactDOM.render(\n      <AppContainer>\n         <NextApp />\n      </AppContainer>,\n      document.getElementById('app')\n    )\n  })\n}\n```\n```javascript\n// myapp/src/Hello.js\nimport React from 'react'\nexport default function Layout () {\n  return (\n    <div>\n      <h1>Hello, world!!</h1>\n    </div>\n  )\n}\n```\n这里有个小坑，改变app.js文件中的内容并不会刷新，需要手动刷新页面。\n\n启动就是`node src/config/server.js`，可以将其写入到package.json文件中`\"script\": {\"start\": \"node src/config/server.js\"}`\n\n最后遇到一个小坑，在HTML文件引用入口文件中，地址应该是webpack配置中的`output.publicPath/[name].js`，如`<script src=\"/static/app.js\"></script>`。引用不到，或者路径错误会将html文件作为js文件引入，报错。  \n至此，在之后的编写中就不需要一遍又一遍的`webpack --config ****`\n\n------------------\n11.18补充\n\n分离打包：  \n在入口文件中添加要分离的模块：(这里将react和react-dom打包到vendor中)\n```javascript\nentry: {\n    app: [\n      'react-hot-loader/patch',\n      'webpack-hot-middleware/client',\n      path.join(src, 'index.js')\n    ],\n+    // 打包分离\n+    vendor: [\n+      'react',\n+      'react-dom'\n+    ]\n  },\n```\n增加CommonsChunkPlugin插件：\n```javascript\n  plugins: [\n+    // 分离打包\n+    new webpack.optimize.CommonsChunkPlugin({\n+      names: ['vendor']\n+    }),\n    // 热加载\n    new webpack.HotModuleReplacementPlugin()\n  ]\n```\n分离打包后，两个app.js和vendor.js都需要引入。","source":"_posts/从零搭建React(2).md","raw":"---\ntitle: 从零开始搭建React(2)\ndate: 2016-11-14\ntags: javascript React Webpack\ncategories: \n- React\ncomments: true\n---\n\n提高开发效率，我们发现前面用的最多的就是`webpack --config ***`，然后去刷新页面。解决此问题，可以使用[react-hot-loader](https://github.com/gaearon/react-hot-loader)，这应该也是我们使用github的原因，在这里我们可以找到解决各种问题的办法。  \n查看其中使用方法（看不懂英文就用翻译一句一句看呗，其实我也是这么看过来的），会发现这一句These steps are covered by [the walkthrough](http://gaearon.github.io/react-hot-loader/getstarted/)（这里应该是1版本的写法）。  \n根据这里的步骤，先是安装react-hot-loader，然后是server.js，提供有事例：\n```javascript\n// 我的路径 myapp/src/config/server.js\nvar path = require('path')\nvar webpack = require('webpack')\nvar express = require('express')\nvar config = require('./webpack.config')\n\nvar app = express()\nvar compiler = webpack(config)\n\napp.use(require('webpack-dev-middleware')(compiler, {\n  publicPath: config.output.publicPath\n}))\n\napp.use(require('webpack-hot-middleware')(compiler))\n\napp.get('*', function (req, res) {\n  res.sendFile(path.join(__dirname, '../index.html'))\n})\n\napp.listen(3000, function (err) {\n  if (err) {\n    return console.error(err)\n  }\n\n  console.log('Listening at http://localhost:3000/')\n})\n```\n需要安装express，另外需要修改`res.sendFile(path.join(__dirname, '../index.html'))`这里的路径，还有端口。  \n接着修改webpack的配置文件，在入口配置项前面添加，\n```javascript\nentry: {\n  app: [\n  'webpack-dev-server/client?http://0.0.0.0:3000', // WebpackDevServer host and port\n  'webpack/hot/only-dev-server', // \"only\" prevents reload on syntax errors\n  path.join(src, 'app.js')\n  ]\n}\n```\n这个应该是1版本的写法，而我这里安装的是3版本，导致页面会多次刷新。下面是3版本，具体参看[事例](https://github.com/gaearon/react-hot-boilerplate/tree/next)\n```javascript\nentry: {\n    app: [\n      'react-hot-loader/patch',\n      'webpack-hot-middleware/client',\n      path.join(src, 'app.js')\n    ]\n  },\n```\n接着是在oader中添加react-hot，按照官网是将react-hot添加在babel前面即可\n```javascript\nloaders: [{\n  test: /\\.js$/,\n  include: src,\n  loaders: ['react-hot', 'babel']\n}]\n```\n但是在我这里报错了，报错提示还算明显，大致就是将react-hot-loader/babel添加到babel的plugins中，于是修改`myapp/.babelrc`解决。同样是1和3的区别\n```json\n{\n  \"presets\": [\"es2015\", \"react\", \"stage-0\"],\n  \"plugins\": [\"react-hot-loader/babel\"]\n}\n```\n最后一步，是webpack中添加plugins\n```javascript\nplugins: [\n  new webpack.HotModuleReplacementPlugin()\n]\n```\n1版本到这里就结束了，3版本是这样的\n```javascript\n// myapp/src/app.js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport { AppContainer } from 'react-hot-loader'\nimport Hello from './Hello'\nimport './app.scss'\n\nReactDOM.render(\n    <AppContainer>\n      <Hello />\n    </AppContainer>,\n    document.getElementById('app')\n  )\n\nif (module.hot) {\n  module.hot.accept('./Hello', () => {\n    // If you use Webpack 2 in ES modules mode, you can\n    // use <App /> here rather than require() a <NextApp />.\n    const NextApp = require('./Hello').default\n    ReactDOM.render(\n      <AppContainer>\n         <NextApp />\n      </AppContainer>,\n      document.getElementById('app')\n    )\n  })\n}\n```\n```javascript\n// myapp/src/Hello.js\nimport React from 'react'\nexport default function Layout () {\n  return (\n    <div>\n      <h1>Hello, world!!</h1>\n    </div>\n  )\n}\n```\n这里有个小坑，改变app.js文件中的内容并不会刷新，需要手动刷新页面。\n\n启动就是`node src/config/server.js`，可以将其写入到package.json文件中`\"script\": {\"start\": \"node src/config/server.js\"}`\n\n最后遇到一个小坑，在HTML文件引用入口文件中，地址应该是webpack配置中的`output.publicPath/[name].js`，如`<script src=\"/static/app.js\"></script>`。引用不到，或者路径错误会将html文件作为js文件引入，报错。  \n至此，在之后的编写中就不需要一遍又一遍的`webpack --config ****`\n\n------------------\n11.18补充\n\n分离打包：  \n在入口文件中添加要分离的模块：(这里将react和react-dom打包到vendor中)\n```javascript\nentry: {\n    app: [\n      'react-hot-loader/patch',\n      'webpack-hot-middleware/client',\n      path.join(src, 'index.js')\n    ],\n+    // 打包分离\n+    vendor: [\n+      'react',\n+      'react-dom'\n+    ]\n  },\n```\n增加CommonsChunkPlugin插件：\n```javascript\n  plugins: [\n+    // 分离打包\n+    new webpack.optimize.CommonsChunkPlugin({\n+      names: ['vendor']\n+    }),\n    // 热加载\n    new webpack.HotModuleReplacementPlugin()\n  ]\n```\n分离打包后，两个app.js和vendor.js都需要引入。","slug":"从零搭建React(2)","published":1,"updated":"2016-11-27T01:15:21.926Z","layout":"post","photos":[],"link":"","_id":"ciw3mfvu200150kc7cby8p9um","content":"<p>提高开发效率，我们发现前面用的最多的就是<code>webpack --config ***</code>，然后去刷新页面。解决此问题，可以使用<a href=\"https://github.com/gaearon/react-hot-loader\" target=\"_blank\" rel=\"external\">react-hot-loader</a>，这应该也是我们使用github的原因，在这里我们可以找到解决各种问题的办法。<br>查看其中使用方法（看不懂英文就用翻译一句一句看呗，其实我也是这么看过来的），会发现这一句These steps are covered by <a href=\"http://gaearon.github.io/react-hot-loader/getstarted/\" target=\"_blank\" rel=\"external\">the walkthrough</a>（这里应该是1版本的写法）。<br>根据这里的步骤，先是安装react-hot-loader，然后是server.js，提供有事例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 我的路径 myapp/src/config/server.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.config'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> app = express()</div><div class=\"line\"><span class=\"keyword\">var</span> compiler = webpack(config)</div><div class=\"line\"></div><div class=\"line\">app.use(<span class=\"built_in\">require</span>(<span class=\"string\">'webpack-dev-middleware'</span>)(compiler, &#123;</div><div class=\"line\">  <span class=\"attr\">publicPath</span>: config.output.publicPath</div><div class=\"line\">&#125;))</div><div class=\"line\"></div><div class=\"line\">app.use(<span class=\"built_in\">require</span>(<span class=\"string\">'webpack-hot-middleware'</span>)(compiler))</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'*'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">  res.sendFile(path.join(__dirname, <span class=\"string\">'../index.html'</span>))</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.error(err)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Listening at http://localhost:3000/'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>需要安装express，另外需要修改<code>res.sendFile(path.join(__dirname, &#39;../index.html&#39;))</code>这里的路径，还有端口。<br>接着修改webpack的配置文件，在入口配置项前面添加，<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">entry: &#123;</div><div class=\"line\">  <span class=\"attr\">app</span>: [</div><div class=\"line\">  <span class=\"string\">'webpack-dev-server/client?http://0.0.0.0:3000'</span>, <span class=\"comment\">// WebpackDevServer host and port</span></div><div class=\"line\">  <span class=\"string\">'webpack/hot/only-dev-server'</span>, <span class=\"comment\">// \"only\" prevents reload on syntax errors</span></div><div class=\"line\">  path.join(src, <span class=\"string\">'app.js'</span>)</div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个应该是1版本的写法，而我这里安装的是3版本，导致页面会多次刷新。下面是3版本，具体参看<a href=\"https://github.com/gaearon/react-hot-boilerplate/tree/next\" target=\"_blank\" rel=\"external\">事例</a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">entry: &#123;</div><div class=\"line\">    <span class=\"attr\">app</span>: [</div><div class=\"line\">      <span class=\"string\">'react-hot-loader/patch'</span>,</div><div class=\"line\">      <span class=\"string\">'webpack-hot-middleware/client'</span>,</div><div class=\"line\">      path.join(src, <span class=\"string\">'app.js'</span>)</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>接着是在oader中添加react-hot，按照官网是将react-hot添加在babel前面即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">loaders: [&#123;</div><div class=\"line\">  <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>,</div><div class=\"line\">  <span class=\"attr\">include</span>: src,</div><div class=\"line\">  <span class=\"attr\">loaders</span>: [<span class=\"string\">'react-hot'</span>, <span class=\"string\">'babel'</span>]</div><div class=\"line\">&#125;]</div></pre></td></tr></table></figure></p>\n<p>但是在我这里报错了，报错提示还算明显，大致就是将react-hot-loader/babel添加到babel的plugins中，于是修改<code>myapp/.babelrc</code>解决。同样是1和3的区别<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"presets\"</span>: [<span class=\"string\">\"es2015\"</span>, <span class=\"string\">\"react\"</span>, <span class=\"string\">\"stage-0\"</span>],</div><div class=\"line\">  <span class=\"attr\">\"plugins\"</span>: [<span class=\"string\">\"react-hot-loader/babel\"</span>]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后一步，是webpack中添加plugins<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">plugins: [</div><div class=\"line\">  <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>1版本到这里就结束了，3版本是这样的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// myapp/src/app.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></div><div class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; AppContainer &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-hot-loader'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'./Hello'</span></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./app.scss'</span></div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">AppContainer</span>&gt;</span></span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">Hello</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">AppContainer</span>&gt;</span>,</div><div class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>)</div><div class=\"line\">  )</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.hot) &#123;</div><div class=\"line\">  <span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">'./Hello'</span>, () =&gt; &#123;</div><div class=\"line\">    <span class=\"comment\">// If you use Webpack 2 in ES modules mode, you can</span></div><div class=\"line\">    <span class=\"comment\">// use &lt;App /&gt; here rather than require() a &lt;NextApp /&gt;.</span></div><div class=\"line\">    <span class=\"keyword\">const</span> NextApp = <span class=\"built_in\">require</span>(<span class=\"string\">'./Hello'</span>).default</div><div class=\"line\">    ReactDOM.render(</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">AppContainer</span>&gt;</span></span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">NextApp</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">AppContainer</span>&gt;</span>,</div><div class=\"line\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>)</div><div class=\"line\">    )</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// myapp/src/Hello.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Layout</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  )</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里有个小坑，改变app.js文件中的内容并不会刷新，需要手动刷新页面。</p>\n<p>启动就是<code>node src/config/server.js</code>，可以将其写入到package.json文件中<code>&quot;script&quot;: {&quot;start&quot;: &quot;node src/config/server.js&quot;}</code></p>\n<p>最后遇到一个小坑，在HTML文件引用入口文件中，地址应该是webpack配置中的<code>output.publicPath/[name].js</code>，如<code>&lt;script src=&quot;/static/app.js&quot;&gt;&lt;/script&gt;</code>。引用不到，或者路径错误会将html文件作为js文件引入，报错。<br>至此，在之后的编写中就不需要一遍又一遍的<code>webpack --config ****</code></p>\n<hr>\n<p>11.18补充</p>\n<p>分离打包：<br>在入口文件中添加要分离的模块：(这里将react和react-dom打包到vendor中)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">entry: &#123;</div><div class=\"line\">    <span class=\"attr\">app</span>: [</div><div class=\"line\">      <span class=\"string\">'react-hot-loader/patch'</span>,</div><div class=\"line\">      <span class=\"string\">'webpack-hot-middleware/client'</span>,</div><div class=\"line\">      path.join(src, <span class=\"string\">'index.js'</span>)</div><div class=\"line\">    ],</div><div class=\"line\">+    <span class=\"comment\">// 打包分离</span></div><div class=\"line\">+    vendor: [</div><div class=\"line\">+      <span class=\"string\">'react'</span>,</div><div class=\"line\">+      <span class=\"string\">'react-dom'</span></div><div class=\"line\">+    ]</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>增加CommonsChunkPlugin插件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">  plugins: [</div><div class=\"line\">+    <span class=\"comment\">// 分离打包</span></div><div class=\"line\">+    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class=\"line\">+      names: [<span class=\"string\">'vendor'</span>]</div><div class=\"line\">+    &#125;),</div><div class=\"line\">    <span class=\"comment\">// 热加载</span></div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</div><div class=\"line\">  ]</div></pre></td></tr></table></figure></p>\n<p>分离打包后，两个app.js和vendor.js都需要引入。</p>\n","excerpt":"","more":"<p>提高开发效率，我们发现前面用的最多的就是<code>webpack --config ***</code>，然后去刷新页面。解决此问题，可以使用<a href=\"https://github.com/gaearon/react-hot-loader\">react-hot-loader</a>，这应该也是我们使用github的原因，在这里我们可以找到解决各种问题的办法。<br>查看其中使用方法（看不懂英文就用翻译一句一句看呗，其实我也是这么看过来的），会发现这一句These steps are covered by <a href=\"http://gaearon.github.io/react-hot-loader/getstarted/\">the walkthrough</a>（这里应该是1版本的写法）。<br>根据这里的步骤，先是安装react-hot-loader，然后是server.js，提供有事例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 我的路径 myapp/src/config/server.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.config'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> app = express()</div><div class=\"line\"><span class=\"keyword\">var</span> compiler = webpack(config)</div><div class=\"line\"></div><div class=\"line\">app.use(<span class=\"built_in\">require</span>(<span class=\"string\">'webpack-dev-middleware'</span>)(compiler, &#123;</div><div class=\"line\">  <span class=\"attr\">publicPath</span>: config.output.publicPath</div><div class=\"line\">&#125;))</div><div class=\"line\"></div><div class=\"line\">app.use(<span class=\"built_in\">require</span>(<span class=\"string\">'webpack-hot-middleware'</span>)(compiler))</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'*'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">  res.sendFile(path.join(__dirname, <span class=\"string\">'../index.html'</span>))</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.error(err)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Listening at http://localhost:3000/'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>需要安装express，另外需要修改<code>res.sendFile(path.join(__dirname, &#39;../index.html&#39;))</code>这里的路径，还有端口。<br>接着修改webpack的配置文件，在入口配置项前面添加，<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">entry: &#123;</div><div class=\"line\">  <span class=\"attr\">app</span>: [</div><div class=\"line\">  <span class=\"string\">'webpack-dev-server/client?http://0.0.0.0:3000'</span>, <span class=\"comment\">// WebpackDevServer host and port</span></div><div class=\"line\">  <span class=\"string\">'webpack/hot/only-dev-server'</span>, <span class=\"comment\">// \"only\" prevents reload on syntax errors</span></div><div class=\"line\">  path.join(src, <span class=\"string\">'app.js'</span>)</div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个应该是1版本的写法，而我这里安装的是3版本，导致页面会多次刷新。下面是3版本，具体参看<a href=\"https://github.com/gaearon/react-hot-boilerplate/tree/next\">事例</a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">entry: &#123;</div><div class=\"line\">    <span class=\"attr\">app</span>: [</div><div class=\"line\">      <span class=\"string\">'react-hot-loader/patch'</span>,</div><div class=\"line\">      <span class=\"string\">'webpack-hot-middleware/client'</span>,</div><div class=\"line\">      path.join(src, <span class=\"string\">'app.js'</span>)</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>接着是在oader中添加react-hot，按照官网是将react-hot添加在babel前面即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">loaders: [&#123;</div><div class=\"line\">  <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>,</div><div class=\"line\">  <span class=\"attr\">include</span>: src,</div><div class=\"line\">  <span class=\"attr\">loaders</span>: [<span class=\"string\">'react-hot'</span>, <span class=\"string\">'babel'</span>]</div><div class=\"line\">&#125;]</div></pre></td></tr></table></figure></p>\n<p>但是在我这里报错了，报错提示还算明显，大致就是将react-hot-loader/babel添加到babel的plugins中，于是修改<code>myapp/.babelrc</code>解决。同样是1和3的区别<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"presets\"</span>: [<span class=\"string\">\"es2015\"</span>, <span class=\"string\">\"react\"</span>, <span class=\"string\">\"stage-0\"</span>],</div><div class=\"line\">  <span class=\"attr\">\"plugins\"</span>: [<span class=\"string\">\"react-hot-loader/babel\"</span>]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后一步，是webpack中添加plugins<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">plugins: [</div><div class=\"line\">  <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>1版本到这里就结束了，3版本是这样的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// myapp/src/app.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></div><div class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; AppContainer &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-hot-loader'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'./Hello'</span></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./app.scss'</span></div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">AppContainer</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">Hello</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">AppContainer</span>&gt;</span></span>,</div><div class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>)</div><div class=\"line\">  )</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.hot) &#123;</div><div class=\"line\">  <span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">'./Hello'</span>, () =&gt; &#123;</div><div class=\"line\">    <span class=\"comment\">// If you use Webpack 2 in ES modules mode, you can</span></div><div class=\"line\">    <span class=\"comment\">// use &lt;App /&gt; here rather than require() a &lt;NextApp /&gt;.</span></div><div class=\"line\">    <span class=\"keyword\">const</span> NextApp = <span class=\"built_in\">require</span>(<span class=\"string\">'./Hello'</span>).default</div><div class=\"line\">    ReactDOM.render(</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">AppContainer</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">NextApp</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">AppContainer</span>&gt;</span></span>,</div><div class=\"line\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>)</div><div class=\"line\">    )</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// myapp/src/Hello.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Layout</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">  )</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里有个小坑，改变app.js文件中的内容并不会刷新，需要手动刷新页面。</p>\n<p>启动就是<code>node src/config/server.js</code>，可以将其写入到package.json文件中<code>&quot;script&quot;: {&quot;start&quot;: &quot;node src/config/server.js&quot;}</code></p>\n<p>最后遇到一个小坑，在HTML文件引用入口文件中，地址应该是webpack配置中的<code>output.publicPath/[name].js</code>，如<code>&lt;script src=&quot;/static/app.js&quot;&gt;&lt;/script&gt;</code>。引用不到，或者路径错误会将html文件作为js文件引入，报错。<br>至此，在之后的编写中就不需要一遍又一遍的<code>webpack --config ****</code></p>\n<hr>\n<p>11.18补充</p>\n<p>分离打包：<br>在入口文件中添加要分离的模块：(这里将react和react-dom打包到vendor中)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">entry: &#123;</div><div class=\"line\">    <span class=\"attr\">app</span>: [</div><div class=\"line\">      <span class=\"string\">'react-hot-loader/patch'</span>,</div><div class=\"line\">      <span class=\"string\">'webpack-hot-middleware/client'</span>,</div><div class=\"line\">      path.join(src, <span class=\"string\">'index.js'</span>)</div><div class=\"line\">    ],</div><div class=\"line\">+    <span class=\"comment\">// 打包分离</span></div><div class=\"line\">+    vendor: [</div><div class=\"line\">+      <span class=\"string\">'react'</span>,</div><div class=\"line\">+      <span class=\"string\">'react-dom'</span></div><div class=\"line\">+    ]</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>增加CommonsChunkPlugin插件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">  plugins: [</div><div class=\"line\">+    <span class=\"comment\">// 分离打包</span></div><div class=\"line\">+    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class=\"line\">+      names: [<span class=\"string\">'vendor'</span>]</div><div class=\"line\">+    &#125;),</div><div class=\"line\">    <span class=\"comment\">// 热加载</span></div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</div><div class=\"line\">  ]</div></pre></td></tr></table></figure></p>\n<p>分离打包后，两个app.js和vendor.js都需要引入。</p>\n"},{"title":"从零开始搭建React(3)","date":"2016-11-15T16:00:00.000Z","comments":1,"_content":"\n相信学习React的都是有过一定了解的，React页面都是一个个组件构成的，所以写React也就是写一个个组件的过程。  \n目前，从写法上来说React组件主要有两种写法，一种是函数式(Functional)组件，一种是继承类(Class)组件：\n```javascript\n// Functional\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>\n}\n// ES6下更多情况会写成这样，其实就是一段返回一段jsx的函数\nconst Welcome = (props) => {\n  return (\n    <h1>Hello, {props.name}</h1>\n  )\n}\nexport default Welcome\n\n// Class\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n// ES6下一般为方便导入加入下面\nexport default Welcom\n```\n按照React组件的功能可以分为有状态组件和无状态组件。无状态组件一般使用函数式组件即可。  \n我的建议是，如果不清楚是用哪一种写法去编写组件，可以先使用函数式组件。在编写过程中如若发现需要使用state或者组件生命周期，再将此组件改成继承类组件。下面是一个比较完整的继承类组件架子：\n```javascript\nclass MyComponent extends Component {\n    // 构造函数\n  constructor (props) {\n    super(props)\n    // 设置state\n    this.state = {\n      ...\n    }\n    // 定义 eventHandler\n    this.handleClick = this.handleClick.bind(this)\n  }\n\n  // 生命周期方法\n  componentWillMount () {}\n  componentDidMount () {}\n  componentWillReceiveProps () {}\n  componentWillUpdate () {}\n  componentWillUnmount () {}\n\n  // handlers\n  handleClick() {\n    this.setState({\n      ...\n    })\n  }\n\n  render() {\n    // 这里是组件的内容\n    return (\n        <div onClick={this.handleClick}>\n        </div>\n      )\n  }\n}\n\nMyComponent.defaultProps = {}\nMyComponent.propTypes = {}\n\nexport default MyComponent\n```\n    需要注意点：\n      无论哪种写法，return中必须被一个标签包裹，这是jsx语法要求的。\n      函数式组件也可以设置defaultProps和propTypes。\n      函数式组件中不能访问this。\n      可以声明变量值为jsx，如：let a = <div></div>","source":"_posts/从零搭建React(3).md","raw":"---\ntitle: 从零开始搭建React(3)\ndate: 2016-11-16\ntags: javascript React Webpack\ncategories: \n- React\ncomments: true\n---\n\n相信学习React的都是有过一定了解的，React页面都是一个个组件构成的，所以写React也就是写一个个组件的过程。  \n目前，从写法上来说React组件主要有两种写法，一种是函数式(Functional)组件，一种是继承类(Class)组件：\n```javascript\n// Functional\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>\n}\n// ES6下更多情况会写成这样，其实就是一段返回一段jsx的函数\nconst Welcome = (props) => {\n  return (\n    <h1>Hello, {props.name}</h1>\n  )\n}\nexport default Welcome\n\n// Class\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n// ES6下一般为方便导入加入下面\nexport default Welcom\n```\n按照React组件的功能可以分为有状态组件和无状态组件。无状态组件一般使用函数式组件即可。  \n我的建议是，如果不清楚是用哪一种写法去编写组件，可以先使用函数式组件。在编写过程中如若发现需要使用state或者组件生命周期，再将此组件改成继承类组件。下面是一个比较完整的继承类组件架子：\n```javascript\nclass MyComponent extends Component {\n    // 构造函数\n  constructor (props) {\n    super(props)\n    // 设置state\n    this.state = {\n      ...\n    }\n    // 定义 eventHandler\n    this.handleClick = this.handleClick.bind(this)\n  }\n\n  // 生命周期方法\n  componentWillMount () {}\n  componentDidMount () {}\n  componentWillReceiveProps () {}\n  componentWillUpdate () {}\n  componentWillUnmount () {}\n\n  // handlers\n  handleClick() {\n    this.setState({\n      ...\n    })\n  }\n\n  render() {\n    // 这里是组件的内容\n    return (\n        <div onClick={this.handleClick}>\n        </div>\n      )\n  }\n}\n\nMyComponent.defaultProps = {}\nMyComponent.propTypes = {}\n\nexport default MyComponent\n```\n    需要注意点：\n      无论哪种写法，return中必须被一个标签包裹，这是jsx语法要求的。\n      函数式组件也可以设置defaultProps和propTypes。\n      函数式组件中不能访问this。\n      可以声明变量值为jsx，如：let a = <div></div>","slug":"从零搭建React(3)","published":1,"updated":"2016-11-27T01:15:21.933Z","layout":"post","photos":[],"link":"","_id":"ciw3mfvu200190kc783d844b3","content":"<p>相信学习React的都是有过一定了解的，React页面都是一个个组件构成的，所以写React也就是写一个个组件的过程。<br>目前，从写法上来说React组件主要有两种写法，一种是函数式(Functional)组件，一种是继承类(Class)组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Functional</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// ES6下更多情况会写成这样，其实就是一段返回一段jsx的函数</span></div><div class=\"line\"><span class=\"keyword\">const</span> Welcome = <span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">  )</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Welcome</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Class</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Welcome</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// ES6下一般为方便导入加入下面</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Welcom</div></pre></td></tr></table></figure></p>\n<p>按照React组件的功能可以分为有状态组件和无状态组件。无状态组件一般使用函数式组件即可。<br>我的建议是，如果不清楚是用哪一种写法去编写组件，可以先使用函数式组件。在编写过程中如若发现需要使用state或者组件生命周期，再将此组件改成继承类组件。下面是一个比较完整的继承类组件架子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 构造函数</span></div><div class=\"line\">  <span class=\"keyword\">constructor</span> (props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props)</div><div class=\"line\">    <span class=\"comment\">// 设置state</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 定义 eventHandler</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 生命周期方法</span></div><div class=\"line\">  componentWillMount () &#123;&#125;</div><div class=\"line\">  componentDidMount () &#123;&#125;</div><div class=\"line\">  componentWillReceiveProps () &#123;&#125;</div><div class=\"line\">  componentWillUpdate () &#123;&#125;</div><div class=\"line\">  componentWillUnmount () &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// handlers</span></div><div class=\"line\">  handleClick() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"comment\">// 这里是组件的内容</span></div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">        <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handleClick&#125;</span>&gt;</span></span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">MyComponent.defaultProps = &#123;&#125;</div><div class=\"line\">MyComponent.propTypes = &#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> MyComponent</div></pre></td></tr></table></figure></p>\n<pre><code>需要注意点：\n  无论哪种写法，return中必须被一个标签包裹，这是jsx语法要求的。\n  函数式组件也可以设置defaultProps和propTypes。\n  函数式组件中不能访问this。\n  可以声明变量值为jsx，如：let a = &lt;div&gt;&lt;/div&gt;\n</code></pre>","excerpt":"","more":"<p>相信学习React的都是有过一定了解的，React页面都是一个个组件构成的，所以写React也就是写一个个组件的过程。<br>目前，从写法上来说React组件主要有两种写法，一种是函数式(Functional)组件，一种是继承类(Class)组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Functional</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// ES6下更多情况会写成这样，其实就是一段返回一段jsx的函数</span></div><div class=\"line\"><span class=\"keyword\">const</span> Welcome = <span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">  )</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Welcome</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Class</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Welcome</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// ES6下一般为方便导入加入下面</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Welcom</div></pre></td></tr></table></figure></p>\n<p>按照React组件的功能可以分为有状态组件和无状态组件。无状态组件一般使用函数式组件即可。<br>我的建议是，如果不清楚是用哪一种写法去编写组件，可以先使用函数式组件。在编写过程中如若发现需要使用state或者组件生命周期，再将此组件改成继承类组件。下面是一个比较完整的继承类组件架子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 构造函数</span></div><div class=\"line\">  <span class=\"keyword\">constructor</span> (props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props)</div><div class=\"line\">    <span class=\"comment\">// 设置state</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 定义 eventHandler</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 生命周期方法</span></div><div class=\"line\">  componentWillMount () &#123;&#125;</div><div class=\"line\">  componentDidMount () &#123;&#125;</div><div class=\"line\">  componentWillReceiveProps () &#123;&#125;</div><div class=\"line\">  componentWillUpdate () &#123;&#125;</div><div class=\"line\">  componentWillUnmount () &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// handlers</span></div><div class=\"line\">  handleClick() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"comment\">// 这里是组件的内容</span></div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">        <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handleClick&#125;</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">      )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">MyComponent.defaultProps = &#123;&#125;</div><div class=\"line\">MyComponent.propTypes = &#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> MyComponent</div></pre></td></tr></table></figure></p>\n<pre><code>需要注意点：\n  无论哪种写法，return中必须被一个标签包裹，这是jsx语法要求的。\n  函数式组件也可以设置defaultProps和propTypes。\n  函数式组件中不能访问this。\n  可以声明变量值为jsx，如：let a = &lt;div&gt;&lt;/div&gt;\n</code></pre>"},{"title":"我的第一个Hexo博客","date":"2016-06-09T14:11:35.000Z","_content":"\n  希望自己以后能在这个博客里，留下自己成长的点滴，不管之后会获得什么样的工作，不管以后时间是怎样。\n","source":"_posts/我的首个Hexo博客.md","raw":"---\ntitle: 我的第一个Hexo博客\ndate: 2016-06-09 22:11:35\ntags: \ncategories: \n- 杂记\n---\n\n  希望自己以后能在这个博客里，留下自己成长的点滴，不管之后会获得什么样的工作，不管以后时间是怎样。\n","slug":"我的首个Hexo博客","published":1,"updated":"2016-06-09T14:17:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw3mfvu2001c0kc7kv7r2cnd","content":"<p>  希望自己以后能在这个博客里，留下自己成长的点滴，不管之后会获得什么样的工作，不管以后时间是怎样。</p>\n","excerpt":"","more":"<p>  希望自己以后能在这个博客里，留下自己成长的点滴，不管之后会获得什么样的工作，不管以后时间是怎样。</p>\n"},{"_content":"浏览器环境IE6~8 IE9+ Chrome Firefox Safari Opera Edge\t\t\t\t持续学习\n\nHTTP协议URI Cache Session Cookie Request Response\t\t\t\t\t持续学习\n\nHTMLW3C HTML4.01 HTML5 DOM 语义化\t\t\t\t\t\t\t\t\t\t\t\t\t持续学习\n\nCSSCSS1~3 选择器 盒模型 Flex 媒体检测 响应式 渲染引擎\t\t\t\t\t媒体检测，响应式，渲染引擎\n\nJavaScriptEcmaScript3~5~6 Lexical-scope prototype-chain AJAX js引擎\n\n编辑器Emacs Vim WebStorm Atom Sublime-Text\t\t\t\t\t\t\t\t\t学习WebStorm\n\n发布部署合并 压缩 单元测试 Node.js Grunt Gulp Yeoman Phantom JSLint\n\n框架类库jQuery Zepto UnderScore Backbone Knockout React AngularJS\n\n模块管理CommonJS Webpack\n\nUI框架BootStrap SemanticUI jQueryUI Foundation\n\n推送技术WebSocket 轮询 长连接\n\n跨域技术iframe JSONP CORS\n\n数据可视化D3 Echarts HighCharts Canvas\n\n异步编程Promise $.Deferred Generator\n\nCSS预处理器LESS SASS Stylus\n\n客户端模板Handlebars Haml Jade Mustache\n\n相关语言CoffeeScript TypeScript Dart WebAssembly\n\nWebApp/PCReact-native ionic\n\n环境：nodejs (Node.js)\n包管理：npm (https://www.npmjs.com/)\n框架：react/vue (A JavaScript library for building user interfaces, vue.js)\n架构：redux (rackt/redux · GitHub)\n打包：webpack (webpack module bundler)\n构建：gulp (gulp.js - the streaming build system)\n编译：babel (Babel 路 The compiler for writing next generation JavaScript)\n合并请求：htmlone (https://www.npmjs.com/package/gulp-htmlone)\n\t预处理器：sass (Sass: Syntactically Awesome Style Sheets)\n\t后处理器：postCSS (postcss/postcss · GitHub)\n\t自动前缀：autoprefixer (postcss/autoprefixer · GitHub)\n\t适配方案：lib-flexible&px2rem (amfe/lib-flexible · GitHubhttps://www.npmjs.com/package/postcss-px2rem)\n框架调试工具：vue-devtools/react-devtools(https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpdhttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)\n开发服务器：这个随便，主要是配合hot-loader：(gaearon/react-hot-loader · GitHubvuejs/vue-hot-reload-api · GitHub) \n\n浏览器\n渲染引擎、JavaScript引擎\nHTML/JavaScript/CSS三支柱\n编辑器\n编译任务\n编译工具\n打包、调试、质量\n测试\nJS基础类库\nJS类库\nUI框架\nCSS预处理器\n模板\n现代化\n安全/模式\n中间语言\n跨平台解决方案","source":"_posts/前端技术栈.md","raw":"浏览器环境IE6~8 IE9+ Chrome Firefox Safari Opera Edge\t\t\t\t持续学习\n\nHTTP协议URI Cache Session Cookie Request Response\t\t\t\t\t持续学习\n\nHTMLW3C HTML4.01 HTML5 DOM 语义化\t\t\t\t\t\t\t\t\t\t\t\t\t持续学习\n\nCSSCSS1~3 选择器 盒模型 Flex 媒体检测 响应式 渲染引擎\t\t\t\t\t媒体检测，响应式，渲染引擎\n\nJavaScriptEcmaScript3~5~6 Lexical-scope prototype-chain AJAX js引擎\n\n编辑器Emacs Vim WebStorm Atom Sublime-Text\t\t\t\t\t\t\t\t\t学习WebStorm\n\n发布部署合并 压缩 单元测试 Node.js Grunt Gulp Yeoman Phantom JSLint\n\n框架类库jQuery Zepto UnderScore Backbone Knockout React AngularJS\n\n模块管理CommonJS Webpack\n\nUI框架BootStrap SemanticUI jQueryUI Foundation\n\n推送技术WebSocket 轮询 长连接\n\n跨域技术iframe JSONP CORS\n\n数据可视化D3 Echarts HighCharts Canvas\n\n异步编程Promise $.Deferred Generator\n\nCSS预处理器LESS SASS Stylus\n\n客户端模板Handlebars Haml Jade Mustache\n\n相关语言CoffeeScript TypeScript Dart WebAssembly\n\nWebApp/PCReact-native ionic\n\n环境：nodejs (Node.js)\n包管理：npm (https://www.npmjs.com/)\n框架：react/vue (A JavaScript library for building user interfaces, vue.js)\n架构：redux (rackt/redux · GitHub)\n打包：webpack (webpack module bundler)\n构建：gulp (gulp.js - the streaming build system)\n编译：babel (Babel 路 The compiler for writing next generation JavaScript)\n合并请求：htmlone (https://www.npmjs.com/package/gulp-htmlone)\n\t预处理器：sass (Sass: Syntactically Awesome Style Sheets)\n\t后处理器：postCSS (postcss/postcss · GitHub)\n\t自动前缀：autoprefixer (postcss/autoprefixer · GitHub)\n\t适配方案：lib-flexible&px2rem (amfe/lib-flexible · GitHubhttps://www.npmjs.com/package/postcss-px2rem)\n框架调试工具：vue-devtools/react-devtools(https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpdhttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)\n开发服务器：这个随便，主要是配合hot-loader：(gaearon/react-hot-loader · GitHubvuejs/vue-hot-reload-api · GitHub) \n\n浏览器\n渲染引擎、JavaScript引擎\nHTML/JavaScript/CSS三支柱\n编辑器\n编译任务\n编译工具\n打包、调试、质量\n测试\nJS基础类库\nJS类库\nUI框架\nCSS预处理器\n模板\n现代化\n安全/模式\n中间语言\n跨平台解决方案","slug":"前端技术栈","published":1,"date":"2016-11-28T13:34:34.168Z","updated":"2016-11-27T01:15:21.947Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw3mfvu2001f0kc703hcts7z","content":"<p>浏览器环境IE6~8 IE9+ Chrome Firefox Safari Opera Edge                持续学习</p>\n<p>HTTP协议URI Cache Session Cookie Request Response                    持续学习</p>\n<p>HTMLW3C HTML4.01 HTML5 DOM 语义化                                                    持续学习</p>\n<p>CSSCSS1~3 选择器 盒模型 Flex 媒体检测 响应式 渲染引擎                    媒体检测，响应式，渲染引擎</p>\n<p>JavaScriptEcmaScript3~5~6 Lexical-scope prototype-chain AJAX js引擎</p>\n<p>编辑器Emacs Vim WebStorm Atom Sublime-Text                                    学习WebStorm</p>\n<p>发布部署合并 压缩 单元测试 Node.js Grunt Gulp Yeoman Phantom JSLint</p>\n<p>框架类库jQuery Zepto UnderScore Backbone Knockout React AngularJS</p>\n<p>模块管理CommonJS Webpack</p>\n<p>UI框架BootStrap SemanticUI jQueryUI Foundation</p>\n<p>推送技术WebSocket 轮询 长连接</p>\n<p>跨域技术iframe JSONP CORS</p>\n<p>数据可视化D3 Echarts HighCharts Canvas</p>\n<p>异步编程Promise $.Deferred Generator</p>\n<p>CSS预处理器LESS SASS Stylus</p>\n<p>客户端模板Handlebars Haml Jade Mustache</p>\n<p>相关语言CoffeeScript TypeScript Dart WebAssembly</p>\n<p>WebApp/PCReact-native ionic</p>\n<p>环境：nodejs (Node.js)<br>包管理：npm (<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/</a>)<br>框架：react/vue (A JavaScript library for building user interfaces, vue.js)<br>架构：redux (rackt/redux · GitHub)<br>打包：webpack (webpack module bundler)<br>构建：gulp (gulp.js - the streaming build system)<br>编译：babel (Babel 路 The compiler for writing next generation JavaScript)<br>合并请求：htmlone (<a href=\"https://www.npmjs.com/package/gulp-htmlone\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/package/gulp-htmlone</a>)<br>    预处理器：sass (Sass: Syntactically Awesome Style Sheets)<br>    后处理器：postCSS (postcss/postcss · GitHub)<br>    自动前缀：autoprefixer (postcss/autoprefixer · GitHub)<br>    适配方案：lib-flexible&amp;px2rem (amfe/lib-flexible · GitHub<a href=\"https://www.npmjs.com/package/postcss-px2rem\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/package/postcss-px2rem</a>)<br>框架调试工具：vue-devtools/react-devtools(<a href=\"https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpdhttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi\" target=\"_blank\" rel=\"external\">https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpdhttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi</a>)<br>开发服务器：这个随便，主要是配合hot-loader：(gaearon/react-hot-loader · GitHubvuejs/vue-hot-reload-api · GitHub) </p>\n<p>浏览器<br>渲染引擎、JavaScript引擎<br>HTML/JavaScript/CSS三支柱<br>编辑器<br>编译任务<br>编译工具<br>打包、调试、质量<br>测试<br>JS基础类库<br>JS类库<br>UI框架<br>CSS预处理器<br>模板<br>现代化<br>安全/模式<br>中间语言<br>跨平台解决方案</p>\n","excerpt":"","more":"<p>浏览器环境IE6~8 IE9+ Chrome Firefox Safari Opera Edge                持续学习</p>\n<p>HTTP协议URI Cache Session Cookie Request Response                    持续学习</p>\n<p>HTMLW3C HTML4.01 HTML5 DOM 语义化                                                    持续学习</p>\n<p>CSSCSS1~3 选择器 盒模型 Flex 媒体检测 响应式 渲染引擎                    媒体检测，响应式，渲染引擎</p>\n<p>JavaScriptEcmaScript3~5~6 Lexical-scope prototype-chain AJAX js引擎</p>\n<p>编辑器Emacs Vim WebStorm Atom Sublime-Text                                    学习WebStorm</p>\n<p>发布部署合并 压缩 单元测试 Node.js Grunt Gulp Yeoman Phantom JSLint</p>\n<p>框架类库jQuery Zepto UnderScore Backbone Knockout React AngularJS</p>\n<p>模块管理CommonJS Webpack</p>\n<p>UI框架BootStrap SemanticUI jQueryUI Foundation</p>\n<p>推送技术WebSocket 轮询 长连接</p>\n<p>跨域技术iframe JSONP CORS</p>\n<p>数据可视化D3 Echarts HighCharts Canvas</p>\n<p>异步编程Promise $.Deferred Generator</p>\n<p>CSS预处理器LESS SASS Stylus</p>\n<p>客户端模板Handlebars Haml Jade Mustache</p>\n<p>相关语言CoffeeScript TypeScript Dart WebAssembly</p>\n<p>WebApp/PCReact-native ionic</p>\n<p>环境：nodejs (Node.js)<br>包管理：npm (<a href=\"https://www.npmjs.com/\">https://www.npmjs.com/</a>)<br>框架：react/vue (A JavaScript library for building user interfaces, vue.js)<br>架构：redux (rackt/redux · GitHub)<br>打包：webpack (webpack module bundler)<br>构建：gulp (gulp.js - the streaming build system)<br>编译：babel (Babel 路 The compiler for writing next generation JavaScript)<br>合并请求：htmlone (<a href=\"https://www.npmjs.com/package/gulp-htmlone\">https://www.npmjs.com/package/gulp-htmlone</a>)<br>    预处理器：sass (Sass: Syntactically Awesome Style Sheets)<br>    后处理器：postCSS (postcss/postcss · GitHub)<br>    自动前缀：autoprefixer (postcss/autoprefixer · GitHub)<br>    适配方案：lib-flexible&amp;px2rem (amfe/lib-flexible · GitHub<a href=\"https://www.npmjs.com/package/postcss-px2rem\">https://www.npmjs.com/package/postcss-px2rem</a>)<br>框架调试工具：vue-devtools/react-devtools(<a href=\"https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpdhttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi\">https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpdhttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi</a>)<br>开发服务器：这个随便，主要是配合hot-loader：(gaearon/react-hot-loader · GitHubvuejs/vue-hot-reload-api · GitHub) </p>\n<p>浏览器<br>渲染引擎、JavaScript引擎<br>HTML/JavaScript/CSS三支柱<br>编辑器<br>编译任务<br>编译工具<br>打包、调试、质量<br>测试<br>JS基础类库<br>JS类库<br>UI框架<br>CSS预处理器<br>模板<br>现代化<br>安全/模式<br>中间语言<br>跨平台解决方案</p>\n"},{"title":"起点大事件H5学习","date":"2016-08-09T16:00:00.000Z","comments":1,"_content":"\n[起点大事记 - 515粉丝节](http://m.qidian.com/ploy/20160515/qd/mockup/index.html)\n\n##### 0. js整体代码\n通过自执行函数返回两个对象，Common对象主要包含通用的分享代码，QDHISTORY对象(项目逻辑方法)包含页面主要逻辑，诸如init、loading、pagePlay、musicPlay、events(绑定事件)、JS动画等等。在页面</body>前引入后，标签script中调用。\n\n##### 1. 打开页面，第一个就是碰到的就是自动跳转。  \n代码很简单，只是对屏幕宽度的判断，大于600就显示静态页二维码。\n```javascript\nif(document.documentElement.clientWidth > 600) {\n  location.replace('pc.html');\n}\n```\n\n##### 2. 加载页面\n进度条，css中30s增加width动画。js中监听load事件，load事件完成后通过对进度条添加class实现width:100%过渡，修改加载标志。如果30s内加载标志还是未加载，则提示用户，并修改加载标志为失败，及时后面加载完成也不再触发load事件。  \n预加载，其实也是延迟加载。页面中img标签src属性保存在data-src中，这样就不会下载该图片，之后根据一定条件出发函数将data-src中属性写到src中。可以通过`new Image().src='图片地址'`提前下载图片。\n\n##### 3. 使用svg sprite && 使用canva\nsvg和canva虽然已经很久了，但是大量使用的貌似还不是特别多，使用svg和canva可以减少图片的使用，而且更容易添加动画，局限性主要是颜色上的限制。\n\n##### 4. css动画\ncss动画会在元素display:none和display:block的时候重新开始。一大堆令人眼花的动画，确实需要深厚的功力才能掌握。\n\n##### 5. 还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的[博客](http://www.zhangxinxu.com/wordpress/2016/06/canvas-star-noise-smoke/)吧。\n\n------\n\nps：自己能够写出来吗？ 应该是不行，即使照着临摹，动画的难度感觉也是很大，更别提烟雾、噪点等这些效果了。","source":"_posts/起点H5分析.md","raw":"---\ntitle: 起点大事件H5学习\ndate: 2016-08-10\ntags: javascript H5\ncategories: \n- H5\ncomments: true\n---\n\n[起点大事记 - 515粉丝节](http://m.qidian.com/ploy/20160515/qd/mockup/index.html)\n\n##### 0. js整体代码\n通过自执行函数返回两个对象，Common对象主要包含通用的分享代码，QDHISTORY对象(项目逻辑方法)包含页面主要逻辑，诸如init、loading、pagePlay、musicPlay、events(绑定事件)、JS动画等等。在页面</body>前引入后，标签script中调用。\n\n##### 1. 打开页面，第一个就是碰到的就是自动跳转。  \n代码很简单，只是对屏幕宽度的判断，大于600就显示静态页二维码。\n```javascript\nif(document.documentElement.clientWidth > 600) {\n  location.replace('pc.html');\n}\n```\n\n##### 2. 加载页面\n进度条，css中30s增加width动画。js中监听load事件，load事件完成后通过对进度条添加class实现width:100%过渡，修改加载标志。如果30s内加载标志还是未加载，则提示用户，并修改加载标志为失败，及时后面加载完成也不再触发load事件。  \n预加载，其实也是延迟加载。页面中img标签src属性保存在data-src中，这样就不会下载该图片，之后根据一定条件出发函数将data-src中属性写到src中。可以通过`new Image().src='图片地址'`提前下载图片。\n\n##### 3. 使用svg sprite && 使用canva\nsvg和canva虽然已经很久了，但是大量使用的貌似还不是特别多，使用svg和canva可以减少图片的使用，而且更容易添加动画，局限性主要是颜色上的限制。\n\n##### 4. css动画\ncss动画会在元素display:none和display:block的时候重新开始。一大堆令人眼花的动画，确实需要深厚的功力才能掌握。\n\n##### 5. 还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的[博客](http://www.zhangxinxu.com/wordpress/2016/06/canvas-star-noise-smoke/)吧。\n\n------\n\nps：自己能够写出来吗？ 应该是不行，即使照着临摹，动画的难度感觉也是很大，更别提烟雾、噪点等这些效果了。","slug":"起点H5分析","published":1,"updated":"2016-11-27T01:15:21.954Z","layout":"post","photos":[],"link":"","_id":"ciw3mfvu2001i0kc7zi37n21a","content":"<p><a href=\"http://m.qidian.com/ploy/20160515/qd/mockup/index.html\" target=\"_blank\" rel=\"external\">起点大事记 - 515粉丝节</a></p>\n<h5 id=\"0-js整体代码\"><a href=\"#0-js整体代码\" class=\"headerlink\" title=\"0. js整体代码\"></a>0. js整体代码</h5><p>通过自执行函数返回两个对象，Common对象主要包含通用的分享代码，QDHISTORY对象(项目逻辑方法)包含页面主要逻辑，诸如init、loading、pagePlay、musicPlay、events(绑定事件)、JS动画等等。在页面前引入后，标签script中调用。</p>\n<h5 id=\"1-打开页面，第一个就是碰到的就是自动跳转。\"><a href=\"#1-打开页面，第一个就是碰到的就是自动跳转。\" class=\"headerlink\" title=\"1. 打开页面，第一个就是碰到的就是自动跳转。\"></a>1. 打开页面，第一个就是碰到的就是自动跳转。</h5><p>代码很简单，只是对屏幕宽度的判断，大于600就显示静态页二维码。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">document</span>.documentElement.clientWidth &gt; <span class=\"number\">600</span>) &#123;</div><div class=\"line\">  location.replace(<span class=\"string\">'pc.html'</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"2-加载页面\"><a href=\"#2-加载页面\" class=\"headerlink\" title=\"2. 加载页面\"></a>2. 加载页面</h5><p>进度条，css中30s增加width动画。js中监听load事件，load事件完成后通过对进度条添加class实现width:100%过渡，修改加载标志。如果30s内加载标志还是未加载，则提示用户，并修改加载标志为失败，及时后面加载完成也不再触发load事件。<br>预加载，其实也是延迟加载。页面中img标签src属性保存在data-src中，这样就不会下载该图片，之后根据一定条件出发函数将data-src中属性写到src中。可以通过<code>new Image().src=&#39;图片地址&#39;</code>提前下载图片。</p>\n<h5 id=\"3-使用svg-sprite-amp-amp-使用canva\"><a href=\"#3-使用svg-sprite-amp-amp-使用canva\" class=\"headerlink\" title=\"3. 使用svg sprite &amp;&amp; 使用canva\"></a>3. 使用svg sprite &amp;&amp; 使用canva</h5><p>svg和canva虽然已经很久了，但是大量使用的貌似还不是特别多，使用svg和canva可以减少图片的使用，而且更容易添加动画，局限性主要是颜色上的限制。</p>\n<h5 id=\"4-css动画\"><a href=\"#4-css动画\" class=\"headerlink\" title=\"4. css动画\"></a>4. css动画</h5><p>css动画会在元素display:none和display:block的时候重新开始。一大堆令人眼花的动画，确实需要深厚的功力才能掌握。</p>\n<h5 id=\"5-还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的博客吧。\"><a href=\"#5-还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的博客吧。\" class=\"headerlink\" title=\"5. 还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的博客吧。\"></a>5. 还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的<a href=\"http://www.zhangxinxu.com/wordpress/2016/06/canvas-star-noise-smoke/\" target=\"_blank\" rel=\"external\">博客</a>吧。</h5><hr>\n<p>ps：自己能够写出来吗？ 应该是不行，即使照着临摹，动画的难度感觉也是很大，更别提烟雾、噪点等这些效果了。</p>\n","excerpt":"","more":"<p><a href=\"http://m.qidian.com/ploy/20160515/qd/mockup/index.html\">起点大事记 - 515粉丝节</a></p>\n<h5 id=\"0-js整体代码\"><a href=\"#0-js整体代码\" class=\"headerlink\" title=\"0. js整体代码\"></a>0. js整体代码</h5><p>通过自执行函数返回两个对象，Common对象主要包含通用的分享代码，QDHISTORY对象(项目逻辑方法)包含页面主要逻辑，诸如init、loading、pagePlay、musicPlay、events(绑定事件)、JS动画等等。在页面</body>前引入后，标签script中调用。</p>\n<h5 id=\"1-打开页面，第一个就是碰到的就是自动跳转。\"><a href=\"#1-打开页面，第一个就是碰到的就是自动跳转。\" class=\"headerlink\" title=\"1. 打开页面，第一个就是碰到的就是自动跳转。\"></a>1. 打开页面，第一个就是碰到的就是自动跳转。</h5><p>代码很简单，只是对屏幕宽度的判断，大于600就显示静态页二维码。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">document</span>.documentElement.clientWidth &gt; <span class=\"number\">600</span>) &#123;</div><div class=\"line\">  location.replace(<span class=\"string\">'pc.html'</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"2-加载页面\"><a href=\"#2-加载页面\" class=\"headerlink\" title=\"2. 加载页面\"></a>2. 加载页面</h5><p>进度条，css中30s增加width动画。js中监听load事件，load事件完成后通过对进度条添加class实现width:100%过渡，修改加载标志。如果30s内加载标志还是未加载，则提示用户，并修改加载标志为失败，及时后面加载完成也不再触发load事件。<br>预加载，其实也是延迟加载。页面中img标签src属性保存在data-src中，这样就不会下载该图片，之后根据一定条件出发函数将data-src中属性写到src中。可以通过<code>new Image().src=&#39;图片地址&#39;</code>提前下载图片。</p>\n<h5 id=\"3-使用svg-sprite-amp-amp-使用canva\"><a href=\"#3-使用svg-sprite-amp-amp-使用canva\" class=\"headerlink\" title=\"3. 使用svg sprite &amp;&amp; 使用canva\"></a>3. 使用svg sprite &amp;&amp; 使用canva</h5><p>svg和canva虽然已经很久了，但是大量使用的貌似还不是特别多，使用svg和canva可以减少图片的使用，而且更容易添加动画，局限性主要是颜色上的限制。</p>\n<h5 id=\"4-css动画\"><a href=\"#4-css动画\" class=\"headerlink\" title=\"4. css动画\"></a>4. css动画</h5><p>css动画会在元素display:none和display:block的时候重新开始。一大堆令人眼花的动画，确实需要深厚的功力才能掌握。</p>\n<h5 id=\"5-还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的博客吧。\"><a href=\"#5-还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的博客吧。\" class=\"headerlink\" title=\"5. 还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的博客吧。\"></a>5. 还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的<a href=\"http://www.zhangxinxu.com/wordpress/2016/06/canvas-star-noise-smoke/\">博客</a>吧。</h5><hr>\n<p>ps：自己能够写出来吗？ 应该是不行，即使照着临摹，动画的难度感觉也是很大，更别提烟雾、噪点等这些效果了。</p>\n"},{"title":"微信分享绝对是个坑","date":"2016-08-07T16:00:00.000Z","comments":1,"_content":"\n没想到碰到的第一个大坑竟然是这种问题，原以为一个微信分享，不就是看着微信开发者文档，然后写几个配置参数就可以完成的么？就算开发者文档比较麻烦，像这种常用的功能不是应该公司早就封装好，拿来配置几个参数搞定的事情么！\n\n-----\n\n### 0.先上结论吧\n目前我发现的比较好的解决办法是使用官方的(分享组件)[http://open.mobile.qq.com/api/component/share],但是安卓下微信分享手机QQ方向会有问题。微信分享QQ方向，标题使用的是title标签，描述是链接地址，图标使用的是页面第一个img标签内容(尺寸应该是大于等于300*300)。所以可以使用`div display:none;`包含img标签。  \n\tps:应该是微信API有问题，以后可能会被修复。\n\n### 1.公司封装\n在我项目开始不久前，另一个前端根据新的微信JS-SDK封装了分享方法，正好拿过来使用。使用还是挺方便的，只需要在引入插件前面定义全局对象即可。\n```javascript\nvar weChatShare = {\n\t\t\t\"title\" : '分享标题',    // 分享标题,建议主标题一行 18个字符以内 \n\t\t\t\"desc\"  : '分享描述',    // 分享描述，建议描述最多两行 36个字符以内 \n\t\t\t\"img\"   : '分享图标url', // 分享图标,200*200\n\t\t}\n```\n结果发现只有标题和描述，图标没有出来。手机QQ分享微信标题、描述、图片都没有出来。只能放弃。\n\n后来查看代码，封装的挺基本的，一个生成随机字符串作为生成签名的函数，一个ajax请求根据随机字符串、链接从后台获取签名(签名获取后台方法可以参看微信JS-SDK)，然后就是通过配置调用微信JS-SDK了。只是因为微信调用中配置`imgUrl`写错成了`img`导致图片没有出来。而手机QQ因为这些是微信的接口，手机QQ分享当然出不来了。当然，这都是后来再回头看的，项目期间时间紧，就一直在赶着找现成的方法。\n\n### 2.微信旧的API\n就是WeixinJSBridge这个对象，应该是已经不再推荐使用，但是还是可以生效的。因为是旧的嘛，我也没有太去了解。代码也就不贴了，直接忽略掉吧。  \n结果就是图片出来了，但是微信分享QQ以及QQ分享微信还是不够正常。\n\n### 3.找正常项目\n自己公司的基本上是找不到所谓正常的项目了，只能找其他公司的页面了。看了一遍，严格意义上的正常好像没有，不是QQ分享没有，就是微信分享QQ图片有问题，然后在滴滴的分享代码里找到这么一句`if(mqq !== undefined)`。然后顺着发现了`mqq.data.setShareInfo`。通过搜索这个方法名，发现了[腾讯移动WEB开发平台](http://open.mobile.qq.com/api/mqq/index)。好吧，承认自己蠢，QQ分享当然是应该找QQ的API，微信的API当然不管用了。\n\n### 4.分享组件\n期间又经过了自己的一系列的尝试，不停的add、commit、push，最终无意间发现了[这个](http://open.mobile.qq.com/api/component/share)，竟然有封装好的组件，但是[腾讯移动WEB开发平台](http://open.mobile.qq.com/api/mqq/index)中的手机QQ下没有，微信下没有，竟然是藏在首页的热门API标签下的分享中，这里写的API不应该就是API吗，为什么是组件？我怎么知道这里的『API』会和文档中的API不同呢？  \n使用该组件后，IOS上一切正常，安卓下微信分享QQ无效。\n\n### 5.图片隐藏法\n如果没有调用API，分享的时候会选取页面中第一个img标签中的图片作为图标，所以可以是用`div display:none;`包含图标地址img标签使用。经测试，不要使用太小的图片，200 * 200的图片，微信分享会无法显示，会跳过继续寻找下一个图片作为图标。没有测试太多，300 * 300的应该是比较合适的尺寸。","source":"_posts/微信分享绝对是个坑.md","raw":"---\ntitle: 微信分享绝对是个坑\ndate: 2016-08-08\ntags: javascript H5 微信分享\ncategories: \n- H5\ncomments: true\n---\n\n没想到碰到的第一个大坑竟然是这种问题，原以为一个微信分享，不就是看着微信开发者文档，然后写几个配置参数就可以完成的么？就算开发者文档比较麻烦，像这种常用的功能不是应该公司早就封装好，拿来配置几个参数搞定的事情么！\n\n-----\n\n### 0.先上结论吧\n目前我发现的比较好的解决办法是使用官方的(分享组件)[http://open.mobile.qq.com/api/component/share],但是安卓下微信分享手机QQ方向会有问题。微信分享QQ方向，标题使用的是title标签，描述是链接地址，图标使用的是页面第一个img标签内容(尺寸应该是大于等于300*300)。所以可以使用`div display:none;`包含img标签。  \n\tps:应该是微信API有问题，以后可能会被修复。\n\n### 1.公司封装\n在我项目开始不久前，另一个前端根据新的微信JS-SDK封装了分享方法，正好拿过来使用。使用还是挺方便的，只需要在引入插件前面定义全局对象即可。\n```javascript\nvar weChatShare = {\n\t\t\t\"title\" : '分享标题',    // 分享标题,建议主标题一行 18个字符以内 \n\t\t\t\"desc\"  : '分享描述',    // 分享描述，建议描述最多两行 36个字符以内 \n\t\t\t\"img\"   : '分享图标url', // 分享图标,200*200\n\t\t}\n```\n结果发现只有标题和描述，图标没有出来。手机QQ分享微信标题、描述、图片都没有出来。只能放弃。\n\n后来查看代码，封装的挺基本的，一个生成随机字符串作为生成签名的函数，一个ajax请求根据随机字符串、链接从后台获取签名(签名获取后台方法可以参看微信JS-SDK)，然后就是通过配置调用微信JS-SDK了。只是因为微信调用中配置`imgUrl`写错成了`img`导致图片没有出来。而手机QQ因为这些是微信的接口，手机QQ分享当然出不来了。当然，这都是后来再回头看的，项目期间时间紧，就一直在赶着找现成的方法。\n\n### 2.微信旧的API\n就是WeixinJSBridge这个对象，应该是已经不再推荐使用，但是还是可以生效的。因为是旧的嘛，我也没有太去了解。代码也就不贴了，直接忽略掉吧。  \n结果就是图片出来了，但是微信分享QQ以及QQ分享微信还是不够正常。\n\n### 3.找正常项目\n自己公司的基本上是找不到所谓正常的项目了，只能找其他公司的页面了。看了一遍，严格意义上的正常好像没有，不是QQ分享没有，就是微信分享QQ图片有问题，然后在滴滴的分享代码里找到这么一句`if(mqq !== undefined)`。然后顺着发现了`mqq.data.setShareInfo`。通过搜索这个方法名，发现了[腾讯移动WEB开发平台](http://open.mobile.qq.com/api/mqq/index)。好吧，承认自己蠢，QQ分享当然是应该找QQ的API，微信的API当然不管用了。\n\n### 4.分享组件\n期间又经过了自己的一系列的尝试，不停的add、commit、push，最终无意间发现了[这个](http://open.mobile.qq.com/api/component/share)，竟然有封装好的组件，但是[腾讯移动WEB开发平台](http://open.mobile.qq.com/api/mqq/index)中的手机QQ下没有，微信下没有，竟然是藏在首页的热门API标签下的分享中，这里写的API不应该就是API吗，为什么是组件？我怎么知道这里的『API』会和文档中的API不同呢？  \n使用该组件后，IOS上一切正常，安卓下微信分享QQ无效。\n\n### 5.图片隐藏法\n如果没有调用API，分享的时候会选取页面中第一个img标签中的图片作为图标，所以可以是用`div display:none;`包含图标地址img标签使用。经测试，不要使用太小的图片，200 * 200的图片，微信分享会无法显示，会跳过继续寻找下一个图片作为图标。没有测试太多，300 * 300的应该是比较合适的尺寸。","slug":"微信分享绝对是个坑","published":1,"updated":"2016-11-27T01:15:21.952Z","layout":"post","photos":[],"link":"","_id":"ciw3mfwco00230kc7bayg3v0k","content":"<p>没想到碰到的第一个大坑竟然是这种问题，原以为一个微信分享，不就是看着微信开发者文档，然后写几个配置参数就可以完成的么？就算开发者文档比较麻烦，像这种常用的功能不是应该公司早就封装好，拿来配置几个参数搞定的事情么！</p>\n<hr>\n<h3 id=\"0-先上结论吧\"><a href=\"#0-先上结论吧\" class=\"headerlink\" title=\"0.先上结论吧\"></a>0.先上结论吧</h3><p>目前我发现的比较好的解决办法是使用官方的(分享组件)[<a href=\"http://open.mobile.qq.com/api/component/share],但是安卓下微信分享手机QQ方向会有问题。微信分享QQ方向，标题使用的是title标签，描述是链接地址，图标使用的是页面第一个img标签内容(尺寸应该是大于等于300*300)。所以可以使用`div\" target=\"_blank\" rel=\"external\">http://open.mobile.qq.com/api/component/share],但是安卓下微信分享手机QQ方向会有问题。微信分享QQ方向，标题使用的是title标签，描述是链接地址，图标使用的是页面第一个img标签内容(尺寸应该是大于等于300*300)。所以可以使用`div</a> display:none;`包含img标签。<br>    ps:应该是微信API有问题，以后可能会被修复。</p>\n<h3 id=\"1-公司封装\"><a href=\"#1-公司封装\" class=\"headerlink\" title=\"1.公司封装\"></a>1.公司封装</h3><p>在我项目开始不久前，另一个前端根据新的微信JS-SDK封装了分享方法，正好拿过来使用。使用还是挺方便的，只需要在引入插件前面定义全局对象即可。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> weChatShare = &#123;</div><div class=\"line\">\t\t\t<span class=\"string\">\"title\"</span> : <span class=\"string\">'分享标题'</span>,    <span class=\"comment\">// 分享标题,建议主标题一行 18个字符以内 </span></div><div class=\"line\">\t\t\t<span class=\"string\">\"desc\"</span>  : <span class=\"string\">'分享描述'</span>,    <span class=\"comment\">// 分享描述，建议描述最多两行 36个字符以内 </span></div><div class=\"line\">\t\t\t<span class=\"string\">\"img\"</span>   : <span class=\"string\">'分享图标url'</span>, <span class=\"comment\">// 分享图标,200*200</span></div><div class=\"line\">\t\t&#125;</div></pre></td></tr></table></figure></p>\n<p>结果发现只有标题和描述，图标没有出来。手机QQ分享微信标题、描述、图片都没有出来。只能放弃。</p>\n<p>后来查看代码，封装的挺基本的，一个生成随机字符串作为生成签名的函数，一个ajax请求根据随机字符串、链接从后台获取签名(签名获取后台方法可以参看微信JS-SDK)，然后就是通过配置调用微信JS-SDK了。只是因为微信调用中配置<code>imgUrl</code>写错成了<code>img</code>导致图片没有出来。而手机QQ因为这些是微信的接口，手机QQ分享当然出不来了。当然，这都是后来再回头看的，项目期间时间紧，就一直在赶着找现成的方法。</p>\n<h3 id=\"2-微信旧的API\"><a href=\"#2-微信旧的API\" class=\"headerlink\" title=\"2.微信旧的API\"></a>2.微信旧的API</h3><p>就是WeixinJSBridge这个对象，应该是已经不再推荐使用，但是还是可以生效的。因为是旧的嘛，我也没有太去了解。代码也就不贴了，直接忽略掉吧。<br>结果就是图片出来了，但是微信分享QQ以及QQ分享微信还是不够正常。</p>\n<h3 id=\"3-找正常项目\"><a href=\"#3-找正常项目\" class=\"headerlink\" title=\"3.找正常项目\"></a>3.找正常项目</h3><p>自己公司的基本上是找不到所谓正常的项目了，只能找其他公司的页面了。看了一遍，严格意义上的正常好像没有，不是QQ分享没有，就是微信分享QQ图片有问题，然后在滴滴的分享代码里找到这么一句<code>if(mqq !== undefined)</code>。然后顺着发现了<code>mqq.data.setShareInfo</code>。通过搜索这个方法名，发现了<a href=\"http://open.mobile.qq.com/api/mqq/index\" target=\"_blank\" rel=\"external\">腾讯移动WEB开发平台</a>。好吧，承认自己蠢，QQ分享当然是应该找QQ的API，微信的API当然不管用了。</p>\n<h3 id=\"4-分享组件\"><a href=\"#4-分享组件\" class=\"headerlink\" title=\"4.分享组件\"></a>4.分享组件</h3><p>期间又经过了自己的一系列的尝试，不停的add、commit、push，最终无意间发现了<a href=\"http://open.mobile.qq.com/api/component/share\" target=\"_blank\" rel=\"external\">这个</a>，竟然有封装好的组件，但是<a href=\"http://open.mobile.qq.com/api/mqq/index\" target=\"_blank\" rel=\"external\">腾讯移动WEB开发平台</a>中的手机QQ下没有，微信下没有，竟然是藏在首页的热门API标签下的分享中，这里写的API不应该就是API吗，为什么是组件？我怎么知道这里的『API』会和文档中的API不同呢？<br>使用该组件后，IOS上一切正常，安卓下微信分享QQ无效。</p>\n<h3 id=\"5-图片隐藏法\"><a href=\"#5-图片隐藏法\" class=\"headerlink\" title=\"5.图片隐藏法\"></a>5.图片隐藏法</h3><p>如果没有调用API，分享的时候会选取页面中第一个img标签中的图片作为图标，所以可以是用<code>div display:none;</code>包含图标地址img标签使用。经测试，不要使用太小的图片，200 <em> 200的图片，微信分享会无法显示，会跳过继续寻找下一个图片作为图标。没有测试太多，300 </em> 300的应该是比较合适的尺寸。</p>\n","excerpt":"","more":"<p>没想到碰到的第一个大坑竟然是这种问题，原以为一个微信分享，不就是看着微信开发者文档，然后写几个配置参数就可以完成的么？就算开发者文档比较麻烦，像这种常用的功能不是应该公司早就封装好，拿来配置几个参数搞定的事情么！</p>\n<hr>\n<h3 id=\"0-先上结论吧\"><a href=\"#0-先上结论吧\" class=\"headerlink\" title=\"0.先上结论吧\"></a>0.先上结论吧</h3><p>目前我发现的比较好的解决办法是使用官方的(分享组件)[<a href=\"http://open.mobile.qq.com/api/component/share],但是安卓下微信分享手机QQ方向会有问题。微信分享QQ方向，标题使用的是title标签，描述是链接地址，图标使用的是页面第一个img标签内容(尺寸应该是大于等于300*300)。所以可以使用`div\">http://open.mobile.qq.com/api/component/share],但是安卓下微信分享手机QQ方向会有问题。微信分享QQ方向，标题使用的是title标签，描述是链接地址，图标使用的是页面第一个img标签内容(尺寸应该是大于等于300*300)。所以可以使用`div</a> display:none;`包含img标签。<br>    ps:应该是微信API有问题，以后可能会被修复。</p>\n<h3 id=\"1-公司封装\"><a href=\"#1-公司封装\" class=\"headerlink\" title=\"1.公司封装\"></a>1.公司封装</h3><p>在我项目开始不久前，另一个前端根据新的微信JS-SDK封装了分享方法，正好拿过来使用。使用还是挺方便的，只需要在引入插件前面定义全局对象即可。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> weChatShare = &#123;</div><div class=\"line\">\t\t\t<span class=\"string\">\"title\"</span> : <span class=\"string\">'分享标题'</span>,    <span class=\"comment\">// 分享标题,建议主标题一行 18个字符以内 </span></div><div class=\"line\">\t\t\t<span class=\"string\">\"desc\"</span>  : <span class=\"string\">'分享描述'</span>,    <span class=\"comment\">// 分享描述，建议描述最多两行 36个字符以内 </span></div><div class=\"line\">\t\t\t<span class=\"string\">\"img\"</span>   : <span class=\"string\">'分享图标url'</span>, <span class=\"comment\">// 分享图标,200*200</span></div><div class=\"line\">\t\t&#125;</div></pre></td></tr></table></figure></p>\n<p>结果发现只有标题和描述，图标没有出来。手机QQ分享微信标题、描述、图片都没有出来。只能放弃。</p>\n<p>后来查看代码，封装的挺基本的，一个生成随机字符串作为生成签名的函数，一个ajax请求根据随机字符串、链接从后台获取签名(签名获取后台方法可以参看微信JS-SDK)，然后就是通过配置调用微信JS-SDK了。只是因为微信调用中配置<code>imgUrl</code>写错成了<code>img</code>导致图片没有出来。而手机QQ因为这些是微信的接口，手机QQ分享当然出不来了。当然，这都是后来再回头看的，项目期间时间紧，就一直在赶着找现成的方法。</p>\n<h3 id=\"2-微信旧的API\"><a href=\"#2-微信旧的API\" class=\"headerlink\" title=\"2.微信旧的API\"></a>2.微信旧的API</h3><p>就是WeixinJSBridge这个对象，应该是已经不再推荐使用，但是还是可以生效的。因为是旧的嘛，我也没有太去了解。代码也就不贴了，直接忽略掉吧。<br>结果就是图片出来了，但是微信分享QQ以及QQ分享微信还是不够正常。</p>\n<h3 id=\"3-找正常项目\"><a href=\"#3-找正常项目\" class=\"headerlink\" title=\"3.找正常项目\"></a>3.找正常项目</h3><p>自己公司的基本上是找不到所谓正常的项目了，只能找其他公司的页面了。看了一遍，严格意义上的正常好像没有，不是QQ分享没有，就是微信分享QQ图片有问题，然后在滴滴的分享代码里找到这么一句<code>if(mqq !== undefined)</code>。然后顺着发现了<code>mqq.data.setShareInfo</code>。通过搜索这个方法名，发现了<a href=\"http://open.mobile.qq.com/api/mqq/index\">腾讯移动WEB开发平台</a>。好吧，承认自己蠢，QQ分享当然是应该找QQ的API，微信的API当然不管用了。</p>\n<h3 id=\"4-分享组件\"><a href=\"#4-分享组件\" class=\"headerlink\" title=\"4.分享组件\"></a>4.分享组件</h3><p>期间又经过了自己的一系列的尝试，不停的add、commit、push，最终无意间发现了<a href=\"http://open.mobile.qq.com/api/component/share\">这个</a>，竟然有封装好的组件，但是<a href=\"http://open.mobile.qq.com/api/mqq/index\">腾讯移动WEB开发平台</a>中的手机QQ下没有，微信下没有，竟然是藏在首页的热门API标签下的分享中，这里写的API不应该就是API吗，为什么是组件？我怎么知道这里的『API』会和文档中的API不同呢？<br>使用该组件后，IOS上一切正常，安卓下微信分享QQ无效。</p>\n<h3 id=\"5-图片隐藏法\"><a href=\"#5-图片隐藏法\" class=\"headerlink\" title=\"5.图片隐藏法\"></a>5.图片隐藏法</h3><p>如果没有调用API，分享的时候会选取页面中第一个img标签中的图片作为图标，所以可以是用<code>div display:none;</code>包含图标地址img标签使用。经测试，不要使用太小的图片，200 <em> 200的图片，微信分享会无法显示，会跳过继续寻找下一个图片作为图标。没有测试太多，300 </em> 300的应该是比较合适的尺寸。</p>\n"},{"title":"面向对象的javascript(继承)","date":"2016-06-21T12:33:00.000Z","comments":1,"_content":"　　继承就是从已有的类(对象)派生出新的类(对象)，新的类(对象)会拥有父类的所有属性和方法，并可以添加或修改属性和方法。\n\n--------------------\n\n### 1.类式继承(prototype模式)\n```javascript\n// 父类\nfunction SupClass() {\n\tthis.superValue = true;\n}\nSuperClass.prototype = {\n\tgetSuperValue = function() {\n\t\treturn this.superValue;\n\t}\n};\n// 子类\nfunction SubClass() {\n\tthis.subValue = false;\n}\n// 通过原型链实现继承\nSubClass.prototype = new SuperClass();\n// 修正constructor的指向\nSubClass.prototype.contructor = SubClass;\n// 子类添加公有方法\nSubClass.prototype.getSubValue = function() {}\n```\n将父类实例赋值给子类的prototype，子类就能通过原型链来访问到父类中的属性以及方法。缺点是因为子类是通过原型链继承父类的，所以多个实例化的子类中包含的父类属性和方法其实是一份，其中一个修改，其他会受到影响。另外是实例化无法传递参数。\n\n### 2.构造函数继承\n```javascript\n// 父类\nfunction SupClass(id) {\n\tthis.superValue = true;\n\tthis.id = id;\n}\nSuperClass.prototype = {\n\tgetSuperValue = function() {\n\t\treturn this.superValue;\n\t}\n};\n// 子类\nfunction SubClass(id, name) {\n\tSupClass.call(this, id);\n\tthis.name = name;\n}\n```\n通过call或apply函数修改父类中的this指向，可以实现参数的传递。缺点是只能继承构造函数中的属性(即this指向的属性和方法)，原型链得不到继承。\n\n### 3.组合继承\n```javascript\n// 父类\nfunction SupClass(id) {\n\tthis.superValue = true;\n\tthis.id = id;\n}\nSuperClass.prototype = {\n\tgetSuperValue = function() {\n\t\treturn this.superValue;\n\t}\n};\n// 子类\nfunction SubClass(id, name) {\n\t// 继承构造函数中的属性和方法\n\tSupClass.call(this, id);\n\tthis.name = name;\n}\n// 继承所有属性和方法\nSubClass.prototype = new SuperClass();\nSubClass.prototype.contructor = SubClass;\n```\n结合了类式继承和构造函数继承的优点，去除了两者的缺点。唯一的缺点就是在子类中执行了SupClass()，在子类原型中又执行了SupClass()。\n\n### 4.直接继承prototype\n```javascript\n// 同上\n... ...\n// 继承原型中的属性和方法\nSubClass.prototype = SuperClass.prototype;\nSubClass.prototype.contructor = SubClass;\n```\n既然在子类中构造函数的属性和方法已经被继承了，所以子类的原型中只需要继承父类的原型。缺点是SubClass.prototype和SupClass.prototype指向同一对象，修改会互相影响。\n\n### 5.利用空对象继承prototype\n```javascript\n// 同上\n... ...\n// 在空对象中复制一份父类的原型\nvar O = function(){};\nO.prototype = SuperClass.prototype;\n// 继承原型中的属性和方法\nSubClass.prototype = new O();\nSubClass.prototype.contructor = SubClass;\n```\n基于3.的修改，执行两次SupClass()消耗资源，执行空对象，消耗资源就会大大减少。\n\n### 6.拷贝继承\n拷贝就是将父类的属性和方法拷贝到子类中，拷贝可以是浅拷贝和深拷贝。拷贝可以实现多继承。\n\n----------------\n　　　　-------来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢","source":"_posts/面向对象的javascript(继承).md","raw":"---\ntitle: 面向对象的javascript(继承)\ndate: 2016-06-21 20:33\ntags: [javascript,面向对象]\ncategories: \n- javascript\ncomments: true\n---\n　　继承就是从已有的类(对象)派生出新的类(对象)，新的类(对象)会拥有父类的所有属性和方法，并可以添加或修改属性和方法。\n\n--------------------\n\n### 1.类式继承(prototype模式)\n```javascript\n// 父类\nfunction SupClass() {\n\tthis.superValue = true;\n}\nSuperClass.prototype = {\n\tgetSuperValue = function() {\n\t\treturn this.superValue;\n\t}\n};\n// 子类\nfunction SubClass() {\n\tthis.subValue = false;\n}\n// 通过原型链实现继承\nSubClass.prototype = new SuperClass();\n// 修正constructor的指向\nSubClass.prototype.contructor = SubClass;\n// 子类添加公有方法\nSubClass.prototype.getSubValue = function() {}\n```\n将父类实例赋值给子类的prototype，子类就能通过原型链来访问到父类中的属性以及方法。缺点是因为子类是通过原型链继承父类的，所以多个实例化的子类中包含的父类属性和方法其实是一份，其中一个修改，其他会受到影响。另外是实例化无法传递参数。\n\n### 2.构造函数继承\n```javascript\n// 父类\nfunction SupClass(id) {\n\tthis.superValue = true;\n\tthis.id = id;\n}\nSuperClass.prototype = {\n\tgetSuperValue = function() {\n\t\treturn this.superValue;\n\t}\n};\n// 子类\nfunction SubClass(id, name) {\n\tSupClass.call(this, id);\n\tthis.name = name;\n}\n```\n通过call或apply函数修改父类中的this指向，可以实现参数的传递。缺点是只能继承构造函数中的属性(即this指向的属性和方法)，原型链得不到继承。\n\n### 3.组合继承\n```javascript\n// 父类\nfunction SupClass(id) {\n\tthis.superValue = true;\n\tthis.id = id;\n}\nSuperClass.prototype = {\n\tgetSuperValue = function() {\n\t\treturn this.superValue;\n\t}\n};\n// 子类\nfunction SubClass(id, name) {\n\t// 继承构造函数中的属性和方法\n\tSupClass.call(this, id);\n\tthis.name = name;\n}\n// 继承所有属性和方法\nSubClass.prototype = new SuperClass();\nSubClass.prototype.contructor = SubClass;\n```\n结合了类式继承和构造函数继承的优点，去除了两者的缺点。唯一的缺点就是在子类中执行了SupClass()，在子类原型中又执行了SupClass()。\n\n### 4.直接继承prototype\n```javascript\n// 同上\n... ...\n// 继承原型中的属性和方法\nSubClass.prototype = SuperClass.prototype;\nSubClass.prototype.contructor = SubClass;\n```\n既然在子类中构造函数的属性和方法已经被继承了，所以子类的原型中只需要继承父类的原型。缺点是SubClass.prototype和SupClass.prototype指向同一对象，修改会互相影响。\n\n### 5.利用空对象继承prototype\n```javascript\n// 同上\n... ...\n// 在空对象中复制一份父类的原型\nvar O = function(){};\nO.prototype = SuperClass.prototype;\n// 继承原型中的属性和方法\nSubClass.prototype = new O();\nSubClass.prototype.contructor = SubClass;\n```\n基于3.的修改，执行两次SupClass()消耗资源，执行空对象，消耗资源就会大大减少。\n\n### 6.拷贝继承\n拷贝就是将父类的属性和方法拷贝到子类中，拷贝可以是浅拷贝和深拷贝。拷贝可以实现多继承。\n\n----------------\n　　　　-------来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢","slug":"面向对象的javascript(继承)","published":1,"updated":"2016-08-14T13:42:10.000Z","layout":"post","photos":[],"link":"","_id":"ciw3mfwco00240kc7mntkiajb","content":"<p>　　继承就是从已有的类(对象)派生出新的类(对象)，新的类(对象)会拥有父类的所有属性和方法，并可以添加或修改属性和方法。</p>\n<hr>\n<h3 id=\"1-类式继承-prototype模式\"><a href=\"#1-类式继承-prototype模式\" class=\"headerlink\" title=\"1.类式继承(prototype模式)\"></a>1.类式继承(prototype模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 父类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupClass</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.superValue = <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">SuperClass.prototype = &#123;</div><div class=\"line\">\tgetSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.superValue;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 子类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.subValue = <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 通过原型链实现继承</span></div><div class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> SuperClass();</div><div class=\"line\"><span class=\"comment\">// 修正constructor的指向</span></div><div class=\"line\">SubClass.prototype.contructor = SubClass;</div><div class=\"line\"><span class=\"comment\">// 子类添加公有方法</span></div><div class=\"line\">SubClass.prototype.getSubValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>将父类实例赋值给子类的prototype，子类就能通过原型链来访问到父类中的属性以及方法。缺点是因为子类是通过原型链继承父类的，所以多个实例化的子类中包含的父类属性和方法其实是一份，其中一个修改，其他会受到影响。另外是实例化无法传递参数。</p>\n<h3 id=\"2-构造函数继承\"><a href=\"#2-构造函数继承\" class=\"headerlink\" title=\"2.构造函数继承\"></a>2.构造函数继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 父类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupClass</span>(<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.superValue = <span class=\"literal\">true</span>;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">&#125;</div><div class=\"line\">SuperClass.prototype = &#123;</div><div class=\"line\">\tgetSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.superValue;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 子类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">id, name</span>) </span>&#123;</div><div class=\"line\">\tSupClass.call(<span class=\"keyword\">this</span>, id);</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过call或apply函数修改父类中的this指向，可以实现参数的传递。缺点是只能继承构造函数中的属性(即this指向的属性和方法)，原型链得不到继承。</p>\n<h3 id=\"3-组合继承\"><a href=\"#3-组合继承\" class=\"headerlink\" title=\"3.组合继承\"></a>3.组合继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 父类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupClass</span>(<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.superValue = <span class=\"literal\">true</span>;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">&#125;</div><div class=\"line\">SuperClass.prototype = &#123;</div><div class=\"line\">\tgetSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.superValue;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 子类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">id, name</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 继承构造函数中的属性和方法</span></div><div class=\"line\">\tSupClass.call(<span class=\"keyword\">this</span>, id);</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 继承所有属性和方法</span></div><div class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> SuperClass();</div><div class=\"line\">SubClass.prototype.contructor = SubClass;</div></pre></td></tr></table></figure>\n<p>结合了类式继承和构造函数继承的优点，去除了两者的缺点。唯一的缺点就是在子类中执行了SupClass()，在子类原型中又执行了SupClass()。</p>\n<h3 id=\"4-直接继承prototype\"><a href=\"#4-直接继承prototype\" class=\"headerlink\" title=\"4.直接继承prototype\"></a>4.直接继承prototype</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 同上</span></div><div class=\"line\">... ...</div><div class=\"line\"><span class=\"comment\">// 继承原型中的属性和方法</span></div><div class=\"line\">SubClass.prototype = SuperClass.prototype;</div><div class=\"line\">SubClass.prototype.contructor = SubClass;</div></pre></td></tr></table></figure>\n<p>既然在子类中构造函数的属性和方法已经被继承了，所以子类的原型中只需要继承父类的原型。缺点是SubClass.prototype和SupClass.prototype指向同一对象，修改会互相影响。</p>\n<h3 id=\"5-利用空对象继承prototype\"><a href=\"#5-利用空对象继承prototype\" class=\"headerlink\" title=\"5.利用空对象继承prototype\"></a>5.利用空对象继承prototype</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 同上</span></div><div class=\"line\">... ...</div><div class=\"line\"><span class=\"comment\">// 在空对象中复制一份父类的原型</span></div><div class=\"line\"><span class=\"keyword\">var</span> O = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">O.prototype = SuperClass.prototype;</div><div class=\"line\"><span class=\"comment\">// 继承原型中的属性和方法</span></div><div class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> O();</div><div class=\"line\">SubClass.prototype.contructor = SubClass;</div></pre></td></tr></table></figure>\n<p>基于3.的修改，执行两次SupClass()消耗资源，执行空对象，消耗资源就会大大减少。</p>\n<h3 id=\"6-拷贝继承\"><a href=\"#6-拷贝继承\" class=\"headerlink\" title=\"6.拷贝继承\"></a>6.拷贝继承</h3><p>拷贝就是将父类的属性和方法拷贝到子类中，拷贝可以是浅拷贝和深拷贝。拷贝可以实现多继承。</p>\n<hr>\n<p>　　　　——-来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢</p>\n","excerpt":"","more":"<p>　　继承就是从已有的类(对象)派生出新的类(对象)，新的类(对象)会拥有父类的所有属性和方法，并可以添加或修改属性和方法。</p>\n<hr>\n<h3 id=\"1-类式继承-prototype模式\"><a href=\"#1-类式继承-prototype模式\" class=\"headerlink\" title=\"1.类式继承(prototype模式)\"></a>1.类式继承(prototype模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 父类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupClass</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.superValue = <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">SuperClass.prototype = &#123;</div><div class=\"line\">\tgetSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.superValue;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 子类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.subValue = <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 通过原型链实现继承</span></div><div class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> SuperClass();</div><div class=\"line\"><span class=\"comment\">// 修正constructor的指向</span></div><div class=\"line\">SubClass.prototype.contructor = SubClass;</div><div class=\"line\"><span class=\"comment\">// 子类添加公有方法</span></div><div class=\"line\">SubClass.prototype.getSubValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>将父类实例赋值给子类的prototype，子类就能通过原型链来访问到父类中的属性以及方法。缺点是因为子类是通过原型链继承父类的，所以多个实例化的子类中包含的父类属性和方法其实是一份，其中一个修改，其他会受到影响。另外是实例化无法传递参数。</p>\n<h3 id=\"2-构造函数继承\"><a href=\"#2-构造函数继承\" class=\"headerlink\" title=\"2.构造函数继承\"></a>2.构造函数继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 父类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupClass</span>(<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.superValue = <span class=\"literal\">true</span>;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">&#125;</div><div class=\"line\">SuperClass.prototype = &#123;</div><div class=\"line\">\tgetSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.superValue;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 子类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">id, name</span>) </span>&#123;</div><div class=\"line\">\tSupClass.call(<span class=\"keyword\">this</span>, id);</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过call或apply函数修改父类中的this指向，可以实现参数的传递。缺点是只能继承构造函数中的属性(即this指向的属性和方法)，原型链得不到继承。</p>\n<h3 id=\"3-组合继承\"><a href=\"#3-组合继承\" class=\"headerlink\" title=\"3.组合继承\"></a>3.组合继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 父类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupClass</span>(<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.superValue = <span class=\"literal\">true</span>;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">&#125;</div><div class=\"line\">SuperClass.prototype = &#123;</div><div class=\"line\">\tgetSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.superValue;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 子类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">id, name</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 继承构造函数中的属性和方法</span></div><div class=\"line\">\tSupClass.call(<span class=\"keyword\">this</span>, id);</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 继承所有属性和方法</span></div><div class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> SuperClass();</div><div class=\"line\">SubClass.prototype.contructor = SubClass;</div></pre></td></tr></table></figure>\n<p>结合了类式继承和构造函数继承的优点，去除了两者的缺点。唯一的缺点就是在子类中执行了SupClass()，在子类原型中又执行了SupClass()。</p>\n<h3 id=\"4-直接继承prototype\"><a href=\"#4-直接继承prototype\" class=\"headerlink\" title=\"4.直接继承prototype\"></a>4.直接继承prototype</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 同上</span></div><div class=\"line\">... ...</div><div class=\"line\"><span class=\"comment\">// 继承原型中的属性和方法</span></div><div class=\"line\">SubClass.prototype = SuperClass.prototype;</div><div class=\"line\">SubClass.prototype.contructor = SubClass;</div></pre></td></tr></table></figure>\n<p>既然在子类中构造函数的属性和方法已经被继承了，所以子类的原型中只需要继承父类的原型。缺点是SubClass.prototype和SupClass.prototype指向同一对象，修改会互相影响。</p>\n<h3 id=\"5-利用空对象继承prototype\"><a href=\"#5-利用空对象继承prototype\" class=\"headerlink\" title=\"5.利用空对象继承prototype\"></a>5.利用空对象继承prototype</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 同上</span></div><div class=\"line\">... ...</div><div class=\"line\"><span class=\"comment\">// 在空对象中复制一份父类的原型</span></div><div class=\"line\"><span class=\"keyword\">var</span> O = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">O.prototype = SuperClass.prototype;</div><div class=\"line\"><span class=\"comment\">// 继承原型中的属性和方法</span></div><div class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> O();</div><div class=\"line\">SubClass.prototype.contructor = SubClass;</div></pre></td></tr></table></figure>\n<p>基于3.的修改，执行两次SupClass()消耗资源，执行空对象，消耗资源就会大大减少。</p>\n<h3 id=\"6-拷贝继承\"><a href=\"#6-拷贝继承\" class=\"headerlink\" title=\"6.拷贝继承\"></a>6.拷贝继承</h3><p>拷贝就是将父类的属性和方法拷贝到子类中，拷贝可以是浅拷贝和深拷贝。拷贝可以实现多继承。</p>\n<hr>\n<p>　　　　——-来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢</p>\n"},{"title":"面向对象的javascript(封装)","date":"2016-06-17T12:23:00.000Z","comments":1,"_content":"\n　　面向对象的基本特征：封装、继承、多态。\n　　封装就是把对象的属性和方法结合成在一些，也可以隐藏对象的属性和实现细节，所以封装后的对象一般有私有属性、私有方法、公有属性、公有方法等。\n\n--------------------\n\n### 1.最初的javascript代码是这样的\n```javascript\nfunction checkName() {\n\t\n}\nfunction checkEmail() {\n\t\n}\nfunction checkPassword() {\n\t\n}\n```\n调用时候，直接使用函数名checkName()。这样编写相当于创建多个全局变量：checkName、checkEmail、checkPassword。\n\n### 2.使用对象封装(原始模式)\n```javascript\nvar CheckObject = {\n\tcheckName: function() {\n\n\t},\n\tcheckEmail: function() {\n\n\t},\n\tcheckPassword: function() {\n\n\t}\n};\n```\n调用时，通过对象名调用，CheckObject.checkName()。缺点是只能够通过CheckObject使用，不能生成新的实例。\n\n### 3.返回新的对象(原始模式改进)\n```javascript\nvar CheckObject = function() {\n\treturn {\n\t\tcheckName: function() {\n\n\t\t},\n\t\tcheckEmail: function() {\n\n\t\t},\n\t\tcheckPassword: function() {\n\n\t\t}\n\t}\n};\n```\n调用方式\n```javascript\nvar a = CheckObject();\na.checkName();\n```\n每次调用CHeckObject都会产生新的对象，这样每个人在使用的时候互相之间不会影响，但是新生成的实例与实例之间没有关联，与CheckObject也没有关联。\n\n### 4.new操作符，能将方法中this指向新的实例(构造函数模式)\n```javascript\nvar CheckObject = function() {\n\tthis.checkName = function() {\n\n\t};\n\tthis.checkEmail = function() {\n\n\t};\n\tthis.checkPassword = function() {\n\n\t};\n};\n```\n调用方式\n```javascript\nvar a = new CheckObject();\na.checkName();\n```\n所有通过new生成的实例对象，都包含constructor属性，这个属性都会指向CheckObject。`a.constructor == CHeckObject`每个新生成的实例中都会包含checkName、checkEmail、checkPassword方法，这些方法都是相同的，可以通过原型链保存在prototype属性中，这样这些方法就只会存储一遍。\n\tps: new首先会创建一个空的对象。然后将新对象的_proto_指向调用函数的prototype属性。 最后将调用函数中的所有this指向新对象。\n\n### 5.利用prototype节省内存(prototype模式)\n```javascript\nvar CheckObject = function() {\n\t\n};\nCheckObject.prototype = {\n\tcheckName: function() {\n\n\t\treturn this;  //链式使用\n\t},\n\tcheckEmail: function() {\n\n\t\treturn this; //链式使用\n\t}，\n\tcheckPassword: function() {\n\n\t\treturn this; //链式使用\n\t}\n};\n```\n调用方法与4.相同。\n\n### 6.更像一个类\n```javascript\nvar Book = function(id, name, price) {\n\t// 私有属性  (外界不能直接访问、调用)\n\tvar num = 0;\n\t// 私有方法\n\tfunction checkId() {}\n\t// 对象公有属性  (对象可以访问、调用)\n\tthis.id = id;\n\t// 特权方法  (对象可以访问、调用，并且操作私有属性、方法)\n\tthis.getName = function() {};\n\tthis.setName = function() {};\n\tthis.getPrice = function() {};\n\tthis.setPrice = function() {};\n};\n// 类静态公有属性  (类可以访问、调用)\nBook.isChinese = true;\n// 类静态公有方法\nBook.resetTime = function() {};\nBook.prototype = {\n\t// 静态公有属性  (对象可以访问、调用，并且只保存一份)\n\tisJSBook: false,\n\t// 静态公有方法\n\tdisplay: function() {}\n};\n```\n\n### 7.利用闭包来实现\n```javascript\nvar Book = (function() {\n\t// 静态私有\n\tvar bookNum = 0;\n\tfunction checkBook() {};\n\t// 创建类\n\tfunction _book(id, name, price) {\n\t\t// 私有\n\t\tvar name,price;\n\t\tfunction checkID(){}\n\t\tthis.sayNum = function() {\n\t\t\tconsole.log(bookNum);\n\t\t};\n\t\tthis.setNum = function(number) {\n\t\t\tbookNum = number;\n\t\t};\n\t\t// 公有\n\t\tthis.id = id;\n\t\t// 特权方法\n\t\tthis.getName = function(){};\n\t\tthis.setName = function(){};\n\t\tthis.getPrice = function(){};\n\t\tthis.setPrice = function(){};\n\t}\n\t_book.prototype = {\n\t\t// 静态公有\n\t\tisJSBook: true,\n\t\tdisplay: function(){}\n\t};\n\treturn _book;\n})();\n```\n\tps: 静态私有变量只存在一份，如果通过创建类中的特权方法修改静态私有变量，所有对象实例中的此静态私有变量都会改变。(闭包)\n\t在6.中通过特权方法修改私有变量，其他对象中的私有变量，不会改变。\n\t这个，怎么理解呢？回头还需要研究下。\n\n### 8.创建对象的安全模式\n在创建实例对象的时候，如果没有使用new操作符，会造成this指向的是全局环境，在浏览器中也就是window对象。为了避免这种情况，可以使用instanceof来检测。\n```javascript\nvar Book = function(id, name, price) {\n\tif(this instanceof Book) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.price = price;\n\t} else  {\n\t\treturn new Book(id, name, price);\n\t}\n}\n```\n----------------\n　　　　-------来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢","source":"_posts/面向对象的javascript.md","raw":"---\ntitle: 面向对象的javascript(封装)\ndate: 2016-06-17 20:23\ntags: [javascript,面向对象]\ncategories: \n- javascript\ncomments: true\n---\n\n　　面向对象的基本特征：封装、继承、多态。\n　　封装就是把对象的属性和方法结合成在一些，也可以隐藏对象的属性和实现细节，所以封装后的对象一般有私有属性、私有方法、公有属性、公有方法等。\n\n--------------------\n\n### 1.最初的javascript代码是这样的\n```javascript\nfunction checkName() {\n\t\n}\nfunction checkEmail() {\n\t\n}\nfunction checkPassword() {\n\t\n}\n```\n调用时候，直接使用函数名checkName()。这样编写相当于创建多个全局变量：checkName、checkEmail、checkPassword。\n\n### 2.使用对象封装(原始模式)\n```javascript\nvar CheckObject = {\n\tcheckName: function() {\n\n\t},\n\tcheckEmail: function() {\n\n\t},\n\tcheckPassword: function() {\n\n\t}\n};\n```\n调用时，通过对象名调用，CheckObject.checkName()。缺点是只能够通过CheckObject使用，不能生成新的实例。\n\n### 3.返回新的对象(原始模式改进)\n```javascript\nvar CheckObject = function() {\n\treturn {\n\t\tcheckName: function() {\n\n\t\t},\n\t\tcheckEmail: function() {\n\n\t\t},\n\t\tcheckPassword: function() {\n\n\t\t}\n\t}\n};\n```\n调用方式\n```javascript\nvar a = CheckObject();\na.checkName();\n```\n每次调用CHeckObject都会产生新的对象，这样每个人在使用的时候互相之间不会影响，但是新生成的实例与实例之间没有关联，与CheckObject也没有关联。\n\n### 4.new操作符，能将方法中this指向新的实例(构造函数模式)\n```javascript\nvar CheckObject = function() {\n\tthis.checkName = function() {\n\n\t};\n\tthis.checkEmail = function() {\n\n\t};\n\tthis.checkPassword = function() {\n\n\t};\n};\n```\n调用方式\n```javascript\nvar a = new CheckObject();\na.checkName();\n```\n所有通过new生成的实例对象，都包含constructor属性，这个属性都会指向CheckObject。`a.constructor == CHeckObject`每个新生成的实例中都会包含checkName、checkEmail、checkPassword方法，这些方法都是相同的，可以通过原型链保存在prototype属性中，这样这些方法就只会存储一遍。\n\tps: new首先会创建一个空的对象。然后将新对象的_proto_指向调用函数的prototype属性。 最后将调用函数中的所有this指向新对象。\n\n### 5.利用prototype节省内存(prototype模式)\n```javascript\nvar CheckObject = function() {\n\t\n};\nCheckObject.prototype = {\n\tcheckName: function() {\n\n\t\treturn this;  //链式使用\n\t},\n\tcheckEmail: function() {\n\n\t\treturn this; //链式使用\n\t}，\n\tcheckPassword: function() {\n\n\t\treturn this; //链式使用\n\t}\n};\n```\n调用方法与4.相同。\n\n### 6.更像一个类\n```javascript\nvar Book = function(id, name, price) {\n\t// 私有属性  (外界不能直接访问、调用)\n\tvar num = 0;\n\t// 私有方法\n\tfunction checkId() {}\n\t// 对象公有属性  (对象可以访问、调用)\n\tthis.id = id;\n\t// 特权方法  (对象可以访问、调用，并且操作私有属性、方法)\n\tthis.getName = function() {};\n\tthis.setName = function() {};\n\tthis.getPrice = function() {};\n\tthis.setPrice = function() {};\n};\n// 类静态公有属性  (类可以访问、调用)\nBook.isChinese = true;\n// 类静态公有方法\nBook.resetTime = function() {};\nBook.prototype = {\n\t// 静态公有属性  (对象可以访问、调用，并且只保存一份)\n\tisJSBook: false,\n\t// 静态公有方法\n\tdisplay: function() {}\n};\n```\n\n### 7.利用闭包来实现\n```javascript\nvar Book = (function() {\n\t// 静态私有\n\tvar bookNum = 0;\n\tfunction checkBook() {};\n\t// 创建类\n\tfunction _book(id, name, price) {\n\t\t// 私有\n\t\tvar name,price;\n\t\tfunction checkID(){}\n\t\tthis.sayNum = function() {\n\t\t\tconsole.log(bookNum);\n\t\t};\n\t\tthis.setNum = function(number) {\n\t\t\tbookNum = number;\n\t\t};\n\t\t// 公有\n\t\tthis.id = id;\n\t\t// 特权方法\n\t\tthis.getName = function(){};\n\t\tthis.setName = function(){};\n\t\tthis.getPrice = function(){};\n\t\tthis.setPrice = function(){};\n\t}\n\t_book.prototype = {\n\t\t// 静态公有\n\t\tisJSBook: true,\n\t\tdisplay: function(){}\n\t};\n\treturn _book;\n})();\n```\n\tps: 静态私有变量只存在一份，如果通过创建类中的特权方法修改静态私有变量，所有对象实例中的此静态私有变量都会改变。(闭包)\n\t在6.中通过特权方法修改私有变量，其他对象中的私有变量，不会改变。\n\t这个，怎么理解呢？回头还需要研究下。\n\n### 8.创建对象的安全模式\n在创建实例对象的时候，如果没有使用new操作符，会造成this指向的是全局环境，在浏览器中也就是window对象。为了避免这种情况，可以使用instanceof来检测。\n```javascript\nvar Book = function(id, name, price) {\n\tif(this instanceof Book) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.price = price;\n\t} else  {\n\t\treturn new Book(id, name, price);\n\t}\n}\n```\n----------------\n　　　　-------来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢","slug":"面向对象的javascript","published":1,"updated":"2016-08-14T13:42:18.000Z","layout":"post","photos":[],"link":"","_id":"ciw3mfwco00260kc75hle3972","content":"<p>　　面向对象的基本特征：封装、继承、多态。<br>　　封装就是把对象的属性和方法结合成在一些，也可以隐藏对象的属性和实现细节，所以封装后的对象一般有私有属性、私有方法、公有属性、公有方法等。</p>\n<hr>\n<h3 id=\"1-最初的javascript代码是这样的\"><a href=\"#1-最初的javascript代码是这样的\" class=\"headerlink\" title=\"1.最初的javascript代码是这样的\"></a>1.最初的javascript代码是这样的</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkName</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkEmail</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkPassword</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用时候，直接使用函数名checkName()。这样编写相当于创建多个全局变量：checkName、checkEmail、checkPassword。</p>\n<h3 id=\"2-使用对象封装-原始模式\"><a href=\"#2-使用对象封装-原始模式\" class=\"headerlink\" title=\"2.使用对象封装(原始模式)\"></a>2.使用对象封装(原始模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = &#123;</div><div class=\"line\">\t<span class=\"attr\">checkName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">checkEmail</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">checkPassword</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>调用时，通过对象名调用，CheckObject.checkName()。缺点是只能够通过CheckObject使用，不能生成新的实例。</p>\n<h3 id=\"3-返回新的对象-原始模式改进\"><a href=\"#3-返回新的对象-原始模式改进\" class=\"headerlink\" title=\"3.返回新的对象(原始模式改进)\"></a>3.返回新的对象(原始模式改进)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t<span class=\"attr\">checkName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">checkEmail</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">checkPassword</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>调用方式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = CheckObject();</div><div class=\"line\">a.checkName();</div></pre></td></tr></table></figure></p>\n<p>每次调用CHeckObject都会产生新的对象，这样每个人在使用的时候互相之间不会影响，但是新生成的实例与实例之间没有关联，与CheckObject也没有关联。</p>\n<h3 id=\"4-new操作符，能将方法中this指向新的实例-构造函数模式\"><a href=\"#4-new操作符，能将方法中this指向新的实例-构造函数模式\" class=\"headerlink\" title=\"4.new操作符，能将方法中this指向新的实例(构造函数模式)\"></a>4.new操作符，能将方法中this指向新的实例(构造函数模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.checkName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.checkEmail = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.checkPassword = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>调用方式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> CheckObject();</div><div class=\"line\">a.checkName();</div></pre></td></tr></table></figure></p>\n<p>所有通过new生成的实例对象，都包含constructor属性，这个属性都会指向CheckObject。<code>a.constructor == CHeckObject</code>每个新生成的实例中都会包含checkName、checkEmail、checkPassword方法，这些方法都是相同的，可以通过原型链保存在prototype属性中，这样这些方法就只会存储一遍。<br>    ps: new首先会创建一个空的对象。然后将新对象的<em>proto</em>指向调用函数的prototype属性。 最后将调用函数中的所有this指向新对象。</p>\n<h3 id=\"5-利用prototype节省内存-prototype模式\"><a href=\"#5-利用prototype节省内存-prototype模式\" class=\"headerlink\" title=\"5.利用prototype节省内存(prototype模式)\"></a>5.利用prototype节省内存(prototype模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;;</div><div class=\"line\">CheckObject.prototype = &#123;</div><div class=\"line\">\t<span class=\"attr\">checkName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  <span class=\"comment\">//链式使用</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">checkEmail</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; <span class=\"comment\">//链式使用</span></div><div class=\"line\">\t&#125;，</div><div class=\"line\">\tcheckPassword: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; <span class=\"comment\">//链式使用</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>调用方法与4.相同。</p>\n<h3 id=\"6-更像一个类\"><a href=\"#6-更像一个类\" class=\"headerlink\" title=\"6.更像一个类\"></a>6.更像一个类</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Book = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, name, price</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 私有属性  (外界不能直接访问、调用)</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> num = <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"comment\">// 私有方法</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkId</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">\t<span class=\"comment\">// 对象公有属性  (对象可以访问、调用)</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">\t<span class=\"comment\">// 特权方法  (对象可以访问、调用，并且操作私有属性、方法)</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.getPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.setPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 类静态公有属性  (类可以访问、调用)</span></div><div class=\"line\">Book.isChinese = <span class=\"literal\">true</span>;</div><div class=\"line\"><span class=\"comment\">// 类静态公有方法</span></div><div class=\"line\">Book.resetTime = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">Book.prototype = &#123;</div><div class=\"line\">\t<span class=\"comment\">// 静态公有属性  (对象可以访问、调用，并且只保存一份)</span></div><div class=\"line\">\tisJSBook: <span class=\"literal\">false</span>,</div><div class=\"line\">\t<span class=\"comment\">// 静态公有方法</span></div><div class=\"line\">\tdisplay: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"7-利用闭包来实现\"><a href=\"#7-利用闭包来实现\" class=\"headerlink\" title=\"7.利用闭包来实现\"></a>7.利用闭包来实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Book = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 静态私有</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> bookNum = <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkBook</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">\t<span class=\"comment\">// 创建类</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_book</span>(<span class=\"params\">id, name, price</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 私有</span></div><div class=\"line\">\t\t<span class=\"keyword\">var</span> name,price;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkID</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.sayNum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(bookNum);</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.setNum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">number</span>) </span>&#123;</div><div class=\"line\">\t\t\tbookNum = number;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\t<span class=\"comment\">// 公有</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">\t\t<span class=\"comment\">// 特权方法</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.getPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.setPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t_book.prototype = &#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 静态公有</span></div><div class=\"line\">\t\tisJSBook: <span class=\"literal\">true</span>,</div><div class=\"line\">\t\t<span class=\"attr\">display</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">return</span> _book;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<pre><code>ps: 静态私有变量只存在一份，如果通过创建类中的特权方法修改静态私有变量，所有对象实例中的此静态私有变量都会改变。(闭包)\n在6.中通过特权方法修改私有变量，其他对象中的私有变量，不会改变。\n这个，怎么理解呢？回头还需要研究下。\n</code></pre><h3 id=\"8-创建对象的安全模式\"><a href=\"#8-创建对象的安全模式\" class=\"headerlink\" title=\"8.创建对象的安全模式\"></a>8.创建对象的安全模式</h3><p>在创建实例对象的时候，如果没有使用new操作符，会造成this指向的是全局环境，在浏览器中也就是window对象。为了避免这种情况，可以使用instanceof来检测。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Book = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, name, price</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> Book) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.price = price;</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span>  &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Book(id, name, price);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<p>　　　　——-来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢</p>\n","excerpt":"","more":"<p>　　面向对象的基本特征：封装、继承、多态。<br>　　封装就是把对象的属性和方法结合成在一些，也可以隐藏对象的属性和实现细节，所以封装后的对象一般有私有属性、私有方法、公有属性、公有方法等。</p>\n<hr>\n<h3 id=\"1-最初的javascript代码是这样的\"><a href=\"#1-最初的javascript代码是这样的\" class=\"headerlink\" title=\"1.最初的javascript代码是这样的\"></a>1.最初的javascript代码是这样的</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkName</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkEmail</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkPassword</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用时候，直接使用函数名checkName()。这样编写相当于创建多个全局变量：checkName、checkEmail、checkPassword。</p>\n<h3 id=\"2-使用对象封装-原始模式\"><a href=\"#2-使用对象封装-原始模式\" class=\"headerlink\" title=\"2.使用对象封装(原始模式)\"></a>2.使用对象封装(原始模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = &#123;</div><div class=\"line\">\t<span class=\"attr\">checkName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">checkEmail</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">checkPassword</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>调用时，通过对象名调用，CheckObject.checkName()。缺点是只能够通过CheckObject使用，不能生成新的实例。</p>\n<h3 id=\"3-返回新的对象-原始模式改进\"><a href=\"#3-返回新的对象-原始模式改进\" class=\"headerlink\" title=\"3.返回新的对象(原始模式改进)\"></a>3.返回新的对象(原始模式改进)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t<span class=\"attr\">checkName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">checkEmail</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">checkPassword</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>调用方式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = CheckObject();</div><div class=\"line\">a.checkName();</div></pre></td></tr></table></figure></p>\n<p>每次调用CHeckObject都会产生新的对象，这样每个人在使用的时候互相之间不会影响，但是新生成的实例与实例之间没有关联，与CheckObject也没有关联。</p>\n<h3 id=\"4-new操作符，能将方法中this指向新的实例-构造函数模式\"><a href=\"#4-new操作符，能将方法中this指向新的实例-构造函数模式\" class=\"headerlink\" title=\"4.new操作符，能将方法中this指向新的实例(构造函数模式)\"></a>4.new操作符，能将方法中this指向新的实例(构造函数模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.checkName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.checkEmail = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.checkPassword = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>调用方式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> CheckObject();</div><div class=\"line\">a.checkName();</div></pre></td></tr></table></figure></p>\n<p>所有通过new生成的实例对象，都包含constructor属性，这个属性都会指向CheckObject。<code>a.constructor == CHeckObject</code>每个新生成的实例中都会包含checkName、checkEmail、checkPassword方法，这些方法都是相同的，可以通过原型链保存在prototype属性中，这样这些方法就只会存储一遍。<br>    ps: new首先会创建一个空的对象。然后将新对象的<em>proto</em>指向调用函数的prototype属性。 最后将调用函数中的所有this指向新对象。</p>\n<h3 id=\"5-利用prototype节省内存-prototype模式\"><a href=\"#5-利用prototype节省内存-prototype模式\" class=\"headerlink\" title=\"5.利用prototype节省内存(prototype模式)\"></a>5.利用prototype节省内存(prototype模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;;</div><div class=\"line\">CheckObject.prototype = &#123;</div><div class=\"line\">\t<span class=\"attr\">checkName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  <span class=\"comment\">//链式使用</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">checkEmail</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; <span class=\"comment\">//链式使用</span></div><div class=\"line\">\t&#125;，</div><div class=\"line\">\tcheckPassword: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; <span class=\"comment\">//链式使用</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>调用方法与4.相同。</p>\n<h3 id=\"6-更像一个类\"><a href=\"#6-更像一个类\" class=\"headerlink\" title=\"6.更像一个类\"></a>6.更像一个类</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Book = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, name, price</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 私有属性  (外界不能直接访问、调用)</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> num = <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"comment\">// 私有方法</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkId</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">\t<span class=\"comment\">// 对象公有属性  (对象可以访问、调用)</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">\t<span class=\"comment\">// 特权方法  (对象可以访问、调用，并且操作私有属性、方法)</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.getPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.setPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 类静态公有属性  (类可以访问、调用)</span></div><div class=\"line\">Book.isChinese = <span class=\"literal\">true</span>;</div><div class=\"line\"><span class=\"comment\">// 类静态公有方法</span></div><div class=\"line\">Book.resetTime = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">Book.prototype = &#123;</div><div class=\"line\">\t<span class=\"comment\">// 静态公有属性  (对象可以访问、调用，并且只保存一份)</span></div><div class=\"line\">\tisJSBook: <span class=\"literal\">false</span>,</div><div class=\"line\">\t<span class=\"comment\">// 静态公有方法</span></div><div class=\"line\">\tdisplay: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"7-利用闭包来实现\"><a href=\"#7-利用闭包来实现\" class=\"headerlink\" title=\"7.利用闭包来实现\"></a>7.利用闭包来实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Book = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 静态私有</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> bookNum = <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkBook</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">\t<span class=\"comment\">// 创建类</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_book</span>(<span class=\"params\">id, name, price</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 私有</span></div><div class=\"line\">\t\t<span class=\"keyword\">var</span> name,price;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkID</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.sayNum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(bookNum);</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.setNum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">number</span>) </span>&#123;</div><div class=\"line\">\t\t\tbookNum = number;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\t<span class=\"comment\">// 公有</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">\t\t<span class=\"comment\">// 特权方法</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.getPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.setPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t_book.prototype = &#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 静态公有</span></div><div class=\"line\">\t\tisJSBook: <span class=\"literal\">true</span>,</div><div class=\"line\">\t\t<span class=\"attr\">display</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">return</span> _book;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<pre><code>ps: 静态私有变量只存在一份，如果通过创建类中的特权方法修改静态私有变量，所有对象实例中的此静态私有变量都会改变。(闭包)\n在6.中通过特权方法修改私有变量，其他对象中的私有变量，不会改变。\n这个，怎么理解呢？回头还需要研究下。\n</code></pre><h3 id=\"8-创建对象的安全模式\"><a href=\"#8-创建对象的安全模式\" class=\"headerlink\" title=\"8.创建对象的安全模式\"></a>8.创建对象的安全模式</h3><p>在创建实例对象的时候，如果没有使用new操作符，会造成this指向的是全局环境，在浏览器中也就是window对象。为了避免这种情况，可以使用instanceof来检测。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Book = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, name, price</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> Book) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.price = price;</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span>  &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Book(id, name, price);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<p>　　　　——-来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ciw3mfvsc00010kc77o1n4si2","category_id":"ciw3mfvsr00030kc7l6awsews","_id":"ciw3mfvt7000c0kc7frg6znuh"},{"post_id":"ciw3mfvsr00020kc7mg5lw70m","category_id":"ciw3mfvt700080kc724voed2f","_id":"ciw3mfvt7000j0kc7h4k0yakd"},{"post_id":"ciw3mfvt7000g0kc7pue7z6nk","category_id":"ciw3mfvt700080kc724voed2f","_id":"ciw3mfvtn000o0kc7l0n3iihg"},{"post_id":"ciw3mfvsr00060kc7hqqteqzw","category_id":"ciw3mfvt700080kc724voed2f","_id":"ciw3mfvtn000q0kc7elxdkcvv"},{"post_id":"ciw3mfvt7000i0kc72xi7ken2","category_id":"ciw3mfvt700080kc724voed2f","_id":"ciw3mfvtn000v0kc7ccgsy7p4"},{"post_id":"ciw3mfvt7000m0kc7uq6a554c","category_id":"ciw3mfvsr00030kc7l6awsews","_id":"ciw3mfvtn000x0kc7e8n4hu2h"},{"post_id":"ciw3mfvsr00070kc73gzz189a","category_id":"ciw3mfvt700080kc724voed2f","_id":"ciw3mfvu200100kc7f8mntapi"},{"post_id":"ciw3mfvtn000w0kc7pqtazkjm","category_id":"ciw3mfvt700080kc724voed2f","_id":"ciw3mfvu200140kc7fwvnp71v"},{"post_id":"ciw3mfvtn000y0kc7w3mzyhnh","category_id":"ciw3mfvtn000u0kc76bg4vgoy","_id":"ciw3mfvu200180kc7hn9qo2fk"},{"post_id":"ciw3mfvtn000p0kc707nwblxm","category_id":"ciw3mfvtn000u0kc76bg4vgoy","_id":"ciw3mfvu2001b0kc7f8s6uslv"},{"post_id":"ciw3mfvu200120kc7l7hjzywz","category_id":"ciw3mfvt700080kc724voed2f","_id":"ciw3mfvu2001e0kc74hp3784d"},{"post_id":"ciw3mfvu200150kc7cby8p9um","category_id":"ciw3mfvu200130kc7wugl5782","_id":"ciw3mfvu2001h0kc7vyqsmbln"},{"post_id":"ciw3mfvtn000s0kc7iexrfqrm","category_id":"ciw3mfvu200130kc7wugl5782","_id":"ciw3mfvuk001k0kc7dv0w6ndn"},{"post_id":"ciw3mfvu200190kc783d844b3","category_id":"ciw3mfvu200130kc7wugl5782","_id":"ciw3mfvum001n0kc777sy4mte"},{"post_id":"ciw3mfvu2001c0kc7kv7r2cnd","category_id":"ciw3mfvtn000u0kc76bg4vgoy","_id":"ciw3mfvum001p0kc74gsee5lp"},{"post_id":"ciw3mfvu2001i0kc7zi37n21a","category_id":"ciw3mfvsr00030kc7l6awsews","_id":"ciw3mfvun001s0kc7mblqrxra"},{"post_id":"ciw3mfwco00230kc7bayg3v0k","category_id":"ciw3mfvsr00030kc7l6awsews","_id":"ciw3mfwco00270kc7rsugvsh6"},{"post_id":"ciw3mfwco00240kc7mntkiajb","category_id":"ciw3mfvt700080kc724voed2f","_id":"ciw3mfwco00280kc71v82zcgg"},{"post_id":"ciw3mfwco00260kc75hle3972","category_id":"ciw3mfvt700080kc724voed2f","_id":"ciw3mfwco002a0kc7br8tbx4r"}],"PostTag":[{"post_id":"ciw3mfvsc00010kc77o1n4si2","tag_id":"ciw3mfvsr00040kc7uwntlp5h","_id":"ciw3mfvt7000a0kc7dhuqqjsx"},{"post_id":"ciw3mfvsr00020kc7mg5lw70m","tag_id":"ciw3mfvt700090kc7sd78toz7","_id":"ciw3mfvt7000h0kc7bmiv9cid"},{"post_id":"ciw3mfvsr00060kc7hqqteqzw","tag_id":"ciw3mfvt7000f0kc7l2wrr8a6","_id":"ciw3mfvtn000n0kc7pk93hpl5"},{"post_id":"ciw3mfvsr00070kc73gzz189a","tag_id":"ciw3mfvt7000l0kc7thvo5msv","_id":"ciw3mfvtn000t0kc7qm59wp8l"},{"post_id":"ciw3mfvt7000g0kc7pue7z6nk","tag_id":"ciw3mfvtn000r0kc7jdmxd8s6","_id":"ciw3mfvu200110kc774mwc415"},{"post_id":"ciw3mfvu200120kc7l7hjzywz","tag_id":"ciw3mfvt700090kc7sd78toz7","_id":"ciw3mfvu200170kc7fdxhh2vb"},{"post_id":"ciw3mfvt7000i0kc72xi7ken2","tag_id":"ciw3mfvtn000z0kc7d5jl9up1","_id":"ciw3mfvu2001a0kc7zm1d67wp"},{"post_id":"ciw3mfvt7000m0kc7uq6a554c","tag_id":"ciw3mfvt700090kc7sd78toz7","_id":"ciw3mfvu2001g0kc7k02lk7b7"},{"post_id":"ciw3mfvt7000m0kc7uq6a554c","tag_id":"ciw3mfvu200160kc7o7edzgzl","_id":"ciw3mfvu2001j0kc7yj6l2m1e"},{"post_id":"ciw3mfvtn000p0kc707nwblxm","tag_id":"ciw3mfvu2001d0kc7hc6e25z0","_id":"ciw3mfvum001m0kc7v5d5n2jg"},{"post_id":"ciw3mfvtn000p0kc707nwblxm","tag_id":"ciw3mfvt700090kc7sd78toz7","_id":"ciw3mfvum001o0kc7gqml7hrk"},{"post_id":"ciw3mfvu2001i0kc7zi37n21a","tag_id":"ciw3mfvsr00040kc7uwntlp5h","_id":"ciw3mfvun001r0kc74xy14h1n"},{"post_id":"ciw3mfvtn000s0kc7iexrfqrm","tag_id":"ciw3mfvul001l0kc799m9tuzh","_id":"ciw3mfvun001t0kc7sdqo0b2k"},{"post_id":"ciw3mfvtn000w0kc7pqtazkjm","tag_id":"ciw3mfvun001q0kc70mt6emde","_id":"ciw3mfvuo001v0kc7qcyhtwa0"},{"post_id":"ciw3mfvtn000y0kc7w3mzyhnh","tag_id":"ciw3mfvuo001u0kc7uix7b1oq","_id":"ciw3mfvuo001y0kc7by8pbd8g"},{"post_id":"ciw3mfvtn000y0kc7w3mzyhnh","tag_id":"ciw3mfvuo001w0kc7c3p3hpie","_id":"ciw3mfvuo001z0kc7d18cqw3z"},{"post_id":"ciw3mfvu200150kc7cby8p9um","tag_id":"ciw3mfvul001l0kc799m9tuzh","_id":"ciw3mfvuo00210kc7cng3dog7"},{"post_id":"ciw3mfvu200190kc783d844b3","tag_id":"ciw3mfvul001l0kc799m9tuzh","_id":"ciw3mfvuo00220kc7qtxnf9oy"},{"post_id":"ciw3mfwco00230kc7bayg3v0k","tag_id":"ciw3mfwco00250kc718q1fbh4","_id":"ciw3mfwco002b0kc7f2d04kge"},{"post_id":"ciw3mfwco00240kc7mntkiajb","tag_id":"ciw3mfvt700090kc7sd78toz7","_id":"ciw3mfwco002d0kc7w27ngpo4"},{"post_id":"ciw3mfwco00240kc7mntkiajb","tag_id":"ciw3mfwco00290kc70r59xqb9","_id":"ciw3mfwco002e0kc79ayrasxl"},{"post_id":"ciw3mfwco00260kc75hle3972","tag_id":"ciw3mfvt700090kc7sd78toz7","_id":"ciw3mfwco002f0kc7b791r322"},{"post_id":"ciw3mfwco00260kc75hle3972","tag_id":"ciw3mfwco00290kc70r59xqb9","_id":"ciw3mfwco002g0kc7jmp7xaq4"}],"Tag":[{"name":"javascript H5","_id":"ciw3mfvsr00040kc7uwntlp5h"},{"name":"javascript","_id":"ciw3mfvt700090kc7sd78toz7"},{"name":"javascript React","_id":"ciw3mfvt7000f0kc7l2wrr8a6"},{"name":"javascript 移动Web","_id":"ciw3mfvt7000l0kc7thvo5msv"},{"name":"javascript React redux","_id":"ciw3mfvtn000r0kc7jdmxd8s6"},{"name":"javascript 项目经验","_id":"ciw3mfvtn000z0kc7d5jl9up1"},{"name":"H5","_id":"ciw3mfvu200160kc7o7edzgzl"},{"name":"面试","_id":"ciw3mfvu2001d0kc7hc6e25z0"},{"name":"javascript React Webpack","_id":"ciw3mfvul001l0kc799m9tuzh"},{"name":"javascript 构建工具 gulp","_id":"ciw3mfvun001q0kc70mt6emde"},{"name":"Hexo","_id":"ciw3mfvuo001u0kc7uix7b1oq"},{"name":"搭建博客","_id":"ciw3mfvuo001w0kc7c3p3hpie"},{"name":"javascript H5 微信分享","_id":"ciw3mfwco00250kc718q1fbh4"},{"name":"面向对象","_id":"ciw3mfwco00290kc70r59xqb9"}]}}