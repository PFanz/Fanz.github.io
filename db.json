{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":1,"renderable":0},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","path":"css/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/favicon.ico","hash":"7346009ac30c875e23c96d5a3fc4410b8e84f4ea","modified":1490153465000},{"_id":"themes/maupassant/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1487231107000},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1487229542000},{"_id":"themes/maupassant/LICENSE","hash":"019dc6a9aba02ae3aaabca45f39aecd6e8e7f1d8","modified":1487229542000},{"_id":"themes/maupassant/README.md","hash":"0b219f558d18afa89cbc14448f3a139dc79644b9","modified":1487231117000},{"_id":"themes/maupassant/_config.yml","hash":"85954635e5441cdf91ba839baf59ad3203985758","modified":1491985805000},{"_id":"themes/maupassant/package.json","hash":"81fb4e2ac051ecfb9a93f37b28910291b939771a","modified":1487229542000},{"_id":"source/apple-touch-icon.png","hash":"45e33af92dd42b3cf147ac82a6685d6067863775","modified":1490153549000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1489460454000},{"_id":"source/_posts/2016小结.md","hash":"e6fa0a234226e22fc52c6257dbce21011f6dd622","modified":1490146181000},{"_id":"source/_posts/ES6.md","hash":"6e5531ff8f816d272aa5c6c662d7b0fb151ea649","modified":1487227364000},{"_id":"source/_posts/H5页面.md","hash":"b26bc43d671588283294429eda128a1e2614259a","modified":1490146063000},{"_id":"source/_posts/LICENSE","hash":"c2b8384c44d2f6128c2280f3a9f57a400fbd2a70","modified":1487227364000},{"_id":"source/_posts/Promise总结.md","hash":"9fbe1f14f30dacef25d1098ee829184b0c3c20f1","modified":1490146075000},{"_id":"source/_posts/React Docs(1).md","hash":"212f54cd397ad8e26a42180d03569fa10d1d22af","modified":1490146084000},{"_id":"source/_posts/React Docs(2).md","hash":"4870eea6d62fd2c83e2ee337e6f1a05601cdddf1","modified":1490146091000},{"_id":"source/_posts/React Docs(3).md","hash":"46eddb81c30eab5509cd9dae652f7605149fd416","modified":1487230760000},{"_id":"source/_posts/React Router学习.md","hash":"24283768db4cd30d8474582f11fbf03e5ad378d4","modified":1490146107000},{"_id":"source/_posts/dva中的handleAction.md","hash":"b93c5baafc7b00cac49b199869b2369884994aec","modified":1490146431000},{"_id":"source/_posts/fixed移动端解决.md","hash":"f67592d58de4b80b321a714fbb45e5352d42d3d6","modified":1490146013000},{"_id":"source/_posts/gulp初次实践.md","hash":"f3e462d1b876f31b708bd65b307673a672480c40","modified":1490146047000},{"_id":"source/_posts/redux学习.md","hash":"9b99246025e5507fa01010a4d2cb0932d7d26013","modified":1490146113000},{"_id":"source/_posts/redux应用于React.md","hash":"5153474706c78acbbb531c6abe454ad2043e1dba","modified":1490146138000},{"_id":"source/_posts/一次H5页面.md","hash":"5013996406fbb29878b5a8eac7314865c7ee1833","modified":1490145733000},{"_id":"source/_posts/一次麻烦的投票.md","hash":"4f2d7a1ef7e18ade718a9175defe21147261ad5b","modified":1490145736000},{"_id":"source/_posts/为gulp添加更多.md","hash":"6649353ce414e0857757b83e2aa8baf734c6f6c4","modified":1490145731000},{"_id":"source/_posts/今天的面试.md","hash":"d4da8d1d28c12cc05c57a5a403316513a0e51cee","modified":1490145727000},{"_id":"source/_posts/从零搭建React(1).md","hash":"a32ef29c001632185622fd7864b33af8bbbc8bae","modified":1490145709000},{"_id":"source/_posts/从零搭建React(2).md","hash":"8b0b61b32216007ff0338081587c68e710cc8073","modified":1490145764000},{"_id":"source/_posts/从零搭建React(3).md","hash":"ed338b3e44769f902b11df381a4639cd4b757c45","modified":1490145803000},{"_id":"source/_posts/函数节流.md","hash":"8baa0b7c3bb44d0be5199bfe2f692134e3dca830","modified":1490145821000},{"_id":"source/_posts/利用Github+Hexo搭建博客过程.md","hash":"0f036e14df934fa812a5bf68738e9cfc7a2758f8","modified":1490145836000},{"_id":"source/_posts/前端工具","hash":"49849622d286f6721059c41fe168e01b0238631d","modified":1487227364000},{"_id":"source/_posts/前端技术栈.md","hash":"304cbac21d6a14f3ab269e8479dd1f1e58878898","modified":1487227364000},{"_id":"source/_posts/微信分享绝对是个坑.md","hash":"b015d618562805a4fc024745ef519ccb149956fe","modified":1490145873000},{"_id":"source/_posts/我的首个Hexo博客.md","hash":"ee74aea797835aaa8bfbd787f492b673d920cd9c","modified":1487227364000},{"_id":"source/_posts/批量移动QQ邮箱文件夹.md","hash":"b00f08470519a7aa2a6a905c7a44b207440a3318","modified":1489460135000},{"_id":"source/_posts/起点H5分析.md","hash":"519cdcd10e3f5d47bf3cc9d758e34994874c28a4","modified":1490145906000},{"_id":"source/_posts/面向对象的javascript(继承).md","hash":"d7490e332970438e8a0c87de1b8b96a81b6d08c9","modified":1490145914000},{"_id":"source/_posts/面向对象的javascript.md","hash":"2504f11a90625e504b4892961018d07280179c71","modified":1490145961000},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1487229542000},{"_id":"themes/maupassant/languages/en.yml","hash":"e13ab1a2d2f1edbe67b4c035fd4667cb6a31db8e","modified":1487229542000},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1487229542000},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1487229542000},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1487229542000},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"ebacfa5d0c14d603e0d505757adb24c0bbe5dd13","modified":1487229542000},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"56b65995c60e99dcebbf00168447fd225d28e5b2","modified":1487229542000},{"_id":"themes/maupassant/layout/archive.jade","hash":"0050c883b4f202add71c8664d65e6072179e7190","modified":1487229542000},{"_id":"themes/maupassant/layout/base-without-sidebar.jade","hash":"779c736a61a999292156ed23625b46e4ad69af86","modified":1487229542000},{"_id":"themes/maupassant/layout/base.jade","hash":"cec08a14b717a9b28bf3dce151efb72f16e74f80","modified":1491986482000},{"_id":"themes/maupassant/layout/index.jade","hash":"f842164f6cba007c1dfcd7fe7bba24736bc886a9","modified":1487229542000},{"_id":"themes/maupassant/layout/page.jade","hash":"8d70fd3b93f2c9087a9ea7ec538dcc1d413bea01","modified":1487229542000},{"_id":"themes/maupassant/layout/post.jade","hash":"9cf29fb0daed95935154ce0fa2b154df5a9b11b1","modified":1487229542000},{"_id":"themes/maupassant/layout/single-column.jade","hash":"c35fff4d9b331a41af5bc10f4278ec3d9da503db","modified":1487229542000},{"_id":"themes/maupassant/layout/timeline.jade","hash":"f03d8df63a188543cfe4e85e76194abe081411a1","modified":1487229542000},{"_id":"source/_posts/images/Promise_Object.png","hash":"6df0592eba8d2fdb744cadc93b50f2846d4e427d","modified":1487227364000},{"_id":"source/_posts/images/iframe.png","hash":"ec3e99f41d9b82e2fc920ce4a0460893ad602b37","modified":1489459458000},{"_id":"themes/maupassant/layout/_partial/after_footer.jade","hash":"3dbcc9a9f0d6e55da191d3393c18bbfcfe99fa69","modified":1487229542000},{"_id":"themes/maupassant/layout/_partial/comments.jade","hash":"6c7f63ba04a4d28323ba31e79a4927f3d3fcc56e","modified":1487229542000},{"_id":"themes/maupassant/layout/_partial/footer.jade","hash":"aa020b794e697e8e9612530c97c6295efde469fe","modified":1487229542000},{"_id":"themes/maupassant/layout/_partial/helpers.jade","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1487229542000},{"_id":"themes/maupassant/layout/_partial/mathjax.jade","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1487229542000},{"_id":"themes/maupassant/layout/_partial/mathjax2.jade","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1487229542000},{"_id":"themes/maupassant/layout/_partial/paginator.jade","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1487229542000},{"_id":"themes/maupassant/layout/_partial/post_nav.jade","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1487229542000},{"_id":"themes/maupassant/layout/_partial/tag.jade","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1487229542000},{"_id":"themes/maupassant/layout/_partial/totop.jade","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1487229542000},{"_id":"themes/maupassant/layout/_widget/category.jade","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1487229542000},{"_id":"themes/maupassant/layout/_widget/links.jade","hash":"f57a0c76d243882b2b77330132bdb43bc648948b","modified":1487229542000},{"_id":"themes/maupassant/layout/_widget/music.jade","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1491985791000},{"_id":"themes/maupassant/layout/_widget/recent_comments.jade","hash":"e119c5afa85abc60d139e2da99b0bfcd7a6530f8","modified":1487229542000},{"_id":"themes/maupassant/layout/_widget/recent_posts.jade","hash":"19431336d724d2118e46da43683bce9063176541","modified":1487229542000},{"_id":"themes/maupassant/layout/_widget/search.jade","hash":"193546282908e499813534f86d27ef6e0a1357b3","modified":1487229542000},{"_id":"themes/maupassant/layout/_widget/tag.jade","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1487229542000},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1487229542000},{"_id":"themes/maupassant/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1487229542000},{"_id":"themes/maupassant/source/css/style.scss","hash":"f1f16a4217725a5f45160c334e0cdb449f767951","modified":1491986390000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1487229542000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1487229542000},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1487229542000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1487229542000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1487229542000},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1487229542000},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1487229542000},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1487229542000},{"_id":"themes/maupassant/source/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1487229542000},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1487229542000},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1487229542000},{"_id":"source/_posts/images/triangles.png","hash":"9ed6e83d13b3c1ff2ec693440234a7f60b1d65cf","modified":1487227364000}],"Category":[{"name":"杂记","_id":"cj1eq8kgv0002ohfksluzhyfo"},{"name":"JavaScript","_id":"cj1eq8kh50007ohfk36rm3x3w"},{"name":"H5","_id":"cj1eq8khb000dohfkjvp9un7y"},{"name":"React","_id":"cj1eq8khk000oohfkqg70u7t1"}],"Data":[],"Page":[],"Post":[{"title":"2016小结","date":"2017-01-02T16:00:00.000Z","comments":1,"_content":"\n这一年经历还算丰富，总结起来两件大事：毕业、工作。\n\n毕业既令人期待，也让人伤感，大学生活也许不太充实，但是充满欢声。很佩服那些日子可以过得既能一直拼搏奋斗，又能充实有趣的人们。如果大学时光可以重来，我也不知道自己会选择怎样，也许选择那时候更努力的学习，希望可以改变现在的平庸；也许选择那时候更疯狂的玩耍，希望以此来珍惜那段无虑的时光；也许我能够在学习和玩耍之间能找到一个更好的平衡点；也许我根本就没认真地想过“如果重来”这个问题。\n\n工作虽然不怎么顺利，值得庆幸的是目前也算是入了前端的坑。现在想想，那时候的自己确实挺差劲的，学习PHP却连个页面都写不出来，实习半年，才开始对Web有一些理解，大学的课程真的和完全没学过一样。刚刚对Java的Web开发熟悉一些，了解了SSH三大框架就离职转前端也是有点作死的感觉。  \n","source":"_posts/2016小结.md","raw":"---\ntitle: 2016小结\ndate: 2017-01-03\ntags: \ncategories: \n- 杂记\ncomments: true\n---\n\n这一年经历还算丰富，总结起来两件大事：毕业、工作。\n\n毕业既令人期待，也让人伤感，大学生活也许不太充实，但是充满欢声。很佩服那些日子可以过得既能一直拼搏奋斗，又能充实有趣的人们。如果大学时光可以重来，我也不知道自己会选择怎样，也许选择那时候更努力的学习，希望可以改变现在的平庸；也许选择那时候更疯狂的玩耍，希望以此来珍惜那段无虑的时光；也许我能够在学习和玩耍之间能找到一个更好的平衡点；也许我根本就没认真地想过“如果重来”这个问题。\n\n工作虽然不怎么顺利，值得庆幸的是目前也算是入了前端的坑。现在想想，那时候的自己确实挺差劲的，学习PHP却连个页面都写不出来，实习半年，才开始对Web有一些理解，大学的课程真的和完全没学过一样。刚刚对Java的Web开发熟悉一些，了解了SSH三大框架就离职转前端也是有点作死的感觉。  \n","slug":"2016小结","published":1,"updated":"2017-03-22T01:29:41.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8kgn0000ohfks93i2k4r","content":"<p>这一年经历还算丰富，总结起来两件大事：毕业、工作。</p>\n<p>毕业既令人期待，也让人伤感，大学生活也许不太充实，但是充满欢声。很佩服那些日子可以过得既能一直拼搏奋斗，又能充实有趣的人们。如果大学时光可以重来，我也不知道自己会选择怎样，也许选择那时候更努力的学习，希望可以改变现在的平庸；也许选择那时候更疯狂的玩耍，希望以此来珍惜那段无虑的时光；也许我能够在学习和玩耍之间能找到一个更好的平衡点；也许我根本就没认真地想过“如果重来”这个问题。</p>\n<p>工作虽然不怎么顺利，值得庆幸的是目前也算是入了前端的坑。现在想想，那时候的自己确实挺差劲的，学习PHP却连个页面都写不出来，实习半年，才开始对Web有一些理解，大学的课程真的和完全没学过一样。刚刚对Java的Web开发熟悉一些，了解了SSH三大框架就离职转前端也是有点作死的感觉。  </p>\n","excerpt":"","more":"<p>这一年经历还算丰富，总结起来两件大事：毕业、工作。</p>\n<p>毕业既令人期待，也让人伤感，大学生活也许不太充实，但是充满欢声。很佩服那些日子可以过得既能一直拼搏奋斗，又能充实有趣的人们。如果大学时光可以重来，我也不知道自己会选择怎样，也许选择那时候更努力的学习，希望可以改变现在的平庸；也许选择那时候更疯狂的玩耍，希望以此来珍惜那段无虑的时光；也许我能够在学习和玩耍之间能找到一个更好的平衡点；也许我根本就没认真地想过“如果重来”这个问题。</p>\n<p>工作虽然不怎么顺利，值得庆幸的是目前也算是入了前端的坑。现在想想，那时候的自己确实挺差劲的，学习PHP却连个页面都写不出来，实习半年，才开始对Web有一些理解，大学的课程真的和完全没学过一样。刚刚对Java的Web开发熟悉一些，了解了SSH三大框架就离职转前端也是有点作死的感觉。  </p>\n"},{"title":"ES6初探","date":"2016-07-08T16:00:00.000Z","comments":1,"_content":"\nFrom [点击这里](http://mp.weixin.qq.com/s?__biz=MzAxMjA5ODQwMQ==&mid=2455058700&idx=1&sn=9361036ef5dc0c27cafb0612d495a85c)\n## ES6\n### 定义变量：let、const\n* let、const声明变量为块级作用域，var声明为函数作用域\n* let声明不具备变量提升，const声明具备\n* const用于声明常量，必须声明时赋值\n* let、const声明变量不能再次声明覆盖\n### 函数声明：箭头函数\n缘由\n\nps:\n```\n// 六种语言中的简单函数示例\nfunction (a) { return a > 0; } // JS\n[](int a) { return a > 0; }  // C++\n(lambda (a) (> a 0))  ;; Lisp\nlambda a: a > 0  # Python\na => a > 0  // C#\na -> a > 0  // Java\n```\n1. 情况一 a => a > 0   相当于 function(a) { return a > 0 }  tag:单个参数、直接返回\n2. 情况二 (a, b) => a + b  相当于 function(a, b) { return a + b }  tag:多个参数、直接返回\n3. 情况三 （a, b）=> { a + b ... }  相当于 function(a, b) { a + b ... } tag:函数体，返回需要自己写return语句\n4. 情况四  (a, b) => ({a: 'a'}) 相当于 function(a, b) { return {a: 'a'} } tab:直接返回对象，因为=>后面的{}会被理解为函数体，添加()才会被理解为对象\n\n* 箭头函数相当于匿名函数的简写\n* 箭头函数的this总是和外层函数的this指向相同。\n\teg.\n```javascript\n// ES5\nfunction Person() {\n  var self = this;\n  self.age = 0;\n\n  setInterval(function growUp() {\n  \t// this会指向windows\n  \t// 所以用self保存了this\n    self.age++;\n  }, 1000);\n}\n// ES6\nfunction Person(){\n  this.age = 0;\n\n  setInterval(() => {\n    // |this| 指向 person 对象\n    this.age++;\n  }, 1000);\n}\n\nvar person = new Person();\n```\n### for...of \n1. for...of  遍历数组,遍历字符串,对象没有该方法\n```javascript\nlet nicknames = ['di', 'boo', 'punkeye'];\nfor (let nickname of nicknames) {\n  console.log(nickname);\n}\nResult: di, boo, punkeye\n```\n2. for...in  遍历对象，数组也能够使用该方法\n```javascript\nlet nicknames = ['di', 'boo', 'punkeye'];\nnicknames.size = 3;\nfor (let nickname in nicknames) {\n  console.log(nickname); // 0 1 2 size\n}\n```\n### 类Class\n```javascript\n// ES5 定义类\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n// 相当于 ES6中\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  // 不需要添加function，方法和方法之间不能用逗号隔开\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\ntyof Point // function  说明Class只是一个语法糖\nPoint === Point.prototype.constructor // true\n```\n* new className()会自动调用constructor()\n* class定义的类只能通过new操作符，不能直接调用\n* 通过class只能定义在construtor中的共有属性，不能定义私有属性，定义的方法也都是相当于定义在prototype上的共有方法\n* 与ES5中定义在prototype不同在于不可枚举\n* 与ES5相同，所有实例共享原型。所以通过实例的__proto__属性可以为Class添加方法\n* 不存在变量提升，Class定义与ES5不同\n\n### 继承extends\n在使用extends继承时，子类的constructor中必须先调用super()方法，也就是父类的构造方法。\n\n### 对象超类\n```javascript\nvar parent = {\n  foo() {\n    console.log(\"Hello from the Parent\");\n  }\n}\n\nvar child = {\n  foo() {\n    super.foo();\n    console.log(\"Hello from the Child\");\n  }\n}\n\nObject.setPrototypeOf(child, parent); // ES6设置对象原型的方法\nchild.foo(); // Hello from the Parent\n             // Hello from the Child\n```\n### Promise\nPromise对象有三种状态：Pending、Resolved，Rejected，外界无法改变状态，状态一旦改变就不会再变。\n```javascript\nvar promise = new Promise(function(resolve, reject) {\n\t// ... some code\n\n\tif(/* 异步操作成功 */) {\n\t\tresolve(value);  // 将promise状态变为Resolved\n\t} else {\n\t\treject(error);\n\t}\n});\n\npromise.then(function(value) {\n\t// success\n}, function(error) {\n\t// failure\n})\n```\nps:\n\n一个用Promise实现Ajax操作的例子\n```javascript\nvar getJSON = function(url) {\n\tvar promise = new Promise(function(resolve, reject) {\n\t\tvar client = new XMLHttpRequest();\n\t\tclient.open('GET', url);\n\t\tclient.onreadystatechange = handler;\n\t\tclient.responseType = 'json';\n\t\tclient.setRequestHeader('Accept', 'application/json');\n\t\tclient.send();\n\n\t\tfunction handler() {\n\t\t\tif(this.readyState !== 4) {\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tif(this.status === 200) {\n\t\t\t\tresolve(this.response);\n\t\t\t} else {\n\t\t\t\treject(new Error(this.statusText));\n\t\t\t}\n\t\t};\n\t});\n\n\treturn promise;\n}\n```\n### 模板语法和分隔符\n```javascript\nlet user = 'Barret';\nconsole.log(`Hi ${user}!`); // Hi Barret\n```\n\n### 对象扩展\n```javascript\nfunction getCar(make, model, value) {\n  return {\n    // 简写变量\n    make,  // 等同于 make: make\n    model, // 等同于 model: model\n    value, // 等同于 value: value\n\n    // 属性可以使用表达式计算值\n    ['make' + make]: true,\n\n    // 忽略 `function` 关键词简写对象函数\n    depreciate() {\n      this.value -= 2500;\n    }\n  };\n}\n```\n### 对象和数组解构\n```javascript\nfunction foo() {\n  return [1,2,3];\n}\nlet arr = foo(); // [1,2,3]\n\nlet [a, b, c] = foo();\nconsole.log(a, b, c); // 1 2 3\n\nfunction bar() {\n  return {\n    x: 4,\n    y: 5,\n    z: 6\n  };\n}\nlet {x: x, y: y, z: z} = bar();\nconsole.log(x, y, z); // 4 5 6\n```\n### 迭代器\n通过[Symbol.iterator]()定义一个对象的迭代器\n```javascript\nvar arr = [11,12,13];\nvar itr = arr[Symbol.iterator]();\n\nitr.next(); // { value: 11, done: false }\nitr.next(); // { value: 12, done: false }\nitr.next(); // { value: 13, done: false }\n\nitr.next(); // { value: undefined, done: true }\n```\n\n### 扩展操作符...\n貌似只能用于参数传递\n1. 情况一 \n```javascript\nfunction foo(x,y,z) {\n  console.log(x,y,z);\n}\n\nlet arr = [1,2,3];\nfoo(...arr); // 1 2 3\n```\n2. 情况二\n```javascript\nfunction foo(...args) {\n  console.log(args);\n}\nfoo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]\n```","source":"_posts/ES6.md","raw":"---\ntitle: ES6初探\ndate: 2016-07-09\ntags: [JavaScript]\ncategories: \n- JavaScript\ncomments: true\n---\n\nFrom [点击这里](http://mp.weixin.qq.com/s?__biz=MzAxMjA5ODQwMQ==&mid=2455058700&idx=1&sn=9361036ef5dc0c27cafb0612d495a85c)\n## ES6\n### 定义变量：let、const\n* let、const声明变量为块级作用域，var声明为函数作用域\n* let声明不具备变量提升，const声明具备\n* const用于声明常量，必须声明时赋值\n* let、const声明变量不能再次声明覆盖\n### 函数声明：箭头函数\n缘由\n\nps:\n```\n// 六种语言中的简单函数示例\nfunction (a) { return a > 0; } // JS\n[](int a) { return a > 0; }  // C++\n(lambda (a) (> a 0))  ;; Lisp\nlambda a: a > 0  # Python\na => a > 0  // C#\na -> a > 0  // Java\n```\n1. 情况一 a => a > 0   相当于 function(a) { return a > 0 }  tag:单个参数、直接返回\n2. 情况二 (a, b) => a + b  相当于 function(a, b) { return a + b }  tag:多个参数、直接返回\n3. 情况三 （a, b）=> { a + b ... }  相当于 function(a, b) { a + b ... } tag:函数体，返回需要自己写return语句\n4. 情况四  (a, b) => ({a: 'a'}) 相当于 function(a, b) { return {a: 'a'} } tab:直接返回对象，因为=>后面的{}会被理解为函数体，添加()才会被理解为对象\n\n* 箭头函数相当于匿名函数的简写\n* 箭头函数的this总是和外层函数的this指向相同。\n\teg.\n```javascript\n// ES5\nfunction Person() {\n  var self = this;\n  self.age = 0;\n\n  setInterval(function growUp() {\n  \t// this会指向windows\n  \t// 所以用self保存了this\n    self.age++;\n  }, 1000);\n}\n// ES6\nfunction Person(){\n  this.age = 0;\n\n  setInterval(() => {\n    // |this| 指向 person 对象\n    this.age++;\n  }, 1000);\n}\n\nvar person = new Person();\n```\n### for...of \n1. for...of  遍历数组,遍历字符串,对象没有该方法\n```javascript\nlet nicknames = ['di', 'boo', 'punkeye'];\nfor (let nickname of nicknames) {\n  console.log(nickname);\n}\nResult: di, boo, punkeye\n```\n2. for...in  遍历对象，数组也能够使用该方法\n```javascript\nlet nicknames = ['di', 'boo', 'punkeye'];\nnicknames.size = 3;\nfor (let nickname in nicknames) {\n  console.log(nickname); // 0 1 2 size\n}\n```\n### 类Class\n```javascript\n// ES5 定义类\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n// 相当于 ES6中\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  // 不需要添加function，方法和方法之间不能用逗号隔开\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\ntyof Point // function  说明Class只是一个语法糖\nPoint === Point.prototype.constructor // true\n```\n* new className()会自动调用constructor()\n* class定义的类只能通过new操作符，不能直接调用\n* 通过class只能定义在construtor中的共有属性，不能定义私有属性，定义的方法也都是相当于定义在prototype上的共有方法\n* 与ES5中定义在prototype不同在于不可枚举\n* 与ES5相同，所有实例共享原型。所以通过实例的__proto__属性可以为Class添加方法\n* 不存在变量提升，Class定义与ES5不同\n\n### 继承extends\n在使用extends继承时，子类的constructor中必须先调用super()方法，也就是父类的构造方法。\n\n### 对象超类\n```javascript\nvar parent = {\n  foo() {\n    console.log(\"Hello from the Parent\");\n  }\n}\n\nvar child = {\n  foo() {\n    super.foo();\n    console.log(\"Hello from the Child\");\n  }\n}\n\nObject.setPrototypeOf(child, parent); // ES6设置对象原型的方法\nchild.foo(); // Hello from the Parent\n             // Hello from the Child\n```\n### Promise\nPromise对象有三种状态：Pending、Resolved，Rejected，外界无法改变状态，状态一旦改变就不会再变。\n```javascript\nvar promise = new Promise(function(resolve, reject) {\n\t// ... some code\n\n\tif(/* 异步操作成功 */) {\n\t\tresolve(value);  // 将promise状态变为Resolved\n\t} else {\n\t\treject(error);\n\t}\n});\n\npromise.then(function(value) {\n\t// success\n}, function(error) {\n\t// failure\n})\n```\nps:\n\n一个用Promise实现Ajax操作的例子\n```javascript\nvar getJSON = function(url) {\n\tvar promise = new Promise(function(resolve, reject) {\n\t\tvar client = new XMLHttpRequest();\n\t\tclient.open('GET', url);\n\t\tclient.onreadystatechange = handler;\n\t\tclient.responseType = 'json';\n\t\tclient.setRequestHeader('Accept', 'application/json');\n\t\tclient.send();\n\n\t\tfunction handler() {\n\t\t\tif(this.readyState !== 4) {\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tif(this.status === 200) {\n\t\t\t\tresolve(this.response);\n\t\t\t} else {\n\t\t\t\treject(new Error(this.statusText));\n\t\t\t}\n\t\t};\n\t});\n\n\treturn promise;\n}\n```\n### 模板语法和分隔符\n```javascript\nlet user = 'Barret';\nconsole.log(`Hi ${user}!`); // Hi Barret\n```\n\n### 对象扩展\n```javascript\nfunction getCar(make, model, value) {\n  return {\n    // 简写变量\n    make,  // 等同于 make: make\n    model, // 等同于 model: model\n    value, // 等同于 value: value\n\n    // 属性可以使用表达式计算值\n    ['make' + make]: true,\n\n    // 忽略 `function` 关键词简写对象函数\n    depreciate() {\n      this.value -= 2500;\n    }\n  };\n}\n```\n### 对象和数组解构\n```javascript\nfunction foo() {\n  return [1,2,3];\n}\nlet arr = foo(); // [1,2,3]\n\nlet [a, b, c] = foo();\nconsole.log(a, b, c); // 1 2 3\n\nfunction bar() {\n  return {\n    x: 4,\n    y: 5,\n    z: 6\n  };\n}\nlet {x: x, y: y, z: z} = bar();\nconsole.log(x, y, z); // 4 5 6\n```\n### 迭代器\n通过[Symbol.iterator]()定义一个对象的迭代器\n```javascript\nvar arr = [11,12,13];\nvar itr = arr[Symbol.iterator]();\n\nitr.next(); // { value: 11, done: false }\nitr.next(); // { value: 12, done: false }\nitr.next(); // { value: 13, done: false }\n\nitr.next(); // { value: undefined, done: true }\n```\n\n### 扩展操作符...\n貌似只能用于参数传递\n1. 情况一 \n```javascript\nfunction foo(x,y,z) {\n  console.log(x,y,z);\n}\n\nlet arr = [1,2,3];\nfoo(...arr); // 1 2 3\n```\n2. 情况二\n```javascript\nfunction foo(...args) {\n  console.log(args);\n}\nfoo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]\n```","slug":"ES6","published":1,"updated":"2017-02-16T06:42:44.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8kgs0001ohfk6r4xqlm9","content":"<p>From <a href=\"http://mp.weixin.qq.com/s?__biz=MzAxMjA5ODQwMQ==&amp;mid=2455058700&amp;idx=1&amp;sn=9361036ef5dc0c27cafb0612d495a85c\" target=\"_blank\" rel=\"external\">点击这里</a></p>\n<h2 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h2><h3 id=\"定义变量：let、const\"><a href=\"#定义变量：let、const\" class=\"headerlink\" title=\"定义变量：let、const\"></a>定义变量：let、const</h3><ul>\n<li>let、const声明变量为块级作用域，var声明为函数作用域</li>\n<li>let声明不具备变量提升，const声明具备</li>\n<li>const用于声明常量，必须声明时赋值</li>\n<li>let、const声明变量不能再次声明覆盖<h3 id=\"函数声明：箭头函数\"><a href=\"#函数声明：箭头函数\" class=\"headerlink\" title=\"函数声明：箭头函数\"></a>函数声明：箭头函数</h3>缘由</li>\n</ul>\n<p>ps:<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 六种语言中的简单函数示例</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(a)</span> <span class=\"comment\">&#123; return a &gt; 0; &#125;</span> <span class=\"comment\">// JS</span></span></div><div class=\"line\">[]<span class=\"params\">(int a)</span> <span class=\"comment\">&#123; return a &gt; 0; &#125;</span>  <span class=\"comment\">// C++</span></div><div class=\"line\"><span class=\"params\">(lambda (a)</span> <span class=\"params\">(&gt; a 0)</span>)  ;; Lisp</div><div class=\"line\">lambda a: a &gt; <span class=\"number\">0</span>  # Python</div><div class=\"line\">a =&gt; a &gt; <span class=\"number\">0</span>  <span class=\"comment\">// C#</span></div><div class=\"line\">a -&gt; a &gt; <span class=\"number\">0</span>  <span class=\"comment\">// Java</span></div></pre></td></tr></table></figure></p>\n<ol>\n<li>情况一 a =&gt; a &gt; 0   相当于 function(a) { return a &gt; 0 }  tag:单个参数、直接返回</li>\n<li>情况二 (a, b) =&gt; a + b  相当于 function(a, b) { return a + b }  tag:多个参数、直接返回</li>\n<li>情况三 （a, b）=&gt; { a + b … }  相当于 function(a, b) { a + b … } tag:函数体，返回需要自己写return语句</li>\n<li>情况四  (a, b) =&gt; ({a: ‘a’}) 相当于 function(a, b) { return {a: ‘a’} } tab:直接返回对象，因为=&gt;后面的{}会被理解为函数体，添加()才会被理解为对象</li>\n</ol>\n<ul>\n<li>箭头函数相当于匿名函数的简写</li>\n<li>箭头函数的this总是和外层函数的this指向相同。<br>  eg.<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</div><div class=\"line\">  self.age = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">  setInterval(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">growUp</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  \t<span class=\"comment\">// this会指向windows</span></div><div class=\"line\">  \t<span class=\"comment\">// 所以用self保存了this</span></div><div class=\"line\">    self.age++;</div><div class=\"line\">  &#125;, <span class=\"number\">1000</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// ES6</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.age = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">  setInterval(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// |this| 指向 person 对象</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.age++;</div><div class=\"line\">  &#125;, <span class=\"number\">1000</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"for…of\"><a href=\"#for…of\" class=\"headerlink\" title=\"for…of\"></a>for…of</h3><ol>\n<li><p>for…of  遍历数组,遍历字符串,对象没有该方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> nicknames = [<span class=\"string\">'di'</span>, <span class=\"string\">'boo'</span>, <span class=\"string\">'punkeye'</span>];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> nickname <span class=\"keyword\">of</span> nicknames) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(nickname);</div><div class=\"line\">&#125;</div><div class=\"line\">Result: di, boo, punkeye</div></pre></td></tr></table></figure>\n</li>\n<li><p>for…in  遍历对象，数组也能够使用该方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> nicknames = [<span class=\"string\">'di'</span>, <span class=\"string\">'boo'</span>, <span class=\"string\">'punkeye'</span>];</div><div class=\"line\">nicknames.size = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> nickname <span class=\"keyword\">in</span> nicknames) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(nickname); <span class=\"comment\">// 0 1 2 size</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"类Class\"><a href=\"#类Class\" class=\"headerlink\" title=\"类Class\"></a>类Class</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5 定义类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.x = x;</div><div class=\"line\">  <span class=\"keyword\">this</span>.y = y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Point.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 相当于 ES6中</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = x;</div><div class=\"line\">    <span class=\"keyword\">this</span>.y = y;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 不需要添加function，方法和方法之间不能用逗号隔开</span></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">tyof Point <span class=\"comment\">// function  说明Class只是一个语法糖</span></div><div class=\"line\">Point === Point.prototype.constructor <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<ul>\n<li>new className()会自动调用constructor()</li>\n<li>class定义的类只能通过new操作符，不能直接调用</li>\n<li>通过class只能定义在construtor中的共有属性，不能定义私有属性，定义的方法也都是相当于定义在prototype上的共有方法</li>\n<li>与ES5中定义在prototype不同在于不可枚举</li>\n<li>与ES5相同，所有实例共享原型。所以通过实例的<strong>proto</strong>属性可以为Class添加方法</li>\n<li>不存在变量提升，Class定义与ES5不同</li>\n</ul>\n<h3 id=\"继承extends\"><a href=\"#继承extends\" class=\"headerlink\" title=\"继承extends\"></a>继承extends</h3><p>在使用extends继承时，子类的constructor中必须先调用super()方法，也就是父类的构造方法。</p>\n<h3 id=\"对象超类\"><a href=\"#对象超类\" class=\"headerlink\" title=\"对象超类\"></a>对象超类</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> parent = &#123;</div><div class=\"line\">  foo() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello from the Parent\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> child = &#123;</div><div class=\"line\">  foo() &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.foo();</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello from the Child\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(child, parent); <span class=\"comment\">// ES6设置对象原型的方法</span></div><div class=\"line\">child.foo(); <span class=\"comment\">// Hello from the Parent</span></div><div class=\"line\">             <span class=\"comment\">// Hello from the Child</span></div></pre></td></tr></table></figure>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>Promise对象有三种状态：Pending、Resolved，Rejected，外界无法改变状态，状态一旦改变就不会再变。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// ... some code</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"comment\">/* 异步操作成功 */</span>) &#123;</div><div class=\"line\">\t\tresolve(value);  <span class=\"comment\">// 将promise状态变为Resolved</span></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\treject(error);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// success</span></div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// failure</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>ps:</p>\n<p>一个用Promise实现Ajax操作的例子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> getJSON = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> client = <span class=\"keyword\">new</span> XMLHttpRequest();</div><div class=\"line\">\t\tclient.open(<span class=\"string\">'GET'</span>, url);</div><div class=\"line\">\t\tclient.onreadystatechange = handler;</div><div class=\"line\">\t\tclient.responseType = <span class=\"string\">'json'</span>;</div><div class=\"line\">\t\tclient.setRequestHeader(<span class=\"string\">'Accept'</span>, <span class=\"string\">'application/json'</span>);</div><div class=\"line\">\t\tclient.send();</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.readyState !== <span class=\"number\">4</span>) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.status === <span class=\"number\">200</span>) &#123;</div><div class=\"line\">\t\t\t\tresolve(<span class=\"keyword\">this</span>.response);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\treject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"keyword\">this</span>.statusText));</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> promise;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"模板语法和分隔符\"><a href=\"#模板语法和分隔符\" class=\"headerlink\" title=\"模板语法和分隔符\"></a>模板语法和分隔符</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"string\">'Barret'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi <span class=\"subst\">$&#123;user&#125;</span>!`</span>); <span class=\"comment\">// Hi Barret</span></div></pre></td></tr></table></figure>\n<h3 id=\"对象扩展\"><a href=\"#对象扩展\" class=\"headerlink\" title=\"对象扩展\"></a>对象扩展</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCar</span>(<span class=\"params\">make, model, value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 简写变量</span></div><div class=\"line\">    make,  <span class=\"comment\">// 等同于 make: make</span></div><div class=\"line\">    model, <span class=\"comment\">// 等同于 model: model</span></div><div class=\"line\">    value, <span class=\"comment\">// 等同于 value: value</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 属性可以使用表达式计算值</span></div><div class=\"line\">    [<span class=\"string\">'make'</span> + make]: <span class=\"literal\">true</span>,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 忽略 `function` 关键词简写对象函数</span></div><div class=\"line\">    depreciate() &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.value -= <span class=\"number\">2500</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"对象和数组解构\"><a href=\"#对象和数组解构\" class=\"headerlink\" title=\"对象和数组解构\"></a>对象和数组解构</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> arr = foo(); <span class=\"comment\">// [1,2,3]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> [a, b, c] = foo();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a, b, c); <span class=\"comment\">// 1 2 3</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">x</span>: <span class=\"number\">4</span>,</div><div class=\"line\">    <span class=\"attr\">y</span>: <span class=\"number\">5</span>,</div><div class=\"line\">    <span class=\"attr\">z</span>: <span class=\"number\">6</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">x</span>: x, <span class=\"attr\">y</span>: y, <span class=\"attr\">z</span>: z&#125; = bar();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(x, y, z); <span class=\"comment\">// 4 5 6</span></div></pre></td></tr></table></figure>\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>通过<a href=\"\">Symbol.iterator</a>定义一个对象的迭代器<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">13</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> itr = arr[<span class=\"built_in\">Symbol</span>.iterator]();</div><div class=\"line\"></div><div class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: 11, done: false &#125;</span></div><div class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: 12, done: false &#125;</span></div><div class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: 13, done: false &#125;</span></div><div class=\"line\"></div><div class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"扩展操作符…\"><a href=\"#扩展操作符…\" class=\"headerlink\" title=\"扩展操作符…\"></a>扩展操作符…</h3><p>貌似只能用于参数传递</p>\n<ol>\n<li><p>情况一 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x,y,z</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(x,y,z);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</div><div class=\"line\">foo(...arr); <span class=\"comment\">// 1 2 3</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>情况二</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">...args</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(args);</div><div class=\"line\">&#125;</div><div class=\"line\">foo( <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>); <span class=\"comment\">// [1, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure></li>\n</ol>\n","excerpt":"","more":"<p>From <a href=\"http://mp.weixin.qq.com/s?__biz=MzAxMjA5ODQwMQ==&amp;mid=2455058700&amp;idx=1&amp;sn=9361036ef5dc0c27cafb0612d495a85c\">点击这里</a></p>\n<h2 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h2><h3 id=\"定义变量：let、const\"><a href=\"#定义变量：let、const\" class=\"headerlink\" title=\"定义变量：let、const\"></a>定义变量：let、const</h3><ul>\n<li>let、const声明变量为块级作用域，var声明为函数作用域</li>\n<li>let声明不具备变量提升，const声明具备</li>\n<li>const用于声明常量，必须声明时赋值</li>\n<li>let、const声明变量不能再次声明覆盖<h3 id=\"函数声明：箭头函数\"><a href=\"#函数声明：箭头函数\" class=\"headerlink\" title=\"函数声明：箭头函数\"></a>函数声明：箭头函数</h3>缘由</li>\n</ul>\n<p>ps:<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 六种语言中的简单函数示例</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(a)</span> <span class=\"comment\">&#123; return a &gt; 0; &#125;</span> <span class=\"comment\">// JS</span></div><div class=\"line\">[]<span class=\"params\">(int a)</span> <span class=\"comment\">&#123; return a &gt; 0; &#125;</span>  <span class=\"comment\">// C++</span></div><div class=\"line\"><span class=\"params\">(lambda (a)</span> <span class=\"params\">(&gt; a 0)</span>)  ;</span>; Lisp</div><div class=\"line\">lambda a: a &gt; <span class=\"number\">0</span>  # Python</div><div class=\"line\">a =&gt; a &gt; <span class=\"number\">0</span>  <span class=\"comment\">// C#</span></div><div class=\"line\">a -&gt; a &gt; <span class=\"number\">0</span>  <span class=\"comment\">// Java</span></div></pre></td></tr></table></figure></p>\n<ol>\n<li>情况一 a =&gt; a &gt; 0   相当于 function(a) { return a &gt; 0 }  tag:单个参数、直接返回</li>\n<li>情况二 (a, b) =&gt; a + b  相当于 function(a, b) { return a + b }  tag:多个参数、直接返回</li>\n<li>情况三 （a, b）=&gt; { a + b … }  相当于 function(a, b) { a + b … } tag:函数体，返回需要自己写return语句</li>\n<li>情况四  (a, b) =&gt; ({a: ‘a’}) 相当于 function(a, b) { return {a: ‘a’} } tab:直接返回对象，因为=&gt;后面的{}会被理解为函数体，添加()才会被理解为对象</li>\n</ol>\n<ul>\n<li>箭头函数相当于匿名函数的简写</li>\n<li>箭头函数的this总是和外层函数的this指向相同。<br>  eg.<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</div><div class=\"line\">  self.age = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">  setInterval(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">growUp</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  \t<span class=\"comment\">// this会指向windows</span></div><div class=\"line\">  \t<span class=\"comment\">// 所以用self保存了this</span></div><div class=\"line\">    self.age++;</div><div class=\"line\">  &#125;, <span class=\"number\">1000</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// ES6</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.age = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">  setInterval(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// |this| 指向 person 对象</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.age++;</div><div class=\"line\">  &#125;, <span class=\"number\">1000</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"for…of\"><a href=\"#for…of\" class=\"headerlink\" title=\"for…of\"></a>for…of</h3><ol>\n<li><p>for…of  遍历数组,遍历字符串,对象没有该方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> nicknames = [<span class=\"string\">'di'</span>, <span class=\"string\">'boo'</span>, <span class=\"string\">'punkeye'</span>];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> nickname <span class=\"keyword\">of</span> nicknames) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(nickname);</div><div class=\"line\">&#125;</div><div class=\"line\">Result: di, boo, punkeye</div></pre></td></tr></table></figure>\n</li>\n<li><p>for…in  遍历对象，数组也能够使用该方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> nicknames = [<span class=\"string\">'di'</span>, <span class=\"string\">'boo'</span>, <span class=\"string\">'punkeye'</span>];</div><div class=\"line\">nicknames.size = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> nickname <span class=\"keyword\">in</span> nicknames) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(nickname); <span class=\"comment\">// 0 1 2 size</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"类Class\"><a href=\"#类Class\" class=\"headerlink\" title=\"类Class\"></a>类Class</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5 定义类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.x = x;</div><div class=\"line\">  <span class=\"keyword\">this</span>.y = y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Point.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 相当于 ES6中</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = x;</div><div class=\"line\">    <span class=\"keyword\">this</span>.y = y;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 不需要添加function，方法和方法之间不能用逗号隔开</span></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">tyof Point <span class=\"comment\">// function  说明Class只是一个语法糖</span></div><div class=\"line\">Point === Point.prototype.constructor <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<ul>\n<li>new className()会自动调用constructor()</li>\n<li>class定义的类只能通过new操作符，不能直接调用</li>\n<li>通过class只能定义在construtor中的共有属性，不能定义私有属性，定义的方法也都是相当于定义在prototype上的共有方法</li>\n<li>与ES5中定义在prototype不同在于不可枚举</li>\n<li>与ES5相同，所有实例共享原型。所以通过实例的<strong>proto</strong>属性可以为Class添加方法</li>\n<li>不存在变量提升，Class定义与ES5不同</li>\n</ul>\n<h3 id=\"继承extends\"><a href=\"#继承extends\" class=\"headerlink\" title=\"继承extends\"></a>继承extends</h3><p>在使用extends继承时，子类的constructor中必须先调用super()方法，也就是父类的构造方法。</p>\n<h3 id=\"对象超类\"><a href=\"#对象超类\" class=\"headerlink\" title=\"对象超类\"></a>对象超类</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> parent = &#123;</div><div class=\"line\">  foo() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello from the Parent\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> child = &#123;</div><div class=\"line\">  foo() &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.foo();</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello from the Child\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(child, parent); <span class=\"comment\">// ES6设置对象原型的方法</span></div><div class=\"line\">child.foo(); <span class=\"comment\">// Hello from the Parent</span></div><div class=\"line\">             <span class=\"comment\">// Hello from the Child</span></div></pre></td></tr></table></figure>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>Promise对象有三种状态：Pending、Resolved，Rejected，外界无法改变状态，状态一旦改变就不会再变。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// ... some code</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"comment\">/* 异步操作成功 */</span>) &#123;</div><div class=\"line\">\t\tresolve(value);  <span class=\"comment\">// 将promise状态变为Resolved</span></div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\treject(error);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// success</span></div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// failure</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>ps:</p>\n<p>一个用Promise实现Ajax操作的例子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> getJSON = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> client = <span class=\"keyword\">new</span> XMLHttpRequest();</div><div class=\"line\">\t\tclient.open(<span class=\"string\">'GET'</span>, url);</div><div class=\"line\">\t\tclient.onreadystatechange = handler;</div><div class=\"line\">\t\tclient.responseType = <span class=\"string\">'json'</span>;</div><div class=\"line\">\t\tclient.setRequestHeader(<span class=\"string\">'Accept'</span>, <span class=\"string\">'application/json'</span>);</div><div class=\"line\">\t\tclient.send();</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.readyState !== <span class=\"number\">4</span>) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.status === <span class=\"number\">200</span>) &#123;</div><div class=\"line\">\t\t\t\tresolve(<span class=\"keyword\">this</span>.response);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\treject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"keyword\">this</span>.statusText));</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> promise;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"模板语法和分隔符\"><a href=\"#模板语法和分隔符\" class=\"headerlink\" title=\"模板语法和分隔符\"></a>模板语法和分隔符</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"string\">'Barret'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi <span class=\"subst\">$&#123;user&#125;</span>!`</span>); <span class=\"comment\">// Hi Barret</span></div></pre></td></tr></table></figure>\n<h3 id=\"对象扩展\"><a href=\"#对象扩展\" class=\"headerlink\" title=\"对象扩展\"></a>对象扩展</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCar</span>(<span class=\"params\">make, model, value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 简写变量</span></div><div class=\"line\">    make,  <span class=\"comment\">// 等同于 make: make</span></div><div class=\"line\">    model, <span class=\"comment\">// 等同于 model: model</span></div><div class=\"line\">    value, <span class=\"comment\">// 等同于 value: value</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 属性可以使用表达式计算值</span></div><div class=\"line\">    [<span class=\"string\">'make'</span> + make]: <span class=\"literal\">true</span>,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 忽略 `function` 关键词简写对象函数</span></div><div class=\"line\">    depreciate() &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.value -= <span class=\"number\">2500</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"对象和数组解构\"><a href=\"#对象和数组解构\" class=\"headerlink\" title=\"对象和数组解构\"></a>对象和数组解构</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> arr = foo(); <span class=\"comment\">// [1,2,3]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> [a, b, c] = foo();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a, b, c); <span class=\"comment\">// 1 2 3</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">x</span>: <span class=\"number\">4</span>,</div><div class=\"line\">    <span class=\"attr\">y</span>: <span class=\"number\">5</span>,</div><div class=\"line\">    <span class=\"attr\">z</span>: <span class=\"number\">6</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">x</span>: x, <span class=\"attr\">y</span>: y, <span class=\"attr\">z</span>: z&#125; = bar();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(x, y, z); <span class=\"comment\">// 4 5 6</span></div></pre></td></tr></table></figure>\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>通过<a href=\"\">Symbol.iterator</a>定义一个对象的迭代器<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">13</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> itr = arr[<span class=\"built_in\">Symbol</span>.iterator]();</div><div class=\"line\"></div><div class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: 11, done: false &#125;</span></div><div class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: 12, done: false &#125;</span></div><div class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: 13, done: false &#125;</span></div><div class=\"line\"></div><div class=\"line\">itr.next(); <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"扩展操作符…\"><a href=\"#扩展操作符…\" class=\"headerlink\" title=\"扩展操作符…\"></a>扩展操作符…</h3><p>貌似只能用于参数传递</p>\n<ol>\n<li><p>情况一 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x,y,z</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(x,y,z);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</div><div class=\"line\">foo(...arr); <span class=\"comment\">// 1 2 3</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>情况二</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">...args</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(args);</div><div class=\"line\">&#125;</div><div class=\"line\">foo( <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>); <span class=\"comment\">// [1, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"H5页面","date":"2016-08-02T16:00:00.000Z","comments":1,"_content":"\n任务：环球网-2016七夕H5页面  \n环境：swiper插件，gulp及相关常用工具。\n\n---\n\n### 适配\n使用的还是lib-flexible那套解决方案，需要查看的可以点击[这里](https://github.com/amfe/lib-flexible)  \n### 使用swiper\n使用swiper页面的控制以及滑动功能就变得非常容易，可以参见[Swiper中文网](http://www.swiper.com.cn/)，其中添加给类名添加`swiper-slide`即可表示一页。  \n在Swiper实例化中，属性`direction`可以定义横向/竖向滑动，`nextButton`可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在`onSlideChangeStart`中不能够出发`slideTo()`方法。  \nSwiper还有许多其他功能，可以参见[Swiper中文网](http://www.swiper.com.cn/)中API。\n\n### ES6的使用\nES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是`gulp-babel`。\n\n### 目录、git以及gulp相关\n目录和之前的项目目录基本相同。\n```\n.\n├── .eslintrc.json\n├── .gitignore\n├── dist\n│   ├── css\n│   ├── imgs\n│   ├── js\n│   └── libs\n├── gulpfile.js\n├── index.html\n├── node_modules\n├── package.json\n├── psd\n└── src\n    ├── ES6\n    ├── css\n    ├── imgs\n    ├── js\n    ├── libs\n    └── sass\n```\ndist目录存放合并、压缩的代码，用于上线使用。(自动生成)  \nsrc目录存放源文件。  \nnode_modules目录存放用到的node工具。(自动生成)  \npsd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。  \n相比之前增加的文件：\n\n*  .eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看[这里](https://segmentfault.com/a/1190000004468428)。\n*  .gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。\n```\n/node_modules/\n/psd/\n```\n* src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。\n\ngit开始学习使用分支处理bug、添加尝试性功能等。\n\n### 坑是用来爬的\n#### 最经典的坑——this\n在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过`fn.bind(this)`来指向想要的this，在旧版本浏览器下需要使用兼容写法。\n\n#### 省事也被坑——autoprefixer\nautoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是`remove`，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。  \nandriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。\n\n#### 没想到的坑——微信分享\n关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。  \n问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中`mqq.data.setShareInfo`可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。\n\n### 其他\n#### 自定义单选框\n自定义单选框并没有想象中的那么难，除了`<input type=\"radio\">`外，还有个label标签和after伪类。  \n设置css`[type=radio]: display: none;`，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)\n\n#### 文字居中\n要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。\n\n#### 横屏问题\n我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。\n\n### 改进\n需要改进的东西就太多太多了。 \n \n* 最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。\n* 图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。\n* 动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。","source":"_posts/H5页面.md","raw":"---\ntitle: H5页面\ndate: 2016-08-03\ntags: [JavaScript, H5]\ncategories: \n- H5\ncomments: true\n---\n\n任务：环球网-2016七夕H5页面  \n环境：swiper插件，gulp及相关常用工具。\n\n---\n\n### 适配\n使用的还是lib-flexible那套解决方案，需要查看的可以点击[这里](https://github.com/amfe/lib-flexible)  \n### 使用swiper\n使用swiper页面的控制以及滑动功能就变得非常容易，可以参见[Swiper中文网](http://www.swiper.com.cn/)，其中添加给类名添加`swiper-slide`即可表示一页。  \n在Swiper实例化中，属性`direction`可以定义横向/竖向滑动，`nextButton`可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在`onSlideChangeStart`中不能够出发`slideTo()`方法。  \nSwiper还有许多其他功能，可以参见[Swiper中文网](http://www.swiper.com.cn/)中API。\n\n### ES6的使用\nES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是`gulp-babel`。\n\n### 目录、git以及gulp相关\n目录和之前的项目目录基本相同。\n```\n.\n├── .eslintrc.json\n├── .gitignore\n├── dist\n│   ├── css\n│   ├── imgs\n│   ├── js\n│   └── libs\n├── gulpfile.js\n├── index.html\n├── node_modules\n├── package.json\n├── psd\n└── src\n    ├── ES6\n    ├── css\n    ├── imgs\n    ├── js\n    ├── libs\n    └── sass\n```\ndist目录存放合并、压缩的代码，用于上线使用。(自动生成)  \nsrc目录存放源文件。  \nnode_modules目录存放用到的node工具。(自动生成)  \npsd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。  \n相比之前增加的文件：\n\n*  .eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看[这里](https://segmentfault.com/a/1190000004468428)。\n*  .gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。\n```\n/node_modules/\n/psd/\n```\n* src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。\n\ngit开始学习使用分支处理bug、添加尝试性功能等。\n\n### 坑是用来爬的\n#### 最经典的坑——this\n在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过`fn.bind(this)`来指向想要的this，在旧版本浏览器下需要使用兼容写法。\n\n#### 省事也被坑——autoprefixer\nautoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是`remove`，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。  \nandriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。\n\n#### 没想到的坑——微信分享\n关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。  \n问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中`mqq.data.setShareInfo`可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。\n\n### 其他\n#### 自定义单选框\n自定义单选框并没有想象中的那么难，除了`<input type=\"radio\">`外，还有个label标签和after伪类。  \n设置css`[type=radio]: display: none;`，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)\n\n#### 文字居中\n要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。\n\n#### 横屏问题\n我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。\n\n### 改进\n需要改进的东西就太多太多了。 \n \n* 最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。\n* 图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。\n* 动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。","slug":"H5页面","published":1,"updated":"2017-03-22T01:27:43.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8kgz0003ohfkwlaug7pa","content":"<p>任务：环球网-2016七夕H5页面<br>环境：swiper插件，gulp及相关常用工具。</p>\n<hr>\n<h3 id=\"适配\"><a href=\"#适配\" class=\"headerlink\" title=\"适配\"></a>适配</h3><p>使用的还是lib-flexible那套解决方案，需要查看的可以点击<a href=\"https://github.com/amfe/lib-flexible\" target=\"_blank\" rel=\"external\">这里</a>  </p>\n<h3 id=\"使用swiper\"><a href=\"#使用swiper\" class=\"headerlink\" title=\"使用swiper\"></a>使用swiper</h3><p>使用swiper页面的控制以及滑动功能就变得非常容易，可以参见<a href=\"http://www.swiper.com.cn/\" target=\"_blank\" rel=\"external\">Swiper中文网</a>，其中添加给类名添加<code>swiper-slide</code>即可表示一页。<br>在Swiper实例化中，属性<code>direction</code>可以定义横向/竖向滑动，<code>nextButton</code>可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在<code>onSlideChangeStart</code>中不能够出发<code>slideTo()</code>方法。<br>Swiper还有许多其他功能，可以参见<a href=\"http://www.swiper.com.cn/\" target=\"_blank\" rel=\"external\">Swiper中文网</a>中API。</p>\n<h3 id=\"ES6的使用\"><a href=\"#ES6的使用\" class=\"headerlink\" title=\"ES6的使用\"></a>ES6的使用</h3><p>ES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是<code>gulp-babel</code>。</p>\n<h3 id=\"目录、git以及gulp相关\"><a href=\"#目录、git以及gulp相关\" class=\"headerlink\" title=\"目录、git以及gulp相关\"></a>目录、git以及gulp相关</h3><p>目录和之前的项目目录基本相同。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── <span class=\"selector-class\">.eslintrc</span><span class=\"selector-class\">.json</span></div><div class=\"line\">├── <span class=\"selector-class\">.gitignore</span></div><div class=\"line\">├── dist</div><div class=\"line\">│   ├── css</div><div class=\"line\">│   ├── imgs</div><div class=\"line\">│   ├── js</div><div class=\"line\">│   └── libs</div><div class=\"line\">├── gulpfile<span class=\"selector-class\">.js</span></div><div class=\"line\">├── index<span class=\"selector-class\">.html</span></div><div class=\"line\">├── node_modules</div><div class=\"line\">├── package<span class=\"selector-class\">.json</span></div><div class=\"line\">├── psd</div><div class=\"line\">└── src</div><div class=\"line\">    ├── ES6</div><div class=\"line\">    ├── css</div><div class=\"line\">    ├── imgs</div><div class=\"line\">    ├── js</div><div class=\"line\">    ├── libs</div><div class=\"line\">    └── sass</div></pre></td></tr></table></figure></p>\n<p>dist目录存放合并、压缩的代码，用于上线使用。(自动生成)<br>src目录存放源文件。<br>node_modules目录存放用到的node工具。(自动生成)<br>psd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。<br>相比之前增加的文件：</p>\n<ul>\n<li>.eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看<a href=\"https://segmentfault.com/a/1190000004468428\" target=\"_blank\" rel=\"external\">这里</a>。</li>\n<li><p>.gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"regexp\">/node_modules/</span></div><div class=\"line\"><span class=\"regexp\">/psd/</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。</p>\n</li>\n</ul>\n<p>git开始学习使用分支处理bug、添加尝试性功能等。</p>\n<h3 id=\"坑是用来爬的\"><a href=\"#坑是用来爬的\" class=\"headerlink\" title=\"坑是用来爬的\"></a>坑是用来爬的</h3><h4 id=\"最经典的坑——this\"><a href=\"#最经典的坑——this\" class=\"headerlink\" title=\"最经典的坑——this\"></a>最经典的坑——this</h4><p>在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过<code>fn.bind(this)</code>来指向想要的this，在旧版本浏览器下需要使用兼容写法。</p>\n<h4 id=\"省事也被坑——autoprefixer\"><a href=\"#省事也被坑——autoprefixer\" class=\"headerlink\" title=\"省事也被坑——autoprefixer\"></a>省事也被坑——autoprefixer</h4><p>autoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是<code>remove</code>，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。<br>andriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。</p>\n<h4 id=\"没想到的坑——微信分享\"><a href=\"#没想到的坑——微信分享\" class=\"headerlink\" title=\"没想到的坑——微信分享\"></a>没想到的坑——微信分享</h4><p>关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。<br>问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中<code>mqq.data.setShareInfo</code>可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"自定义单选框\"><a href=\"#自定义单选框\" class=\"headerlink\" title=\"自定义单选框\"></a>自定义单选框</h4><p>自定义单选框并没有想象中的那么难，除了<code>&lt;input type=&quot;radio&quot;&gt;</code>外，还有个label标签和after伪类。<br>设置css<code>[type=radio]: display: none;</code>，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)</p>\n<h4 id=\"文字居中\"><a href=\"#文字居中\" class=\"headerlink\" title=\"文字居中\"></a>文字居中</h4><p>要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。</p>\n<h4 id=\"横屏问题\"><a href=\"#横屏问题\" class=\"headerlink\" title=\"横屏问题\"></a>横屏问题</h4><p>我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。</p>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>需要改进的东西就太多太多了。 </p>\n<ul>\n<li>最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。</li>\n<li>图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。</li>\n<li>动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。</li>\n</ul>\n","excerpt":"","more":"<p>任务：环球网-2016七夕H5页面<br>环境：swiper插件，gulp及相关常用工具。</p>\n<hr>\n<h3 id=\"适配\"><a href=\"#适配\" class=\"headerlink\" title=\"适配\"></a>适配</h3><p>使用的还是lib-flexible那套解决方案，需要查看的可以点击<a href=\"https://github.com/amfe/lib-flexible\">这里</a>  </p>\n<h3 id=\"使用swiper\"><a href=\"#使用swiper\" class=\"headerlink\" title=\"使用swiper\"></a>使用swiper</h3><p>使用swiper页面的控制以及滑动功能就变得非常容易，可以参见<a href=\"http://www.swiper.com.cn/\">Swiper中文网</a>，其中添加给类名添加<code>swiper-slide</code>即可表示一页。<br>在Swiper实例化中，属性<code>direction</code>可以定义横向/竖向滑动，<code>nextButton</code>可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在<code>onSlideChangeStart</code>中不能够出发<code>slideTo()</code>方法。<br>Swiper还有许多其他功能，可以参见<a href=\"http://www.swiper.com.cn/\">Swiper中文网</a>中API。</p>\n<h3 id=\"ES6的使用\"><a href=\"#ES6的使用\" class=\"headerlink\" title=\"ES6的使用\"></a>ES6的使用</h3><p>ES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是<code>gulp-babel</code>。</p>\n<h3 id=\"目录、git以及gulp相关\"><a href=\"#目录、git以及gulp相关\" class=\"headerlink\" title=\"目录、git以及gulp相关\"></a>目录、git以及gulp相关</h3><p>目录和之前的项目目录基本相同。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── <span class=\"selector-class\">.eslintrc</span><span class=\"selector-class\">.json</span></div><div class=\"line\">├── <span class=\"selector-class\">.gitignore</span></div><div class=\"line\">├── dist</div><div class=\"line\">│   ├── css</div><div class=\"line\">│   ├── imgs</div><div class=\"line\">│   ├── js</div><div class=\"line\">│   └── libs</div><div class=\"line\">├── gulpfile<span class=\"selector-class\">.js</span></div><div class=\"line\">├── index<span class=\"selector-class\">.html</span></div><div class=\"line\">├── node_modules</div><div class=\"line\">├── package<span class=\"selector-class\">.json</span></div><div class=\"line\">├── psd</div><div class=\"line\">└── src</div><div class=\"line\">    ├── ES6</div><div class=\"line\">    ├── css</div><div class=\"line\">    ├── imgs</div><div class=\"line\">    ├── js</div><div class=\"line\">    ├── libs</div><div class=\"line\">    └── sass</div></pre></td></tr></table></figure></p>\n<p>dist目录存放合并、压缩的代码，用于上线使用。(自动生成)<br>src目录存放源文件。<br>node_modules目录存放用到的node工具。(自动生成)<br>psd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。<br>相比之前增加的文件：</p>\n<ul>\n<li>.eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看<a href=\"https://segmentfault.com/a/1190000004468428\">这里</a>。</li>\n<li><p>.gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"regexp\">/node_modules/</span></div><div class=\"line\"><span class=\"regexp\">/psd/</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。</p>\n</li>\n</ul>\n<p>git开始学习使用分支处理bug、添加尝试性功能等。</p>\n<h3 id=\"坑是用来爬的\"><a href=\"#坑是用来爬的\" class=\"headerlink\" title=\"坑是用来爬的\"></a>坑是用来爬的</h3><h4 id=\"最经典的坑——this\"><a href=\"#最经典的坑——this\" class=\"headerlink\" title=\"最经典的坑——this\"></a>最经典的坑——this</h4><p>在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过<code>fn.bind(this)</code>来指向想要的this，在旧版本浏览器下需要使用兼容写法。</p>\n<h4 id=\"省事也被坑——autoprefixer\"><a href=\"#省事也被坑——autoprefixer\" class=\"headerlink\" title=\"省事也被坑——autoprefixer\"></a>省事也被坑——autoprefixer</h4><p>autoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是<code>remove</code>，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。<br>andriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。</p>\n<h4 id=\"没想到的坑——微信分享\"><a href=\"#没想到的坑——微信分享\" class=\"headerlink\" title=\"没想到的坑——微信分享\"></a>没想到的坑——微信分享</h4><p>关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。<br>问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中<code>mqq.data.setShareInfo</code>可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"自定义单选框\"><a href=\"#自定义单选框\" class=\"headerlink\" title=\"自定义单选框\"></a>自定义单选框</h4><p>自定义单选框并没有想象中的那么难，除了<code>&lt;input type=&quot;radio&quot;&gt;</code>外，还有个label标签和after伪类。<br>设置css<code>[type=radio]: display: none;</code>，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)</p>\n<h4 id=\"文字居中\"><a href=\"#文字居中\" class=\"headerlink\" title=\"文字居中\"></a>文字居中</h4><p>要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。</p>\n<h4 id=\"横屏问题\"><a href=\"#横屏问题\" class=\"headerlink\" title=\"横屏问题\"></a>横屏问题</h4><p>我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。</p>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>需要改进的东西就太多太多了。 </p>\n<ul>\n<li>最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。</li>\n<li>图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。</li>\n<li>动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。</li>\n</ul>\n"},{"title":"Promise总结","date":"2016-11-24T16:00:00.000Z","comments":1,"_content":"\n## Promise总结\n\n因为最近项目中用到了ajax，想尝试下Promise，所以看了下ES6中的[Promise](http://es6.ruanyifeng.com/#docs/promise)。\n\n一般用法：\n```javascript\n// promise表示一个Promise对象\npromise\n  .then(function (data) {\n    // success\n  })\n  .catch(function (err) {\n    // error\n  })\n```\n所以如果使用jQuery或者zepto，可以这样：\n```javascript\nvar ajaxBack = $.ajax({\n  url: '*****'\n})\n\najaxBack\n  .then(data => {\n    // 处理数据\n  })\n  .catch(error => {\n    // 处理报错\n  })\n```\n\n### 什么是Promise对象？\n\nPromise是异步编程的一种解决方案。  \n首先，我们通过chrome浏览器控制台来看一下Promise对象的样子。  \n在控制台输入`Promise`然后回车，会看到输出`function Promise() { [native code] }`。然后我们new一个Promise出来看一下，`var promise = new Promise(function(){})`，在创建Promise对象时候，必须传递一个函数，否则会报错。  \n看一下promise：  \n![Promise对象](./images/Promise_Object.png)  \n包括\\_\\_proto\\_\\_，[[PromiseStatus]]，[[PromiseValue]]三个属性，其中\\_\\_proto\\_\\_主要包括catch、then、constructor方法。所以我们对Promise的学习主要就是[[PromiseStatus]]，[[PromiseValue]]属性和catch，then方法。\n\n### Promise的三种状态\n通过[资料](http://es6.ruanyifeng.com/#docs/promise)，我们会知道Promise对象有三种状态：Pending、Resolved和Rejected。  \nPromise构造函数接受一个函数作为参数，该函数有两个参数分别为resolve和reject，我们的创建方法应该是这样`new Promise(function (resolve, reject) {})`。  \n这两个参数resolve和reject也是函数，resolve是将Promise对象的状态从Pending变成Resolved，reject是将Promise对象的状态从Pending变成Rejected。  \n如果我们执行`var promise = new Promise(function(resolve, reject){resolve()})`，会发现promise中的[[PromiseStatus]]变成了`\"resolved\"`。如果我们执行`var promise = new Promise(function(resolve, reject){resolve('执行成功')})`，会发现不仅[[PromiseStatus]]变了，[[PromiseValue]]的值变成了`“执行成功”`。(reject函数同理)\n\n    需要注意：\n      只有函数中的构造函数参数中的resolve和reject可以改变Promise对象的状态。\n      一旦Promise对象的状态改变，就会一直保持这个状态，不能再改变。\n\n### Promise的then函数和catch函数\n\nthen函数和catch函数可以理解成对Promise状态的监听函数，不同点在于监听函数需要在事件发生之前创建，而因为Promise中的状态在改变后是不能再次改变的，所以then函数和catch函数可以在Promise对象改变状态之后创建，这样的话，该函数会立即执行。  \nthen函数接受两个函数作为参数，分别是Promise状态为`Resolved`时执行和状态为`Rejected`时执行。\n```javascript\n// promise是一个Promise对象\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\nthen函数中的函数参数是[[PromiseValue]]中的值，即是Promise构造中的resolve()、reject()中的参数。\n\n另外，then函数中的方法是异步的，即使resolve立即执行，then中的函数也在同步函数执行结束之后执行：\n```javascript\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise');\n  resolve();\n});\n\npromise.then(function() {\n  console.log('Resolved.');\n});\n\nconsole.log('Hi!');\n\n// Promise\n// Hi!\n// Resolved\n```\n\ncatch函数相当于.then(null, function () {})，是在发生错误时的回调函数，reject()执行时也算是一种错误发生，所以在执行reject()时，catch中的函数也会被执行。  \n所以，最好的方式是reject()发生时候需要执行的函数定义在catch中，而不是在then的第二个参数中，这样无论是reject()还是其他错误都能够被捕获。\n```javascript\n// bad\npromise\n  .then(function(data) {\n    // success\n  }, function(err) {\n    // error\n  });\n\n// good\npromise\n  .then(function(data) { //cb\n    // success\n  })\n  .catch(function(err) {\n    // error\n  });\n```\n\n### Promise对象的嵌套\n在resolve()和reject()中传递的可以是另一个Promise对象，例如\n```javascript\nvar p1 = new Promise(function (resolve, reject) {\n  setTimeout(() => reject(new Error('fail')), 3000)\n})\n\nvar p2 = new Promise(function (resolve, reject) {\n  setTimeout(() => resolve(p1), 1000)\n})\n\np2\n  .then(result => console.log(result))\n  .catch(error => console.log(error))\n// Error: fail\n```\np1是一个Promise，3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。此时，由于p2返回的是另一个Promise，所以后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。\n\n### 其他函数\n\n#### Promise.all()\nPromise.all()将多个Promise包装成一个Promise对象，只有在包装的多个Promise都转变成`Resolved`状态，此Promise.all()才会转变成`Resolved`状态，返回值是多个Promise返回值组成的数组；如果有其中一个转变成了`Rejected`状态，则此Promise.all()变成`Rejected`状态，返回值是第一个被reject的返回值。\n\n#### Promise.race()\nPromise.race()可以理解成Promise.all()的“否命题”。  \n将多个Promise包装成一个，只要有其中一个状态变成`Resolved`，则此Promise.race()变成`Resolved`，返回值是第一个状态变成`Resolved`的值。\n\n#### Promise.resolve()\nPromise.resolve()用于将对象转换成Promise对象。\n\n    1. 参数为Promise对象，方法什么也不做，直接返回。\n    2. 参数为一个有then方法的对象，方法将对象转换成Promise对象，并立即执行then方法。例如：Promise.resolve(Object)相当于new Promise(Object.then)\n    3. 参数不是具有then方法的对象，或者不是对象，则返回一个状态为`Resolved`的Promise对象，并将此参数传递给then中的第一个参数函数。\n    4. 不带任何参数，直接返回`Resolved`的Promise对象。\n\n#### Promise.reject()\nPromise.reject()和Promise.resolve()行为一致，只是返回的默认是`Rejected`的Promise对象。\n\n#### done()\n\n#### finally()\n","source":"_posts/Promise总结.md","raw":"---\ntitle: Promise总结\ndate: 2016-11-25\ntags: JavaScript\ncategories: \n- JavaScript\ncomments: true\n---\n\n## Promise总结\n\n因为最近项目中用到了ajax，想尝试下Promise，所以看了下ES6中的[Promise](http://es6.ruanyifeng.com/#docs/promise)。\n\n一般用法：\n```javascript\n// promise表示一个Promise对象\npromise\n  .then(function (data) {\n    // success\n  })\n  .catch(function (err) {\n    // error\n  })\n```\n所以如果使用jQuery或者zepto，可以这样：\n```javascript\nvar ajaxBack = $.ajax({\n  url: '*****'\n})\n\najaxBack\n  .then(data => {\n    // 处理数据\n  })\n  .catch(error => {\n    // 处理报错\n  })\n```\n\n### 什么是Promise对象？\n\nPromise是异步编程的一种解决方案。  \n首先，我们通过chrome浏览器控制台来看一下Promise对象的样子。  \n在控制台输入`Promise`然后回车，会看到输出`function Promise() { [native code] }`。然后我们new一个Promise出来看一下，`var promise = new Promise(function(){})`，在创建Promise对象时候，必须传递一个函数，否则会报错。  \n看一下promise：  \n![Promise对象](./images/Promise_Object.png)  \n包括\\_\\_proto\\_\\_，[[PromiseStatus]]，[[PromiseValue]]三个属性，其中\\_\\_proto\\_\\_主要包括catch、then、constructor方法。所以我们对Promise的学习主要就是[[PromiseStatus]]，[[PromiseValue]]属性和catch，then方法。\n\n### Promise的三种状态\n通过[资料](http://es6.ruanyifeng.com/#docs/promise)，我们会知道Promise对象有三种状态：Pending、Resolved和Rejected。  \nPromise构造函数接受一个函数作为参数，该函数有两个参数分别为resolve和reject，我们的创建方法应该是这样`new Promise(function (resolve, reject) {})`。  \n这两个参数resolve和reject也是函数，resolve是将Promise对象的状态从Pending变成Resolved，reject是将Promise对象的状态从Pending变成Rejected。  \n如果我们执行`var promise = new Promise(function(resolve, reject){resolve()})`，会发现promise中的[[PromiseStatus]]变成了`\"resolved\"`。如果我们执行`var promise = new Promise(function(resolve, reject){resolve('执行成功')})`，会发现不仅[[PromiseStatus]]变了，[[PromiseValue]]的值变成了`“执行成功”`。(reject函数同理)\n\n    需要注意：\n      只有函数中的构造函数参数中的resolve和reject可以改变Promise对象的状态。\n      一旦Promise对象的状态改变，就会一直保持这个状态，不能再改变。\n\n### Promise的then函数和catch函数\n\nthen函数和catch函数可以理解成对Promise状态的监听函数，不同点在于监听函数需要在事件发生之前创建，而因为Promise中的状态在改变后是不能再次改变的，所以then函数和catch函数可以在Promise对象改变状态之后创建，这样的话，该函数会立即执行。  \nthen函数接受两个函数作为参数，分别是Promise状态为`Resolved`时执行和状态为`Rejected`时执行。\n```javascript\n// promise是一个Promise对象\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\nthen函数中的函数参数是[[PromiseValue]]中的值，即是Promise构造中的resolve()、reject()中的参数。\n\n另外，then函数中的方法是异步的，即使resolve立即执行，then中的函数也在同步函数执行结束之后执行：\n```javascript\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise');\n  resolve();\n});\n\npromise.then(function() {\n  console.log('Resolved.');\n});\n\nconsole.log('Hi!');\n\n// Promise\n// Hi!\n// Resolved\n```\n\ncatch函数相当于.then(null, function () {})，是在发生错误时的回调函数，reject()执行时也算是一种错误发生，所以在执行reject()时，catch中的函数也会被执行。  \n所以，最好的方式是reject()发生时候需要执行的函数定义在catch中，而不是在then的第二个参数中，这样无论是reject()还是其他错误都能够被捕获。\n```javascript\n// bad\npromise\n  .then(function(data) {\n    // success\n  }, function(err) {\n    // error\n  });\n\n// good\npromise\n  .then(function(data) { //cb\n    // success\n  })\n  .catch(function(err) {\n    // error\n  });\n```\n\n### Promise对象的嵌套\n在resolve()和reject()中传递的可以是另一个Promise对象，例如\n```javascript\nvar p1 = new Promise(function (resolve, reject) {\n  setTimeout(() => reject(new Error('fail')), 3000)\n})\n\nvar p2 = new Promise(function (resolve, reject) {\n  setTimeout(() => resolve(p1), 1000)\n})\n\np2\n  .then(result => console.log(result))\n  .catch(error => console.log(error))\n// Error: fail\n```\np1是一个Promise，3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。此时，由于p2返回的是另一个Promise，所以后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。\n\n### 其他函数\n\n#### Promise.all()\nPromise.all()将多个Promise包装成一个Promise对象，只有在包装的多个Promise都转变成`Resolved`状态，此Promise.all()才会转变成`Resolved`状态，返回值是多个Promise返回值组成的数组；如果有其中一个转变成了`Rejected`状态，则此Promise.all()变成`Rejected`状态，返回值是第一个被reject的返回值。\n\n#### Promise.race()\nPromise.race()可以理解成Promise.all()的“否命题”。  \n将多个Promise包装成一个，只要有其中一个状态变成`Resolved`，则此Promise.race()变成`Resolved`，返回值是第一个状态变成`Resolved`的值。\n\n#### Promise.resolve()\nPromise.resolve()用于将对象转换成Promise对象。\n\n    1. 参数为Promise对象，方法什么也不做，直接返回。\n    2. 参数为一个有then方法的对象，方法将对象转换成Promise对象，并立即执行then方法。例如：Promise.resolve(Object)相当于new Promise(Object.then)\n    3. 参数不是具有then方法的对象，或者不是对象，则返回一个状态为`Resolved`的Promise对象，并将此参数传递给then中的第一个参数函数。\n    4. 不带任何参数，直接返回`Resolved`的Promise对象。\n\n#### Promise.reject()\nPromise.reject()和Promise.resolve()行为一致，只是返回的默认是`Rejected`的Promise对象。\n\n#### done()\n\n#### finally()\n","slug":"Promise总结","published":1,"updated":"2017-03-22T01:27:55.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8kh20005ohfkrmgw7sy4","content":"<h2 id=\"Promise总结\"><a href=\"#Promise总结\" class=\"headerlink\" title=\"Promise总结\"></a>Promise总结</h2><p>因为最近项目中用到了ajax，想尝试下Promise，所以看了下ES6中的<a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"external\">Promise</a>。</p>\n<p>一般用法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// promise表示一个Promise对象</span></div><div class=\"line\">promise</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// success</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// error</span></div><div class=\"line\">  &#125;)</div></pre></td></tr></table></figure></p>\n<p>所以如果使用jQuery或者zepto，可以这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ajaxBack = $.ajax(&#123;</div><div class=\"line\">  <span class=\"attr\">url</span>: <span class=\"string\">'*****'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">ajaxBack</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 处理数据</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 处理报错</span></div><div class=\"line\">  &#125;)</div></pre></td></tr></table></figure></p>\n<h3 id=\"什么是Promise对象？\"><a href=\"#什么是Promise对象？\" class=\"headerlink\" title=\"什么是Promise对象？\"></a>什么是Promise对象？</h3><p>Promise是异步编程的一种解决方案。<br>首先，我们通过chrome浏览器控制台来看一下Promise对象的样子。<br>在控制台输入<code>Promise</code>然后回车，会看到输出<code>function Promise() { [native code] }</code>。然后我们new一个Promise出来看一下，<code>var promise = new Promise(function(){})</code>，在创建Promise对象时候，必须传递一个函数，否则会报错。<br>看一下promise：<br><img src=\"./images/Promise_Object.png\" alt=\"Promise对象\"><br>包括__proto__，[[PromiseStatus]]，[[PromiseValue]]三个属性，其中__proto__主要包括catch、then、constructor方法。所以我们对Promise的学习主要就是[[PromiseStatus]]，[[PromiseValue]]属性和catch，then方法。</p>\n<h3 id=\"Promise的三种状态\"><a href=\"#Promise的三种状态\" class=\"headerlink\" title=\"Promise的三种状态\"></a>Promise的三种状态</h3><p>通过<a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"external\">资料</a>，我们会知道Promise对象有三种状态：Pending、Resolved和Rejected。<br>Promise构造函数接受一个函数作为参数，该函数有两个参数分别为resolve和reject，我们的创建方法应该是这样<code>new Promise(function (resolve, reject) {})</code>。<br>这两个参数resolve和reject也是函数，resolve是将Promise对象的状态从Pending变成Resolved，reject是将Promise对象的状态从Pending变成Rejected。<br>如果我们执行<code>var promise = new Promise(function(resolve, reject){resolve()})</code>，会发现promise中的[[PromiseStatus]]变成了<code>&quot;resolved&quot;</code>。如果我们执行<code>var promise = new Promise(function(resolve, reject){resolve(&#39;执行成功&#39;)})</code>，会发现不仅[[PromiseStatus]]变了，[[PromiseValue]]的值变成了<code>“执行成功”</code>。(reject函数同理)</p>\n<pre><code>需要注意：\n  只有函数中的构造函数参数中的resolve和reject可以改变Promise对象的状态。\n  一旦Promise对象的状态改变，就会一直保持这个状态，不能再改变。\n</code></pre><h3 id=\"Promise的then函数和catch函数\"><a href=\"#Promise的then函数和catch函数\" class=\"headerlink\" title=\"Promise的then函数和catch函数\"></a>Promise的then函数和catch函数</h3><p>then函数和catch函数可以理解成对Promise状态的监听函数，不同点在于监听函数需要在事件发生之前创建，而因为Promise中的状态在改变后是不能再次改变的，所以then函数和catch函数可以在Promise对象改变状态之后创建，这样的话，该函数会立即执行。<br>then函数接受两个函数作为参数，分别是Promise状态为<code>Resolved</code>时执行和状态为<code>Rejected</code>时执行。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// promise是一个Promise对象</span></div><div class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// success</span></div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// failure</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>then函数中的函数参数是[[PromiseValue]]中的值，即是Promise构造中的resolve()、reject()中的参数。</p>\n<p>另外，then函数中的方法是异步的，即使resolve立即执行，then中的函数也在同步函数执行结束之后执行：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Promise'</span>);</div><div class=\"line\">  resolve();</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved.'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi!'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Promise</span></div><div class=\"line\"><span class=\"comment\">// Hi!</span></div><div class=\"line\"><span class=\"comment\">// Resolved</span></div></pre></td></tr></table></figure></p>\n<p>catch函数相当于.then(null, function () {})，是在发生错误时的回调函数，reject()执行时也算是一种错误发生，所以在执行reject()时，catch中的函数也会被执行。<br>所以，最好的方式是reject()发生时候需要执行的函数定义在catch中，而不是在then的第二个参数中，这样无论是reject()还是其他错误都能够被捕获。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// bad</span></div><div class=\"line\">promise</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// success</span></div><div class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// error</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// good</span></div><div class=\"line\">promise</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123; <span class=\"comment\">//cb</span></div><div class=\"line\">    <span class=\"comment\">// success</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// error</span></div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"Promise对象的嵌套\"><a href=\"#Promise对象的嵌套\" class=\"headerlink\" title=\"Promise对象的嵌套\"></a>Promise对象的嵌套</h3><p>在resolve()和reject()中传递的可以是另一个Promise对象，例如<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'fail'</span>)), <span class=\"number\">3000</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(p1), <span class=\"number\">1000</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">p2</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> <span class=\"built_in\">console</span>.log(result))</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(error))</div><div class=\"line\"><span class=\"comment\">// Error: fail</span></div></pre></td></tr></table></figure></p>\n<p>p1是一个Promise，3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。此时，由于p2返回的是另一个Promise，所以后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。</p>\n<h3 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h3><h4 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h4><p>Promise.all()将多个Promise包装成一个Promise对象，只有在包装的多个Promise都转变成<code>Resolved</code>状态，此Promise.all()才会转变成<code>Resolved</code>状态，返回值是多个Promise返回值组成的数组；如果有其中一个转变成了<code>Rejected</code>状态，则此Promise.all()变成<code>Rejected</code>状态，返回值是第一个被reject的返回值。</p>\n<h4 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h4><p>Promise.race()可以理解成Promise.all()的“否命题”。<br>将多个Promise包装成一个，只要有其中一个状态变成<code>Resolved</code>，则此Promise.race()变成<code>Resolved</code>，返回值是第一个状态变成<code>Resolved</code>的值。</p>\n<h4 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h4><p>Promise.resolve()用于将对象转换成Promise对象。</p>\n<pre><code>1. 参数为Promise对象，方法什么也不做，直接返回。\n2. 参数为一个有then方法的对象，方法将对象转换成Promise对象，并立即执行then方法。例如：Promise.resolve(Object)相当于new Promise(Object.then)\n3. 参数不是具有then方法的对象，或者不是对象，则返回一个状态为`Resolved`的Promise对象，并将此参数传递给then中的第一个参数函数。\n4. 不带任何参数，直接返回`Resolved`的Promise对象。\n</code></pre><h4 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h4><p>Promise.reject()和Promise.resolve()行为一致，只是返回的默认是<code>Rejected</code>的Promise对象。</p>\n<h4 id=\"done\"><a href=\"#done\" class=\"headerlink\" title=\"done()\"></a>done()</h4><h4 id=\"finally\"><a href=\"#finally\" class=\"headerlink\" title=\"finally()\"></a>finally()</h4>","excerpt":"","more":"<h2 id=\"Promise总结\"><a href=\"#Promise总结\" class=\"headerlink\" title=\"Promise总结\"></a>Promise总结</h2><p>因为最近项目中用到了ajax，想尝试下Promise，所以看了下ES6中的<a href=\"http://es6.ruanyifeng.com/#docs/promise\">Promise</a>。</p>\n<p>一般用法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// promise表示一个Promise对象</span></div><div class=\"line\">promise</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// success</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// error</span></div><div class=\"line\">  &#125;)</div></pre></td></tr></table></figure></p>\n<p>所以如果使用jQuery或者zepto，可以这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ajaxBack = $.ajax(&#123;</div><div class=\"line\">  <span class=\"attr\">url</span>: <span class=\"string\">'*****'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">ajaxBack</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 处理数据</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 处理报错</span></div><div class=\"line\">  &#125;)</div></pre></td></tr></table></figure></p>\n<h3 id=\"什么是Promise对象？\"><a href=\"#什么是Promise对象？\" class=\"headerlink\" title=\"什么是Promise对象？\"></a>什么是Promise对象？</h3><p>Promise是异步编程的一种解决方案。<br>首先，我们通过chrome浏览器控制台来看一下Promise对象的样子。<br>在控制台输入<code>Promise</code>然后回车，会看到输出<code>function Promise() { [native code] }</code>。然后我们new一个Promise出来看一下，<code>var promise = new Promise(function(){})</code>，在创建Promise对象时候，必须传递一个函数，否则会报错。<br>看一下promise：<br><img src=\"./images/Promise_Object.png\" alt=\"Promise对象\"><br>包括__proto__，[[PromiseStatus]]，[[PromiseValue]]三个属性，其中__proto__主要包括catch、then、constructor方法。所以我们对Promise的学习主要就是[[PromiseStatus]]，[[PromiseValue]]属性和catch，then方法。</p>\n<h3 id=\"Promise的三种状态\"><a href=\"#Promise的三种状态\" class=\"headerlink\" title=\"Promise的三种状态\"></a>Promise的三种状态</h3><p>通过<a href=\"http://es6.ruanyifeng.com/#docs/promise\">资料</a>，我们会知道Promise对象有三种状态：Pending、Resolved和Rejected。<br>Promise构造函数接受一个函数作为参数，该函数有两个参数分别为resolve和reject，我们的创建方法应该是这样<code>new Promise(function (resolve, reject) {})</code>。<br>这两个参数resolve和reject也是函数，resolve是将Promise对象的状态从Pending变成Resolved，reject是将Promise对象的状态从Pending变成Rejected。<br>如果我们执行<code>var promise = new Promise(function(resolve, reject){resolve()})</code>，会发现promise中的[[PromiseStatus]]变成了<code>&quot;resolved&quot;</code>。如果我们执行<code>var promise = new Promise(function(resolve, reject){resolve(&#39;执行成功&#39;)})</code>，会发现不仅[[PromiseStatus]]变了，[[PromiseValue]]的值变成了<code>“执行成功”</code>。(reject函数同理)</p>\n<pre><code>需要注意：\n  只有函数中的构造函数参数中的resolve和reject可以改变Promise对象的状态。\n  一旦Promise对象的状态改变，就会一直保持这个状态，不能再改变。\n</code></pre><h3 id=\"Promise的then函数和catch函数\"><a href=\"#Promise的then函数和catch函数\" class=\"headerlink\" title=\"Promise的then函数和catch函数\"></a>Promise的then函数和catch函数</h3><p>then函数和catch函数可以理解成对Promise状态的监听函数，不同点在于监听函数需要在事件发生之前创建，而因为Promise中的状态在改变后是不能再次改变的，所以then函数和catch函数可以在Promise对象改变状态之后创建，这样的话，该函数会立即执行。<br>then函数接受两个函数作为参数，分别是Promise状态为<code>Resolved</code>时执行和状态为<code>Rejected</code>时执行。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// promise是一个Promise对象</span></div><div class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// success</span></div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// failure</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>then函数中的函数参数是[[PromiseValue]]中的值，即是Promise构造中的resolve()、reject()中的参数。</p>\n<p>另外，then函数中的方法是异步的，即使resolve立即执行，then中的函数也在同步函数执行结束之后执行：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Promise'</span>);</div><div class=\"line\">  resolve();</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved.'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi!'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Promise</span></div><div class=\"line\"><span class=\"comment\">// Hi!</span></div><div class=\"line\"><span class=\"comment\">// Resolved</span></div></pre></td></tr></table></figure></p>\n<p>catch函数相当于.then(null, function () {})，是在发生错误时的回调函数，reject()执行时也算是一种错误发生，所以在执行reject()时，catch中的函数也会被执行。<br>所以，最好的方式是reject()发生时候需要执行的函数定义在catch中，而不是在then的第二个参数中，这样无论是reject()还是其他错误都能够被捕获。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// bad</span></div><div class=\"line\">promise</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// success</span></div><div class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// error</span></div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// good</span></div><div class=\"line\">promise</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123; <span class=\"comment\">//cb</span></div><div class=\"line\">    <span class=\"comment\">// success</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// error</span></div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"Promise对象的嵌套\"><a href=\"#Promise对象的嵌套\" class=\"headerlink\" title=\"Promise对象的嵌套\"></a>Promise对象的嵌套</h3><p>在resolve()和reject()中传递的可以是另一个Promise对象，例如<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'fail'</span>)), <span class=\"number\">3000</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(p1), <span class=\"number\">1000</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">p2</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> <span class=\"built_in\">console</span>.log(result))</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(error))</div><div class=\"line\"><span class=\"comment\">// Error: fail</span></div></pre></td></tr></table></figure></p>\n<p>p1是一个Promise，3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。此时，由于p2返回的是另一个Promise，所以后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。</p>\n<h3 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h3><h4 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h4><p>Promise.all()将多个Promise包装成一个Promise对象，只有在包装的多个Promise都转变成<code>Resolved</code>状态，此Promise.all()才会转变成<code>Resolved</code>状态，返回值是多个Promise返回值组成的数组；如果有其中一个转变成了<code>Rejected</code>状态，则此Promise.all()变成<code>Rejected</code>状态，返回值是第一个被reject的返回值。</p>\n<h4 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h4><p>Promise.race()可以理解成Promise.all()的“否命题”。<br>将多个Promise包装成一个，只要有其中一个状态变成<code>Resolved</code>，则此Promise.race()变成<code>Resolved</code>，返回值是第一个状态变成<code>Resolved</code>的值。</p>\n<h4 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h4><p>Promise.resolve()用于将对象转换成Promise对象。</p>\n<pre><code>1. 参数为Promise对象，方法什么也不做，直接返回。\n2. 参数为一个有then方法的对象，方法将对象转换成Promise对象，并立即执行then方法。例如：Promise.resolve(Object)相当于new Promise(Object.then)\n3. 参数不是具有then方法的对象，或者不是对象，则返回一个状态为`Resolved`的Promise对象，并将此参数传递给then中的第一个参数函数。\n4. 不带任何参数，直接返回`Resolved`的Promise对象。\n</code></pre><h4 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h4><p>Promise.reject()和Promise.resolve()行为一致，只是返回的默认是<code>Rejected</code>的Promise对象。</p>\n<h4 id=\"done\"><a href=\"#done\" class=\"headerlink\" title=\"done()\"></a>done()</h4><h4 id=\"finally\"><a href=\"#finally\" class=\"headerlink\" title=\"finally()\"></a>finally()</h4>"},{"title":"React Docs（1）","date":"2016-12-08T16:00:00.000Z","comments":1,"_content":"\n## 安装\nReact在codepen上提供了一个Hello，World项目事例，只需打开[网站](http://codepen.io/gaearon/pen/rrpgNB?editors=0010)，即可尝试React。  \n另外还提供了一个[html文件](https://facebook.github.io/react/downloads/single-file-example.html)的Hello，World项目，项目中引用CDN的react.js、react-dom.js以及用于编译babel的babel.min.js，运行比较缓慢，只适合学习语法使用。\n\n## 创建单页面应用\n创建React应用的最好方法是单页面应用，这里是最好方法，也是可以创建多页面应用的。可以通过官方方法去创建你的应用：\n```shell\nnpm install -g create-react-app\ncreate-create-app hello-world\ncd hello-world\nnpm start\n```\n这里不涉及任何后端逻辑和数据库，可以使用任何你想用的后端。create-react-app中使用了Webpack，Babel和ESLint，但是你可以自己去配置他们。\n\n### 将React加入一个现有的应用\n使用`npm install --save react react-dom`安装React。  \n将其导入你的代码中，如：\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nReactDOM.render(\n  <h1>Hello, world!</h1>,\n  document.getElementById('root')\n)\n```\n这段代码应该被包含在一个拥有id为root的HTML元素，所以你的HTML文件需要`<div id=\"root\"></div>`  \n当你使用上面方法使用React的时候，需要使用预设为es2015和react的Babel进行转化代码。使用React在生产环境的时候，设置NODE_ENV为\"production\"。\n\n### 使用ES6和JSX\n建议是用Babel将你的ES6和JSX代码转换为JavaScript代码，Babel可以有很多不同的配置，但是确保里面包含`babel-preset-react`和`babel-preset-es2015`。\n\n### 使用CDN\n如果不想使用npm，可以使用CDN\n```html\n<script src=\"https://unpkg.com/react@15/dist/react.js\"></script>\n<script src=\"https://unpkg.com/react-dom@15/dist/react-dom.js\"></script>\n```\n@后面数字可以指定版本\n```html\n<script src=\"https://unpkg.com/react@15/dist/react.min.js\"></script>\n<script src=\"https://unpkg.com/react-dom@15/dist/react-dom.min.js\"></script>\n```\n\n## JSX\n在JSX中，可以在任意地方插入JavaScript代码，只需要将JavaScript放在大括号中即可。下面的代码都是合法的：\n```jsx\nfunction formatName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\nconst user = {\n  firstName: 'Harper',\n  lastName: 'Perez'\n};\n\nconst element = (\n  <h1>\n    Hello, {formatName(user)}!\n  </h1>\n);\n\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);\n```\n将JSX代码放在小括号中，像HTML代码一样换行，可以方便阅读。\n\n#### JSX也是表达式\nJSX最后也被编译成JavaScript代码，这就以为着JSX可以赋值给一个JavaScript变量，可以作为方法的参数，可以被方法返回。\n\n#### JSX添加HTML属性\n可以用字符串设置属性，也可以通过使用{}将JavaScript表达式赋值给属性。\n\n#### 闭合JSX\n如果JSX是空的可以使用`/>`来闭合标签，如果包含其他标签，也可以使用</***>闭合。  \n虽然JSX很接近HTML，但是还是有些不同，比如属性使用小驼峰法命名，class使用className，for使用forHtml等。\n\n#### JSX防止注入攻击\n默认情况下，React DOM在渲染JSX之前会对其进行编码。\n\n#### JSX描述对象\nBabel会将JSX转化为React.createElement()形式，比如下面这样：\n```jsx\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n)\n```\n转化为\n```javascript\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n```\nReact.createElement会对你的代码进行一些检查，但是本质上就是将其转化成一个对象：\n```javascript\nconst element = {\n  type: 'h1',\n  props: {\n    className: 'greeting',\n    children: 'Hello, world'\n  }\n}\n```\n\n## 组件\n将你的页面分成一个个组件，每个组件都是独立的、可以重复使用的。组件就像JavaScript中的方法，可以接受一些输入参数，返回React元素\n\n#### Funtional 和 Class 组件\n定义组件最简单的方式是使用JavaScript方法：\n```javascript\nfunction Welcome (props) {\n  return <h1>Hello, {props.name}</h1>\n}\n这个方法就是个有效的React组件，因为它接受props作为参数，并且返回了一个React元素。\n\n另外也可以使用ES6中的类(class)来定义组件：\n```javascript\nclass Welcome extends React.Component {\n  render () {\n    return <h1>Hello, {this.props.name}</h1>\n  }\n}\n```\n上面两种定义组件的方法是等价的。  \n但是Class组件能够添加一些额外的功能，我们将在下面讨论。在不需要这些额外的方法，可以使用Functional组件。\n\n#### 渲染组件\n渲染如下：\n```javascript\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n\nconst element = <Welcome name=\"Sara\" />;\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);\n```\n过程：\n  1. 调用ReactDOM.render()方法，参数为自定义组件<Welcome name=\"Sara\" />。\n  2. React调用组件Welcome，传递`{name=\"Sara\"}`作为参数。\n  3. Welcome组件返回`<h1>Hello, Sara</h1>`。\n  4. React将`<h1>Hello, Sara</h1>`更新到页面。\n\n#### 组件组合\n组件可以任意组合。  \n通常情况，React应用中在最顶端是一个`App`组件。组件必须有一个根元素，也就是所有元素都得包裹起来。\n\n#### 提取组件\n不要担心组件被拆分的太小。下面是一个对组件进行拆分的例子。  \nComment组件：  \n```javascript\nfunction Comment(props) {\n  return (\n    <div className=\"Comment\">\n      <div className=\"UserInfo\">\n        <img className=\"Avatar\"\n          src={props.author.avatarUrl}\n          alt={props.author.name}\n        />\n        <div className=\"UserInfo-name\">\n          {props.author.name}\n        </div>\n      </div>\n      <div className=\"Comment-text\">\n        {props.text}\n      </div>\n      <div className=\"Comment-date\">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n```\n在Comment组件中，使用了`author (object)`，`text (string)`，`date (date)`来描述这个对象。这样的组件因为组合的原因是很难复用的。\n\n第一步，提取出一个`Avatar`组件：\n```javascript\nfunction Avatar(props) {\n  return (\n    <img className=\"Avatar\"\n      src={props.user.avatarUrl}\n      alt={props.user.name}\n    />\n  );\n}\n```\n这里的`Avatar`组件我们系统他更通用，所以说用了`user`而不是`author`。  \n根据组件去命名参数，而不是根据使用上下文。\n\n下一步是提取`UserInfo`组件，这里使用了上面提取的`Avatar`组件：\n```javascript\nfunction UserInfo(props) {\n  return (\n    <div className=\"UserInfo\">\n      <Avatar user={props.user} />\n      <div className=\"UserInfo-name\">\n        {props.user.name}\n      </div>\n    </div>\n  );\n}\n```\n这样，我们的`Comment`组件就成了下面的样子：\n```javascript\nfunction Comment(props) {\n  return (\n    <div className=\"Comment\">\n      <UserInfo user={props.author} />\n      <div className=\"Comment-text\">\n        {props.text}\n      </div>\n      <div className=\"Comment-date\">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n```\n\n#### Props是只读的\n无论是Funcional还是Class组件，都是不能够修改props的。\n```javascript\n// 下面这个是纯函数，因为它没有试图改变自己的输入，并且对相同的输入会有相同的输出。\nfunction sum(a, b) {\n  return a + b;\n}\n// 下面这个不是纯函数，因为他改变了输入的值\nfunction withdraw(account, amount) {\n  account.total -= amount;\n}\n```\n通过官方这个例子，可以明白纯函数有两点，一是相同的输入就会有相同的输出，第二点是不会更改输入的参数。\n\n所有的React组件对于props参数必须像纯函数一样，也就是不会试图去修改props，并且对于相同的props会有相同的输出。  \n当然，React也提供了随时间动态变化组件的方法，state允许根据用户行为、网络反馈等改变React组件的输出形式，这并不违背React纯函数原则。\n\n## state 和 生命周期\n请看下面一段代码：\n```javascript\nconst Clock = (\n  <div>\n    <h1>Hello, world!</h1>\n    <h2>It is {new Date().toLocaleTimeString()}.</h2>\n  </div>\n);\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n```\n这段代码只能够显示一个Hello,world!与一个生成页面的时间。如果想要时间不停的更新，就需要使用setInterval()不停的去执行。\n```javascript\n// 这样\nfunction tick() {\n  const Clock = (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {new Date().toLocaleTimeString()}.</h2>\n    </div>\n  );\n  ReactDOM.render(\n    <Clock />,\n    document.getElementById('root')\n  );\n}\nsetInterval(tick, 1000);\n\n// 或者这样\nfunction Clock(props) {\n  return (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {props.date.toLocaleTimeString()}.</h2>\n    </div>\n  );\n}\n\nfunction tick() {\n  ReactDOM.render(\n    <Clock date={new Date()} />,\n    document.getElementById('root')\n  );\n}\nsetInterval(tick, 1000);\n\n// 但是下面这种就是不可行的，原因在于Clock组件定义被转化成了一个对象，在之后没有发生过变化。\nconst Clock = (\n  <div>\n    <h1>Hello, world!</h1>\n    <h2>It is {new Date().toLocaleTimeString()}.</h2>\n  </div>\n);\nsetInterval(\nfunction(){\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n)}, 1000)\n```\n这样的代码的问题在于时间的变化应该是`Clock`组件的行为，而不应该定义在全局。  \n`state`可以帮助我们解决这个问题，state与props类似，但是更私有且被组件所控制，而不是传递过来的。\n\n#### 将Functional组件转换为Class组件\nFunctional组件是无状态组件，不能使用state，所以首先需要将Functional转化为Class组件：\n  1. 创建一个和Functional组件名相同的ES6 class继承`React.Component`\n  2. 添加空的方法`render()`\n  3. 将Functional组件中的函数主体移动`render()`方法中\n  4. 将`render()`中的`props`替换成`this.props`\n  5. 删除原来的Functional组件声明\nClass组件不仅可以使用state还可以使用生命周期函数。  \n拿上面的`Clock`组件作为事例，经过上面的转换，现在的Clock组件应该是这个样子：\n```jsx\nclass Clock extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.props.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\n\n#### 为Class组件添加本地state\n还是上面的`Clock`组件：\n  1. 将`render()`中的`this.props`替换成`this.state`\n  2. 添加class构造函数(constructor)初始化this.state (Class组件总是应该将props传递给父类)\n  3. 移除`date`从组件调用的props中\n```javascript\nclass Clock extends React.Component {\n  // 这里是步骤2\n  constructor(props) {\n    // 将props传递给父类\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n```\n这样只是初始化了state，后面会设置定时器。\n","source":"_posts/React Docs(1).md","raw":"---\ntitle: React Docs（1）\ndate: 2016-12-09\ntags: [JavaScript, React]\ncategories: \n- React\ncomments: true\n---\n\n## 安装\nReact在codepen上提供了一个Hello，World项目事例，只需打开[网站](http://codepen.io/gaearon/pen/rrpgNB?editors=0010)，即可尝试React。  \n另外还提供了一个[html文件](https://facebook.github.io/react/downloads/single-file-example.html)的Hello，World项目，项目中引用CDN的react.js、react-dom.js以及用于编译babel的babel.min.js，运行比较缓慢，只适合学习语法使用。\n\n## 创建单页面应用\n创建React应用的最好方法是单页面应用，这里是最好方法，也是可以创建多页面应用的。可以通过官方方法去创建你的应用：\n```shell\nnpm install -g create-react-app\ncreate-create-app hello-world\ncd hello-world\nnpm start\n```\n这里不涉及任何后端逻辑和数据库，可以使用任何你想用的后端。create-react-app中使用了Webpack，Babel和ESLint，但是你可以自己去配置他们。\n\n### 将React加入一个现有的应用\n使用`npm install --save react react-dom`安装React。  \n将其导入你的代码中，如：\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nReactDOM.render(\n  <h1>Hello, world!</h1>,\n  document.getElementById('root')\n)\n```\n这段代码应该被包含在一个拥有id为root的HTML元素，所以你的HTML文件需要`<div id=\"root\"></div>`  \n当你使用上面方法使用React的时候，需要使用预设为es2015和react的Babel进行转化代码。使用React在生产环境的时候，设置NODE_ENV为\"production\"。\n\n### 使用ES6和JSX\n建议是用Babel将你的ES6和JSX代码转换为JavaScript代码，Babel可以有很多不同的配置，但是确保里面包含`babel-preset-react`和`babel-preset-es2015`。\n\n### 使用CDN\n如果不想使用npm，可以使用CDN\n```html\n<script src=\"https://unpkg.com/react@15/dist/react.js\"></script>\n<script src=\"https://unpkg.com/react-dom@15/dist/react-dom.js\"></script>\n```\n@后面数字可以指定版本\n```html\n<script src=\"https://unpkg.com/react@15/dist/react.min.js\"></script>\n<script src=\"https://unpkg.com/react-dom@15/dist/react-dom.min.js\"></script>\n```\n\n## JSX\n在JSX中，可以在任意地方插入JavaScript代码，只需要将JavaScript放在大括号中即可。下面的代码都是合法的：\n```jsx\nfunction formatName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\nconst user = {\n  firstName: 'Harper',\n  lastName: 'Perez'\n};\n\nconst element = (\n  <h1>\n    Hello, {formatName(user)}!\n  </h1>\n);\n\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);\n```\n将JSX代码放在小括号中，像HTML代码一样换行，可以方便阅读。\n\n#### JSX也是表达式\nJSX最后也被编译成JavaScript代码，这就以为着JSX可以赋值给一个JavaScript变量，可以作为方法的参数，可以被方法返回。\n\n#### JSX添加HTML属性\n可以用字符串设置属性，也可以通过使用{}将JavaScript表达式赋值给属性。\n\n#### 闭合JSX\n如果JSX是空的可以使用`/>`来闭合标签，如果包含其他标签，也可以使用</***>闭合。  \n虽然JSX很接近HTML，但是还是有些不同，比如属性使用小驼峰法命名，class使用className，for使用forHtml等。\n\n#### JSX防止注入攻击\n默认情况下，React DOM在渲染JSX之前会对其进行编码。\n\n#### JSX描述对象\nBabel会将JSX转化为React.createElement()形式，比如下面这样：\n```jsx\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n)\n```\n转化为\n```javascript\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n```\nReact.createElement会对你的代码进行一些检查，但是本质上就是将其转化成一个对象：\n```javascript\nconst element = {\n  type: 'h1',\n  props: {\n    className: 'greeting',\n    children: 'Hello, world'\n  }\n}\n```\n\n## 组件\n将你的页面分成一个个组件，每个组件都是独立的、可以重复使用的。组件就像JavaScript中的方法，可以接受一些输入参数，返回React元素\n\n#### Funtional 和 Class 组件\n定义组件最简单的方式是使用JavaScript方法：\n```javascript\nfunction Welcome (props) {\n  return <h1>Hello, {props.name}</h1>\n}\n这个方法就是个有效的React组件，因为它接受props作为参数，并且返回了一个React元素。\n\n另外也可以使用ES6中的类(class)来定义组件：\n```javascript\nclass Welcome extends React.Component {\n  render () {\n    return <h1>Hello, {this.props.name}</h1>\n  }\n}\n```\n上面两种定义组件的方法是等价的。  \n但是Class组件能够添加一些额外的功能，我们将在下面讨论。在不需要这些额外的方法，可以使用Functional组件。\n\n#### 渲染组件\n渲染如下：\n```javascript\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n\nconst element = <Welcome name=\"Sara\" />;\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);\n```\n过程：\n  1. 调用ReactDOM.render()方法，参数为自定义组件<Welcome name=\"Sara\" />。\n  2. React调用组件Welcome，传递`{name=\"Sara\"}`作为参数。\n  3. Welcome组件返回`<h1>Hello, Sara</h1>`。\n  4. React将`<h1>Hello, Sara</h1>`更新到页面。\n\n#### 组件组合\n组件可以任意组合。  \n通常情况，React应用中在最顶端是一个`App`组件。组件必须有一个根元素，也就是所有元素都得包裹起来。\n\n#### 提取组件\n不要担心组件被拆分的太小。下面是一个对组件进行拆分的例子。  \nComment组件：  \n```javascript\nfunction Comment(props) {\n  return (\n    <div className=\"Comment\">\n      <div className=\"UserInfo\">\n        <img className=\"Avatar\"\n          src={props.author.avatarUrl}\n          alt={props.author.name}\n        />\n        <div className=\"UserInfo-name\">\n          {props.author.name}\n        </div>\n      </div>\n      <div className=\"Comment-text\">\n        {props.text}\n      </div>\n      <div className=\"Comment-date\">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n```\n在Comment组件中，使用了`author (object)`，`text (string)`，`date (date)`来描述这个对象。这样的组件因为组合的原因是很难复用的。\n\n第一步，提取出一个`Avatar`组件：\n```javascript\nfunction Avatar(props) {\n  return (\n    <img className=\"Avatar\"\n      src={props.user.avatarUrl}\n      alt={props.user.name}\n    />\n  );\n}\n```\n这里的`Avatar`组件我们系统他更通用，所以说用了`user`而不是`author`。  \n根据组件去命名参数，而不是根据使用上下文。\n\n下一步是提取`UserInfo`组件，这里使用了上面提取的`Avatar`组件：\n```javascript\nfunction UserInfo(props) {\n  return (\n    <div className=\"UserInfo\">\n      <Avatar user={props.user} />\n      <div className=\"UserInfo-name\">\n        {props.user.name}\n      </div>\n    </div>\n  );\n}\n```\n这样，我们的`Comment`组件就成了下面的样子：\n```javascript\nfunction Comment(props) {\n  return (\n    <div className=\"Comment\">\n      <UserInfo user={props.author} />\n      <div className=\"Comment-text\">\n        {props.text}\n      </div>\n      <div className=\"Comment-date\">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n```\n\n#### Props是只读的\n无论是Funcional还是Class组件，都是不能够修改props的。\n```javascript\n// 下面这个是纯函数，因为它没有试图改变自己的输入，并且对相同的输入会有相同的输出。\nfunction sum(a, b) {\n  return a + b;\n}\n// 下面这个不是纯函数，因为他改变了输入的值\nfunction withdraw(account, amount) {\n  account.total -= amount;\n}\n```\n通过官方这个例子，可以明白纯函数有两点，一是相同的输入就会有相同的输出，第二点是不会更改输入的参数。\n\n所有的React组件对于props参数必须像纯函数一样，也就是不会试图去修改props，并且对于相同的props会有相同的输出。  \n当然，React也提供了随时间动态变化组件的方法，state允许根据用户行为、网络反馈等改变React组件的输出形式，这并不违背React纯函数原则。\n\n## state 和 生命周期\n请看下面一段代码：\n```javascript\nconst Clock = (\n  <div>\n    <h1>Hello, world!</h1>\n    <h2>It is {new Date().toLocaleTimeString()}.</h2>\n  </div>\n);\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n```\n这段代码只能够显示一个Hello,world!与一个生成页面的时间。如果想要时间不停的更新，就需要使用setInterval()不停的去执行。\n```javascript\n// 这样\nfunction tick() {\n  const Clock = (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {new Date().toLocaleTimeString()}.</h2>\n    </div>\n  );\n  ReactDOM.render(\n    <Clock />,\n    document.getElementById('root')\n  );\n}\nsetInterval(tick, 1000);\n\n// 或者这样\nfunction Clock(props) {\n  return (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {props.date.toLocaleTimeString()}.</h2>\n    </div>\n  );\n}\n\nfunction tick() {\n  ReactDOM.render(\n    <Clock date={new Date()} />,\n    document.getElementById('root')\n  );\n}\nsetInterval(tick, 1000);\n\n// 但是下面这种就是不可行的，原因在于Clock组件定义被转化成了一个对象，在之后没有发生过变化。\nconst Clock = (\n  <div>\n    <h1>Hello, world!</h1>\n    <h2>It is {new Date().toLocaleTimeString()}.</h2>\n  </div>\n);\nsetInterval(\nfunction(){\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n)}, 1000)\n```\n这样的代码的问题在于时间的变化应该是`Clock`组件的行为，而不应该定义在全局。  \n`state`可以帮助我们解决这个问题，state与props类似，但是更私有且被组件所控制，而不是传递过来的。\n\n#### 将Functional组件转换为Class组件\nFunctional组件是无状态组件，不能使用state，所以首先需要将Functional转化为Class组件：\n  1. 创建一个和Functional组件名相同的ES6 class继承`React.Component`\n  2. 添加空的方法`render()`\n  3. 将Functional组件中的函数主体移动`render()`方法中\n  4. 将`render()`中的`props`替换成`this.props`\n  5. 删除原来的Functional组件声明\nClass组件不仅可以使用state还可以使用生命周期函数。  \n拿上面的`Clock`组件作为事例，经过上面的转换，现在的Clock组件应该是这个样子：\n```jsx\nclass Clock extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.props.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\n\n#### 为Class组件添加本地state\n还是上面的`Clock`组件：\n  1. 将`render()`中的`this.props`替换成`this.state`\n  2. 添加class构造函数(constructor)初始化this.state (Class组件总是应该将props传递给父类)\n  3. 移除`date`从组件调用的props中\n```javascript\nclass Clock extends React.Component {\n  // 这里是步骤2\n  constructor(props) {\n    // 将props传递给父类\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n```\n这样只是初始化了state，后面会设置定时器。\n","slug":"React Docs(1)","published":1,"updated":"2017-03-22T01:28:04.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8kh40006ohfks9j0ns1x","content":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>React在codepen上提供了一个Hello，World项目事例，只需打开<a href=\"http://codepen.io/gaearon/pen/rrpgNB?editors=0010\" target=\"_blank\" rel=\"external\">网站</a>，即可尝试React。<br>另外还提供了一个<a href=\"https://facebook.github.io/react/downloads/single-file-example.html\" target=\"_blank\" rel=\"external\">html文件</a>的Hello，World项目，项目中引用CDN的react.js、react-dom.js以及用于编译babel的babel.min.js，运行比较缓慢，只适合学习语法使用。</p>\n<h2 id=\"创建单页面应用\"><a href=\"#创建单页面应用\" class=\"headerlink\" title=\"创建单页面应用\"></a>创建单页面应用</h2><p>创建React应用的最好方法是单页面应用，这里是最好方法，也是可以创建多页面应用的。可以通过官方方法去创建你的应用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g create-react-app</div><div class=\"line\">create-create-app hello-world</div><div class=\"line\">cd hello-world</div><div class=\"line\">npm start</div></pre></td></tr></table></figure></p>\n<p>这里不涉及任何后端逻辑和数据库，可以使用任何你想用的后端。create-react-app中使用了Webpack，Babel和ESLint，但是你可以自己去配置他们。</p>\n<h3 id=\"将React加入一个现有的应用\"><a href=\"#将React加入一个现有的应用\" class=\"headerlink\" title=\"将React加入一个现有的应用\"></a>将React加入一个现有的应用</h3><p>使用<code>npm install --save react react-dom</code>安装React。<br>将其导入你的代码中，如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>,</div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>这段代码应该被包含在一个拥有id为root的HTML元素，所以你的HTML文件需要<code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code><br>当你使用上面方法使用React的时候，需要使用预设为es2015和react的Babel进行转化代码。使用React在生产环境的时候，设置NODE_ENV为”production”。</p>\n<h3 id=\"使用ES6和JSX\"><a href=\"#使用ES6和JSX\" class=\"headerlink\" title=\"使用ES6和JSX\"></a>使用ES6和JSX</h3><p>建议是用Babel将你的ES6和JSX代码转换为JavaScript代码，Babel可以有很多不同的配置，但是确保里面包含<code>babel-preset-react</code>和<code>babel-preset-es2015</code>。</p>\n<h3 id=\"使用CDN\"><a href=\"#使用CDN\" class=\"headerlink\" title=\"使用CDN\"></a>使用CDN</h3><p>如果不想使用npm，可以使用CDN<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react@15/dist/react.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react-dom@15/dist/react-dom.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>@后面数字可以指定版本<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react@15/dist/react.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react-dom@15/dist/react-dom.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h2><p>在JSX中，可以在任意地方插入JavaScript代码，只需要将JavaScript放在大括号中即可。下面的代码都是合法的：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatName</span>(<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> user.firstName + <span class=\"string\">' '</span> + user.lastName;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> user = &#123;</div><div class=\"line\">  <span class=\"attr\">firstName</span>: <span class=\"string\">'Harper'</span>,</div><div class=\"line\">  <span class=\"attr\">lastName</span>: <span class=\"string\">'Perez'</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> element = (</div><div class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">    Hello, &#123;formatName(user)&#125;!</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">);</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  element,</div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<p>将JSX代码放在小括号中，像HTML代码一样换行，可以方便阅读。</p>\n<h4 id=\"JSX也是表达式\"><a href=\"#JSX也是表达式\" class=\"headerlink\" title=\"JSX也是表达式\"></a>JSX也是表达式</h4><p>JSX最后也被编译成JavaScript代码，这就以为着JSX可以赋值给一个JavaScript变量，可以作为方法的参数，可以被方法返回。</p>\n<h4 id=\"JSX添加HTML属性\"><a href=\"#JSX添加HTML属性\" class=\"headerlink\" title=\"JSX添加HTML属性\"></a>JSX添加HTML属性</h4><p>可以用字符串设置属性，也可以通过使用{}将JavaScript表达式赋值给属性。</p>\n<h4 id=\"闭合JSX\"><a href=\"#闭合JSX\" class=\"headerlink\" title=\"闭合JSX\"></a>闭合JSX</h4><p>如果JSX是空的可以使用<code>/&gt;</code>来闭合标签，如果包含其他标签，也可以使用&lt;/<em>*</em>&gt;闭合。<br>虽然JSX很接近HTML，但是还是有些不同，比如属性使用小驼峰法命名，class使用className，for使用forHtml等。</p>\n<h4 id=\"JSX防止注入攻击\"><a href=\"#JSX防止注入攻击\" class=\"headerlink\" title=\"JSX防止注入攻击\"></a>JSX防止注入攻击</h4><p>默认情况下，React DOM在渲染JSX之前会对其进行编码。</p>\n<h4 id=\"JSX描述对象\"><a href=\"#JSX描述对象\" class=\"headerlink\" title=\"JSX描述对象\"></a>JSX描述对象</h4><p>Babel会将JSX转化为React.createElement()形式，比如下面这样：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> element = (</div><div class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">className</span>=<span class=\"string\">\"greeting\"</span>&gt;</span></span></div><div class=\"line\">    Hello, world!</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>转化为<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> element = React.createElement(</div><div class=\"line\">  <span class=\"string\">'h1'</span>,</div><div class=\"line\">  &#123;<span class=\"attr\">className</span>: <span class=\"string\">'greeting'</span>&#125;,</div><div class=\"line\">  <span class=\"string\">'Hello, world!'</span></div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<p>React.createElement会对你的代码进行一些检查，但是本质上就是将其转化成一个对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> element = &#123;</div><div class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">'h1'</span>,</div><div class=\"line\">  <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">className</span>: <span class=\"string\">'greeting'</span>,</div><div class=\"line\">    <span class=\"attr\">children</span>: <span class=\"string\">'Hello, world'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><p>将你的页面分成一个个组件，每个组件都是独立的、可以重复使用的。组件就像JavaScript中的方法，可以接受一些输入参数，返回React元素</p>\n<h4 id=\"Funtional-和-Class-组件\"><a href=\"#Funtional-和-Class-组件\" class=\"headerlink\" title=\"Funtional 和 Class 组件\"></a>Funtional 和 Class 组件</h4><p>定义组件最简单的方式是使用JavaScript方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span> (<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">&#125;</div><div class=\"line\">这个方法就是个有效的React组件，因为它接受props作为参数，并且返回了一个React元素。</div><div class=\"line\"></div><div class=\"line\">另外也可以使用ES6中的类(<span class=\"class\"><span class=\"keyword\">class</span>)来定义组件：</span></div><div class=\"line\">```<span class=\"title\">javascript</span></div><div class=\"line\"><span class=\"title\">class</span> <span class=\"title\">Welcome</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> &#123;</div><div class=\"line\">  render () &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面两种定义组件的方法是等价的。<br>但是Class组件能够添加一些额外的功能，我们将在下面讨论。在不需要这些额外的方法，可以使用Functional组件。</p>\n<h4 id=\"渲染组件\"><a href=\"#渲染组件\" class=\"headerlink\" title=\"渲染组件\"></a>渲染组件</h4><p>渲染如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Welcome</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Sara\"</span> /&gt;</span>;</span></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  element,</div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<p>过程：</p>\n<ol>\n<li>调用ReactDOM.render()方法，参数为自定义组件<welcome name=\"Sara\">。</welcome></li>\n<li>React调用组件Welcome，传递<code>{name=&quot;Sara&quot;}</code>作为参数。</li>\n<li>Welcome组件返回<code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>。</li>\n<li>React将<code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>更新到页面。</li>\n</ol>\n<h4 id=\"组件组合\"><a href=\"#组件组合\" class=\"headerlink\" title=\"组件组合\"></a>组件组合</h4><p>组件可以任意组合。<br>通常情况，React应用中在最顶端是一个<code>App</code>组件。组件必须有一个根元素，也就是所有元素都得包裹起来。</p>\n<h4 id=\"提取组件\"><a href=\"#提取组件\" class=\"headerlink\" title=\"提取组件\"></a>提取组件</h4><p>不要担心组件被拆分的太小。下面是一个对组件进行拆分的例子。<br>Comment组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Comment</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment\"</span>&gt;</span></span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"UserInfo\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Avatar\"</span></span></div><div class=\"line\">          <span class=\"attr\">src</span>=<span class=\"string\">&#123;props.author.avatarUrl&#125;</span></div><div class=\"line\">          <span class=\"attr\">alt</span>=<span class=\"string\">&#123;props.author.name&#125;</span></div><div class=\"line\">        /&gt;</div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"UserInfo-name\"</span>&gt;</span></div><div class=\"line\">          &#123;props.author.name&#125;</div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment-text\"</span>&gt;</span></div><div class=\"line\">        &#123;props.text&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment-date\"</span>&gt;</span></div><div class=\"line\">        &#123;formatDate(props.date)&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在Comment组件中，使用了<code>author (object)</code>，<code>text (string)</code>，<code>date (date)</code>来描述这个对象。这样的组件因为组合的原因是很难复用的。</p>\n<p>第一步，提取出一个<code>Avatar</code>组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Avatar</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Avatar\"</span></span></span></div><div class=\"line\">      <span class=\"attr\">src</span>=<span class=\"string\">&#123;props.user.avatarUrl&#125;</span></div><div class=\"line\">      <span class=\"attr\">alt</span>=<span class=\"string\">&#123;props.user.name&#125;</span></div><div class=\"line\">    /&gt;</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里的<code>Avatar</code>组件我们系统他更通用，所以说用了<code>user</code>而不是<code>author</code>。<br>根据组件去命名参数，而不是根据使用上下文。</p>\n<p>下一步是提取<code>UserInfo</code>组件，这里使用了上面提取的<code>Avatar</code>组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserInfo</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"UserInfo\"</span>&gt;</span></span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">Avatar</span> <span class=\"attr\">user</span>=<span class=\"string\">&#123;props.user&#125;</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"UserInfo-name\"</span>&gt;</span></div><div class=\"line\">        &#123;props.user.name&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样，我们的<code>Comment</code>组件就成了下面的样子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Comment</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment\"</span>&gt;</span></span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">UserInfo</span> <span class=\"attr\">user</span>=<span class=\"string\">&#123;props.author&#125;</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment-text\"</span>&gt;</span></div><div class=\"line\">        &#123;props.text&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment-date\"</span>&gt;</span></div><div class=\"line\">        &#123;formatDate(props.date)&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"Props是只读的\"><a href=\"#Props是只读的\" class=\"headerlink\" title=\"Props是只读的\"></a>Props是只读的</h4><p>无论是Funcional还是Class组件，都是不能够修改props的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 下面这个是纯函数，因为它没有试图改变自己的输入，并且对相同的输入会有相同的输出。</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 下面这个不是纯函数，因为他改变了输入的值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withdraw</span>(<span class=\"params\">account, amount</span>) </span>&#123;</div><div class=\"line\">  account.total -= amount;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过官方这个例子，可以明白纯函数有两点，一是相同的输入就会有相同的输出，第二点是不会更改输入的参数。</p>\n<p>所有的React组件对于props参数必须像纯函数一样，也就是不会试图去修改props，并且对于相同的props会有相同的输出。<br>当然，React也提供了随时间动态变化组件的方法，state允许根据用户行为、网络反馈等改变React组件的输出形式，这并不违背React纯函数原则。</p>\n<h2 id=\"state-和-生命周期\"><a href=\"#state-和-生命周期\" class=\"headerlink\" title=\"state 和 生命周期\"></a>state 和 生命周期</h2><p>请看下面一段代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Clock = (</div><div class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>It is &#123;new Date().toLocaleTimeString()&#125;.<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">);</div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Clock</span> /&gt;</span>,</span></div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<p>这段代码只能够显示一个Hello,world!与一个生成页面的时间。如果想要时间不停的更新，就需要使用setInterval()不停的去执行。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 这样</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tick</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> Clock = (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>It is &#123;new Date().toLocaleTimeString()&#125;.<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  );</div><div class=\"line\">  ReactDOM.render(</div><div class=\"line\">    &lt;Clock /&gt;,</div><div class=\"line\">    document.getElementById('root')</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\">setInterval(tick, 1000);</div><div class=\"line\"></div><div class=\"line\">// 或者这样</div><div class=\"line\">function Clock(props) &#123;</div><div class=\"line\">  return (</div><div class=\"line\">    &lt;div&gt;</div><div class=\"line\">      &lt;h1&gt;Hello, world!&lt;/h1&gt;</div><div class=\"line\">      &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function tick() &#123;</div><div class=\"line\">  ReactDOM.render(</div><div class=\"line\">    &lt;Clock date=&#123;new Date()&#125; /&gt;,</div><div class=\"line\">    document.getElementById('root')</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\">setInterval(tick, 1000);</div><div class=\"line\"></div><div class=\"line\">// 但是下面这种就是不可行的，原因在于Clock组件定义被转化成了一个对象，在之后没有发生过变化。</div><div class=\"line\">const Clock = (</div><div class=\"line\">  &lt;div&gt;</div><div class=\"line\">    &lt;h1&gt;Hello, world!&lt;/h1&gt;</div><div class=\"line\">    &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt;</div><div class=\"line\">  &lt;/div&gt;</div><div class=\"line\">);</div><div class=\"line\">setInterval(</div><div class=\"line\">function()&#123;</div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;Clock /&gt;,</div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">)&#125;, 1000)</div></pre></td></tr></table></figure></p>\n<p>这样的代码的问题在于时间的变化应该是<code>Clock</code>组件的行为，而不应该定义在全局。<br><code>state</code>可以帮助我们解决这个问题，state与props类似，但是更私有且被组件所控制，而不是传递过来的。</p>\n<h4 id=\"将Functional组件转换为Class组件\"><a href=\"#将Functional组件转换为Class组件\" class=\"headerlink\" title=\"将Functional组件转换为Class组件\"></a>将Functional组件转换为Class组件</h4><p>Functional组件是无状态组件，不能使用state，所以首先需要将Functional转化为Class组件：</p>\n<ol>\n<li>创建一个和Functional组件名相同的ES6 class继承<code>React.Component</code></li>\n<li>添加空的方法<code>render()</code></li>\n<li>将Functional组件中的函数主体移动<code>render()</code>方法中</li>\n<li>将<code>render()</code>中的<code>props</code>替换成<code>this.props</code></li>\n<li>删除原来的Functional组件声明<br>Class组件不仅可以使用state还可以使用生命周期函数。<br>拿上面的<code>Clock</code>组件作为事例，经过上面的转换，现在的Clock组件应该是这个样子：<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>It is &#123;this.props.date.toLocaleTimeString()&#125;.<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"为Class组件添加本地state\"><a href=\"#为Class组件添加本地state\" class=\"headerlink\" title=\"为Class组件添加本地state\"></a>为Class组件添加本地state</h4><p>还是上面的<code>Clock</code>组件：</p>\n<ol>\n<li>将<code>render()</code>中的<code>this.props</code>替换成<code>this.state</code></li>\n<li>添加class构造函数(constructor)初始化this.state (Class组件总是应该将props传递给父类)</li>\n<li>移除<code>date</code>从组件调用的props中<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 这里是步骤2</span></div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"comment\">// 将props传递给父类</span></div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">date</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>It is &#123;this.state.date.toLocaleTimeString()&#125;.<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Clock</span> /&gt;</span>,</span></div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这样只是初始化了state，后面会设置定时器。</p>\n","excerpt":"","more":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>React在codepen上提供了一个Hello，World项目事例，只需打开<a href=\"http://codepen.io/gaearon/pen/rrpgNB?editors=0010\">网站</a>，即可尝试React。<br>另外还提供了一个<a href=\"https://facebook.github.io/react/downloads/single-file-example.html\">html文件</a>的Hello，World项目，项目中引用CDN的react.js、react-dom.js以及用于编译babel的babel.min.js，运行比较缓慢，只适合学习语法使用。</p>\n<h2 id=\"创建单页面应用\"><a href=\"#创建单页面应用\" class=\"headerlink\" title=\"创建单页面应用\"></a>创建单页面应用</h2><p>创建React应用的最好方法是单页面应用，这里是最好方法，也是可以创建多页面应用的。可以通过官方方法去创建你的应用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g create-react-app</div><div class=\"line\">create-create-app hello-world</div><div class=\"line\">cd hello-world</div><div class=\"line\">npm start</div></pre></td></tr></table></figure></p>\n<p>这里不涉及任何后端逻辑和数据库，可以使用任何你想用的后端。create-react-app中使用了Webpack，Babel和ESLint，但是你可以自己去配置他们。</p>\n<h3 id=\"将React加入一个现有的应用\"><a href=\"#将React加入一个现有的应用\" class=\"headerlink\" title=\"将React加入一个现有的应用\"></a>将React加入一个现有的应用</h3><p>使用<code>npm install --save react react-dom</code>安装React。<br>将其导入你的代码中，如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>,</div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>这段代码应该被包含在一个拥有id为root的HTML元素，所以你的HTML文件需要<code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code><br>当你使用上面方法使用React的时候，需要使用预设为es2015和react的Babel进行转化代码。使用React在生产环境的时候，设置NODE_ENV为”production”。</p>\n<h3 id=\"使用ES6和JSX\"><a href=\"#使用ES6和JSX\" class=\"headerlink\" title=\"使用ES6和JSX\"></a>使用ES6和JSX</h3><p>建议是用Babel将你的ES6和JSX代码转换为JavaScript代码，Babel可以有很多不同的配置，但是确保里面包含<code>babel-preset-react</code>和<code>babel-preset-es2015</code>。</p>\n<h3 id=\"使用CDN\"><a href=\"#使用CDN\" class=\"headerlink\" title=\"使用CDN\"></a>使用CDN</h3><p>如果不想使用npm，可以使用CDN<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react@15/dist/react.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react-dom@15/dist/react-dom.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>@后面数字可以指定版本<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react@15/dist/react.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/react-dom@15/dist/react-dom.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h2><p>在JSX中，可以在任意地方插入JavaScript代码，只需要将JavaScript放在大括号中即可。下面的代码都是合法的：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatName</span>(<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> user.firstName + <span class=\"string\">' '</span> + user.lastName;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> user = &#123;</div><div class=\"line\">  <span class=\"attr\">firstName</span>: <span class=\"string\">'Harper'</span>,</div><div class=\"line\">  <span class=\"attr\">lastName</span>: <span class=\"string\">'Perez'</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> element = (</div><div class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">    Hello, &#123;formatName(user)&#125;!</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">);</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  element,</div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<p>将JSX代码放在小括号中，像HTML代码一样换行，可以方便阅读。</p>\n<h4 id=\"JSX也是表达式\"><a href=\"#JSX也是表达式\" class=\"headerlink\" title=\"JSX也是表达式\"></a>JSX也是表达式</h4><p>JSX最后也被编译成JavaScript代码，这就以为着JSX可以赋值给一个JavaScript变量，可以作为方法的参数，可以被方法返回。</p>\n<h4 id=\"JSX添加HTML属性\"><a href=\"#JSX添加HTML属性\" class=\"headerlink\" title=\"JSX添加HTML属性\"></a>JSX添加HTML属性</h4><p>可以用字符串设置属性，也可以通过使用{}将JavaScript表达式赋值给属性。</p>\n<h4 id=\"闭合JSX\"><a href=\"#闭合JSX\" class=\"headerlink\" title=\"闭合JSX\"></a>闭合JSX</h4><p>如果JSX是空的可以使用<code>/&gt;</code>来闭合标签，如果包含其他标签，也可以使用&lt;/<em>*</em>&gt;闭合。<br>虽然JSX很接近HTML，但是还是有些不同，比如属性使用小驼峰法命名，class使用className，for使用forHtml等。</p>\n<h4 id=\"JSX防止注入攻击\"><a href=\"#JSX防止注入攻击\" class=\"headerlink\" title=\"JSX防止注入攻击\"></a>JSX防止注入攻击</h4><p>默认情况下，React DOM在渲染JSX之前会对其进行编码。</p>\n<h4 id=\"JSX描述对象\"><a href=\"#JSX描述对象\" class=\"headerlink\" title=\"JSX描述对象\"></a>JSX描述对象</h4><p>Babel会将JSX转化为React.createElement()形式，比如下面这样：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> element = (</div><div class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">className</span>=<span class=\"string\">\"greeting\"</span>&gt;</span></div><div class=\"line\">    Hello, world!</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>转化为<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> element = React.createElement(</div><div class=\"line\">  <span class=\"string\">'h1'</span>,</div><div class=\"line\">  &#123;<span class=\"attr\">className</span>: <span class=\"string\">'greeting'</span>&#125;,</div><div class=\"line\">  <span class=\"string\">'Hello, world!'</span></div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<p>React.createElement会对你的代码进行一些检查，但是本质上就是将其转化成一个对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> element = &#123;</div><div class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">'h1'</span>,</div><div class=\"line\">  <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">className</span>: <span class=\"string\">'greeting'</span>,</div><div class=\"line\">    <span class=\"attr\">children</span>: <span class=\"string\">'Hello, world'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><p>将你的页面分成一个个组件，每个组件都是独立的、可以重复使用的。组件就像JavaScript中的方法，可以接受一些输入参数，返回React元素</p>\n<h4 id=\"Funtional-和-Class-组件\"><a href=\"#Funtional-和-Class-组件\" class=\"headerlink\" title=\"Funtional 和 Class 组件\"></a>Funtional 和 Class 组件</h4><p>定义组件最简单的方式是使用JavaScript方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span> (<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">&#125;</div><div class=\"line\">这个方法就是个有效的React组件，因为它接受props作为参数，并且返回了一个React元素。</div><div class=\"line\"></div><div class=\"line\">另外也可以使用ES6中的类(<span class=\"class\"><span class=\"keyword\">class</span>)来定义组件：</div><div class=\"line\">```<span class=\"title\">javascript</span></div><div class=\"line\"><span class=\"title\">class</span> <span class=\"title\">Welcome</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render () &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面两种定义组件的方法是等价的。<br>但是Class组件能够添加一些额外的功能，我们将在下面讨论。在不需要这些额外的方法，可以使用Functional组件。</p>\n<h4 id=\"渲染组件\"><a href=\"#渲染组件\" class=\"headerlink\" title=\"渲染组件\"></a>渲染组件</h4><p>渲染如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Welcome</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Sara\"</span> /&gt;</span>;</div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  element,</div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">);</span></div></pre></td></tr></table></figure></p>\n<p>过程：</p>\n<ol>\n<li>调用ReactDOM.render()方法，参数为自定义组件<Welcome name=\"Sara\" />。</li>\n<li>React调用组件Welcome，传递<code>{name=&quot;Sara&quot;}</code>作为参数。</li>\n<li>Welcome组件返回<code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>。</li>\n<li>React将<code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>更新到页面。</li>\n</ol>\n<h4 id=\"组件组合\"><a href=\"#组件组合\" class=\"headerlink\" title=\"组件组合\"></a>组件组合</h4><p>组件可以任意组合。<br>通常情况，React应用中在最顶端是一个<code>App</code>组件。组件必须有一个根元素，也就是所有元素都得包裹起来。</p>\n<h4 id=\"提取组件\"><a href=\"#提取组件\" class=\"headerlink\" title=\"提取组件\"></a>提取组件</h4><p>不要担心组件被拆分的太小。下面是一个对组件进行拆分的例子。<br>Comment组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Comment</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"UserInfo\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Avatar\"</span></div><div class=\"line\">          <span class=\"attr\">src</span>=<span class=\"string\">&#123;props.author.avatarUrl&#125;</span></div><div class=\"line\">          <span class=\"attr\">alt</span>=<span class=\"string\">&#123;props.author.name&#125;</span></div><div class=\"line\">        /&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"UserInfo-name\"</span>&gt;</span></div><div class=\"line\">          &#123;props.author.name&#125;</div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment-text\"</span>&gt;</span></div><div class=\"line\">        &#123;props.text&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment-date\"</span>&gt;</span></div><div class=\"line\">        &#123;formatDate(props.date)&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure></p>\n<p>在Comment组件中，使用了<code>author (object)</code>，<code>text (string)</code>，<code>date (date)</code>来描述这个对象。这样的组件因为组合的原因是很难复用的。</p>\n<p>第一步，提取出一个<code>Avatar</code>组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Avatar</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Avatar\"</span></div><div class=\"line\">      <span class=\"attr\">src</span>=<span class=\"string\">&#123;props.user.avatarUrl&#125;</span></div><div class=\"line\">      <span class=\"attr\">alt</span>=<span class=\"string\">&#123;props.user.name&#125;</span></div><div class=\"line\">    /&gt;</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure></p>\n<p>这里的<code>Avatar</code>组件我们系统他更通用，所以说用了<code>user</code>而不是<code>author</code>。<br>根据组件去命名参数，而不是根据使用上下文。</p>\n<p>下一步是提取<code>UserInfo</code>组件，这里使用了上面提取的<code>Avatar</code>组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserInfo</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"UserInfo\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">Avatar</span> <span class=\"attr\">user</span>=<span class=\"string\">&#123;props.user&#125;</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"UserInfo-name\"</span>&gt;</span></div><div class=\"line\">        &#123;props.user.name&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure></p>\n<p>这样，我们的<code>Comment</code>组件就成了下面的样子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Comment</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">UserInfo</span> <span class=\"attr\">user</span>=<span class=\"string\">&#123;props.author&#125;</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment-text\"</span>&gt;</span></div><div class=\"line\">        &#123;props.text&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Comment-date\"</span>&gt;</span></div><div class=\"line\">        &#123;formatDate(props.date)&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"Props是只读的\"><a href=\"#Props是只读的\" class=\"headerlink\" title=\"Props是只读的\"></a>Props是只读的</h4><p>无论是Funcional还是Class组件，都是不能够修改props的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 下面这个是纯函数，因为它没有试图改变自己的输入，并且对相同的输入会有相同的输出。</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 下面这个不是纯函数，因为他改变了输入的值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withdraw</span>(<span class=\"params\">account, amount</span>) </span>&#123;</div><div class=\"line\">  account.total -= amount;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过官方这个例子，可以明白纯函数有两点，一是相同的输入就会有相同的输出，第二点是不会更改输入的参数。</p>\n<p>所有的React组件对于props参数必须像纯函数一样，也就是不会试图去修改props，并且对于相同的props会有相同的输出。<br>当然，React也提供了随时间动态变化组件的方法，state允许根据用户行为、网络反馈等改变React组件的输出形式，这并不违背React纯函数原则。</p>\n<h2 id=\"state-和-生命周期\"><a href=\"#state-和-生命周期\" class=\"headerlink\" title=\"state 和 生命周期\"></a>state 和 生命周期</h2><p>请看下面一段代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Clock = (</div><div class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>It is &#123;new Date().toLocaleTimeString()&#125;.<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">);</div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Clock</span> /&gt;</span>,</div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">);</span></div></pre></td></tr></table></figure></p>\n<p>这段代码只能够显示一个Hello,world!与一个生成页面的时间。如果想要时间不停的更新，就需要使用setInterval()不停的去执行。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 这样</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tick</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> Clock = (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>It is &#123;new Date().toLocaleTimeString()&#125;.<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">  );</div><div class=\"line\">  ReactDOM.render(</div><div class=\"line\">    &lt;Clock /&gt;,</div><div class=\"line\">    document.getElementById('root')</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\">setInterval(tick, 1000);</div><div class=\"line\"></div><div class=\"line\">// 或者这样</div><div class=\"line\">function Clock(props) &#123;</div><div class=\"line\">  return (</div><div class=\"line\">    &lt;div&gt;</div><div class=\"line\">      &lt;h1&gt;Hello, world!&lt;/h1&gt;</div><div class=\"line\">      &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function tick() &#123;</div><div class=\"line\">  ReactDOM.render(</div><div class=\"line\">    &lt;Clock date=&#123;new Date()&#125; /&gt;,</div><div class=\"line\">    document.getElementById('root')</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\">setInterval(tick, 1000);</div><div class=\"line\"></div><div class=\"line\">// 但是下面这种就是不可行的，原因在于Clock组件定义被转化成了一个对象，在之后没有发生过变化。</div><div class=\"line\">const Clock = (</div><div class=\"line\">  &lt;div&gt;</div><div class=\"line\">    &lt;h1&gt;Hello, world!&lt;/h1&gt;</div><div class=\"line\">    &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt;</div><div class=\"line\">  &lt;/div&gt;</div><div class=\"line\">);</div><div class=\"line\">setInterval(</div><div class=\"line\">function()&#123;</div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;Clock /&gt;,</div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">)&#125;, 1000)</div></pre></td></tr></table></figure></p>\n<p>这样的代码的问题在于时间的变化应该是<code>Clock</code>组件的行为，而不应该定义在全局。<br><code>state</code>可以帮助我们解决这个问题，state与props类似，但是更私有且被组件所控制，而不是传递过来的。</p>\n<h4 id=\"将Functional组件转换为Class组件\"><a href=\"#将Functional组件转换为Class组件\" class=\"headerlink\" title=\"将Functional组件转换为Class组件\"></a>将Functional组件转换为Class组件</h4><p>Functional组件是无状态组件，不能使用state，所以首先需要将Functional转化为Class组件：</p>\n<ol>\n<li>创建一个和Functional组件名相同的ES6 class继承<code>React.Component</code></li>\n<li>添加空的方法<code>render()</code></li>\n<li>将Functional组件中的函数主体移动<code>render()</code>方法中</li>\n<li>将<code>render()</code>中的<code>props</code>替换成<code>this.props</code></li>\n<li>删除原来的Functional组件声明<br>Class组件不仅可以使用state还可以使用生命周期函数。<br>拿上面的<code>Clock</code>组件作为事例，经过上面的转换，现在的Clock组件应该是这个样子：<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>It is &#123;this.props.date.toLocaleTimeString()&#125;.<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"为Class组件添加本地state\"><a href=\"#为Class组件添加本地state\" class=\"headerlink\" title=\"为Class组件添加本地state\"></a>为Class组件添加本地state</h4><p>还是上面的<code>Clock</code>组件：</p>\n<ol>\n<li>将<code>render()</code>中的<code>this.props</code>替换成<code>this.state</code></li>\n<li>添加class构造函数(constructor)初始化this.state (Class组件总是应该将props传递给父类)</li>\n<li>移除<code>date</code>从组件调用的props中<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 这里是步骤2</span></div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"comment\">// 将props传递给父类</span></div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">date</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>It is &#123;this.state.date.toLocaleTimeString()&#125;.<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Clock</span> /&gt;</span>,</div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">);</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这样只是初始化了state，后面会设置定时器。</p>\n"},{"title":"React Docs（2）","date":"2017-01-14T16:00:00.000Z","comments":1,"_content":"\n## 事件\nReact对事件的处理和在DOM元素上添加事件属性绑定事件的方式几乎一样，不同点在于React使用驼峰命名，而不是全小写；React中传递的是一个函数，不是一个字符串。\n另一个区别是，不能使用return false来阻止事件默认行为。  \nHTML中：\n```HTML\n<button onclick=\"activateLasers()\">\n  Activate Lasers\n</button>\n```\nReact中：\n```JSX\n<button onClick={activeteLasers}>\n  Activate Lasers\n</button>\n```\n在React中，event是合成事件，不需要考虑跨浏览器兼容问题。  \n在使用React中，一般不应该使用addEventListener在DOM元素创建以后去绑定事件，而应该在渲染初始化的时候就提供一个监听器。  \n在使用ES6语法Class创建组件时候，常见的模式是绑定事件是类中的一个方法：\n```javascript\nclass Toggle extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {isToggleOn: true};\n\n    // 这里的绑定this是必要的，这样可以使函数上下文环境为这个组件\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    this.setState(prevState => ({\n      isToggleOn: !prevState.isToggleOn\n    }));\n  }\n\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        {this.state.isToggleOn ? 'ON' : 'OFF'}\n      </button>\n    );\n  }\n}\n\nReactDOM.render(\n  <Toggle />,\n  document.getElementById('root')\n);\n```\n必须小心在事件回调函数中的this，在javascript中，Class中的方法默认是不绑定this的。如果忘记绑定，函调函数中的this指向的将是undefined。  \n如果不想使用bind函数，可以使用箭头函数这种语法来绑定this，下面函数中handleClick属性初始化时，里面的this就被绑定到了LoggingButton中:\n```javascript\nclass LoggingButton extends React.Component {\n  // 箭头函数可以绑定this\n  handleClick = () => {\n    console.log('this is:', this);\n  }\n\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        Click me\n      </button>\n    );\n  }\n}\n```\n另一种方式是在定义回调的时候用箭头函数绑定this：\n```javascript\nlass LoggingButton extends React.Component {\n  handleClick() {\n    console.log('this is:', this);\n  }\n\n  render() {\n    // 在onClick中，用箭头函数绑定了this\n    return (\n      <button onClick={(e) => this.handleClick(e)}>\n        Click me\n      </button>\n    );\n  }\n}\n```\n这种方法的问题在于每一次渲染该组件都会创建不同的回调函数。大多数情况下这是没有问题的，但是如果函调函数中传递一个prop给一个低阶组件，这些低阶组件会做额外的重复渲染。所以，一般建议使用第一种构造函数中bind绑定this或者是属性初始化中用箭头函数绑定this。\n\n## 条件渲染\n有时候需要根据组件的不同状态，渲染不同的组件。  \nReact中的条件渲染与JavaScript中的条件语句工作方式相同，可以使用if或者条件操作符来创建一个表示当前状态的元素，让React更新UI以配合组件状态。  \n下面是根据用户的登陆状态显示不同的问候语：\n```javascript\nfunction UserGreeting(props) {\n  return <h1>Welcome back!</h1>;\n}\n\nfunction GuestGreeting(props) {\n  return <h1>Please sign up.</h1>;\n}\n\nfunction Greeting(props) {\n  const isLoggedIn = props.isLoggedIn;\n  if (isLoggedIn) {\n    return <UserGreeting />;\n  }\n  return <GuestGreeting />;\n}\n\nReactDOM.render(\n  // Try changing to isLoggedIn={true}:\n  <Greeting isLoggedIn={false} />,\n  document.getElementById('root')\n);\n```\n### 元素变量\n可以使用变量来存储元素，其余都不变。\n```javascript\n// 一个登陆按钮，一个注销按钮\nfunction LoginButton(props) {\n  return (\n    <button onClick={props.onClick}>\n      Login\n    </button>\n  );\n}\n\nfunction LogoutButton(props) {\n  return (\n    <button onClick={props.onClick}>\n      Logout\n    </button>\n  );\n}\n```\n下面创建一个有状态的组件LoginControl\n```javascript\nclass LoginControl extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleLoginClick = this.handleLoginClick.bind(this);\n    this.handleLogoutClick = this.handleLogoutClick.bind(this);\n    this.state = {isLoggedIn: false};\n  }\n\n  handleLoginClick() {\n    this.setState({isLoggedIn: true});\n  }\n\n  handleLogoutClick() {\n    this.setState({isLoggedIn: false});\n  }\n\n  render() {\n    const isLoggedIn = this.state.isLoggedIn;\n\n    let button = null;\n    if (isLoggedIn) {\n      button = <LogoutButton onClick={this.handleLogoutClick} />;\n    } else {\n      button = <LoginButton onClick={this.handleLoginClick} />;\n    }\n\n    return (\n      <div>\n        <Greeting isLoggedIn={isLoggedIn} />\n        {button}\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <LoginControl />,\n  document.getElementById('root')\n);\n```\n除了if语句，你也可以使用更短的逻辑语句，比如&&运算符，三目运算符等。\n\n### 防止组件呈现\n极少数的情况下才需要这么做，通过return null可以使组件不被渲染。","source":"_posts/React Docs(2).md","raw":"---\ntitle: React Docs（2）\ndate: 2017-01-15\ntags: [JavaScript, React]\ncategories: \n- React\ncomments: true\n---\n\n## 事件\nReact对事件的处理和在DOM元素上添加事件属性绑定事件的方式几乎一样，不同点在于React使用驼峰命名，而不是全小写；React中传递的是一个函数，不是一个字符串。\n另一个区别是，不能使用return false来阻止事件默认行为。  \nHTML中：\n```HTML\n<button onclick=\"activateLasers()\">\n  Activate Lasers\n</button>\n```\nReact中：\n```JSX\n<button onClick={activeteLasers}>\n  Activate Lasers\n</button>\n```\n在React中，event是合成事件，不需要考虑跨浏览器兼容问题。  \n在使用React中，一般不应该使用addEventListener在DOM元素创建以后去绑定事件，而应该在渲染初始化的时候就提供一个监听器。  \n在使用ES6语法Class创建组件时候，常见的模式是绑定事件是类中的一个方法：\n```javascript\nclass Toggle extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {isToggleOn: true};\n\n    // 这里的绑定this是必要的，这样可以使函数上下文环境为这个组件\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    this.setState(prevState => ({\n      isToggleOn: !prevState.isToggleOn\n    }));\n  }\n\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        {this.state.isToggleOn ? 'ON' : 'OFF'}\n      </button>\n    );\n  }\n}\n\nReactDOM.render(\n  <Toggle />,\n  document.getElementById('root')\n);\n```\n必须小心在事件回调函数中的this，在javascript中，Class中的方法默认是不绑定this的。如果忘记绑定，函调函数中的this指向的将是undefined。  \n如果不想使用bind函数，可以使用箭头函数这种语法来绑定this，下面函数中handleClick属性初始化时，里面的this就被绑定到了LoggingButton中:\n```javascript\nclass LoggingButton extends React.Component {\n  // 箭头函数可以绑定this\n  handleClick = () => {\n    console.log('this is:', this);\n  }\n\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        Click me\n      </button>\n    );\n  }\n}\n```\n另一种方式是在定义回调的时候用箭头函数绑定this：\n```javascript\nlass LoggingButton extends React.Component {\n  handleClick() {\n    console.log('this is:', this);\n  }\n\n  render() {\n    // 在onClick中，用箭头函数绑定了this\n    return (\n      <button onClick={(e) => this.handleClick(e)}>\n        Click me\n      </button>\n    );\n  }\n}\n```\n这种方法的问题在于每一次渲染该组件都会创建不同的回调函数。大多数情况下这是没有问题的，但是如果函调函数中传递一个prop给一个低阶组件，这些低阶组件会做额外的重复渲染。所以，一般建议使用第一种构造函数中bind绑定this或者是属性初始化中用箭头函数绑定this。\n\n## 条件渲染\n有时候需要根据组件的不同状态，渲染不同的组件。  \nReact中的条件渲染与JavaScript中的条件语句工作方式相同，可以使用if或者条件操作符来创建一个表示当前状态的元素，让React更新UI以配合组件状态。  \n下面是根据用户的登陆状态显示不同的问候语：\n```javascript\nfunction UserGreeting(props) {\n  return <h1>Welcome back!</h1>;\n}\n\nfunction GuestGreeting(props) {\n  return <h1>Please sign up.</h1>;\n}\n\nfunction Greeting(props) {\n  const isLoggedIn = props.isLoggedIn;\n  if (isLoggedIn) {\n    return <UserGreeting />;\n  }\n  return <GuestGreeting />;\n}\n\nReactDOM.render(\n  // Try changing to isLoggedIn={true}:\n  <Greeting isLoggedIn={false} />,\n  document.getElementById('root')\n);\n```\n### 元素变量\n可以使用变量来存储元素，其余都不变。\n```javascript\n// 一个登陆按钮，一个注销按钮\nfunction LoginButton(props) {\n  return (\n    <button onClick={props.onClick}>\n      Login\n    </button>\n  );\n}\n\nfunction LogoutButton(props) {\n  return (\n    <button onClick={props.onClick}>\n      Logout\n    </button>\n  );\n}\n```\n下面创建一个有状态的组件LoginControl\n```javascript\nclass LoginControl extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleLoginClick = this.handleLoginClick.bind(this);\n    this.handleLogoutClick = this.handleLogoutClick.bind(this);\n    this.state = {isLoggedIn: false};\n  }\n\n  handleLoginClick() {\n    this.setState({isLoggedIn: true});\n  }\n\n  handleLogoutClick() {\n    this.setState({isLoggedIn: false});\n  }\n\n  render() {\n    const isLoggedIn = this.state.isLoggedIn;\n\n    let button = null;\n    if (isLoggedIn) {\n      button = <LogoutButton onClick={this.handleLogoutClick} />;\n    } else {\n      button = <LoginButton onClick={this.handleLoginClick} />;\n    }\n\n    return (\n      <div>\n        <Greeting isLoggedIn={isLoggedIn} />\n        {button}\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <LoginControl />,\n  document.getElementById('root')\n);\n```\n除了if语句，你也可以使用更短的逻辑语句，比如&&运算符，三目运算符等。\n\n### 防止组件呈现\n极少数的情况下才需要这么做，通过return null可以使组件不被渲染。","slug":"React Docs(2)","published":1,"updated":"2017-03-22T01:28:11.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8kh50008ohfkkprrbvwj","content":"<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><p>React对事件的处理和在DOM元素上添加事件属性绑定事件的方式几乎一样，不同点在于React使用驼峰命名，而不是全小写；React中传递的是一个函数，不是一个字符串。<br>另一个区别是，不能使用return false来阻止事件默认行为。<br>HTML中：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"activateLasers()\"</span>&gt;</span></div><div class=\"line\">  Activate Lasers</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>React中：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;button onClick=&#123;activeteLasers&#125;&gt;</div><div class=\"line\">  Activate Lasers</div><div class=\"line\">&lt;<span class=\"regexp\">/button&gt;</span></div></pre></td></tr></table></figure></p>\n<p>在React中，event是合成事件，不需要考虑跨浏览器兼容问题。<br>在使用React中，一般不应该使用addEventListener在DOM元素创建以后去绑定事件，而应该在渲染初始化的时候就提供一个监听器。<br>在使用ES6语法Class创建组件时候，常见的模式是绑定事件是类中的一个方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Toggle</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">isToggleOn</span>: <span class=\"literal\">true</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 这里的绑定this是必要的，这样可以使函数上下文环境为这个组件</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleClick() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(<span class=\"function\"><span class=\"params\">prevState</span> =&gt;</span> (&#123;</div><div class=\"line\">      <span class=\"attr\">isToggleOn</span>: !prevState.isToggleOn</div><div class=\"line\">    &#125;));</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handleClick&#125;</span>&gt;</span></span></div><div class=\"line\">        &#123;this.state.isToggleOn ? 'ON' : 'OFF'&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Toggle</span> /&gt;</span>,</span></div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<p>必须小心在事件回调函数中的this，在javascript中，Class中的方法默认是不绑定this的。如果忘记绑定，函调函数中的this指向的将是undefined。<br>如果不想使用bind函数，可以使用箭头函数这种语法来绑定this，下面函数中handleClick属性初始化时，里面的this就被绑定到了LoggingButton中:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoggingButton</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 箭头函数可以绑定this</span></div><div class=\"line\">  handleClick = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'this is:'</span>, <span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handleClick&#125;</span>&gt;</span></span></div><div class=\"line\">        Click me</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>另一种方式是在定义回调的时候用箭头函数绑定this：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">lass LoggingButton extends React.Component &#123;</div><div class=\"line\">  handleClick() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'this is:'</span>, <span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"comment\">// 在onClick中，用箭头函数绑定了this</span></div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;(e)</span> =&gt;</span> this.handleClick(e)&#125;&gt;</span></div><div class=\"line\">        Click me</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这种方法的问题在于每一次渲染该组件都会创建不同的回调函数。大多数情况下这是没有问题的，但是如果函调函数中传递一个prop给一个低阶组件，这些低阶组件会做额外的重复渲染。所以，一般建议使用第一种构造函数中bind绑定this或者是属性初始化中用箭头函数绑定this。</p>\n<h2 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h2><p>有时候需要根据组件的不同状态，渲染不同的组件。<br>React中的条件渲染与JavaScript中的条件语句工作方式相同，可以使用if或者条件操作符来创建一个表示当前状态的元素，让React更新UI以配合组件状态。<br>下面是根据用户的登陆状态显示不同的问候语：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserGreeting</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Welcome back!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GuestGreeting</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Please sign up.<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Greeting</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> isLoggedIn = props.isLoggedIn;</div><div class=\"line\">  <span class=\"keyword\">if</span> (isLoggedIn) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;UserGreeting /&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return &lt;GuestGreeting /&gt;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  // Try changing to isLoggedIn=&#123;true&#125;:</div><div class=\"line\">  &lt;Greeting isLoggedIn=&#123;false&#125; /&gt;,</div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<h3 id=\"元素变量\"><a href=\"#元素变量\" class=\"headerlink\" title=\"元素变量\"></a>元素变量</h3><p>可以使用变量来存储元素，其余都不变。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 一个登陆按钮，一个注销按钮</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LoginButton</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;props.onClick&#125;</span>&gt;</span></span></div><div class=\"line\">      Login</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LogoutButton</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;props.onClick&#125;</span>&gt;</span></span></div><div class=\"line\">      Logout</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面创建一个有状态的组件LoginControl<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginControl</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.handleLoginClick = <span class=\"keyword\">this</span>.handleLoginClick.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.handleLogoutClick = <span class=\"keyword\">this</span>.handleLogoutClick.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">isLoggedIn</span>: <span class=\"literal\">false</span>&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleLoginClick() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">isLoggedIn</span>: <span class=\"literal\">true</span>&#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleLogoutClick() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">isLoggedIn</span>: <span class=\"literal\">false</span>&#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> isLoggedIn = <span class=\"keyword\">this</span>.state.isLoggedIn;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> button = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (isLoggedIn) &#123;</div><div class=\"line\">      button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return (</div><div class=\"line\">      &lt;div&gt;</div><div class=\"line\">        &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;</div><div class=\"line\">        &#123;button&#125;</div><div class=\"line\">      &lt;/div&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;LoginControl /&gt;,</div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<p>除了if语句，你也可以使用更短的逻辑语句，比如&amp;&amp;运算符，三目运算符等。</p>\n<h3 id=\"防止组件呈现\"><a href=\"#防止组件呈现\" class=\"headerlink\" title=\"防止组件呈现\"></a>防止组件呈现</h3><p>极少数的情况下才需要这么做，通过return null可以使组件不被渲染。</p>\n","excerpt":"","more":"<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><p>React对事件的处理和在DOM元素上添加事件属性绑定事件的方式几乎一样，不同点在于React使用驼峰命名，而不是全小写；React中传递的是一个函数，不是一个字符串。<br>另一个区别是，不能使用return false来阻止事件默认行为。<br>HTML中：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"activateLasers()\"</span>&gt;</span></div><div class=\"line\">  Activate Lasers</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>React中：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;button onClick=&#123;activeteLasers&#125;&gt;</div><div class=\"line\">  Activate Lasers</div><div class=\"line\">&lt;<span class=\"regexp\">/button&gt;</span></div></pre></td></tr></table></figure></p>\n<p>在React中，event是合成事件，不需要考虑跨浏览器兼容问题。<br>在使用React中，一般不应该使用addEventListener在DOM元素创建以后去绑定事件，而应该在渲染初始化的时候就提供一个监听器。<br>在使用ES6语法Class创建组件时候，常见的模式是绑定事件是类中的一个方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Toggle</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">isToggleOn</span>: <span class=\"literal\">true</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 这里的绑定this是必要的，这样可以使函数上下文环境为这个组件</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleClick() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(<span class=\"function\"><span class=\"params\">prevState</span> =&gt;</span> (&#123;</div><div class=\"line\">      <span class=\"attr\">isToggleOn</span>: !prevState.isToggleOn</div><div class=\"line\">    &#125;));</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handleClick&#125;</span>&gt;</span></div><div class=\"line\">        &#123;this.state.isToggleOn ? 'ON' : 'OFF'&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Toggle</span> /&gt;</span>,</div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">);</span></div></pre></td></tr></table></figure></p>\n<p>必须小心在事件回调函数中的this，在javascript中，Class中的方法默认是不绑定this的。如果忘记绑定，函调函数中的this指向的将是undefined。<br>如果不想使用bind函数，可以使用箭头函数这种语法来绑定this，下面函数中handleClick属性初始化时，里面的this就被绑定到了LoggingButton中:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoggingButton</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 箭头函数可以绑定this</span></div><div class=\"line\">  handleClick = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'this is:'</span>, <span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handleClick&#125;</span>&gt;</span></div><div class=\"line\">        Click me</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>另一种方式是在定义回调的时候用箭头函数绑定this：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">lass LoggingButton extends React.Component &#123;</div><div class=\"line\">  handleClick() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'this is:'</span>, <span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"comment\">// 在onClick中，用箭头函数绑定了this</span></div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;(e)</span> =&gt;</span> this.handleClick(e)&#125;&gt;</div><div class=\"line\">        Click me</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这种方法的问题在于每一次渲染该组件都会创建不同的回调函数。大多数情况下这是没有问题的，但是如果函调函数中传递一个prop给一个低阶组件，这些低阶组件会做额外的重复渲染。所以，一般建议使用第一种构造函数中bind绑定this或者是属性初始化中用箭头函数绑定this。</p>\n<h2 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h2><p>有时候需要根据组件的不同状态，渲染不同的组件。<br>React中的条件渲染与JavaScript中的条件语句工作方式相同，可以使用if或者条件操作符来创建一个表示当前状态的元素，让React更新UI以配合组件状态。<br>下面是根据用户的登陆状态显示不同的问候语：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserGreeting</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Welcome back!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GuestGreeting</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Please sign up.<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Greeting</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> isLoggedIn = props.isLoggedIn;</div><div class=\"line\">  <span class=\"keyword\">if</span> (isLoggedIn) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;UserGreeting /&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return &lt;GuestGreeting /&gt;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  // Try changing to isLoggedIn=&#123;true&#125;:</div><div class=\"line\">  &lt;Greeting isLoggedIn=&#123;false&#125; /&gt;,</div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<h3 id=\"元素变量\"><a href=\"#元素变量\" class=\"headerlink\" title=\"元素变量\"></a>元素变量</h3><p>可以使用变量来存储元素，其余都不变。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 一个登陆按钮，一个注销按钮</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LoginButton</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;props.onClick&#125;</span>&gt;</span></div><div class=\"line\">      Login</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LogoutButton</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;props.onClick&#125;</span>&gt;</span></div><div class=\"line\">      Logout</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面创建一个有状态的组件LoginControl<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginControl</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.handleLoginClick = <span class=\"keyword\">this</span>.handleLoginClick.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.handleLogoutClick = <span class=\"keyword\">this</span>.handleLogoutClick.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">isLoggedIn</span>: <span class=\"literal\">false</span>&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleLoginClick() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">isLoggedIn</span>: <span class=\"literal\">true</span>&#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleLogoutClick() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">isLoggedIn</span>: <span class=\"literal\">false</span>&#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> isLoggedIn = <span class=\"keyword\">this</span>.state.isLoggedIn;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> button = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (isLoggedIn) &#123;</div><div class=\"line\">      button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return (</div><div class=\"line\">      &lt;div&gt;</div><div class=\"line\">        &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;</div><div class=\"line\">        &#123;button&#125;</div><div class=\"line\">      &lt;/div&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;LoginControl /&gt;,</div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<p>除了if语句，你也可以使用更短的逻辑语句，比如&amp;&amp;运算符，三目运算符等。</p>\n<h3 id=\"防止组件呈现\"><a href=\"#防止组件呈现\" class=\"headerlink\" title=\"防止组件呈现\"></a>防止组件呈现</h3><p>极少数的情况下才需要这么做，通过return null可以使组件不被渲染。</p>\n"},{"title":"React Docs（3）","date":"2017-01-15T16:00:00.000Z","comments":1,"_content":"\n## 列表和键（key）\n在React中转换数组和在JavaScript中几乎相同，可以通过数组的map方法渲染多个组件：\n```javascript\n// 显示内容为1到5的列表\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    <li>{number}</li>\n  );\n  return (\n    <ul>{listItems}</ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  <NumberList numbers={numbers} />,\n  document.getElementById('root')\n);\n```\n在运行此代码的时候，会收到一条警告，警告指出需要为每一项提供一个key，这个是很重要的。\n```javascript\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    <li key={number.toString()}>\n      {number}\n    </li>\n  );\n  return (\n    <ul>{listItems}</ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  <NumberList numbers={numbers} />,\n  document.getElementById('root')\n);\n```\n### 键（key）\nkey可以帮助确定哪些项发生了变化，或者添加、删除了哪些项，通常使用数据的id作为key，这样在整个列表中key的值是唯一的。\nkey只有在周围环境是数据的情况下才有意义，如下：\n```javascript\n// 错误的做法\nfunction ListItem(props) {\n  const value = props.value;\n  return (\n    // 这里不必要使用key，使用\n    <li key={value.toString()}>\n      {value}\n    </li>\n  );\n}\n\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    // key属性应该添加在这里\n    <ListItem value={number} />\n  );\n  return (\n    <ul>\n      {listItems}\n    </ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  <NumberList numbers={numbers} />,\n  document.getElementById('root')\n);\n```\n其实只需要记得在map函数中使用key就可以了。\n\n### key在兄弟节点间是唯一的\n数组中使用key需要是唯一的，但是在全局不需要是唯一的。当生成两个不同的数组，我们可以使用相同的键。  \nkey作为组件的标识，但是不会将值传递给组件，如果需要使用key中的值，需要另外传给组件的一个属性。  \nJSX中可以嵌套map函数。这种形式有时候会使代码更加清晰，有时候也会被滥用，这就需要你来决定是否需要提取出来，以提高可读性。\n\n## 表单\n表单元素自身本来就拥有一些属性（比如name等），表单在用户提交时，会执行默认的表单行为，提交到一个新的页面。但是在多数情况下，我们使用JavaScript函数处理表单的提交，处理用户提交的数据。实现这种方法的组件我们称为“受控组件”。\n\n### 受控组件\n在HTML中，表单元素如`<input>`，`<textarea>`和`<select>`通常保持自己的状态，并根据用户的输入进行更新。而在React中，状态一般保存都state属性中，并且state属性只能通过`setState()`更新。  \n我们可以将React的state设置成HTML的输入将两者结合，然后React组件还需要控制用户的输入，这样的组件被称为“受控组件”。\n```javascript\nclass NameForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {value: ''};\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {\n    this.setState({value: event.target.value});\n  }\n\n  handleSubmit(event) {\n    alert('A name was submitted: ' + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Name:\n          <input type=\"text\" value={this.state.value} onChange={this.handleChange} />\n        </label>\n        <input type=\"submit\" value=\"Submit\" />\n      </form>\n    );\n  }\n}\n```\n其中将input元素的value值交给React组件的state，通过handleChange函数响应每次输入来更新state。使用受控组件，每个输入都会关联到处理函数，这使得可以直接修改或验证用户输入。\n\n### textarea标签\n在React中，textarea标签也使用了value属性来代替在元素中的显示值。\n\n### select标签\n在HTML中使用`<select>`标签时候，可以使用option中selected属性表示当前选择的选项。而在React中，将当前选项保存在select中的value，当select中的value与option的Value相同时，该选项被选择。\n\n### 受控组件的代码\n使用受控组件有时候是很复杂的，因为你需要为更改数据的所有方式编写事件处理函数，并通过React组件管理所有输入状态。这时候可能需要不受控组件。\n\n## 提升state属性\n通常，几个组件需要反映相同的数据变化，这时候可以将共享的state提升到最接近的共同的父组件中。\n\n下面这个组件BoilingVerdict接受一个celsius温度参数，并打印是否能把水烧开\n```javascript\nfunction BoilingVerdict(props) {\n  if (props.celsius >= 100) {\n    return <p>The water would boil.</p>;\n  }\n  return <p>The water would not boil.</p>;\n}\n```\n下面这个组件Calculator，输入一个celsius摄氏温度，保存到this.state.value中，并作为BoilingVerdict输入。\n```javascript\nclass Calculator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {value: ''};\n  }\n\n  handleChange(e) {\n    this.setState({value: e.target.value});\n  }\n\n  render() {\n    const value = this.state.value;\n    return (\n      <fieldset>\n        <legend>Enter temperature in Celsius:</legend>\n        <input\n          value={value}\n          onChange={this.handleChange} />\n        <BoilingVerdict\n          celsius={parseFloat(value)} />\n      </fieldset>\n    );\n  }\n}\n```\n\n### 添加第二个输入\n输入一个华氏温度，能够和摄氏度相互转换。  \n首先定义两个函数实现华氏度和摄氏度转换，再定义一个函数实现将值转换为字符串：\n```javascript\nfunction toCelsius(fahrenheit) {\n  return (fahrenheit - 32) * 5 / 9;\n}\n\nfunction toFahrenheit(celsius) {\n  return (celsius * 9 / 5) + 32;\n}\n\nfunction tryConvert(value, convert) {\n  const input = parseFloat(value);\n  if (Number.isNaN(input)) {\n    return '';\n  }\n  const output = convert(input);\n  const rounded = Math.round(output * 1000) / 1000;\n  return rounded.toString();\n}\n```\n下面是温度输入组件\n```javascript\nclass TemperatureInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n  }\n\n  handleChange(e) {\n    this.props.onChange(e.target.value);\n  }\n\n  render() {\n    const value = this.props.value;\n    const scale = this.props.scale;\n    return (\n      <fieldset>\n        <legend>Enter temperature in {scaleNames[scale]}:</legend>\n        <input value={value}\n               onChange={this.handleChange} />\n      </fieldset>\n    );\n  }\n}\n```\n下面是温度转换，以及显示沸水情况组件\n```javascript\nclass Calculator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleCelsiusChange = this.handleCelsiusChange.bind(this);\n    this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);\n    this.state = {value: '', scale: 'c'};\n  }\n\n  handleCelsiusChange(value) {\n    this.setState({scale: 'c', value});\n  }\n\n  handleFahrenheitChange(value) {\n    this.setState({scale: 'f', value});\n  }\n\n  render() {\n    const scale = this.state.scale;\n    const value = this.state.value;\n    const celsius = scale === 'f' ? tryConvert(value, toCelsius) : value;\n    const fahrenheit = scale === 'c' ? tryConvert(value, toFahrenheit) : value;\n\n    return (\n      <div>\n        <TemperatureInput\n          scale=\"c\"\n          value={celsius}\n          onChange={this.handleCelsiusChange} />\n        <TemperatureInput\n          scale=\"f\"\n          value={fahrenheit}\n          onChange={this.handleFahrenheitChange} />\n        <BoilingVerdict\n          celsius={parseFloat(celsius)} />\n      </div>\n    );\n  }\n}\n```\n### 总结\n对于React中的任何数据，应该有一个单一的来源。通常将state添加到需要渲染的组件，如果其他组件也需要该state，将它提升到最接近的共同父组件中，而不是试图同步不同组件之间的state。这种解决方法就是自上而下的数据流。  \n提升state需要编写更多的代码，但是这可以方便寻找和修改bug。state存在一些组件中，在这些组件中都可以单独改变该state，这可以减少错误。另外，你可以控制用户的输入。  \n如果某个state属性，可以通过props或者其他state属性得到，我们可能就不需要该state属性。\n\n## 组件的组成和继承\nReact组件具有强大的组合功能，我们建议使用组合来重用组件之间的代码，而不是继承。\n### 包含\n一些组件提前不知道自己包含什么。可以使用props的children来传递包含的组件\n```javascript\n// 使用props.children来调用被包含的组件\nfunction FancyBorder(props) {\n  return (\n    <div className={'FancyBorder FancyBorder-' + props.color}>\n      {props.children}\n    </div>\n  );\n}\n// 其他组件通过JSX传递被包含的组件给父组件\nfunction WelcomeDialog() {\n  return (\n    <FancyBorder color=\"blue\">\n      <h1 className=\"Dialog-title\">\n        Welcome\n      </h1>\n      <p className=\"Dialog-message\">\n        Thank you for visiting our spacecraft!\n      </p>\n    </FancyBorder>\n  );\n}\n```\n有时候也可以包含多个子组件，可以通过自定义props传递\n```javascript\nfunction SplitPane(props) {\n  return (\n    <div className=\"SplitPane\">\n      <div className=\"SplitPane-left\">\n        {props.left}\n      </div>\n      <div className=\"SplitPane-right\">\n        {props.right}\n      </div>\n    </div>\n  );\n}\n// 向SplitPane组件中传递Contacts和Chat组件\nfunction App() {\n  return (\n    <SplitPane\n      left={\n        <Contacts />\n      }\n      right={\n        <Chat />\n      } />\n  );\n}\n```\n### 特殊化\n有些组件是另一些组件的特殊情况。比如：WelcomDialog是Dialog的特例。可以通过传递props来实现\n```javascript\nfunction Dialog(props) {\n  return (\n    <FancyBorder color=\"blue\">\n      <h1 className=\"Dialog-title\">\n        {props.title}\n      </h1>\n      <p className=\"Dialog-message\">\n        {props.message}\n      </p>\n    </FancyBorder>\n  );\n}\n\nfunction WelcomeDialog() {\n  return (\n    <Dialog\n      title=\"Welcome\"\n      message=\"Thank you for visiting our spacecraft!\" />\n  );\n}\n```\n### 不建议使用继承\nprops和组合可以使React组件有很大的灵活性，组件可以接受任意props，原始值，React组件，以及函数。  \n如果组件之间重用非UI功能，建议可以将这部分函数单独提到一个JavaScript模块中，组件可以导入该模块中的函数、对象或者类，而不需要继承。\n\n## Think in React\n### 第一步 拆分组件\n拆分组件应该遵循单一职责原则，每个组件只负责做一件事。一般情况下，正确的组件划分能够正好的映射JSON数据模型。[具体参考这里](https://facebook.github.io/react/docs/thinking-in-react.html)\n### 第二步 构建静态版本\n根据层次解构组合组件，接受模拟的数据呈现出UI，但是这是没有交互性的。  \n构建静态版本，要构建一个重用其他组件的组件，并且使用props传递数据。在静态版本中，不要使用state。state保留用于交互，所以这里不需要使用它。  \n在构造过程中，可以自上到下，也可以使用自下到上。  \n在完成这一步后，你将有一个可重用的组件库，用来呈现你的模拟数据。组件只会有render()方法。在最上层组件，传递模拟数据，更改模拟数据查看组件的变化是否正常。\n### 第三步 识别最小且完整的state\n正确的构建项目，首先需要考虑项目所需要考虑所有需要的最小的state集合，并且通过这些state计算出所有需要的其他内容。如果是能够计算出来的，就不需要存储在state中。  \n比如在一个TODO列表中，所有数据包括：\n* 原本的列表\n* 用户输入搜索框的内容\n* 用户勾选的选项\n* 过滤掉的列表\n对于这样的所有数据，我们需要弄清哪些才是state，可以问自己三个问题：\n1. 它可以通过父组件的props传递进来吗？\n2. 是否不会变化？\n3. 是否可以通过其他state或props计算出来？\n如果有一个回答是，那么该属性不应该是state。  \n原本的列表应该是通过props传递来的，过滤掉的列表可以通过原本的列表和输入框中的值计算出来。最后得到的state是：\n* 用户输入搜索框的内容\n* 用户勾选的选项\n### 第四步 确定state应该在哪个位置\n确定好state之后，是要确定在哪里定义state，在哪里更改state。  \n对于每一个state：\n* 确定哪些组件要用到该state\n* 找到一个包含这些所有组件的父组件\n* 包含这些所有组件的父组件其中结构层次最高的组件应该拥有该state\n* 如果找不到这样的父组件，创建一个这样的父组件，并且添加state\n### 第五步 添加反向数据流\n因为是单向数据流，所以需要添加操作对state的更改。比如，输入框绑定了用户输入搜索框内容这个state，输入框就不会响应用户的输入行为，需要为input绑定修改state事件。这里是子组件修改父组件中的state，所以就是反向数据流。","source":"_posts/React Docs(3).md","raw":"---\ntitle: React Docs（3）\ndate: 2017-01-16\ntags: [JavaScript, React]\ncategories: \n- React\ncomments: true\n---\n\n## 列表和键（key）\n在React中转换数组和在JavaScript中几乎相同，可以通过数组的map方法渲染多个组件：\n```javascript\n// 显示内容为1到5的列表\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    <li>{number}</li>\n  );\n  return (\n    <ul>{listItems}</ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  <NumberList numbers={numbers} />,\n  document.getElementById('root')\n);\n```\n在运行此代码的时候，会收到一条警告，警告指出需要为每一项提供一个key，这个是很重要的。\n```javascript\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    <li key={number.toString()}>\n      {number}\n    </li>\n  );\n  return (\n    <ul>{listItems}</ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  <NumberList numbers={numbers} />,\n  document.getElementById('root')\n);\n```\n### 键（key）\nkey可以帮助确定哪些项发生了变化，或者添加、删除了哪些项，通常使用数据的id作为key，这样在整个列表中key的值是唯一的。\nkey只有在周围环境是数据的情况下才有意义，如下：\n```javascript\n// 错误的做法\nfunction ListItem(props) {\n  const value = props.value;\n  return (\n    // 这里不必要使用key，使用\n    <li key={value.toString()}>\n      {value}\n    </li>\n  );\n}\n\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    // key属性应该添加在这里\n    <ListItem value={number} />\n  );\n  return (\n    <ul>\n      {listItems}\n    </ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  <NumberList numbers={numbers} />,\n  document.getElementById('root')\n);\n```\n其实只需要记得在map函数中使用key就可以了。\n\n### key在兄弟节点间是唯一的\n数组中使用key需要是唯一的，但是在全局不需要是唯一的。当生成两个不同的数组，我们可以使用相同的键。  \nkey作为组件的标识，但是不会将值传递给组件，如果需要使用key中的值，需要另外传给组件的一个属性。  \nJSX中可以嵌套map函数。这种形式有时候会使代码更加清晰，有时候也会被滥用，这就需要你来决定是否需要提取出来，以提高可读性。\n\n## 表单\n表单元素自身本来就拥有一些属性（比如name等），表单在用户提交时，会执行默认的表单行为，提交到一个新的页面。但是在多数情况下，我们使用JavaScript函数处理表单的提交，处理用户提交的数据。实现这种方法的组件我们称为“受控组件”。\n\n### 受控组件\n在HTML中，表单元素如`<input>`，`<textarea>`和`<select>`通常保持自己的状态，并根据用户的输入进行更新。而在React中，状态一般保存都state属性中，并且state属性只能通过`setState()`更新。  \n我们可以将React的state设置成HTML的输入将两者结合，然后React组件还需要控制用户的输入，这样的组件被称为“受控组件”。\n```javascript\nclass NameForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {value: ''};\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {\n    this.setState({value: event.target.value});\n  }\n\n  handleSubmit(event) {\n    alert('A name was submitted: ' + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Name:\n          <input type=\"text\" value={this.state.value} onChange={this.handleChange} />\n        </label>\n        <input type=\"submit\" value=\"Submit\" />\n      </form>\n    );\n  }\n}\n```\n其中将input元素的value值交给React组件的state，通过handleChange函数响应每次输入来更新state。使用受控组件，每个输入都会关联到处理函数，这使得可以直接修改或验证用户输入。\n\n### textarea标签\n在React中，textarea标签也使用了value属性来代替在元素中的显示值。\n\n### select标签\n在HTML中使用`<select>`标签时候，可以使用option中selected属性表示当前选择的选项。而在React中，将当前选项保存在select中的value，当select中的value与option的Value相同时，该选项被选择。\n\n### 受控组件的代码\n使用受控组件有时候是很复杂的，因为你需要为更改数据的所有方式编写事件处理函数，并通过React组件管理所有输入状态。这时候可能需要不受控组件。\n\n## 提升state属性\n通常，几个组件需要反映相同的数据变化，这时候可以将共享的state提升到最接近的共同的父组件中。\n\n下面这个组件BoilingVerdict接受一个celsius温度参数，并打印是否能把水烧开\n```javascript\nfunction BoilingVerdict(props) {\n  if (props.celsius >= 100) {\n    return <p>The water would boil.</p>;\n  }\n  return <p>The water would not boil.</p>;\n}\n```\n下面这个组件Calculator，输入一个celsius摄氏温度，保存到this.state.value中，并作为BoilingVerdict输入。\n```javascript\nclass Calculator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {value: ''};\n  }\n\n  handleChange(e) {\n    this.setState({value: e.target.value});\n  }\n\n  render() {\n    const value = this.state.value;\n    return (\n      <fieldset>\n        <legend>Enter temperature in Celsius:</legend>\n        <input\n          value={value}\n          onChange={this.handleChange} />\n        <BoilingVerdict\n          celsius={parseFloat(value)} />\n      </fieldset>\n    );\n  }\n}\n```\n\n### 添加第二个输入\n输入一个华氏温度，能够和摄氏度相互转换。  \n首先定义两个函数实现华氏度和摄氏度转换，再定义一个函数实现将值转换为字符串：\n```javascript\nfunction toCelsius(fahrenheit) {\n  return (fahrenheit - 32) * 5 / 9;\n}\n\nfunction toFahrenheit(celsius) {\n  return (celsius * 9 / 5) + 32;\n}\n\nfunction tryConvert(value, convert) {\n  const input = parseFloat(value);\n  if (Number.isNaN(input)) {\n    return '';\n  }\n  const output = convert(input);\n  const rounded = Math.round(output * 1000) / 1000;\n  return rounded.toString();\n}\n```\n下面是温度输入组件\n```javascript\nclass TemperatureInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n  }\n\n  handleChange(e) {\n    this.props.onChange(e.target.value);\n  }\n\n  render() {\n    const value = this.props.value;\n    const scale = this.props.scale;\n    return (\n      <fieldset>\n        <legend>Enter temperature in {scaleNames[scale]}:</legend>\n        <input value={value}\n               onChange={this.handleChange} />\n      </fieldset>\n    );\n  }\n}\n```\n下面是温度转换，以及显示沸水情况组件\n```javascript\nclass Calculator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleCelsiusChange = this.handleCelsiusChange.bind(this);\n    this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);\n    this.state = {value: '', scale: 'c'};\n  }\n\n  handleCelsiusChange(value) {\n    this.setState({scale: 'c', value});\n  }\n\n  handleFahrenheitChange(value) {\n    this.setState({scale: 'f', value});\n  }\n\n  render() {\n    const scale = this.state.scale;\n    const value = this.state.value;\n    const celsius = scale === 'f' ? tryConvert(value, toCelsius) : value;\n    const fahrenheit = scale === 'c' ? tryConvert(value, toFahrenheit) : value;\n\n    return (\n      <div>\n        <TemperatureInput\n          scale=\"c\"\n          value={celsius}\n          onChange={this.handleCelsiusChange} />\n        <TemperatureInput\n          scale=\"f\"\n          value={fahrenheit}\n          onChange={this.handleFahrenheitChange} />\n        <BoilingVerdict\n          celsius={parseFloat(celsius)} />\n      </div>\n    );\n  }\n}\n```\n### 总结\n对于React中的任何数据，应该有一个单一的来源。通常将state添加到需要渲染的组件，如果其他组件也需要该state，将它提升到最接近的共同父组件中，而不是试图同步不同组件之间的state。这种解决方法就是自上而下的数据流。  \n提升state需要编写更多的代码，但是这可以方便寻找和修改bug。state存在一些组件中，在这些组件中都可以单独改变该state，这可以减少错误。另外，你可以控制用户的输入。  \n如果某个state属性，可以通过props或者其他state属性得到，我们可能就不需要该state属性。\n\n## 组件的组成和继承\nReact组件具有强大的组合功能，我们建议使用组合来重用组件之间的代码，而不是继承。\n### 包含\n一些组件提前不知道自己包含什么。可以使用props的children来传递包含的组件\n```javascript\n// 使用props.children来调用被包含的组件\nfunction FancyBorder(props) {\n  return (\n    <div className={'FancyBorder FancyBorder-' + props.color}>\n      {props.children}\n    </div>\n  );\n}\n// 其他组件通过JSX传递被包含的组件给父组件\nfunction WelcomeDialog() {\n  return (\n    <FancyBorder color=\"blue\">\n      <h1 className=\"Dialog-title\">\n        Welcome\n      </h1>\n      <p className=\"Dialog-message\">\n        Thank you for visiting our spacecraft!\n      </p>\n    </FancyBorder>\n  );\n}\n```\n有时候也可以包含多个子组件，可以通过自定义props传递\n```javascript\nfunction SplitPane(props) {\n  return (\n    <div className=\"SplitPane\">\n      <div className=\"SplitPane-left\">\n        {props.left}\n      </div>\n      <div className=\"SplitPane-right\">\n        {props.right}\n      </div>\n    </div>\n  );\n}\n// 向SplitPane组件中传递Contacts和Chat组件\nfunction App() {\n  return (\n    <SplitPane\n      left={\n        <Contacts />\n      }\n      right={\n        <Chat />\n      } />\n  );\n}\n```\n### 特殊化\n有些组件是另一些组件的特殊情况。比如：WelcomDialog是Dialog的特例。可以通过传递props来实现\n```javascript\nfunction Dialog(props) {\n  return (\n    <FancyBorder color=\"blue\">\n      <h1 className=\"Dialog-title\">\n        {props.title}\n      </h1>\n      <p className=\"Dialog-message\">\n        {props.message}\n      </p>\n    </FancyBorder>\n  );\n}\n\nfunction WelcomeDialog() {\n  return (\n    <Dialog\n      title=\"Welcome\"\n      message=\"Thank you for visiting our spacecraft!\" />\n  );\n}\n```\n### 不建议使用继承\nprops和组合可以使React组件有很大的灵活性，组件可以接受任意props，原始值，React组件，以及函数。  \n如果组件之间重用非UI功能，建议可以将这部分函数单独提到一个JavaScript模块中，组件可以导入该模块中的函数、对象或者类，而不需要继承。\n\n## Think in React\n### 第一步 拆分组件\n拆分组件应该遵循单一职责原则，每个组件只负责做一件事。一般情况下，正确的组件划分能够正好的映射JSON数据模型。[具体参考这里](https://facebook.github.io/react/docs/thinking-in-react.html)\n### 第二步 构建静态版本\n根据层次解构组合组件，接受模拟的数据呈现出UI，但是这是没有交互性的。  \n构建静态版本，要构建一个重用其他组件的组件，并且使用props传递数据。在静态版本中，不要使用state。state保留用于交互，所以这里不需要使用它。  \n在构造过程中，可以自上到下，也可以使用自下到上。  \n在完成这一步后，你将有一个可重用的组件库，用来呈现你的模拟数据。组件只会有render()方法。在最上层组件，传递模拟数据，更改模拟数据查看组件的变化是否正常。\n### 第三步 识别最小且完整的state\n正确的构建项目，首先需要考虑项目所需要考虑所有需要的最小的state集合，并且通过这些state计算出所有需要的其他内容。如果是能够计算出来的，就不需要存储在state中。  \n比如在一个TODO列表中，所有数据包括：\n* 原本的列表\n* 用户输入搜索框的内容\n* 用户勾选的选项\n* 过滤掉的列表\n对于这样的所有数据，我们需要弄清哪些才是state，可以问自己三个问题：\n1. 它可以通过父组件的props传递进来吗？\n2. 是否不会变化？\n3. 是否可以通过其他state或props计算出来？\n如果有一个回答是，那么该属性不应该是state。  \n原本的列表应该是通过props传递来的，过滤掉的列表可以通过原本的列表和输入框中的值计算出来。最后得到的state是：\n* 用户输入搜索框的内容\n* 用户勾选的选项\n### 第四步 确定state应该在哪个位置\n确定好state之后，是要确定在哪里定义state，在哪里更改state。  \n对于每一个state：\n* 确定哪些组件要用到该state\n* 找到一个包含这些所有组件的父组件\n* 包含这些所有组件的父组件其中结构层次最高的组件应该拥有该state\n* 如果找不到这样的父组件，创建一个这样的父组件，并且添加state\n### 第五步 添加反向数据流\n因为是单向数据流，所以需要添加操作对state的更改。比如，输入框绑定了用户输入搜索框内容这个state，输入框就不会响应用户的输入行为，需要为input绑定修改state事件。这里是子组件修改父组件中的state，所以就是反向数据流。","slug":"React Docs(3)","published":1,"updated":"2017-02-16T07:39:20.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8kh9000cohfkvbc6vciq","content":"<h2 id=\"列表和键（key）\"><a href=\"#列表和键（key）\" class=\"headerlink\" title=\"列表和键（key）\"></a>列表和键（key）</h2><p>在React中转换数组和在JavaScript中几乎相同，可以通过数组的map方法渲染多个组件：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 显示内容为1到5的列表</div><div class=\"line\">function NumberList(props) &#123;</div><div class=\"line\">  const numbers = props.numbers;</div><div class=\"line\">  const listItems = numbers.map((number) =&gt;</div><div class=\"line\">    &lt;li&gt;&#123;number&#125;&lt;/li&gt;</div><div class=\"line\">  );</div><div class=\"line\">  return (</div><div class=\"line\">    &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const numbers = [1, 2, 3, 4, 5];</div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<p>在运行此代码的时候，会收到一条警告，警告指出需要为每一项提供一个key，这个是很重要的。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">function NumberList(props) &#123;</div><div class=\"line\">  const numbers = props.numbers;</div><div class=\"line\">  const listItems = numbers.map((number) =&gt;</div><div class=\"line\">    &lt;li key=&#123;number.toString()&#125;&gt;</div><div class=\"line\">      &#123;number&#125;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">  );</div><div class=\"line\">  return (</div><div class=\"line\">    &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const numbers = [1, 2, 3, 4, 5];</div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<h3 id=\"键（key）\"><a href=\"#键（key）\" class=\"headerlink\" title=\"键（key）\"></a>键（key）</h3><p>key可以帮助确定哪些项发生了变化，或者添加、删除了哪些项，通常使用数据的id作为key，这样在整个列表中key的值是唯一的。<br>key只有在周围环境是数据的情况下才有意义，如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 错误的做法</div><div class=\"line\">function ListItem(props) &#123;</div><div class=\"line\">  const value = props.value;</div><div class=\"line\">  return (</div><div class=\"line\">    // 这里不必要使用key，使用</div><div class=\"line\">    &lt;li key=&#123;value.toString()&#125;&gt;</div><div class=\"line\">      &#123;value&#125;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function NumberList(props) &#123;</div><div class=\"line\">  const numbers = props.numbers;</div><div class=\"line\">  const listItems = numbers.map((number) =&gt;</div><div class=\"line\">    // key属性应该添加在这里</div><div class=\"line\">    &lt;ListItem value=&#123;number&#125; /&gt;</div><div class=\"line\">  );</div><div class=\"line\">  return (</div><div class=\"line\">    &lt;ul&gt;</div><div class=\"line\">      &#123;listItems&#125;</div><div class=\"line\">    &lt;/ul&gt;</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const numbers = [1, 2, 3, 4, 5];</div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<p>其实只需要记得在map函数中使用key就可以了。</p>\n<h3 id=\"key在兄弟节点间是唯一的\"><a href=\"#key在兄弟节点间是唯一的\" class=\"headerlink\" title=\"key在兄弟节点间是唯一的\"></a>key在兄弟节点间是唯一的</h3><p>数组中使用key需要是唯一的，但是在全局不需要是唯一的。当生成两个不同的数组，我们可以使用相同的键。<br>key作为组件的标识，但是不会将值传递给组件，如果需要使用key中的值，需要另外传给组件的一个属性。<br>JSX中可以嵌套map函数。这种形式有时候会使代码更加清晰，有时候也会被滥用，这就需要你来决定是否需要提取出来，以提高可读性。</p>\n<h2 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h2><p>表单元素自身本来就拥有一些属性（比如name等），表单在用户提交时，会执行默认的表单行为，提交到一个新的页面。但是在多数情况下，我们使用JavaScript函数处理表单的提交，处理用户提交的数据。实现这种方法的组件我们称为“受控组件”。</p>\n<h3 id=\"受控组件\"><a href=\"#受控组件\" class=\"headerlink\" title=\"受控组件\"></a>受控组件</h3><p>在HTML中，表单元素如<code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>和<code>&lt;select&gt;</code>通常保持自己的状态，并根据用户的输入进行更新。而在React中，状态一般保存都state属性中，并且state属性只能通过<code>setState()</code>更新。<br>我们可以将React的state设置成HTML的输入将两者结合，然后React组件还需要控制用户的输入，这样的组件被称为“受控组件”。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NameForm</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">value</span>: <span class=\"string\">''</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.handleSubmit = <span class=\"keyword\">this</span>.handleSubmit.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleChange(event) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">value</span>: event.target.value&#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleSubmit(event) &#123;</div><div class=\"line\">    alert(<span class=\"string\">'A name was submitted: '</span> + <span class=\"keyword\">this</span>.state.value);</div><div class=\"line\">    event.preventDefault();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</div><div class=\"line\">        &lt;label&gt;</div><div class=\"line\">          Name:</div><div class=\"line\">          &lt;input type=\"text\" value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</div><div class=\"line\">        &lt;/label&gt;</div><div class=\"line\">        &lt;input type=\"submit\" value=\"Submit\" /&gt;</div><div class=\"line\">      &lt;/form&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中将input元素的value值交给React组件的state，通过handleChange函数响应每次输入来更新state。使用受控组件，每个输入都会关联到处理函数，这使得可以直接修改或验证用户输入。</p>\n<h3 id=\"textarea标签\"><a href=\"#textarea标签\" class=\"headerlink\" title=\"textarea标签\"></a>textarea标签</h3><p>在React中，textarea标签也使用了value属性来代替在元素中的显示值。</p>\n<h3 id=\"select标签\"><a href=\"#select标签\" class=\"headerlink\" title=\"select标签\"></a>select标签</h3><p>在HTML中使用<code>&lt;select&gt;</code>标签时候，可以使用option中selected属性表示当前选择的选项。而在React中，将当前选项保存在select中的value，当select中的value与option的Value相同时，该选项被选择。</p>\n<h3 id=\"受控组件的代码\"><a href=\"#受控组件的代码\" class=\"headerlink\" title=\"受控组件的代码\"></a>受控组件的代码</h3><p>使用受控组件有时候是很复杂的，因为你需要为更改数据的所有方式编写事件处理函数，并通过React组件管理所有输入状态。这时候可能需要不受控组件。</p>\n<h2 id=\"提升state属性\"><a href=\"#提升state属性\" class=\"headerlink\" title=\"提升state属性\"></a>提升state属性</h2><p>通常，几个组件需要反映相同的数据变化，这时候可以将共享的state提升到最接近的共同的父组件中。</p>\n<p>下面这个组件BoilingVerdict接受一个celsius温度参数，并打印是否能把水烧开<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BoilingVerdict</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (props.celsius &gt;= <span class=\"number\">100</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>The water would boil.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>The water would not boil.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面这个组件Calculator，输入一个celsius摄氏温度，保存到this.state.value中，并作为BoilingVerdict输入。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Calculator</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">value</span>: <span class=\"string\">''</span>&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleChange(e) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">value</span>: e.target.value&#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> value = <span class=\"keyword\">this</span>.state.value;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;fieldset&gt;</div><div class=\"line\">        &lt;legend&gt;Enter temperature in Celsius:&lt;/legend&gt;</div><div class=\"line\">        &lt;input</div><div class=\"line\">          value=&#123;value&#125;</div><div class=\"line\">          onChange=&#123;this.handleChange&#125; /&gt;</div><div class=\"line\">        &lt;BoilingVerdict</div><div class=\"line\">          celsius=&#123;parseFloat(value)&#125; /&gt;</div><div class=\"line\">      &lt;/fieldset&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"添加第二个输入\"><a href=\"#添加第二个输入\" class=\"headerlink\" title=\"添加第二个输入\"></a>添加第二个输入</h3><p>输入一个华氏温度，能够和摄氏度相互转换。<br>首先定义两个函数实现华氏度和摄氏度转换，再定义一个函数实现将值转换为字符串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toCelsius</span>(<span class=\"params\">fahrenheit</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (fahrenheit - <span class=\"number\">32</span>) * <span class=\"number\">5</span> / <span class=\"number\">9</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toFahrenheit</span>(<span class=\"params\">celsius</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (celsius * <span class=\"number\">9</span> / <span class=\"number\">5</span>) + <span class=\"number\">32</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tryConvert</span>(<span class=\"params\">value, convert</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> input = <span class=\"built_in\">parseFloat</span>(value);</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Number</span>.isNaN(input)) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">const</span> output = convert(input);</div><div class=\"line\">  <span class=\"keyword\">const</span> rounded = <span class=\"built_in\">Math</span>.round(output * <span class=\"number\">1000</span>) / <span class=\"number\">1000</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> rounded.toString();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面是温度输入组件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TemperatureInput</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleChange(e) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.props.onChange(e.target.value);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> value = <span class=\"keyword\">this</span>.props.value;</div><div class=\"line\">    <span class=\"keyword\">const</span> scale = <span class=\"keyword\">this</span>.props.scale;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">fieldset</span>&gt;</span></span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">legend</span>&gt;</span>Enter temperature in &#123;scaleNames[scale]&#125;:<span class=\"tag\">&lt;/<span class=\"name\">legend</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;value&#125;</span></span></div><div class=\"line\">               <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;this.handleChange&#125;</span> /&gt;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">fieldset</span>&gt;</span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面是温度转换，以及显示沸水情况组件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Calculator</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.handleCelsiusChange = <span class=\"keyword\">this</span>.handleCelsiusChange.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.handleFahrenheitChange = <span class=\"keyword\">this</span>.handleFahrenheitChange.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">value</span>: <span class=\"string\">''</span>, <span class=\"attr\">scale</span>: <span class=\"string\">'c'</span>&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleCelsiusChange(value) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">scale</span>: <span class=\"string\">'c'</span>, value&#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleFahrenheitChange(value) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">scale</span>: <span class=\"string\">'f'</span>, value&#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> scale = <span class=\"keyword\">this</span>.state.scale;</div><div class=\"line\">    <span class=\"keyword\">const</span> value = <span class=\"keyword\">this</span>.state.value;</div><div class=\"line\">    <span class=\"keyword\">const</span> celsius = scale === <span class=\"string\">'f'</span> ? tryConvert(value, toCelsius) : value;</div><div class=\"line\">    <span class=\"keyword\">const</span> fahrenheit = scale === <span class=\"string\">'c'</span> ? tryConvert(value, toFahrenheit) : value;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div&gt;</div><div class=\"line\">        &lt;TemperatureInput</div><div class=\"line\">          scale=\"c\"</div><div class=\"line\">          value=&#123;celsius&#125;</div><div class=\"line\">          onChange=&#123;this.handleCelsiusChange&#125; /&gt;</div><div class=\"line\">        &lt;TemperatureInput</div><div class=\"line\">          scale=\"f\"</div><div class=\"line\">          value=&#123;fahrenheit&#125;</div><div class=\"line\">          onChange=&#123;this.handleFahrenheitChange&#125; /&gt;</div><div class=\"line\">        &lt;BoilingVerdict</div><div class=\"line\">          celsius=&#123;parseFloat(celsius)&#125; /&gt;</div><div class=\"line\">      &lt;/div&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>对于React中的任何数据，应该有一个单一的来源。通常将state添加到需要渲染的组件，如果其他组件也需要该state，将它提升到最接近的共同父组件中，而不是试图同步不同组件之间的state。这种解决方法就是自上而下的数据流。<br>提升state需要编写更多的代码，但是这可以方便寻找和修改bug。state存在一些组件中，在这些组件中都可以单独改变该state，这可以减少错误。另外，你可以控制用户的输入。<br>如果某个state属性，可以通过props或者其他state属性得到，我们可能就不需要该state属性。</p>\n<h2 id=\"组件的组成和继承\"><a href=\"#组件的组成和继承\" class=\"headerlink\" title=\"组件的组成和继承\"></a>组件的组成和继承</h2><p>React组件具有强大的组合功能，我们建议使用组合来重用组件之间的代码，而不是继承。</p>\n<h3 id=\"包含\"><a href=\"#包含\" class=\"headerlink\" title=\"包含\"></a>包含</h3><p>一些组件提前不知道自己包含什么。可以使用props的children来传递包含的组件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 使用props.children来调用被包含的组件</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FancyBorder</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;</span>'<span class=\"attr\">FancyBorder</span> <span class=\"attr\">FancyBorder-</span>' + <span class=\"attr\">props.color</span>&#125;&gt;</span></span></div><div class=\"line\">      &#123;props.children&#125;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 其他组件通过JSX传递被包含的组件给父组件</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">WelcomeDialog</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">FancyBorder</span> <span class=\"attr\">color</span>=<span class=\"string\">\"blue\"</span>&gt;</span></span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Dialog-title\"</span>&gt;</span></div><div class=\"line\">        Welcome</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Dialog-message\"</span>&gt;</span></div><div class=\"line\">        Thank you for visiting our spacecraft!</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">FancyBorder</span>&gt;</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>有时候也可以包含多个子组件，可以通过自定义props传递<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SplitPane</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"SplitPane\"</span>&gt;</span></span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"SplitPane-left\"</span>&gt;</span></div><div class=\"line\">        &#123;props.left&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"SplitPane-right\"</span>&gt;</span></div><div class=\"line\">        &#123;props.right&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 向SplitPane组件中传递Contacts和Chat组件</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">SplitPane</span></span></span></div><div class=\"line\">      <span class=\"attr\">left</span>=<span class=\"string\">&#123;</span></div><div class=\"line\">        &lt;<span class=\"attr\">Contacts</span> /&gt;</div><div class=\"line\">      &#125;</div><div class=\"line\">      right=&#123;</div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Chat</span> /&gt;</span></div><div class=\"line\">      &#125; /&gt;</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"特殊化\"><a href=\"#特殊化\" class=\"headerlink\" title=\"特殊化\"></a>特殊化</h3><p>有些组件是另一些组件的特殊情况。比如：WelcomDialog是Dialog的特例。可以通过传递props来实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dialog</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">FancyBorder</span> <span class=\"attr\">color</span>=<span class=\"string\">\"blue\"</span>&gt;</span></span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Dialog-title\"</span>&gt;</span></div><div class=\"line\">        &#123;props.title&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Dialog-message\"</span>&gt;</span></div><div class=\"line\">        &#123;props.message&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">FancyBorder</span>&gt;</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">WelcomeDialog</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Dialog</span></span></span></div><div class=\"line\">      <span class=\"attr\">title</span>=<span class=\"string\">\"Welcome\"</span></div><div class=\"line\">      <span class=\"attr\">message</span>=<span class=\"string\">\"Thank you for visiting our spacecraft!\"</span> /&gt;</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"不建议使用继承\"><a href=\"#不建议使用继承\" class=\"headerlink\" title=\"不建议使用继承\"></a>不建议使用继承</h3><p>props和组合可以使React组件有很大的灵活性，组件可以接受任意props，原始值，React组件，以及函数。<br>如果组件之间重用非UI功能，建议可以将这部分函数单独提到一个JavaScript模块中，组件可以导入该模块中的函数、对象或者类，而不需要继承。</p>\n<h2 id=\"Think-in-React\"><a href=\"#Think-in-React\" class=\"headerlink\" title=\"Think in React\"></a>Think in React</h2><h3 id=\"第一步-拆分组件\"><a href=\"#第一步-拆分组件\" class=\"headerlink\" title=\"第一步 拆分组件\"></a>第一步 拆分组件</h3><p>拆分组件应该遵循单一职责原则，每个组件只负责做一件事。一般情况下，正确的组件划分能够正好的映射JSON数据模型。<a href=\"https://facebook.github.io/react/docs/thinking-in-react.html\" target=\"_blank\" rel=\"external\">具体参考这里</a></p>\n<h3 id=\"第二步-构建静态版本\"><a href=\"#第二步-构建静态版本\" class=\"headerlink\" title=\"第二步 构建静态版本\"></a>第二步 构建静态版本</h3><p>根据层次解构组合组件，接受模拟的数据呈现出UI，但是这是没有交互性的。<br>构建静态版本，要构建一个重用其他组件的组件，并且使用props传递数据。在静态版本中，不要使用state。state保留用于交互，所以这里不需要使用它。<br>在构造过程中，可以自上到下，也可以使用自下到上。<br>在完成这一步后，你将有一个可重用的组件库，用来呈现你的模拟数据。组件只会有render()方法。在最上层组件，传递模拟数据，更改模拟数据查看组件的变化是否正常。</p>\n<h3 id=\"第三步-识别最小且完整的state\"><a href=\"#第三步-识别最小且完整的state\" class=\"headerlink\" title=\"第三步 识别最小且完整的state\"></a>第三步 识别最小且完整的state</h3><p>正确的构建项目，首先需要考虑项目所需要考虑所有需要的最小的state集合，并且通过这些state计算出所有需要的其他内容。如果是能够计算出来的，就不需要存储在state中。<br>比如在一个TODO列表中，所有数据包括：</p>\n<ul>\n<li>原本的列表</li>\n<li>用户输入搜索框的内容</li>\n<li>用户勾选的选项</li>\n<li>过滤掉的列表<br>对于这样的所有数据，我们需要弄清哪些才是state，可以问自己三个问题：</li>\n</ul>\n<ol>\n<li>它可以通过父组件的props传递进来吗？</li>\n<li>是否不会变化？</li>\n<li>是否可以通过其他state或props计算出来？<br>如果有一个回答是，那么该属性不应该是state。<br>原本的列表应该是通过props传递来的，过滤掉的列表可以通过原本的列表和输入框中的值计算出来。最后得到的state是：</li>\n</ol>\n<ul>\n<li>用户输入搜索框的内容</li>\n<li>用户勾选的选项<h3 id=\"第四步-确定state应该在哪个位置\"><a href=\"#第四步-确定state应该在哪个位置\" class=\"headerlink\" title=\"第四步 确定state应该在哪个位置\"></a>第四步 确定state应该在哪个位置</h3>确定好state之后，是要确定在哪里定义state，在哪里更改state。<br>对于每一个state：</li>\n<li>确定哪些组件要用到该state</li>\n<li>找到一个包含这些所有组件的父组件</li>\n<li>包含这些所有组件的父组件其中结构层次最高的组件应该拥有该state</li>\n<li>如果找不到这样的父组件，创建一个这样的父组件，并且添加state<h3 id=\"第五步-添加反向数据流\"><a href=\"#第五步-添加反向数据流\" class=\"headerlink\" title=\"第五步 添加反向数据流\"></a>第五步 添加反向数据流</h3>因为是单向数据流，所以需要添加操作对state的更改。比如，输入框绑定了用户输入搜索框内容这个state，输入框就不会响应用户的输入行为，需要为input绑定修改state事件。这里是子组件修改父组件中的state，所以就是反向数据流。</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"列表和键（key）\"><a href=\"#列表和键（key）\" class=\"headerlink\" title=\"列表和键（key）\"></a>列表和键（key）</h2><p>在React中转换数组和在JavaScript中几乎相同，可以通过数组的map方法渲染多个组件：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 显示内容为1到5的列表</div><div class=\"line\">function NumberList(props) &#123;</div><div class=\"line\">  const numbers = props.numbers;</div><div class=\"line\">  const listItems = numbers.map((number) =&gt;</div><div class=\"line\">    &lt;li&gt;&#123;number&#125;&lt;/li&gt;</div><div class=\"line\">  );</div><div class=\"line\">  return (</div><div class=\"line\">    &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const numbers = [1, 2, 3, 4, 5];</div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<p>在运行此代码的时候，会收到一条警告，警告指出需要为每一项提供一个key，这个是很重要的。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">function NumberList(props) &#123;</div><div class=\"line\">  const numbers = props.numbers;</div><div class=\"line\">  const listItems = numbers.map((number) =&gt;</div><div class=\"line\">    &lt;li key=&#123;number.toString()&#125;&gt;</div><div class=\"line\">      &#123;number&#125;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">  );</div><div class=\"line\">  return (</div><div class=\"line\">    &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const numbers = [1, 2, 3, 4, 5];</div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<h3 id=\"键（key）\"><a href=\"#键（key）\" class=\"headerlink\" title=\"键（key）\"></a>键（key）</h3><p>key可以帮助确定哪些项发生了变化，或者添加、删除了哪些项，通常使用数据的id作为key，这样在整个列表中key的值是唯一的。<br>key只有在周围环境是数据的情况下才有意义，如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 错误的做法</div><div class=\"line\">function ListItem(props) &#123;</div><div class=\"line\">  const value = props.value;</div><div class=\"line\">  return (</div><div class=\"line\">    // 这里不必要使用key，使用</div><div class=\"line\">    &lt;li key=&#123;value.toString()&#125;&gt;</div><div class=\"line\">      &#123;value&#125;</div><div class=\"line\">    &lt;/li&gt;</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function NumberList(props) &#123;</div><div class=\"line\">  const numbers = props.numbers;</div><div class=\"line\">  const listItems = numbers.map((number) =&gt;</div><div class=\"line\">    // key属性应该添加在这里</div><div class=\"line\">    &lt;ListItem value=&#123;number&#125; /&gt;</div><div class=\"line\">  );</div><div class=\"line\">  return (</div><div class=\"line\">    &lt;ul&gt;</div><div class=\"line\">      &#123;listItems&#125;</div><div class=\"line\">    &lt;/ul&gt;</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const numbers = [1, 2, 3, 4, 5];</div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</div><div class=\"line\">  document.getElementById('root')</div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<p>其实只需要记得在map函数中使用key就可以了。</p>\n<h3 id=\"key在兄弟节点间是唯一的\"><a href=\"#key在兄弟节点间是唯一的\" class=\"headerlink\" title=\"key在兄弟节点间是唯一的\"></a>key在兄弟节点间是唯一的</h3><p>数组中使用key需要是唯一的，但是在全局不需要是唯一的。当生成两个不同的数组，我们可以使用相同的键。<br>key作为组件的标识，但是不会将值传递给组件，如果需要使用key中的值，需要另外传给组件的一个属性。<br>JSX中可以嵌套map函数。这种形式有时候会使代码更加清晰，有时候也会被滥用，这就需要你来决定是否需要提取出来，以提高可读性。</p>\n<h2 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h2><p>表单元素自身本来就拥有一些属性（比如name等），表单在用户提交时，会执行默认的表单行为，提交到一个新的页面。但是在多数情况下，我们使用JavaScript函数处理表单的提交，处理用户提交的数据。实现这种方法的组件我们称为“受控组件”。</p>\n<h3 id=\"受控组件\"><a href=\"#受控组件\" class=\"headerlink\" title=\"受控组件\"></a>受控组件</h3><p>在HTML中，表单元素如<code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>和<code>&lt;select&gt;</code>通常保持自己的状态，并根据用户的输入进行更新。而在React中，状态一般保存都state属性中，并且state属性只能通过<code>setState()</code>更新。<br>我们可以将React的state设置成HTML的输入将两者结合，然后React组件还需要控制用户的输入，这样的组件被称为“受控组件”。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NameForm</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">value</span>: <span class=\"string\">''</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.handleSubmit = <span class=\"keyword\">this</span>.handleSubmit.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleChange(event) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">value</span>: event.target.value&#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleSubmit(event) &#123;</div><div class=\"line\">    alert(<span class=\"string\">'A name was submitted: '</span> + <span class=\"keyword\">this</span>.state.value);</div><div class=\"line\">    event.preventDefault();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</div><div class=\"line\">        &lt;label&gt;</div><div class=\"line\">          Name:</div><div class=\"line\">          &lt;input type=\"text\" value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</div><div class=\"line\">        &lt;/label&gt;</div><div class=\"line\">        &lt;input type=\"submit\" value=\"Submit\" /&gt;</div><div class=\"line\">      &lt;/form&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中将input元素的value值交给React组件的state，通过handleChange函数响应每次输入来更新state。使用受控组件，每个输入都会关联到处理函数，这使得可以直接修改或验证用户输入。</p>\n<h3 id=\"textarea标签\"><a href=\"#textarea标签\" class=\"headerlink\" title=\"textarea标签\"></a>textarea标签</h3><p>在React中，textarea标签也使用了value属性来代替在元素中的显示值。</p>\n<h3 id=\"select标签\"><a href=\"#select标签\" class=\"headerlink\" title=\"select标签\"></a>select标签</h3><p>在HTML中使用<code>&lt;select&gt;</code>标签时候，可以使用option中selected属性表示当前选择的选项。而在React中，将当前选项保存在select中的value，当select中的value与option的Value相同时，该选项被选择。</p>\n<h3 id=\"受控组件的代码\"><a href=\"#受控组件的代码\" class=\"headerlink\" title=\"受控组件的代码\"></a>受控组件的代码</h3><p>使用受控组件有时候是很复杂的，因为你需要为更改数据的所有方式编写事件处理函数，并通过React组件管理所有输入状态。这时候可能需要不受控组件。</p>\n<h2 id=\"提升state属性\"><a href=\"#提升state属性\" class=\"headerlink\" title=\"提升state属性\"></a>提升state属性</h2><p>通常，几个组件需要反映相同的数据变化，这时候可以将共享的state提升到最接近的共同的父组件中。</p>\n<p>下面这个组件BoilingVerdict接受一个celsius温度参数，并打印是否能把水烧开<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BoilingVerdict</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (props.celsius &gt;= <span class=\"number\">100</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>The water would boil.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>The water would not boil.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面这个组件Calculator，输入一个celsius摄氏温度，保存到this.state.value中，并作为BoilingVerdict输入。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Calculator</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">value</span>: <span class=\"string\">''</span>&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleChange(e) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">value</span>: e.target.value&#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> value = <span class=\"keyword\">this</span>.state.value;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;fieldset&gt;</div><div class=\"line\">        &lt;legend&gt;Enter temperature in Celsius:&lt;/legend&gt;</div><div class=\"line\">        &lt;input</div><div class=\"line\">          value=&#123;value&#125;</div><div class=\"line\">          onChange=&#123;this.handleChange&#125; /&gt;</div><div class=\"line\">        &lt;BoilingVerdict</div><div class=\"line\">          celsius=&#123;parseFloat(value)&#125; /&gt;</div><div class=\"line\">      &lt;/fieldset&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"添加第二个输入\"><a href=\"#添加第二个输入\" class=\"headerlink\" title=\"添加第二个输入\"></a>添加第二个输入</h3><p>输入一个华氏温度，能够和摄氏度相互转换。<br>首先定义两个函数实现华氏度和摄氏度转换，再定义一个函数实现将值转换为字符串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toCelsius</span>(<span class=\"params\">fahrenheit</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (fahrenheit - <span class=\"number\">32</span>) * <span class=\"number\">5</span> / <span class=\"number\">9</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toFahrenheit</span>(<span class=\"params\">celsius</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (celsius * <span class=\"number\">9</span> / <span class=\"number\">5</span>) + <span class=\"number\">32</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tryConvert</span>(<span class=\"params\">value, convert</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> input = <span class=\"built_in\">parseFloat</span>(value);</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Number</span>.isNaN(input)) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">const</span> output = convert(input);</div><div class=\"line\">  <span class=\"keyword\">const</span> rounded = <span class=\"built_in\">Math</span>.round(output * <span class=\"number\">1000</span>) / <span class=\"number\">1000</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> rounded.toString();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面是温度输入组件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TemperatureInput</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.handleChange = <span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleChange(e) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.props.onChange(e.target.value);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> value = <span class=\"keyword\">this</span>.props.value;</div><div class=\"line\">    <span class=\"keyword\">const</span> scale = <span class=\"keyword\">this</span>.props.scale;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">fieldset</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">legend</span>&gt;</span>Enter temperature in &#123;scaleNames[scale]&#125;:<span class=\"tag\">&lt;/<span class=\"name\">legend</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;value&#125;</span></div><div class=\"line\">               <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;this.handleChange&#125;</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">fieldset</span>&gt;</span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure></p>\n<p>下面是温度转换，以及显示沸水情况组件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Calculator</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.handleCelsiusChange = <span class=\"keyword\">this</span>.handleCelsiusChange.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.handleFahrenheitChange = <span class=\"keyword\">this</span>.handleFahrenheitChange.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">value</span>: <span class=\"string\">''</span>, <span class=\"attr\">scale</span>: <span class=\"string\">'c'</span>&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleCelsiusChange(value) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">scale</span>: <span class=\"string\">'c'</span>, value&#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleFahrenheitChange(value) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">scale</span>: <span class=\"string\">'f'</span>, value&#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> scale = <span class=\"keyword\">this</span>.state.scale;</div><div class=\"line\">    <span class=\"keyword\">const</span> value = <span class=\"keyword\">this</span>.state.value;</div><div class=\"line\">    <span class=\"keyword\">const</span> celsius = scale === <span class=\"string\">'f'</span> ? tryConvert(value, toCelsius) : value;</div><div class=\"line\">    <span class=\"keyword\">const</span> fahrenheit = scale === <span class=\"string\">'c'</span> ? tryConvert(value, toFahrenheit) : value;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div&gt;</div><div class=\"line\">        &lt;TemperatureInput</div><div class=\"line\">          scale=\"c\"</div><div class=\"line\">          value=&#123;celsius&#125;</div><div class=\"line\">          onChange=&#123;this.handleCelsiusChange&#125; /&gt;</div><div class=\"line\">        &lt;TemperatureInput</div><div class=\"line\">          scale=\"f\"</div><div class=\"line\">          value=&#123;fahrenheit&#125;</div><div class=\"line\">          onChange=&#123;this.handleFahrenheitChange&#125; /&gt;</div><div class=\"line\">        &lt;BoilingVerdict</div><div class=\"line\">          celsius=&#123;parseFloat(celsius)&#125; /&gt;</div><div class=\"line\">      &lt;/div&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>对于React中的任何数据，应该有一个单一的来源。通常将state添加到需要渲染的组件，如果其他组件也需要该state，将它提升到最接近的共同父组件中，而不是试图同步不同组件之间的state。这种解决方法就是自上而下的数据流。<br>提升state需要编写更多的代码，但是这可以方便寻找和修改bug。state存在一些组件中，在这些组件中都可以单独改变该state，这可以减少错误。另外，你可以控制用户的输入。<br>如果某个state属性，可以通过props或者其他state属性得到，我们可能就不需要该state属性。</p>\n<h2 id=\"组件的组成和继承\"><a href=\"#组件的组成和继承\" class=\"headerlink\" title=\"组件的组成和继承\"></a>组件的组成和继承</h2><p>React组件具有强大的组合功能，我们建议使用组合来重用组件之间的代码，而不是继承。</p>\n<h3 id=\"包含\"><a href=\"#包含\" class=\"headerlink\" title=\"包含\"></a>包含</h3><p>一些组件提前不知道自己包含什么。可以使用props的children来传递包含的组件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 使用props.children来调用被包含的组件</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FancyBorder</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;</span>'<span class=\"attr\">FancyBorder</span> <span class=\"attr\">FancyBorder-</span>' + <span class=\"attr\">props.color</span>&#125;&gt;</span></div><div class=\"line\">      &#123;props.children&#125;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 其他组件通过JSX传递被包含的组件给父组件</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">WelcomeDialog</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">FancyBorder</span> <span class=\"attr\">color</span>=<span class=\"string\">\"blue\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Dialog-title\"</span>&gt;</span></div><div class=\"line\">        Welcome</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Dialog-message\"</span>&gt;</span></div><div class=\"line\">        Thank you for visiting our spacecraft!</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">FancyBorder</span>&gt;</span></span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>有时候也可以包含多个子组件，可以通过自定义props传递<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SplitPane</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"SplitPane\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"SplitPane-left\"</span>&gt;</span></div><div class=\"line\">        &#123;props.left&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"SplitPane-right\"</span>&gt;</span></div><div class=\"line\">        &#123;props.right&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 向SplitPane组件中传递Contacts和Chat组件</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">SplitPane</span></div><div class=\"line\">      <span class=\"attr\">left</span>=<span class=\"string\">&#123;</span></div><div class=\"line\">        &lt;<span class=\"attr\">Contacts</span> /&gt;</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      right=&#123;</div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Chat</span> /&gt;</span></div><div class=\"line\">      &#125; /&gt;</div><div class=\"line\">  );</div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"特殊化\"><a href=\"#特殊化\" class=\"headerlink\" title=\"特殊化\"></a>特殊化</h3><p>有些组件是另一些组件的特殊情况。比如：WelcomDialog是Dialog的特例。可以通过传递props来实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dialog</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">FancyBorder</span> <span class=\"attr\">color</span>=<span class=\"string\">\"blue\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Dialog-title\"</span>&gt;</span></div><div class=\"line\">        &#123;props.title&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">className</span>=<span class=\"string\">\"Dialog-message\"</span>&gt;</span></div><div class=\"line\">        &#123;props.message&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">FancyBorder</span>&gt;</span></span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">WelcomeDialog</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Dialog</span></div><div class=\"line\">      <span class=\"attr\">title</span>=<span class=\"string\">\"Welcome\"</span></div><div class=\"line\">      <span class=\"attr\">message</span>=<span class=\"string\">\"Thank you for visiting our spacecraft!\"</span> /&gt;</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"不建议使用继承\"><a href=\"#不建议使用继承\" class=\"headerlink\" title=\"不建议使用继承\"></a>不建议使用继承</h3><p>props和组合可以使React组件有很大的灵活性，组件可以接受任意props，原始值，React组件，以及函数。<br>如果组件之间重用非UI功能，建议可以将这部分函数单独提到一个JavaScript模块中，组件可以导入该模块中的函数、对象或者类，而不需要继承。</p>\n<h2 id=\"Think-in-React\"><a href=\"#Think-in-React\" class=\"headerlink\" title=\"Think in React\"></a>Think in React</h2><h3 id=\"第一步-拆分组件\"><a href=\"#第一步-拆分组件\" class=\"headerlink\" title=\"第一步 拆分组件\"></a>第一步 拆分组件</h3><p>拆分组件应该遵循单一职责原则，每个组件只负责做一件事。一般情况下，正确的组件划分能够正好的映射JSON数据模型。<a href=\"https://facebook.github.io/react/docs/thinking-in-react.html\">具体参考这里</a></p>\n<h3 id=\"第二步-构建静态版本\"><a href=\"#第二步-构建静态版本\" class=\"headerlink\" title=\"第二步 构建静态版本\"></a>第二步 构建静态版本</h3><p>根据层次解构组合组件，接受模拟的数据呈现出UI，但是这是没有交互性的。<br>构建静态版本，要构建一个重用其他组件的组件，并且使用props传递数据。在静态版本中，不要使用state。state保留用于交互，所以这里不需要使用它。<br>在构造过程中，可以自上到下，也可以使用自下到上。<br>在完成这一步后，你将有一个可重用的组件库，用来呈现你的模拟数据。组件只会有render()方法。在最上层组件，传递模拟数据，更改模拟数据查看组件的变化是否正常。</p>\n<h3 id=\"第三步-识别最小且完整的state\"><a href=\"#第三步-识别最小且完整的state\" class=\"headerlink\" title=\"第三步 识别最小且完整的state\"></a>第三步 识别最小且完整的state</h3><p>正确的构建项目，首先需要考虑项目所需要考虑所有需要的最小的state集合，并且通过这些state计算出所有需要的其他内容。如果是能够计算出来的，就不需要存储在state中。<br>比如在一个TODO列表中，所有数据包括：</p>\n<ul>\n<li>原本的列表</li>\n<li>用户输入搜索框的内容</li>\n<li>用户勾选的选项</li>\n<li>过滤掉的列表<br>对于这样的所有数据，我们需要弄清哪些才是state，可以问自己三个问题：</li>\n</ul>\n<ol>\n<li>它可以通过父组件的props传递进来吗？</li>\n<li>是否不会变化？</li>\n<li>是否可以通过其他state或props计算出来？<br>如果有一个回答是，那么该属性不应该是state。<br>原本的列表应该是通过props传递来的，过滤掉的列表可以通过原本的列表和输入框中的值计算出来。最后得到的state是：</li>\n</ol>\n<ul>\n<li>用户输入搜索框的内容</li>\n<li>用户勾选的选项<h3 id=\"第四步-确定state应该在哪个位置\"><a href=\"#第四步-确定state应该在哪个位置\" class=\"headerlink\" title=\"第四步 确定state应该在哪个位置\"></a>第四步 确定state应该在哪个位置</h3>确定好state之后，是要确定在哪里定义state，在哪里更改state。<br>对于每一个state：</li>\n<li>确定哪些组件要用到该state</li>\n<li>找到一个包含这些所有组件的父组件</li>\n<li>包含这些所有组件的父组件其中结构层次最高的组件应该拥有该state</li>\n<li>如果找不到这样的父组件，创建一个这样的父组件，并且添加state<h3 id=\"第五步-添加反向数据流\"><a href=\"#第五步-添加反向数据流\" class=\"headerlink\" title=\"第五步 添加反向数据流\"></a>第五步 添加反向数据流</h3>因为是单向数据流，所以需要添加操作对state的更改。比如，输入框绑定了用户输入搜索框内容这个state，输入框就不会响应用户的输入行为，需要为input绑定修改state事件。这里是子组件修改父组件中的state，所以就是反向数据流。</li>\n</ul>\n"},{"title":"React Router学习","date":"2016-08-23T16:00:00.000Z","comments":1,"_content":"\n### 0. 路由\n\n路由也就是地址，就是定义不同url访问不同页面的功能，可以实现导航、页面切换/跳转等功能。\n\n### 1. 引入\n```javascript \nimport { Router, Route, hashHistory } from 'react-router'\n```\n\n### 2. 配置\n```javascript\n<Router history={browserHistory}>\n\t<Route path=\"/\" component={Home}></Route>\n\t<Route path=\"article\" component={Article}></Route>\n</Router>\n```\n\n### 3. 通过Link实现跳转\n```javascript\n<Link to=\"/about\">About</Link>\n```\n\n### 4.1 路由嵌套(公用导航)\n```javascript\n// 路由配置\n<Router history={hashHistory}>\n  <Route path=\"/\" component={App}>\n    <Route path=\"/repos\" component={Repos}/>\n    <Route path=\"/about\" component={About}/>\n  </Route>\n</Router>\n// 页面配置(通过this.props.children调用)\n{this.props.children}\n```\n\n### 4.2 Active Links\n```javascript\n// 活动样式\n<Link to=\"/about\" activeStyle={{ color: 'red' }}>About</Link>\n// 或者 活动类名\n<li><Link to=\"/about\" activeClassName=\"active\">About</Link></li>\n```\n\n### 5. 传参\n```javascript\n// 配置\n// :userName表示匹配参数\n<Route path=\"/repos/:userName/:repoName\" component={Repo}/>\n// 跳转地址\n<Link to=\"/repos/reactjs/react-router\">React Router</Link>\n// 页面中访问参数\n{this.props.params.repoName}\n```\n\n### 6. 嵌套路由下的默认页\n```javascript\n// 需要引入react-router下的{IndexRoute}\n<Router history={hashHistory}>\n  <Route path=\"/\" component={App}>\n\n    {/* add it here, as a child of `/` */}\n    <IndexRoute component={Home}/>\n\n    <Route path=\"/repos\" component={Repos}>\n      <Route path=\"/repos/:userName/:repoName\" component={Repo}/>\n    </Route>\n    <Route path=\"/about\" component={About}/>\n  </Route>\n</Router>\n```\n\n### 7. 首页(默认页)路由地址\n```javascript\n// 直接使用Link to=\"/\"，会导致该链接总是active状态\n<Link to=\"/\"></Link>\n// 引入react-router下的{IndexLink}\n<IndexLink to=\"/\"></IndexLink>\n// 还可以使用属性 onlyActiveOnIndex\n<Link to=\"/\" activeClassName=\"active\" onlyActiveOnIndex={true}>Home</Link>\n```\n### 8. 更好的地址browserHistory\n```javascript\n// 引入\nimport { browserHistory } from 'react-router'\n// 配置\n<Router history={browserHistory}>\n  {/* ... */}\n</Router>\n// 其他方面没有变化\n```\n\n### 9. 路由跳转\n```javascript\n// 使用browserHistory\nbrowserHistory.push(path)\n// 或者使用上下文 context\n\t// 定义对象\n\tcontextType: {\n\t\trouter: React.PropTypes.object\n\t},\n\t// 调用跳转\n\tthis.context.router.push(path)\n```\n\n### 10. 路由钩子\n每个路由都有Enter和Leave钩子，触发onEnter和onLeave。\n\nps:   \n　　[阮一峰老师](http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu)  \n　　[github](https://github.com/reactjs/react-router)","source":"_posts/React Router学习.md","raw":"---\ntitle: React Router学习\ndate: 2016-08-24\ntags: [JavaScript, React]\ncategories: \n- JavaScript\ncomments: true\n---\n\n### 0. 路由\n\n路由也就是地址，就是定义不同url访问不同页面的功能，可以实现导航、页面切换/跳转等功能。\n\n### 1. 引入\n```javascript \nimport { Router, Route, hashHistory } from 'react-router'\n```\n\n### 2. 配置\n```javascript\n<Router history={browserHistory}>\n\t<Route path=\"/\" component={Home}></Route>\n\t<Route path=\"article\" component={Article}></Route>\n</Router>\n```\n\n### 3. 通过Link实现跳转\n```javascript\n<Link to=\"/about\">About</Link>\n```\n\n### 4.1 路由嵌套(公用导航)\n```javascript\n// 路由配置\n<Router history={hashHistory}>\n  <Route path=\"/\" component={App}>\n    <Route path=\"/repos\" component={Repos}/>\n    <Route path=\"/about\" component={About}/>\n  </Route>\n</Router>\n// 页面配置(通过this.props.children调用)\n{this.props.children}\n```\n\n### 4.2 Active Links\n```javascript\n// 活动样式\n<Link to=\"/about\" activeStyle={{ color: 'red' }}>About</Link>\n// 或者 活动类名\n<li><Link to=\"/about\" activeClassName=\"active\">About</Link></li>\n```\n\n### 5. 传参\n```javascript\n// 配置\n// :userName表示匹配参数\n<Route path=\"/repos/:userName/:repoName\" component={Repo}/>\n// 跳转地址\n<Link to=\"/repos/reactjs/react-router\">React Router</Link>\n// 页面中访问参数\n{this.props.params.repoName}\n```\n\n### 6. 嵌套路由下的默认页\n```javascript\n// 需要引入react-router下的{IndexRoute}\n<Router history={hashHistory}>\n  <Route path=\"/\" component={App}>\n\n    {/* add it here, as a child of `/` */}\n    <IndexRoute component={Home}/>\n\n    <Route path=\"/repos\" component={Repos}>\n      <Route path=\"/repos/:userName/:repoName\" component={Repo}/>\n    </Route>\n    <Route path=\"/about\" component={About}/>\n  </Route>\n</Router>\n```\n\n### 7. 首页(默认页)路由地址\n```javascript\n// 直接使用Link to=\"/\"，会导致该链接总是active状态\n<Link to=\"/\"></Link>\n// 引入react-router下的{IndexLink}\n<IndexLink to=\"/\"></IndexLink>\n// 还可以使用属性 onlyActiveOnIndex\n<Link to=\"/\" activeClassName=\"active\" onlyActiveOnIndex={true}>Home</Link>\n```\n### 8. 更好的地址browserHistory\n```javascript\n// 引入\nimport { browserHistory } from 'react-router'\n// 配置\n<Router history={browserHistory}>\n  {/* ... */}\n</Router>\n// 其他方面没有变化\n```\n\n### 9. 路由跳转\n```javascript\n// 使用browserHistory\nbrowserHistory.push(path)\n// 或者使用上下文 context\n\t// 定义对象\n\tcontextType: {\n\t\trouter: React.PropTypes.object\n\t},\n\t// 调用跳转\n\tthis.context.router.push(path)\n```\n\n### 10. 路由钩子\n每个路由都有Enter和Leave钩子，触发onEnter和onLeave。\n\nps:   \n　　[阮一峰老师](http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu)  \n　　[github](https://github.com/reactjs/react-router)","slug":"React Router学习","published":1,"updated":"2017-03-22T01:28:27.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8khc000eohfki4ss30r3","content":"<h3 id=\"0-路由\"><a href=\"#0-路由\" class=\"headerlink\" title=\"0. 路由\"></a>0. 路由</h3><p>路由也就是地址，就是定义不同url访问不同页面的功能，可以实现导航、页面切换/跳转等功能。</p>\n<h3 id=\"1-引入\"><a href=\"#1-引入\" class=\"headerlink\" title=\"1. 引入\"></a>1. 引入</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; Router, Route, hashHistory &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router'</span></div></pre></td></tr></table></figure>\n<h3 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Router history=&#123;browserHistory&#125;&gt;</div><div class=\"line\">\t<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;Home&#125;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></div><div class=\"line\">\t&lt;Route path=<span class=\"string\">\"article\"</span> component=&#123;Article&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></div><div class=\"line\">&lt;<span class=\"regexp\">/Router&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"3-通过Link实现跳转\"><a href=\"#3-通过Link实现跳转\" class=\"headerlink\" title=\"3. 通过Link实现跳转\"></a>3. 通过Link实现跳转</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Link to=<span class=\"string\">\"/about\"</span>&gt;About&lt;<span class=\"regexp\">/Link&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-1-路由嵌套-公用导航\"><a href=\"#4-1-路由嵌套-公用导航\" class=\"headerlink\" title=\"4.1 路由嵌套(公用导航)\"></a>4.1 路由嵌套(公用导航)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 路由配置</span></div><div class=\"line\">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;App&#125;</span>&gt;</span></span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/repos\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;Repos&#125;/</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/about\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;About&#125;/</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></div><div class=\"line\">// 页面配置(通过this.props.children调用)</div><div class=\"line\">&#123;this.props.children&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-2-Active-Links\"><a href=\"#4-2-Active-Links\" class=\"headerlink\" title=\"4.2 Active Links\"></a>4.2 Active Links</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 活动样式</div><div class=\"line\">&lt;Link to=\"/about\" activeStyle=&#123;&#123; color: 'red' &#125;&#125;&gt;About&lt;/Link&gt;</div><div class=\"line\">// 或者 活动类名</div><div class=\"line\">&lt;li&gt;&lt;Link to=\"/about\" activeClassName=\"active\"&gt;About&lt;/Link&gt;&lt;/li&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"5-传参\"><a href=\"#5-传参\" class=\"headerlink\" title=\"5. 传参\"></a>5. 传参</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 配置</div><div class=\"line\">// :userName表示匹配参数</div><div class=\"line\">&lt;Route path=\"/repos/:userName/:repoName\" component=&#123;Repo&#125;/&gt;</div><div class=\"line\">// 跳转地址</div><div class=\"line\">&lt;Link to=\"/repos/reactjs/react-router\"&gt;React Router&lt;/Link&gt;</div><div class=\"line\">// 页面中访问参数</div><div class=\"line\">&#123;this.props.params.repoName&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"6-嵌套路由下的默认页\"><a href=\"#6-嵌套路由下的默认页\" class=\"headerlink\" title=\"6. 嵌套路由下的默认页\"></a>6. 嵌套路由下的默认页</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 需要引入react-router下的&#123;IndexRoute&#125;</span></div><div class=\"line\">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class=\"line\">  &lt;Route path=\"/\" component=&#123;App&#125;&gt;</div><div class=\"line\"></div><div class=\"line\">    &#123;/* add it here, as a child of `/` */&#125;</div><div class=\"line\">    &lt;IndexRoute component=&#123;Home&#125;/&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;Route path=\"/repos\" component=&#123;Repos&#125;&gt;</div><div class=\"line\">      &lt;Route path=\"/repos/:userName/:repoName\" component=&#123;Repo&#125;/&gt;</div><div class=\"line\">    &lt;/Route&gt;</div><div class=\"line\">    &lt;Route path=\"/about\" component=&#123;About&#125;/&gt;</div><div class=\"line\">  &lt;/Route&gt;</div><div class=\"line\">&lt;/Router&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"7-首页-默认页-路由地址\"><a href=\"#7-首页-默认页-路由地址\" class=\"headerlink\" title=\"7. 首页(默认页)路由地址\"></a>7. 首页(默认页)路由地址</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 直接使用Link to=\"/\"，会导致该链接总是active状态</span></div><div class=\"line\">&lt;Link to=<span class=\"string\">\"/\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></div><div class=\"line\"><span class=\"comment\">// 引入react-router下的&#123;IndexLink&#125;</span></div><div class=\"line\">&lt;IndexLink to=<span class=\"string\">\"/\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">IndexLink</span>&gt;</span></span></div><div class=\"line\"><span class=\"comment\">// 还可以使用属性 onlyActiveOnIndex</span></div><div class=\"line\">&lt;Link to=<span class=\"string\">\"/\"</span> activeClassName=<span class=\"string\">\"active\"</span> onlyActiveOnIndex=&#123;<span class=\"literal\">true</span>&#125;&gt;Home&lt;<span class=\"regexp\">/Link&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"8-更好的地址browserHistory\"><a href=\"#8-更好的地址browserHistory\" class=\"headerlink\" title=\"8. 更好的地址browserHistory\"></a>8. 更好的地址browserHistory</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 引入</div><div class=\"line\">import &#123; browserHistory &#125; from 'react-router'</div><div class=\"line\">// 配置</div><div class=\"line\">&lt;Router history=&#123;browserHistory&#125;&gt;</div><div class=\"line\">  &#123;/* ... */&#125;</div><div class=\"line\">&lt;/Router&gt;</div><div class=\"line\">// 其他方面没有变化</div></pre></td></tr></table></figure>\n<h3 id=\"9-路由跳转\"><a href=\"#9-路由跳转\" class=\"headerlink\" title=\"9. 路由跳转\"></a>9. 路由跳转</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 使用browserHistory</span></div><div class=\"line\">browserHistory.push(path)</div><div class=\"line\"><span class=\"comment\">// 或者使用上下文 context</span></div><div class=\"line\">\t<span class=\"comment\">// 定义对象</span></div><div class=\"line\">\tcontextType: &#123;</div><div class=\"line\">\t\t<span class=\"attr\">router</span>: React.PropTypes.object</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">// 调用跳转</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.context.router.push(path)</div></pre></td></tr></table></figure>\n<h3 id=\"10-路由钩子\"><a href=\"#10-路由钩子\" class=\"headerlink\" title=\"10. 路由钩子\"></a>10. 路由钩子</h3><p>每个路由都有Enter和Leave钩子，触发onEnter和onLeave。</p>\n<p>ps:<br>　　<a href=\"http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu\" target=\"_blank\" rel=\"external\">阮一峰老师</a><br>　　<a href=\"https://github.com/reactjs/react-router\" target=\"_blank\" rel=\"external\">github</a></p>\n","excerpt":"","more":"<h3 id=\"0-路由\"><a href=\"#0-路由\" class=\"headerlink\" title=\"0. 路由\"></a>0. 路由</h3><p>路由也就是地址，就是定义不同url访问不同页面的功能，可以实现导航、页面切换/跳转等功能。</p>\n<h3 id=\"1-引入\"><a href=\"#1-引入\" class=\"headerlink\" title=\"1. 引入\"></a>1. 引入</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; Router, Route, hashHistory &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router'</span></div></pre></td></tr></table></figure>\n<h3 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Router history=&#123;browserHistory&#125;&gt;</div><div class=\"line\">\t<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;Home&#125;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></div><div class=\"line\">\t&lt;Route path=<span class=\"string\">\"article\"</span> component=&#123;Article&#125;&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></span></div><div class=\"line\">&lt;<span class=\"regexp\">/Router&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"3-通过Link实现跳转\"><a href=\"#3-通过Link实现跳转\" class=\"headerlink\" title=\"3. 通过Link实现跳转\"></a>3. 通过Link实现跳转</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Link to=<span class=\"string\">\"/about\"</span>&gt;About&lt;<span class=\"regexp\">/Link&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-1-路由嵌套-公用导航\"><a href=\"#4-1-路由嵌套-公用导航\" class=\"headerlink\" title=\"4.1 路由嵌套(公用导航)\"></a>4.1 路由嵌套(公用导航)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 路由配置</span></div><div class=\"line\">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;App&#125;</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/repos\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;Repos&#125;/</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/about\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;About&#125;/</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">Route</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></div><div class=\"line\">// 页面配置(通过this.props.children调用)</div><div class=\"line\">&#123;this.props.children&#125;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-2-Active-Links\"><a href=\"#4-2-Active-Links\" class=\"headerlink\" title=\"4.2 Active Links\"></a>4.2 Active Links</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 活动样式</div><div class=\"line\">&lt;Link to=\"/about\" activeStyle=&#123;&#123; color: 'red' &#125;&#125;&gt;About&lt;/Link&gt;</div><div class=\"line\">// 或者 活动类名</div><div class=\"line\">&lt;li&gt;&lt;Link to=\"/about\" activeClassName=\"active\"&gt;About&lt;/Link&gt;&lt;/li&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"5-传参\"><a href=\"#5-传参\" class=\"headerlink\" title=\"5. 传参\"></a>5. 传参</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 配置</div><div class=\"line\">// :userName表示匹配参数</div><div class=\"line\">&lt;Route path=\"/repos/:userName/:repoName\" component=&#123;Repo&#125;/&gt;</div><div class=\"line\">// 跳转地址</div><div class=\"line\">&lt;Link to=\"/repos/reactjs/react-router\"&gt;React Router&lt;/Link&gt;</div><div class=\"line\">// 页面中访问参数</div><div class=\"line\">&#123;this.props.params.repoName&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"6-嵌套路由下的默认页\"><a href=\"#6-嵌套路由下的默认页\" class=\"headerlink\" title=\"6. 嵌套路由下的默认页\"></a>6. 嵌套路由下的默认页</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 需要引入react-router下的&#123;IndexRoute&#125;</span></div><div class=\"line\">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class=\"line\">  &lt;Route path=\"/\" component=&#123;App&#125;&gt;</div><div class=\"line\"></div><div class=\"line\">    &#123;/* add it here, as a child of `/` */&#125;</div><div class=\"line\">    &lt;IndexRoute component=&#123;Home&#125;/&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;Route path=\"/repos\" component=&#123;Repos&#125;&gt;</div><div class=\"line\">      &lt;Route path=\"/repos/:userName/:repoName\" component=&#123;Repo&#125;/&gt;</div><div class=\"line\">    &lt;/Route&gt;</div><div class=\"line\">    &lt;Route path=\"/about\" component=&#123;About&#125;/&gt;</div><div class=\"line\">  &lt;/Route&gt;</div><div class=\"line\">&lt;/Router&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"7-首页-默认页-路由地址\"><a href=\"#7-首页-默认页-路由地址\" class=\"headerlink\" title=\"7. 首页(默认页)路由地址\"></a>7. 首页(默认页)路由地址</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 直接使用Link to=\"/\"，会导致该链接总是active状态</span></div><div class=\"line\">&lt;Link to=<span class=\"string\">\"/\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></div><div class=\"line\"><span class=\"comment\">// 引入react-router下的&#123;IndexLink&#125;</span></div><div class=\"line\">&lt;IndexLink to=<span class=\"string\">\"/\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">IndexLink</span>&gt;</span></span></div><div class=\"line\"><span class=\"comment\">// 还可以使用属性 onlyActiveOnIndex</span></div><div class=\"line\">&lt;Link to=<span class=\"string\">\"/\"</span> activeClassName=<span class=\"string\">\"active\"</span> onlyActiveOnIndex=&#123;<span class=\"literal\">true</span>&#125;&gt;Home&lt;<span class=\"regexp\">/Link&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"8-更好的地址browserHistory\"><a href=\"#8-更好的地址browserHistory\" class=\"headerlink\" title=\"8. 更好的地址browserHistory\"></a>8. 更好的地址browserHistory</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 引入</div><div class=\"line\">import &#123; browserHistory &#125; from 'react-router'</div><div class=\"line\">// 配置</div><div class=\"line\">&lt;Router history=&#123;browserHistory&#125;&gt;</div><div class=\"line\">  &#123;/* ... */&#125;</div><div class=\"line\">&lt;/Router&gt;</div><div class=\"line\">// 其他方面没有变化</div></pre></td></tr></table></figure>\n<h3 id=\"9-路由跳转\"><a href=\"#9-路由跳转\" class=\"headerlink\" title=\"9. 路由跳转\"></a>9. 路由跳转</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 使用browserHistory</span></div><div class=\"line\">browserHistory.push(path)</div><div class=\"line\"><span class=\"comment\">// 或者使用上下文 context</span></div><div class=\"line\">\t<span class=\"comment\">// 定义对象</span></div><div class=\"line\">\tcontextType: &#123;</div><div class=\"line\">\t\t<span class=\"attr\">router</span>: React.PropTypes.object</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">// 调用跳转</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.context.router.push(path)</div></pre></td></tr></table></figure>\n<h3 id=\"10-路由钩子\"><a href=\"#10-路由钩子\" class=\"headerlink\" title=\"10. 路由钩子\"></a>10. 路由钩子</h3><p>每个路由都有Enter和Leave钩子，触发onEnter和onLeave。</p>\n<p>ps:<br>　　<a href=\"http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu\">阮一峰老师</a><br>　　<a href=\"https://github.com/reactjs/react-router\">github</a></p>\n"},{"title":"dva中的handleAction","date":"2017-03-20T16:00:00.000Z","comments":1,"_content":"\nDva是支付宝基于React、redux、redux-saga和react-router的轻量级框架，代码不多，主要是实现了一些现有应用的一层封装，使得编写React应用编写更清晰方便。  \n最近在学习使用Dva，主要学习了之前没有接触redux-saga的使用，熟悉了Dva的项目结构和开发流程。这两天试着看了下源码，又被虐得不要不要的。\n\n在Dva中有个handleActions.js，只有三十行代码，三个函数，却是困扰我半天。只能说自己还是太菜、太初级。\n\n从文件名handleActions显然是处理redux中的actions的，redux中通过触发action来执行reducer（就是将action传递给reducer），返回新的state以实现页面的更新。\n\n出口函数handleActions是这样的\n```javascript\nfunction handleActions(handlers, defaultState) {\n  const reducers = Object.keys(handlers).map(type => handleAction(type, handlers[type]));\n  const reducer = reduceReducers(...reducers);\n  return (state = defaultState, action) => reducer(state, action);\n}\n```\n参数handlers、defaultState分别表示处理函数和默认state。从使用方法和函数中的定义可以看出handlers和defaultState都是对象。  \n第一句，Object.keys(handlers).map用于对对象的循环，虽然看到Object.keys能够知道是什么作用，但是自己在编写代码时会忘记该方法而使用for...in，for...in循环包括原型链上的属性显然要差些。接着调用了handleAction，传入了type（也就是key）以及处理函数handlers[type]。\n```javascript\nfunction handleAction(actionType, reducer = identify) {\n  return (state, action) => {\n    const { type } = action;\n    if (type && actionType !== type) {\n      return state;\n    }\n    return reducer(state, action);\n  };\n}\n```\nhandleAction接受参数actionType和reducer，reducer默认值是一个直接返回原参数的函数。最后返回的是一个函数，函数中使用了actionType以及reducer，这属于闭包的应用。这个函数如果使用的话是这样的`handleAction(actionType, reducer)(state, action)`，<del>这个应该属于函数的柯里化，对柯里化看了一些资料，但是依然一知半解，这里使用柯里化的目的应该是保存变量actionType和reducer</del>(柯里化应该是单个参数，之前理解有误)。\n\n回到handleActions函数中，reducers最后就被保存为了元素是下面这样函数的数组，其中的actionType和reducer是通过闭包保存不同的内容的。\n```javascript\n(state, action) => {\n  const { type } = action;\n  if (type && actionType !== type) {\n    return state;\n  }\n  return reducer(state, action);\n}\n```\n\n第二句执行函数reduceReducers\n```javascript\nfunction reduceReducers(...reducers) {\n  return (previous, current) =>\n    reducers.reduce(\n      (p, r) => r(p, current),\n      previous,\n    );\n}\n```\n同样又是返回一个函数保存到reducer中，reducer这个函数中通过闭包保存了函数数组reducers。\n\n第三句是return，返回值依然是一个函数。函数中调用reducer，并且传参state和action。  \n这样我们可以知道reducer函数中previous表示的state，current表示action。  \n然后通过reducers.reduce循环执行所有的reducers，传参为state和action。然后在handleAction返回参数中，根据action.type和之前保存的actionType比较决定是否执行之前保存的reducer来处理state。如果type不同，不对state进行处理直接返回。\n\n功能并不是特别复杂，相当于reduceReducers对reducers进行循环，handleAction对action进行判断。主要困扰集中在了对reduce使用上的不熟悉，柯里化的复杂，闭包的实际应用等。\n\n","source":"_posts/dva中的handleAction.md","raw":"---\ntitle: dva中的handleAction\ndate: 2017-03-21\ntags: [JavaScript, React]\ncategories: \n- React\ncomments: true\n---\n\nDva是支付宝基于React、redux、redux-saga和react-router的轻量级框架，代码不多，主要是实现了一些现有应用的一层封装，使得编写React应用编写更清晰方便。  \n最近在学习使用Dva，主要学习了之前没有接触redux-saga的使用，熟悉了Dva的项目结构和开发流程。这两天试着看了下源码，又被虐得不要不要的。\n\n在Dva中有个handleActions.js，只有三十行代码，三个函数，却是困扰我半天。只能说自己还是太菜、太初级。\n\n从文件名handleActions显然是处理redux中的actions的，redux中通过触发action来执行reducer（就是将action传递给reducer），返回新的state以实现页面的更新。\n\n出口函数handleActions是这样的\n```javascript\nfunction handleActions(handlers, defaultState) {\n  const reducers = Object.keys(handlers).map(type => handleAction(type, handlers[type]));\n  const reducer = reduceReducers(...reducers);\n  return (state = defaultState, action) => reducer(state, action);\n}\n```\n参数handlers、defaultState分别表示处理函数和默认state。从使用方法和函数中的定义可以看出handlers和defaultState都是对象。  \n第一句，Object.keys(handlers).map用于对对象的循环，虽然看到Object.keys能够知道是什么作用，但是自己在编写代码时会忘记该方法而使用for...in，for...in循环包括原型链上的属性显然要差些。接着调用了handleAction，传入了type（也就是key）以及处理函数handlers[type]。\n```javascript\nfunction handleAction(actionType, reducer = identify) {\n  return (state, action) => {\n    const { type } = action;\n    if (type && actionType !== type) {\n      return state;\n    }\n    return reducer(state, action);\n  };\n}\n```\nhandleAction接受参数actionType和reducer，reducer默认值是一个直接返回原参数的函数。最后返回的是一个函数，函数中使用了actionType以及reducer，这属于闭包的应用。这个函数如果使用的话是这样的`handleAction(actionType, reducer)(state, action)`，<del>这个应该属于函数的柯里化，对柯里化看了一些资料，但是依然一知半解，这里使用柯里化的目的应该是保存变量actionType和reducer</del>(柯里化应该是单个参数，之前理解有误)。\n\n回到handleActions函数中，reducers最后就被保存为了元素是下面这样函数的数组，其中的actionType和reducer是通过闭包保存不同的内容的。\n```javascript\n(state, action) => {\n  const { type } = action;\n  if (type && actionType !== type) {\n    return state;\n  }\n  return reducer(state, action);\n}\n```\n\n第二句执行函数reduceReducers\n```javascript\nfunction reduceReducers(...reducers) {\n  return (previous, current) =>\n    reducers.reduce(\n      (p, r) => r(p, current),\n      previous,\n    );\n}\n```\n同样又是返回一个函数保存到reducer中，reducer这个函数中通过闭包保存了函数数组reducers。\n\n第三句是return，返回值依然是一个函数。函数中调用reducer，并且传参state和action。  \n这样我们可以知道reducer函数中previous表示的state，current表示action。  \n然后通过reducers.reduce循环执行所有的reducers，传参为state和action。然后在handleAction返回参数中，根据action.type和之前保存的actionType比较决定是否执行之前保存的reducer来处理state。如果type不同，不对state进行处理直接返回。\n\n功能并不是特别复杂，相当于reduceReducers对reducers进行循环，handleAction对action进行判断。主要困扰集中在了对reduce使用上的不熟悉，柯里化的复杂，闭包的实际应用等。\n\n","slug":"dva中的handleAction","published":1,"updated":"2017-03-22T01:33:51.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8khe000gohfkuk2kdkyp","content":"<p>Dva是支付宝基于React、redux、redux-saga和react-router的轻量级框架，代码不多，主要是实现了一些现有应用的一层封装，使得编写React应用编写更清晰方便。<br>最近在学习使用Dva，主要学习了之前没有接触redux-saga的使用，熟悉了Dva的项目结构和开发流程。这两天试着看了下源码，又被虐得不要不要的。</p>\n<p>在Dva中有个handleActions.js，只有三十行代码，三个函数，却是困扰我半天。只能说自己还是太菜、太初级。</p>\n<p>从文件名handleActions显然是处理redux中的actions的，redux中通过触发action来执行reducer（就是将action传递给reducer），返回新的state以实现页面的更新。</p>\n<p>出口函数handleActions是这样的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleActions</span>(<span class=\"params\">handlers, defaultState</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> reducers = <span class=\"built_in\">Object</span>.keys(handlers).map(<span class=\"function\"><span class=\"params\">type</span> =&gt;</span> handleAction(type, handlers[type]));</div><div class=\"line\">  <span class=\"keyword\">const</span> reducer = reduceReducers(...reducers);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">state = defaultState, action</span>) =&gt;</span> reducer(state, action);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>参数handlers、defaultState分别表示处理函数和默认state。从使用方法和函数中的定义可以看出handlers和defaultState都是对象。<br>第一句，Object.keys(handlers).map用于对对象的循环，虽然看到Object.keys能够知道是什么作用，但是自己在编写代码时会忘记该方法而使用for…in，for…in循环包括原型链上的属性显然要差些。接着调用了handleAction，传入了type（也就是key）以及处理函数handlers[type]。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleAction</span>(<span class=\"params\">actionType, reducer = identify</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">state, action</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> &#123; type &#125; = action;</div><div class=\"line\">    <span class=\"keyword\">if</span> (type &amp;&amp; actionType !== type) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> state;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> reducer(state, action);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>handleAction接受参数actionType和reducer，reducer默认值是一个直接返回原参数的函数。最后返回的是一个函数，函数中使用了actionType以及reducer，这属于闭包的应用。这个函数如果使用的话是这样的<code>handleAction(actionType, reducer)(state, action)</code>，<del>这个应该属于函数的柯里化，对柯里化看了一些资料，但是依然一知半解，这里使用柯里化的目的应该是保存变量actionType和reducer</del>(柯里化应该是单个参数，之前理解有误)。</p>\n<p>回到handleActions函数中，reducers最后就被保存为了元素是下面这样函数的数组，其中的actionType和reducer是通过闭包保存不同的内容的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(state, action) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> &#123; type &#125; = action;</div><div class=\"line\">  <span class=\"keyword\">if</span> (type &amp;&amp; actionType !== type) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> state;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> reducer(state, action);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>第二句执行函数reduceReducers<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reduceReducers</span>(<span class=\"params\">...reducers</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">previous, current</span>) =&gt;</span></div><div class=\"line\">    reducers.reduce(</div><div class=\"line\">      <span class=\"function\">(<span class=\"params\">p, r</span>) =&gt;</span> r(p, current),</div><div class=\"line\">      previous,</div><div class=\"line\">    );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>同样又是返回一个函数保存到reducer中，reducer这个函数中通过闭包保存了函数数组reducers。</p>\n<p>第三句是return，返回值依然是一个函数。函数中调用reducer，并且传参state和action。<br>这样我们可以知道reducer函数中previous表示的state，current表示action。<br>然后通过reducers.reduce循环执行所有的reducers，传参为state和action。然后在handleAction返回参数中，根据action.type和之前保存的actionType比较决定是否执行之前保存的reducer来处理state。如果type不同，不对state进行处理直接返回。</p>\n<p>功能并不是特别复杂，相当于reduceReducers对reducers进行循环，handleAction对action进行判断。主要困扰集中在了对reduce使用上的不熟悉，柯里化的复杂，闭包的实际应用等。</p>\n","excerpt":"","more":"<p>Dva是支付宝基于React、redux、redux-saga和react-router的轻量级框架，代码不多，主要是实现了一些现有应用的一层封装，使得编写React应用编写更清晰方便。<br>最近在学习使用Dva，主要学习了之前没有接触redux-saga的使用，熟悉了Dva的项目结构和开发流程。这两天试着看了下源码，又被虐得不要不要的。</p>\n<p>在Dva中有个handleActions.js，只有三十行代码，三个函数，却是困扰我半天。只能说自己还是太菜、太初级。</p>\n<p>从文件名handleActions显然是处理redux中的actions的，redux中通过触发action来执行reducer（就是将action传递给reducer），返回新的state以实现页面的更新。</p>\n<p>出口函数handleActions是这样的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleActions</span>(<span class=\"params\">handlers, defaultState</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> reducers = <span class=\"built_in\">Object</span>.keys(handlers).map(<span class=\"function\"><span class=\"params\">type</span> =&gt;</span> handleAction(type, handlers[type]));</div><div class=\"line\">  <span class=\"keyword\">const</span> reducer = reduceReducers(...reducers);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">state = defaultState, action</span>) =&gt;</span> reducer(state, action);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>参数handlers、defaultState分别表示处理函数和默认state。从使用方法和函数中的定义可以看出handlers和defaultState都是对象。<br>第一句，Object.keys(handlers).map用于对对象的循环，虽然看到Object.keys能够知道是什么作用，但是自己在编写代码时会忘记该方法而使用for…in，for…in循环包括原型链上的属性显然要差些。接着调用了handleAction，传入了type（也就是key）以及处理函数handlers[type]。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleAction</span>(<span class=\"params\">actionType, reducer = identify</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">state, action</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> &#123; type &#125; = action;</div><div class=\"line\">    <span class=\"keyword\">if</span> (type &amp;&amp; actionType !== type) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> state;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> reducer(state, action);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>handleAction接受参数actionType和reducer，reducer默认值是一个直接返回原参数的函数。最后返回的是一个函数，函数中使用了actionType以及reducer，这属于闭包的应用。这个函数如果使用的话是这样的<code>handleAction(actionType, reducer)(state, action)</code>，<del>这个应该属于函数的柯里化，对柯里化看了一些资料，但是依然一知半解，这里使用柯里化的目的应该是保存变量actionType和reducer</del>(柯里化应该是单个参数，之前理解有误)。</p>\n<p>回到handleActions函数中，reducers最后就被保存为了元素是下面这样函数的数组，其中的actionType和reducer是通过闭包保存不同的内容的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(state, action) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> &#123; type &#125; = action;</div><div class=\"line\">  <span class=\"keyword\">if</span> (type &amp;&amp; actionType !== type) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> state;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> reducer(state, action);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>第二句执行函数reduceReducers<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reduceReducers</span>(<span class=\"params\">...reducers</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">previous, current</span>) =&gt;</span></div><div class=\"line\">    reducers.reduce(</div><div class=\"line\">      <span class=\"function\">(<span class=\"params\">p, r</span>) =&gt;</span> r(p, current),</div><div class=\"line\">      previous,</div><div class=\"line\">    );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>同样又是返回一个函数保存到reducer中，reducer这个函数中通过闭包保存了函数数组reducers。</p>\n<p>第三句是return，返回值依然是一个函数。函数中调用reducer，并且传参state和action。<br>这样我们可以知道reducer函数中previous表示的state，current表示action。<br>然后通过reducers.reduce循环执行所有的reducers，传参为state和action。然后在handleAction返回参数中，根据action.type和之前保存的actionType比较决定是否执行之前保存的reducer来处理state。如果type不同，不对state进行处理直接返回。</p>\n<p>功能并不是特别复杂，相当于reduceReducers对reducers进行循环，handleAction对action进行判断。主要困扰集中在了对reduce使用上的不熟悉，柯里化的复杂，闭包的实际应用等。</p>\n"},{"title":"fixed移动端解决","date":"2016-07-28T16:00:00.000Z","comments":1,"_content":"\nFrom [here](http://efe.baidu.com/blog/mobile-fixed-layout/)\n\n### fixed移动端解决\n\n主要是IOS上的。\n\n\t思路：滚动内容在标签中，固定标签的位置。\n\n1. 将所有非fixed定位的，也就是需要滚动的元素用block标签包裹。\n2. fixed定位的元素给fixed或者absolute都可以。\n3. 包裹标签绝对定位在fixed和边界中间，`overflow-y: scroll`。\n4. 标签内滚动不流畅，给包裹标签增加`-webkit-overflow-scrolling: touch;`\n\n```html\n<body class=\"layout-scroll-fixed\">\n    <!-- fixed定位的头部 -->\n    <header>\n        \n    </header>\n    \n    <!-- 可以滚动的区域 -->\n    <main>\n        <div class=\"content\">\n        <!-- 内容在这里... -->\n        </div>\n    </main>\n    \n    <!-- fixed定位的底部 -->\n    <footer>\n        <input type=\"text\" placeholder=\"Footer...\"/>\n        <button class=\"submit\">提交</button>\n    </footer>\n</body>\n```\n\n```css\nheader, footer, main {\n    display: block;\n}\n\nheader {\n    position: fixed;  /* fixed、absolute都可以 */\n    height: 50px;\n    left: 0;\n    right: 0;\n    top: 0;\n}\n\nfooter {\n    position: fixed;\n    height: 34px;\n    left: 0;\n    right: 0;\n    bottom: 0;\n}\n\nmain {\n    /* main绝对定位，进行内部滚动 */\n    position: absolute;\n    top: 50px;\n    bottom: 34px;\n    /* 使之可以滚动 */\n    overflow-y: scroll;\n    /* 增加该属性，可以增加弹性 */\n    -webkit-overflow-scrolling: touch;\n}\n\nmain .content {\n    height: 2000px;\n}\n```\n\nFrom [here](http://imweb.io/topic/577e64a47c99347163ec0b10)\n\n### 图片高度占位\n给图片提供一个容器，设置高度为0，根据图片比例使用padding-top设置百分值。\n```css\n.img-wrap{\n    position: relative;\n    height: 0;\n    padding-top: 50%；// 图片宽度的一半\n}\n.img{\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n```","source":"_posts/fixed移动端解决.md","raw":"---\ntitle: fixed移动端解决\ndate: 2016-07-29\ntags: [JavaScript, 移动Web]\ncategories: \n- JavaScript\ncomments: true\n---\n\nFrom [here](http://efe.baidu.com/blog/mobile-fixed-layout/)\n\n### fixed移动端解决\n\n主要是IOS上的。\n\n\t思路：滚动内容在标签中，固定标签的位置。\n\n1. 将所有非fixed定位的，也就是需要滚动的元素用block标签包裹。\n2. fixed定位的元素给fixed或者absolute都可以。\n3. 包裹标签绝对定位在fixed和边界中间，`overflow-y: scroll`。\n4. 标签内滚动不流畅，给包裹标签增加`-webkit-overflow-scrolling: touch;`\n\n```html\n<body class=\"layout-scroll-fixed\">\n    <!-- fixed定位的头部 -->\n    <header>\n        \n    </header>\n    \n    <!-- 可以滚动的区域 -->\n    <main>\n        <div class=\"content\">\n        <!-- 内容在这里... -->\n        </div>\n    </main>\n    \n    <!-- fixed定位的底部 -->\n    <footer>\n        <input type=\"text\" placeholder=\"Footer...\"/>\n        <button class=\"submit\">提交</button>\n    </footer>\n</body>\n```\n\n```css\nheader, footer, main {\n    display: block;\n}\n\nheader {\n    position: fixed;  /* fixed、absolute都可以 */\n    height: 50px;\n    left: 0;\n    right: 0;\n    top: 0;\n}\n\nfooter {\n    position: fixed;\n    height: 34px;\n    left: 0;\n    right: 0;\n    bottom: 0;\n}\n\nmain {\n    /* main绝对定位，进行内部滚动 */\n    position: absolute;\n    top: 50px;\n    bottom: 34px;\n    /* 使之可以滚动 */\n    overflow-y: scroll;\n    /* 增加该属性，可以增加弹性 */\n    -webkit-overflow-scrolling: touch;\n}\n\nmain .content {\n    height: 2000px;\n}\n```\n\nFrom [here](http://imweb.io/topic/577e64a47c99347163ec0b10)\n\n### 图片高度占位\n给图片提供一个容器，设置高度为0，根据图片比例使用padding-top设置百分值。\n```css\n.img-wrap{\n    position: relative;\n    height: 0;\n    padding-top: 50%；// 图片宽度的一半\n}\n.img{\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n```","slug":"fixed移动端解决","published":1,"updated":"2017-03-22T01:26:53.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8khh000johfkjmrb7r96","content":"<p>From <a href=\"http://efe.baidu.com/blog/mobile-fixed-layout/\" target=\"_blank\" rel=\"external\">here</a></p>\n<h3 id=\"fixed移动端解决\"><a href=\"#fixed移动端解决\" class=\"headerlink\" title=\"fixed移动端解决\"></a>fixed移动端解决</h3><p>主要是IOS上的。</p>\n<pre><code>思路：滚动内容在标签中，固定标签的位置。\n</code></pre><ol>\n<li>将所有非fixed定位的，也就是需要滚动的元素用block标签包裹。</li>\n<li>fixed定位的元素给fixed或者absolute都可以。</li>\n<li>包裹标签绝对定位在fixed和边界中间，<code>overflow-y: scroll</code>。</li>\n<li>标签内滚动不流畅，给包裹标签增加<code>-webkit-overflow-scrolling: touch;</code></li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">class</span>=<span class=\"string\">\"layout-scroll-fixed\"</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- fixed定位的头部 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">        </div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">&lt;!-- 可以滚动的区域 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span></div><div class=\"line\">        <span class=\"comment\">&lt;!-- 内容在这里... --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">&lt;!-- fixed定位的底部 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Footer...\"</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"submit\"</span>&gt;</span>提交<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">header</span>, <span class=\"selector-tag\">footer</span>, <span class=\"selector-tag\">main</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">display</span>: block;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">header</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">position</span>: fixed;  <span class=\"comment\">/* fixed、absolute都可以 */</span></div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">footer</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">position</span>: fixed;</div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">34px</span>;</div><div class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">main</span> &#123;</div><div class=\"line\">    <span class=\"comment\">/* main绝对定位，进行内部滚动 */</span></div><div class=\"line\">    <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">34px</span>;</div><div class=\"line\">    <span class=\"comment\">/* 使之可以滚动 */</span></div><div class=\"line\">    <span class=\"attribute\">overflow-y</span>: scroll;</div><div class=\"line\">    <span class=\"comment\">/* 增加该属性，可以增加弹性 */</span></div><div class=\"line\">    <span class=\"attribute\">-webkit-overflow-scrolling</span>: touch;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">main</span> <span class=\"selector-class\">.content</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">2000px</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>From <a href=\"http://imweb.io/topic/577e64a47c99347163ec0b10\" target=\"_blank\" rel=\"external\">here</a></p>\n<h3 id=\"图片高度占位\"><a href=\"#图片高度占位\" class=\"headerlink\" title=\"图片高度占位\"></a>图片高度占位</h3><p>给图片提供一个容器，设置高度为0，根据图片比例使用padding-top设置百分值。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.img-wrap</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">position</span>: relative;</div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">padding-top</span>: <span class=\"number\">50%</span>；// 图片宽度的一半</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.img</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>From <a href=\"http://efe.baidu.com/blog/mobile-fixed-layout/\">here</a></p>\n<h3 id=\"fixed移动端解决\"><a href=\"#fixed移动端解决\" class=\"headerlink\" title=\"fixed移动端解决\"></a>fixed移动端解决</h3><p>主要是IOS上的。</p>\n<pre><code>思路：滚动内容在标签中，固定标签的位置。\n</code></pre><ol>\n<li>将所有非fixed定位的，也就是需要滚动的元素用block标签包裹。</li>\n<li>fixed定位的元素给fixed或者absolute都可以。</li>\n<li>包裹标签绝对定位在fixed和边界中间，<code>overflow-y: scroll</code>。</li>\n<li>标签内滚动不流畅，给包裹标签增加<code>-webkit-overflow-scrolling: touch;</code></li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">class</span>=<span class=\"string\">\"layout-scroll-fixed\"</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- fixed定位的头部 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">        </div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">&lt;!-- 可以滚动的区域 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span></div><div class=\"line\">        <span class=\"comment\">&lt;!-- 内容在这里... --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">&lt;!-- fixed定位的底部 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Footer...\"</span>/&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"submit\"</span>&gt;</span>提交<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">header</span>, <span class=\"selector-tag\">footer</span>, <span class=\"selector-tag\">main</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">display</span>: block;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">header</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">position</span>: fixed;  <span class=\"comment\">/* fixed、absolute都可以 */</span></div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">footer</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">position</span>: fixed;</div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">34px</span>;</div><div class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">main</span> &#123;</div><div class=\"line\">    <span class=\"comment\">/* main绝对定位，进行内部滚动 */</span></div><div class=\"line\">    <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">34px</span>;</div><div class=\"line\">    <span class=\"comment\">/* 使之可以滚动 */</span></div><div class=\"line\">    <span class=\"attribute\">overflow-y</span>: scroll;</div><div class=\"line\">    <span class=\"comment\">/* 增加该属性，可以增加弹性 */</span></div><div class=\"line\">    <span class=\"attribute\">-webkit-overflow-scrolling</span>: touch;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">main</span> <span class=\"selector-class\">.content</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">2000px</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>From <a href=\"http://imweb.io/topic/577e64a47c99347163ec0b10\">here</a></p>\n<h3 id=\"图片高度占位\"><a href=\"#图片高度占位\" class=\"headerlink\" title=\"图片高度占位\"></a>图片高度占位</h3><p>给图片提供一个容器，设置高度为0，根据图片比例使用padding-top设置百分值。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.img-wrap</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">position</span>: relative;</div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">padding-top</span>: <span class=\"number\">50%</span>；// 图片宽度的一半</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.img</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"gulp初次实践","date":"2016-06-30T16:00:00.000Z","comments":1,"_content":"\ngulp是前端构建工具，通过一系列gulp插件，可以实现实时监控、格式化代码、合并代码、压缩代码、测试功能等功能。\n\n------\n\n前提：node环境，会使用基本命令行\n\n------\n\n### 全局安装gulp\n```\nsudo npm install -g gulp\n```\nWindows环境下不需要sudo命令\n\n### 项目搭建\n#### 第一步，包管理文件 package.json\n通过cd命令进入项目目录，执行`npm init`，之后可以一路的回车来创建`package.json`文件。关于此配置文件的内容挺简单的，可以自己看下，然后搜索下。\n#### 第二步，寻找、安装所需要的插件\n项目目录安装gulp，并写入配置文件package.json中。\n```\nnpm install --save-dev gulp\n```\n这样会把gulp的依赖写入到package.json文件中。\n\n#### 添加需要的各个gulp插件\n比如这里我用到了gulp-clean-css用于css压缩、gulp-uglify用于js压缩、gulp-watch用于文件监控、gulp-sass用于sass编译。\n安装各插件(方法相同)\n```\nnpm install --save-dev gulp-uglify\n```\n#### 第三步，配置gulp任务\n在项目目录下创建文件`gulpfile.js`，用于编写gulp任务。\ngulp基础语法比较简单，管道方式也很容易理解。\n这里我的项目目录如下：\n```\n├── dist\n│   ├── css\n│   ├── img\n│   └── js\n├── gulpfile.js\n├── index.html\n├── node_modules\n│   ├── eruda\n│   ├── gulp\n│   ├── gulp-clean-css\n│   ├── gulp-sass\n│   ├── gulp-uglify\n├── package.json\n└── src\n    ├── css\n    ├── img\n    ├── js\n    ├── libs\n    └── sass\n```\n其中src文件夹中是源文件，\ndist文件夹下是项目用到的压缩后的js、css文件。\n\ngulp任务配置文件gulpfile.js如下：\n```javascript\nvar gulp = require('gulp'),\n\t\tcleanCSS = require('gulp-clean-css'),\n\t\tuglify = require('gulp-uglify'),\n\t\twatch = require('gulp-watch'),\n\t\tsass = require('gulp-sass');\n\ngulp.task('default', function() {\n\t// 默认任务代码\n});\n\n// 压缩文件\ngulp.task('minfile', function() {\n\t// sass\n\tgulp.src('src/sass/*.scss')\n\t\t.pipe(sass())\n\t\t.pipe(gulp.dest('src/css'))\n\t\t.pipe(cleanCSS())\n\t\t.pipe(gulp.dest('dist/css'));\n\t// js\n\tgulp.src('src/js/*.js')\n\t\t.pipe(uglify())\n\t\t.pipe(gulp.dest('dist/js'));\n\t// img\n\tgulp.src('src/img/*')\n\t\t.pipe(gulp.dest('dist/img'));\n});\n\n// 监听\ngulp.task('watchFile', ['minfile'], function() {\n\tgulp.watch('src/**/*', ['minfile']);\n});\n\ngulp.task('default', ['minfile', 'watchFile']);\n```\ngulp API只有五个：task，src，dest，watch和run。\ntask用于定义任务；src用于表示源文件路径；dest用于输出，写入新文件；watch用于监听文件变化；run用于执行任务。\nps:上面的pipe表示管道。\n#### 第四步，开启任务\n项目目录下，执行`gulp`即可。之后就可以开始编写代码了。\n\n---------\n\n第一次对gulp的尝试，也是第一次对构建工具的尝试，其中只是用到了一些最简单也是最常用的插件，给我的感觉就是省去了每次手动编译、压缩等操作，这次使用就像一次Hello World。","source":"_posts/gulp初次实践.md","raw":"---\ntitle: gulp初次实践\ndate: 2016-06-31\ntags: [JavaScript, gulp, 构建工具]\ncategories: \n- JavaScript\ncomments: true\n---\n\ngulp是前端构建工具，通过一系列gulp插件，可以实现实时监控、格式化代码、合并代码、压缩代码、测试功能等功能。\n\n------\n\n前提：node环境，会使用基本命令行\n\n------\n\n### 全局安装gulp\n```\nsudo npm install -g gulp\n```\nWindows环境下不需要sudo命令\n\n### 项目搭建\n#### 第一步，包管理文件 package.json\n通过cd命令进入项目目录，执行`npm init`，之后可以一路的回车来创建`package.json`文件。关于此配置文件的内容挺简单的，可以自己看下，然后搜索下。\n#### 第二步，寻找、安装所需要的插件\n项目目录安装gulp，并写入配置文件package.json中。\n```\nnpm install --save-dev gulp\n```\n这样会把gulp的依赖写入到package.json文件中。\n\n#### 添加需要的各个gulp插件\n比如这里我用到了gulp-clean-css用于css压缩、gulp-uglify用于js压缩、gulp-watch用于文件监控、gulp-sass用于sass编译。\n安装各插件(方法相同)\n```\nnpm install --save-dev gulp-uglify\n```\n#### 第三步，配置gulp任务\n在项目目录下创建文件`gulpfile.js`，用于编写gulp任务。\ngulp基础语法比较简单，管道方式也很容易理解。\n这里我的项目目录如下：\n```\n├── dist\n│   ├── css\n│   ├── img\n│   └── js\n├── gulpfile.js\n├── index.html\n├── node_modules\n│   ├── eruda\n│   ├── gulp\n│   ├── gulp-clean-css\n│   ├── gulp-sass\n│   ├── gulp-uglify\n├── package.json\n└── src\n    ├── css\n    ├── img\n    ├── js\n    ├── libs\n    └── sass\n```\n其中src文件夹中是源文件，\ndist文件夹下是项目用到的压缩后的js、css文件。\n\ngulp任务配置文件gulpfile.js如下：\n```javascript\nvar gulp = require('gulp'),\n\t\tcleanCSS = require('gulp-clean-css'),\n\t\tuglify = require('gulp-uglify'),\n\t\twatch = require('gulp-watch'),\n\t\tsass = require('gulp-sass');\n\ngulp.task('default', function() {\n\t// 默认任务代码\n});\n\n// 压缩文件\ngulp.task('minfile', function() {\n\t// sass\n\tgulp.src('src/sass/*.scss')\n\t\t.pipe(sass())\n\t\t.pipe(gulp.dest('src/css'))\n\t\t.pipe(cleanCSS())\n\t\t.pipe(gulp.dest('dist/css'));\n\t// js\n\tgulp.src('src/js/*.js')\n\t\t.pipe(uglify())\n\t\t.pipe(gulp.dest('dist/js'));\n\t// img\n\tgulp.src('src/img/*')\n\t\t.pipe(gulp.dest('dist/img'));\n});\n\n// 监听\ngulp.task('watchFile', ['minfile'], function() {\n\tgulp.watch('src/**/*', ['minfile']);\n});\n\ngulp.task('default', ['minfile', 'watchFile']);\n```\ngulp API只有五个：task，src，dest，watch和run。\ntask用于定义任务；src用于表示源文件路径；dest用于输出，写入新文件；watch用于监听文件变化；run用于执行任务。\nps:上面的pipe表示管道。\n#### 第四步，开启任务\n项目目录下，执行`gulp`即可。之后就可以开始编写代码了。\n\n---------\n\n第一次对gulp的尝试，也是第一次对构建工具的尝试，其中只是用到了一些最简单也是最常用的插件，给我的感觉就是省去了每次手动编译、压缩等操作，这次使用就像一次Hello World。","slug":"gulp初次实践","published":1,"updated":"2017-03-22T01:27:27.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8khj000mohfkmzcpx4pa","content":"<p>gulp是前端构建工具，通过一系列gulp插件，可以实现实时监控、格式化代码、合并代码、压缩代码、测试功能等功能。</p>\n<hr>\n<p>前提：node环境，会使用基本命令行</p>\n<hr>\n<h3 id=\"全局安装gulp\"><a href=\"#全局安装gulp\" class=\"headerlink\" title=\"全局安装gulp\"></a>全局安装gulp</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo npm <span class=\"keyword\">install</span> -g gulp</div></pre></td></tr></table></figure>\n<p>Windows环境下不需要sudo命令</p>\n<h3 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h3><h4 id=\"第一步，包管理文件-package-json\"><a href=\"#第一步，包管理文件-package-json\" class=\"headerlink\" title=\"第一步，包管理文件 package.json\"></a>第一步，包管理文件 package.json</h4><p>通过cd命令进入项目目录，执行<code>npm init</code>，之后可以一路的回车来创建<code>package.json</code>文件。关于此配置文件的内容挺简单的，可以自己看下，然后搜索下。</p>\n<h4 id=\"第二步，寻找、安装所需要的插件\"><a href=\"#第二步，寻找、安装所需要的插件\" class=\"headerlink\" title=\"第二步，寻找、安装所需要的插件\"></a>第二步，寻找、安装所需要的插件</h4><p>项目目录安装gulp，并写入配置文件package.json中。<br><figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install --<span class=\"built_in\">save</span>-<span class=\"built_in\">dev</span> gulp</div></pre></td></tr></table></figure></p>\n<p>这样会把gulp的依赖写入到package.json文件中。</p>\n<h4 id=\"添加需要的各个gulp插件\"><a href=\"#添加需要的各个gulp插件\" class=\"headerlink\" title=\"添加需要的各个gulp插件\"></a>添加需要的各个gulp插件</h4><p>比如这里我用到了gulp-clean-css用于css压缩、gulp-uglify用于js压缩、gulp-watch用于文件监控、gulp-sass用于sass编译。<br>安装各插件(方法相同)<br><figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install --<span class=\"built_in\">save</span>-<span class=\"built_in\">dev</span> gulp-uglify</div></pre></td></tr></table></figure></p>\n<h4 id=\"第三步，配置gulp任务\"><a href=\"#第三步，配置gulp任务\" class=\"headerlink\" title=\"第三步，配置gulp任务\"></a>第三步，配置gulp任务</h4><p>在项目目录下创建文件<code>gulpfile.js</code>，用于编写gulp任务。<br>gulp基础语法比较简单，管道方式也很容易理解。<br>这里我的项目目录如下：<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── dist</div><div class=\"line\">│   ├── css</div><div class=\"line\">│   ├── <span class=\"selector-tag\">img</span></div><div class=\"line\">│   └── js</div><div class=\"line\">├── gulpfile<span class=\"selector-class\">.js</span></div><div class=\"line\">├── index<span class=\"selector-class\">.html</span></div><div class=\"line\">├── node_modules</div><div class=\"line\">│   ├── eruda</div><div class=\"line\">│   ├── gulp</div><div class=\"line\">│   ├── gulp-clean-css</div><div class=\"line\">│   ├── gulp-sass</div><div class=\"line\">│   ├── gulp-uglify</div><div class=\"line\">├── package<span class=\"selector-class\">.json</span></div><div class=\"line\">└── src</div><div class=\"line\">    ├── css</div><div class=\"line\">    ├── <span class=\"selector-tag\">img</span></div><div class=\"line\">    ├── js</div><div class=\"line\">    ├── libs</div><div class=\"line\">    └── sass</div></pre></td></tr></table></figure></p>\n<p>其中src文件夹中是源文件，<br>dist文件夹下是项目用到的压缩后的js、css文件。</p>\n<p>gulp任务配置文件gulpfile.js如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>),</div><div class=\"line\">\t\tcleanCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-clean-css'</span>),</div><div class=\"line\">\t\tuglify = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-uglify'</span>),</div><div class=\"line\">\t\twatch = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-watch'</span>),</div><div class=\"line\">\t\tsass = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-sass'</span>);</div><div class=\"line\"></div><div class=\"line\">gulp.task(<span class=\"string\">'default'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 默认任务代码</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 压缩文件</span></div><div class=\"line\">gulp.task(<span class=\"string\">'minfile'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// sass</span></div><div class=\"line\">\tgulp.src(<span class=\"string\">'src/sass/*.scss'</span>)</div><div class=\"line\">\t\t.pipe(sass())</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'src/css'</span>))</div><div class=\"line\">\t\t.pipe(cleanCSS())</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/css'</span>));</div><div class=\"line\">\t<span class=\"comment\">// js</span></div><div class=\"line\">\tgulp.src(<span class=\"string\">'src/js/*.js'</span>)</div><div class=\"line\">\t\t.pipe(uglify())</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/js'</span>));</div><div class=\"line\">\t<span class=\"comment\">// img</span></div><div class=\"line\">\tgulp.src(<span class=\"string\">'src/img/*'</span>)</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/img'</span>));</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 监听</span></div><div class=\"line\">gulp.task(<span class=\"string\">'watchFile'</span>, [<span class=\"string\">'minfile'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tgulp.watch(<span class=\"string\">'src/**/*'</span>, [<span class=\"string\">'minfile'</span>]);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">gulp.task(<span class=\"string\">'default'</span>, [<span class=\"string\">'minfile'</span>, <span class=\"string\">'watchFile'</span>]);</div></pre></td></tr></table></figure></p>\n<p>gulp API只有五个：task，src，dest，watch和run。<br>task用于定义任务；src用于表示源文件路径；dest用于输出，写入新文件；watch用于监听文件变化；run用于执行任务。<br>ps:上面的pipe表示管道。</p>\n<h4 id=\"第四步，开启任务\"><a href=\"#第四步，开启任务\" class=\"headerlink\" title=\"第四步，开启任务\"></a>第四步，开启任务</h4><p>项目目录下，执行<code>gulp</code>即可。之后就可以开始编写代码了。</p>\n<hr>\n<p>第一次对gulp的尝试，也是第一次对构建工具的尝试，其中只是用到了一些最简单也是最常用的插件，给我的感觉就是省去了每次手动编译、压缩等操作，这次使用就像一次Hello World。</p>\n","excerpt":"","more":"<p>gulp是前端构建工具，通过一系列gulp插件，可以实现实时监控、格式化代码、合并代码、压缩代码、测试功能等功能。</p>\n<hr>\n<p>前提：node环境，会使用基本命令行</p>\n<hr>\n<h3 id=\"全局安装gulp\"><a href=\"#全局安装gulp\" class=\"headerlink\" title=\"全局安装gulp\"></a>全局安装gulp</h3><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo npm <span class=\"keyword\">install</span> -g gulp</div></pre></td></tr></table></figure>\n<p>Windows环境下不需要sudo命令</p>\n<h3 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h3><h4 id=\"第一步，包管理文件-package-json\"><a href=\"#第一步，包管理文件-package-json\" class=\"headerlink\" title=\"第一步，包管理文件 package.json\"></a>第一步，包管理文件 package.json</h4><p>通过cd命令进入项目目录，执行<code>npm init</code>，之后可以一路的回车来创建<code>package.json</code>文件。关于此配置文件的内容挺简单的，可以自己看下，然后搜索下。</p>\n<h4 id=\"第二步，寻找、安装所需要的插件\"><a href=\"#第二步，寻找、安装所需要的插件\" class=\"headerlink\" title=\"第二步，寻找、安装所需要的插件\"></a>第二步，寻找、安装所需要的插件</h4><p>项目目录安装gulp，并写入配置文件package.json中。<br><figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install --<span class=\"built_in\">save</span>-<span class=\"built_in\">dev</span> gulp</div></pre></td></tr></table></figure></p>\n<p>这样会把gulp的依赖写入到package.json文件中。</p>\n<h4 id=\"添加需要的各个gulp插件\"><a href=\"#添加需要的各个gulp插件\" class=\"headerlink\" title=\"添加需要的各个gulp插件\"></a>添加需要的各个gulp插件</h4><p>比如这里我用到了gulp-clean-css用于css压缩、gulp-uglify用于js压缩、gulp-watch用于文件监控、gulp-sass用于sass编译。<br>安装各插件(方法相同)<br><figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install --<span class=\"built_in\">save</span>-<span class=\"built_in\">dev</span> gulp-uglify</div></pre></td></tr></table></figure></p>\n<h4 id=\"第三步，配置gulp任务\"><a href=\"#第三步，配置gulp任务\" class=\"headerlink\" title=\"第三步，配置gulp任务\"></a>第三步，配置gulp任务</h4><p>在项目目录下创建文件<code>gulpfile.js</code>，用于编写gulp任务。<br>gulp基础语法比较简单，管道方式也很容易理解。<br>这里我的项目目录如下：<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── dist</div><div class=\"line\">│   ├── css</div><div class=\"line\">│   ├── <span class=\"selector-tag\">img</span></div><div class=\"line\">│   └── js</div><div class=\"line\">├── gulpfile<span class=\"selector-class\">.js</span></div><div class=\"line\">├── index<span class=\"selector-class\">.html</span></div><div class=\"line\">├── node_modules</div><div class=\"line\">│   ├── eruda</div><div class=\"line\">│   ├── gulp</div><div class=\"line\">│   ├── gulp-clean-css</div><div class=\"line\">│   ├── gulp-sass</div><div class=\"line\">│   ├── gulp-uglify</div><div class=\"line\">├── package<span class=\"selector-class\">.json</span></div><div class=\"line\">└── src</div><div class=\"line\">    ├── css</div><div class=\"line\">    ├── <span class=\"selector-tag\">img</span></div><div class=\"line\">    ├── js</div><div class=\"line\">    ├── libs</div><div class=\"line\">    └── sass</div></pre></td></tr></table></figure></p>\n<p>其中src文件夹中是源文件，<br>dist文件夹下是项目用到的压缩后的js、css文件。</p>\n<p>gulp任务配置文件gulpfile.js如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>),</div><div class=\"line\">\t\tcleanCSS = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-clean-css'</span>),</div><div class=\"line\">\t\tuglify = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-uglify'</span>),</div><div class=\"line\">\t\twatch = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-watch'</span>),</div><div class=\"line\">\t\tsass = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-sass'</span>);</div><div class=\"line\"></div><div class=\"line\">gulp.task(<span class=\"string\">'default'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 默认任务代码</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 压缩文件</span></div><div class=\"line\">gulp.task(<span class=\"string\">'minfile'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// sass</span></div><div class=\"line\">\tgulp.src(<span class=\"string\">'src/sass/*.scss'</span>)</div><div class=\"line\">\t\t.pipe(sass())</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'src/css'</span>))</div><div class=\"line\">\t\t.pipe(cleanCSS())</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/css'</span>));</div><div class=\"line\">\t<span class=\"comment\">// js</span></div><div class=\"line\">\tgulp.src(<span class=\"string\">'src/js/*.js'</span>)</div><div class=\"line\">\t\t.pipe(uglify())</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/js'</span>));</div><div class=\"line\">\t<span class=\"comment\">// img</span></div><div class=\"line\">\tgulp.src(<span class=\"string\">'src/img/*'</span>)</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/img'</span>));</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 监听</span></div><div class=\"line\">gulp.task(<span class=\"string\">'watchFile'</span>, [<span class=\"string\">'minfile'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tgulp.watch(<span class=\"string\">'src/**/*'</span>, [<span class=\"string\">'minfile'</span>]);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">gulp.task(<span class=\"string\">'default'</span>, [<span class=\"string\">'minfile'</span>, <span class=\"string\">'watchFile'</span>]);</div></pre></td></tr></table></figure></p>\n<p>gulp API只有五个：task，src，dest，watch和run。<br>task用于定义任务；src用于表示源文件路径；dest用于输出，写入新文件；watch用于监听文件变化；run用于执行任务。<br>ps:上面的pipe表示管道。</p>\n<h4 id=\"第四步，开启任务\"><a href=\"#第四步，开启任务\" class=\"headerlink\" title=\"第四步，开启任务\"></a>第四步，开启任务</h4><p>项目目录下，执行<code>gulp</code>即可。之后就可以开始编写代码了。</p>\n<hr>\n<p>第一次对gulp的尝试，也是第一次对构建工具的尝试，其中只是用到了一些最简单也是最常用的插件，给我的感觉就是省去了每次手动编译、压缩等操作，这次使用就像一次Hello World。</p>\n"},{"title":"Redux学习","date":"2016-11-01T00:00:00.000Z","comments":1,"_content":"\naction: 规定动作以及数据\nreducer: 如何更新action中的数据。接受旧的action、state,返回新的。(state)\nstore: 调用reducer更改action中的数据\n\n定义action\naction一般形式：\nfunction addTodo(data) {\n\treturn {\n\t\ttype: type,\t\t\t\t\t\t\t// type属性是必须的\n\t\tdata: data\t\t\t\t\t\t\t// 其他属性，任意定义，保存数据\n\t}\n}\n\nreducer一般形式：\nfunction todos(state = [], action) {\t\t// 参数state,action state给默认值\n  switch (action.type) {\t\t\t\t\t\t\t\t// 对action进行switch判断\n    case ADD_TODO:\n      return [\n        ...state,\n        {\n          text: action.text,\n          completed: false\n        }\n      ]\n    case COMPLETE_TODO:\n      return [\n\n      ]\n    default:\n      return state\n  }\n}\n\n// 通过redux提供的combineReducers方法将多个reducer结合\nconst todoApp = combineReducers({\t\t\t\t\t\t\n  visibilityFilter,\n  todos\n})\nexport default todoApp;\n\nstore通过redux提供的createStore方法传递reducer方法作为参数去创建。\nlet store = createStore(todoApp) // todoApp为reducer\n\nreact-redux的Provider组件通过store属性传递。\n<Provider store={store}>\n  <App />\n</Provider>\n\n组件中通过react-redux的connect方法，将store映射到props上。\nfunction select(state) {\n  return {\n    visibleTodos: ...\n    visibilityFilter: ... \n  };\n}\nexport default connect(select)(App);  // App为组件名，select方法在connect中调用，会将store的getState()传递过去。te()值\n\n组件中通过connect传递过来的props中的dispatch方法更改\nconst { dispatch } = this.props \t// this.props为调用connect后自动传递god了的的。\ndispatch(completeTodo(index))\t\t\t// dispatch调用某action\n\n中间件\n\n// 中间件由三个嵌套的函数构成（会依次调用）：\n// 1) 第一层向其余两层提供分发函数和 getState 函数\n//    （因为你的中间件或 action creator 可能需要从 state 中读取数据）\n// 2) 第二层提供 next 函数，它允许你显式的将处理过的输入传递给下一个中间件或 Redux\n//    （这样 Redux 才能调用所有 reducer)。\n// 3) 第三层提供从上一个中间件或从 dispatch 传递来的 action，\n//     这个 action 可以调用下一个中间件（让 action 继续流动) 或者\n//     以想要的方式处理 action。\n\nvar thunkMiddleware = function ({ dispatch, getState }) {\n  // console.log('Enter thunkMiddleware');\n  return function(next) {\n    // console.log('Function \"next\" provided:', next);\n    return function (action) {\n      // console.log('Handling action:', action);\n      return typeof action === 'function' ?\n          action(dispatch, getState) :\n          next(action)\n    }\n  }\n}\n\n调用中间件\nimport { createStore, combineReducers, applyMiddleware } from 'redux'\nconst finalCreateStore = applyMiddleware(thunkMiddleware)(createStore)\n\n###\n\nFrom [Here](http://div.io/topic/1309?utm_source=tuicool&utm_medium=referral)\n首先，设计state\n```javascript\nlet state = {\n  todos: [{\n    id: 123,\n    text: 'todo item',\n    status: false\n  }],\n  activeFilter: SHOW_ALL\n}\n```\n设计action常量\n```javascript\n//ActionTypes.js 真正改动了数据的 actionType 在这里\nexport const ADD_ITEM = 'ADD_ITEM'\nexport const DELETE_ITEM = 'DELETE_ITEM'\nexport const DELETE_ITEMS = 'DELETE_ITEMS'\nexport const UPDATE_ITEM = 'UPDATE_ITEM'\nexport const UPDATE_ITEMS = 'UPDATE_ITEMS'\n\n//API.js 服务端接口统一放这里\nexport const API_TODOS = '/todos'\n\n//SocketTypes.js websocket 也触发了某个 action 改变了 state，单独放这里\nexport const SERVER_UPDATE = 'SERVER_UPDATE'\n\n//KeyCode.js 键盘的回车键与取消键对应的编码\nexport const ENTER_KEY = 13\nexport const ESCAPE_KEY = 27\n\n//FilterTypes.js 只是筛选数据，没有改变 state 的过滤 action 的常量\nexport const FILTER_ITEMS = 'FILTER_ITEMS'\nexport const SHOW_ALL = 'SHOW_ALL'\nexport const SHOW_ACTIVE = 'SHOW_ACTIVE'\nexport const SHOW_COMPLETED = 'SHOW_COMPLETED'\n```\n开始写actionCreaetor\n```javascript\n//index.js\nimport * as types from '../constants/ActionTypes'\nexport function addItem(text) {\n  return { type: types.ADD_ITEM, text }\n}\nexport function deleteItem(id) {\n  return { type: types.DELETE_ITEM, id }\n}\nexport function updateItem(data) {\n  return { type: types.UPDATE_ITEM, data }\n}\nexport function deleteItems(query) {\n  return { type: types.DELETE_ITEMS, query }\n}\nexport function updateItems(data) {\n  return { type: types.UPDATE_ITEMS, data }\n}\n```\nreducer\n```javacript\n//index.js\nimport * as types from '../constants/ActionTypes'\nexport function addItem(text) {\n  return { type: types.ADD_ITEM, text }\n}\nexport function deleteItem(id) {\n  return { type: types.DELETE_ITEM, id }\n}\nexport function updateItem(data) {\n  return { type: types.UPDATE_ITEM, data }\n}\nexport function deleteItems(query) {\n  return { type: types.DELETE_ITEMS, query }\n}\nexport function updateItems(data) {\n  return { type: types.UPDATE_ITEMS, data }\n}\n\n```\n\n###\n\nFrom [Here](https://github.com/kenberkeley/redux-simple-tutorial)\nstate是应用的状态，store是state的管理器,唯一的 (state == store.getState())\nstrore包括getState()、 dispatch(action)、 subscribe(listener)、 replaceReducer(nextReducer)\naction就是普通对象，用于规定数据格式。\nreducer用来更新state,根据action type修改state，返回新的state。","source":"_posts/redux学习.md","raw":"---\ntitle: Redux学习\ndate: 2016-11\ntags: [React, Redux]\ncategories: \n- React\ncomments: true\n---\n\naction: 规定动作以及数据\nreducer: 如何更新action中的数据。接受旧的action、state,返回新的。(state)\nstore: 调用reducer更改action中的数据\n\n定义action\naction一般形式：\nfunction addTodo(data) {\n\treturn {\n\t\ttype: type,\t\t\t\t\t\t\t// type属性是必须的\n\t\tdata: data\t\t\t\t\t\t\t// 其他属性，任意定义，保存数据\n\t}\n}\n\nreducer一般形式：\nfunction todos(state = [], action) {\t\t// 参数state,action state给默认值\n  switch (action.type) {\t\t\t\t\t\t\t\t// 对action进行switch判断\n    case ADD_TODO:\n      return [\n        ...state,\n        {\n          text: action.text,\n          completed: false\n        }\n      ]\n    case COMPLETE_TODO:\n      return [\n\n      ]\n    default:\n      return state\n  }\n}\n\n// 通过redux提供的combineReducers方法将多个reducer结合\nconst todoApp = combineReducers({\t\t\t\t\t\t\n  visibilityFilter,\n  todos\n})\nexport default todoApp;\n\nstore通过redux提供的createStore方法传递reducer方法作为参数去创建。\nlet store = createStore(todoApp) // todoApp为reducer\n\nreact-redux的Provider组件通过store属性传递。\n<Provider store={store}>\n  <App />\n</Provider>\n\n组件中通过react-redux的connect方法，将store映射到props上。\nfunction select(state) {\n  return {\n    visibleTodos: ...\n    visibilityFilter: ... \n  };\n}\nexport default connect(select)(App);  // App为组件名，select方法在connect中调用，会将store的getState()传递过去。te()值\n\n组件中通过connect传递过来的props中的dispatch方法更改\nconst { dispatch } = this.props \t// this.props为调用connect后自动传递god了的的。\ndispatch(completeTodo(index))\t\t\t// dispatch调用某action\n\n中间件\n\n// 中间件由三个嵌套的函数构成（会依次调用）：\n// 1) 第一层向其余两层提供分发函数和 getState 函数\n//    （因为你的中间件或 action creator 可能需要从 state 中读取数据）\n// 2) 第二层提供 next 函数，它允许你显式的将处理过的输入传递给下一个中间件或 Redux\n//    （这样 Redux 才能调用所有 reducer)。\n// 3) 第三层提供从上一个中间件或从 dispatch 传递来的 action，\n//     这个 action 可以调用下一个中间件（让 action 继续流动) 或者\n//     以想要的方式处理 action。\n\nvar thunkMiddleware = function ({ dispatch, getState }) {\n  // console.log('Enter thunkMiddleware');\n  return function(next) {\n    // console.log('Function \"next\" provided:', next);\n    return function (action) {\n      // console.log('Handling action:', action);\n      return typeof action === 'function' ?\n          action(dispatch, getState) :\n          next(action)\n    }\n  }\n}\n\n调用中间件\nimport { createStore, combineReducers, applyMiddleware } from 'redux'\nconst finalCreateStore = applyMiddleware(thunkMiddleware)(createStore)\n\n###\n\nFrom [Here](http://div.io/topic/1309?utm_source=tuicool&utm_medium=referral)\n首先，设计state\n```javascript\nlet state = {\n  todos: [{\n    id: 123,\n    text: 'todo item',\n    status: false\n  }],\n  activeFilter: SHOW_ALL\n}\n```\n设计action常量\n```javascript\n//ActionTypes.js 真正改动了数据的 actionType 在这里\nexport const ADD_ITEM = 'ADD_ITEM'\nexport const DELETE_ITEM = 'DELETE_ITEM'\nexport const DELETE_ITEMS = 'DELETE_ITEMS'\nexport const UPDATE_ITEM = 'UPDATE_ITEM'\nexport const UPDATE_ITEMS = 'UPDATE_ITEMS'\n\n//API.js 服务端接口统一放这里\nexport const API_TODOS = '/todos'\n\n//SocketTypes.js websocket 也触发了某个 action 改变了 state，单独放这里\nexport const SERVER_UPDATE = 'SERVER_UPDATE'\n\n//KeyCode.js 键盘的回车键与取消键对应的编码\nexport const ENTER_KEY = 13\nexport const ESCAPE_KEY = 27\n\n//FilterTypes.js 只是筛选数据，没有改变 state 的过滤 action 的常量\nexport const FILTER_ITEMS = 'FILTER_ITEMS'\nexport const SHOW_ALL = 'SHOW_ALL'\nexport const SHOW_ACTIVE = 'SHOW_ACTIVE'\nexport const SHOW_COMPLETED = 'SHOW_COMPLETED'\n```\n开始写actionCreaetor\n```javascript\n//index.js\nimport * as types from '../constants/ActionTypes'\nexport function addItem(text) {\n  return { type: types.ADD_ITEM, text }\n}\nexport function deleteItem(id) {\n  return { type: types.DELETE_ITEM, id }\n}\nexport function updateItem(data) {\n  return { type: types.UPDATE_ITEM, data }\n}\nexport function deleteItems(query) {\n  return { type: types.DELETE_ITEMS, query }\n}\nexport function updateItems(data) {\n  return { type: types.UPDATE_ITEMS, data }\n}\n```\nreducer\n```javacript\n//index.js\nimport * as types from '../constants/ActionTypes'\nexport function addItem(text) {\n  return { type: types.ADD_ITEM, text }\n}\nexport function deleteItem(id) {\n  return { type: types.DELETE_ITEM, id }\n}\nexport function updateItem(data) {\n  return { type: types.UPDATE_ITEM, data }\n}\nexport function deleteItems(query) {\n  return { type: types.DELETE_ITEMS, query }\n}\nexport function updateItems(data) {\n  return { type: types.UPDATE_ITEMS, data }\n}\n\n```\n\n###\n\nFrom [Here](https://github.com/kenberkeley/redux-simple-tutorial)\nstate是应用的状态，store是state的管理器,唯一的 (state == store.getState())\nstrore包括getState()、 dispatch(action)、 subscribe(listener)、 replaceReducer(nextReducer)\naction就是普通对象，用于规定数据格式。\nreducer用来更新state,根据action type修改state，返回新的state。","slug":"redux学习","published":1,"updated":"2017-03-22T01:28:33.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8khl000qohfko1nutmpv","content":"<p>action: 规定动作以及数据<br>reducer: 如何更新action中的数据。接受旧的action、state,返回新的。(state)<br>store: 调用reducer更改action中的数据</p>\n<p>定义action<br>action一般形式：<br>function addTodo(data) {<br>    return {<br>        type: type,                            // type属性是必须的<br>        data: data                            // 其他属性，任意定义，保存数据<br>    }<br>}</p>\n<p>reducer一般形式：<br>function todos(state = [], action) {        // 参数state,action state给默认值<br>  switch (action.type) {                                // 对action进行switch判断<br>    case ADD_TODO:<br>      return [<br>        …state,<br>        {<br>          text: action.text,<br>          completed: false<br>        }<br>      ]<br>    case COMPLETE_TODO:<br>      return [</p>\n<pre><code>  ]\ndefault:\n  return state\n</code></pre><p>  }<br>}</p>\n<p>// 通过redux提供的combineReducers方法将多个reducer结合<br>const todoApp = combineReducers({<br>  visibilityFilter,<br>  todos<br>})<br>export default todoApp;</p>\n<p>store通过redux提供的createStore方法传递reducer方法作为参数去创建。<br>let store = createStore(todoApp) // todoApp为reducer</p>\n<p>react-redux的Provider组件通过store属性传递。</p>\n<provider store=\"{store}\"><br>  <app><br></app></provider>\n\n<p>组件中通过react-redux的connect方法，将store映射到props上。<br>function select(state) {<br>  return {<br>    visibleTodos: …<br>    visibilityFilter: …<br>  };<br>}<br>export default connect(select)(App);  // App为组件名，select方法在connect中调用，会将store的getState()传递过去。te()值</p>\n<p>组件中通过connect传递过来的props中的dispatch方法更改<br>const { dispatch } = this.props     // this.props为调用connect后自动传递god了的的。<br>dispatch(completeTodo(index))            // dispatch调用某action</p>\n<p>中间件</p>\n<p>// 中间件由三个嵌套的函数构成（会依次调用）：<br>// 1) 第一层向其余两层提供分发函数和 getState 函数<br>//    （因为你的中间件或 action creator 可能需要从 state 中读取数据）<br>// 2) 第二层提供 next 函数，它允许你显式的将处理过的输入传递给下一个中间件或 Redux<br>//    （这样 Redux 才能调用所有 reducer)。<br>// 3) 第三层提供从上一个中间件或从 dispatch 传递来的 action，<br>//     这个 action 可以调用下一个中间件（让 action 继续流动) 或者<br>//     以想要的方式处理 action。</p>\n<p>var thunkMiddleware = function ({ dispatch, getState }) {<br>  // console.log(‘Enter thunkMiddleware’);<br>  return function(next) {<br>    // console.log(‘Function “next” provided:’, next);<br>    return function (action) {<br>      // console.log(‘Handling action:’, action);<br>      return typeof action === ‘function’ ?<br>          action(dispatch, getState) :<br>          next(action)<br>    }<br>  }<br>}</p>\n<p>调用中间件<br>import { createStore, combineReducers, applyMiddleware } from ‘redux’<br>const finalCreateStore = applyMiddleware(thunkMiddleware)(createStore)</p>\n<p>###</p>\n<p>From <a href=\"http://div.io/topic/1309?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"external\">Here</a><br>首先，设计state<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> state = &#123;</div><div class=\"line\">  <span class=\"attr\">todos</span>: [&#123;</div><div class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">123</span>,</div><div class=\"line\">    <span class=\"attr\">text</span>: <span class=\"string\">'todo item'</span>,</div><div class=\"line\">    <span class=\"attr\">status</span>: <span class=\"literal\">false</span></div><div class=\"line\">  &#125;],</div><div class=\"line\">  <span class=\"attr\">activeFilter</span>: SHOW_ALL</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>设计action常量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//ActionTypes.js 真正改动了数据的 actionType 在这里</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ADD_ITEM = <span class=\"string\">'ADD_ITEM'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DELETE_ITEM = <span class=\"string\">'DELETE_ITEM'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DELETE_ITEMS = <span class=\"string\">'DELETE_ITEMS'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> UPDATE_ITEM = <span class=\"string\">'UPDATE_ITEM'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> UPDATE_ITEMS = <span class=\"string\">'UPDATE_ITEMS'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//API.js 服务端接口统一放这里</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> API_TODOS = <span class=\"string\">'/todos'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//SocketTypes.js websocket 也触发了某个 action 改变了 state，单独放这里</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SERVER_UPDATE = <span class=\"string\">'SERVER_UPDATE'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//KeyCode.js 键盘的回车键与取消键对应的编码</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ENTER_KEY = <span class=\"number\">13</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ESCAPE_KEY = <span class=\"number\">27</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//FilterTypes.js 只是筛选数据，没有改变 state 的过滤 action 的常量</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> FILTER_ITEMS = <span class=\"string\">'FILTER_ITEMS'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_ALL = <span class=\"string\">'SHOW_ALL'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_ACTIVE = <span class=\"string\">'SHOW_ACTIVE'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_COMPLETED = <span class=\"string\">'SHOW_COMPLETED'</span></div></pre></td></tr></table></figure></p>\n<p>开始写actionCreaetor<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//index.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> types <span class=\"keyword\">from</span> <span class=\"string\">'../constants/ActionTypes'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addItem</span>(<span class=\"params\">text</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.ADD_ITEM, text &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deleteItem</span>(<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.DELETE_ITEM, id &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateItem</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.UPDATE_ITEM, data &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deleteItems</span>(<span class=\"params\">query</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.DELETE_ITEMS, query &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateItems</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.UPDATE_ITEMS, data &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>reducer<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">//index.js</div><div class=\"line\">import * as types from &apos;../constants/ActionTypes&apos;</div><div class=\"line\">export function addItem(text) &#123;</div><div class=\"line\">  return &#123; type: types.ADD_ITEM, text &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">export function deleteItem(id) &#123;</div><div class=\"line\">  return &#123; type: types.DELETE_ITEM, id &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">export function updateItem(data) &#123;</div><div class=\"line\">  return &#123; type: types.UPDATE_ITEM, data &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">export function deleteItems(query) &#123;</div><div class=\"line\">  return &#123; type: types.DELETE_ITEMS, query &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">export function updateItems(data) &#123;</div><div class=\"line\">  return &#123; type: types.UPDATE_ITEMS, data &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>###</p>\n<p>From <a href=\"https://github.com/kenberkeley/redux-simple-tutorial\" target=\"_blank\" rel=\"external\">Here</a><br>state是应用的状态，store是state的管理器,唯一的 (state == store.getState())<br>strore包括getState()、 dispatch(action)、 subscribe(listener)、 replaceReducer(nextReducer)<br>action就是普通对象，用于规定数据格式。<br>reducer用来更新state,根据action type修改state，返回新的state。</p>\n","excerpt":"","more":"<p>action: 规定动作以及数据<br>reducer: 如何更新action中的数据。接受旧的action、state,返回新的。(state)<br>store: 调用reducer更改action中的数据</p>\n<p>定义action<br>action一般形式：<br>function addTodo(data) {<br>    return {<br>        type: type,                            // type属性是必须的<br>        data: data                            // 其他属性，任意定义，保存数据<br>    }<br>}</p>\n<p>reducer一般形式：<br>function todos(state = [], action) {        // 参数state,action state给默认值<br>  switch (action.type) {                                // 对action进行switch判断<br>    case ADD_TODO:<br>      return [<br>        …state,<br>        {<br>          text: action.text,<br>          completed: false<br>        }<br>      ]<br>    case COMPLETE_TODO:<br>      return [</p>\n<pre><code>  ]\ndefault:\n  return state\n</code></pre><p>  }<br>}</p>\n<p>// 通过redux提供的combineReducers方法将多个reducer结合<br>const todoApp = combineReducers({<br>  visibilityFilter,<br>  todos<br>})<br>export default todoApp;</p>\n<p>store通过redux提供的createStore方法传递reducer方法作为参数去创建。<br>let store = createStore(todoApp) // todoApp为reducer</p>\n<p>react-redux的Provider组件通过store属性传递。</p>\n<Provider store={store}><br>  <App /><br></Provider>\n\n<p>组件中通过react-redux的connect方法，将store映射到props上。<br>function select(state) {<br>  return {<br>    visibleTodos: …<br>    visibilityFilter: …<br>  };<br>}<br>export default connect(select)(App);  // App为组件名，select方法在connect中调用，会将store的getState()传递过去。te()值</p>\n<p>组件中通过connect传递过来的props中的dispatch方法更改<br>const { dispatch } = this.props     // this.props为调用connect后自动传递god了的的。<br>dispatch(completeTodo(index))            // dispatch调用某action</p>\n<p>中间件</p>\n<p>// 中间件由三个嵌套的函数构成（会依次调用）：<br>// 1) 第一层向其余两层提供分发函数和 getState 函数<br>//    （因为你的中间件或 action creator 可能需要从 state 中读取数据）<br>// 2) 第二层提供 next 函数，它允许你显式的将处理过的输入传递给下一个中间件或 Redux<br>//    （这样 Redux 才能调用所有 reducer)。<br>// 3) 第三层提供从上一个中间件或从 dispatch 传递来的 action，<br>//     这个 action 可以调用下一个中间件（让 action 继续流动) 或者<br>//     以想要的方式处理 action。</p>\n<p>var thunkMiddleware = function ({ dispatch, getState }) {<br>  // console.log(‘Enter thunkMiddleware’);<br>  return function(next) {<br>    // console.log(‘Function “next” provided:’, next);<br>    return function (action) {<br>      // console.log(‘Handling action:’, action);<br>      return typeof action === ‘function’ ?<br>          action(dispatch, getState) :<br>          next(action)<br>    }<br>  }<br>}</p>\n<p>调用中间件<br>import { createStore, combineReducers, applyMiddleware } from ‘redux’<br>const finalCreateStore = applyMiddleware(thunkMiddleware)(createStore)</p>\n<p>###</p>\n<p>From <a href=\"http://div.io/topic/1309?utm_source=tuicool&amp;utm_medium=referral\">Here</a><br>首先，设计state<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> state = &#123;</div><div class=\"line\">  <span class=\"attr\">todos</span>: [&#123;</div><div class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">123</span>,</div><div class=\"line\">    <span class=\"attr\">text</span>: <span class=\"string\">'todo item'</span>,</div><div class=\"line\">    <span class=\"attr\">status</span>: <span class=\"literal\">false</span></div><div class=\"line\">  &#125;],</div><div class=\"line\">  <span class=\"attr\">activeFilter</span>: SHOW_ALL</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>设计action常量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//ActionTypes.js 真正改动了数据的 actionType 在这里</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ADD_ITEM = <span class=\"string\">'ADD_ITEM'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DELETE_ITEM = <span class=\"string\">'DELETE_ITEM'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DELETE_ITEMS = <span class=\"string\">'DELETE_ITEMS'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> UPDATE_ITEM = <span class=\"string\">'UPDATE_ITEM'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> UPDATE_ITEMS = <span class=\"string\">'UPDATE_ITEMS'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//API.js 服务端接口统一放这里</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> API_TODOS = <span class=\"string\">'/todos'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//SocketTypes.js websocket 也触发了某个 action 改变了 state，单独放这里</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SERVER_UPDATE = <span class=\"string\">'SERVER_UPDATE'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//KeyCode.js 键盘的回车键与取消键对应的编码</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ENTER_KEY = <span class=\"number\">13</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ESCAPE_KEY = <span class=\"number\">27</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//FilterTypes.js 只是筛选数据，没有改变 state 的过滤 action 的常量</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> FILTER_ITEMS = <span class=\"string\">'FILTER_ITEMS'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_ALL = <span class=\"string\">'SHOW_ALL'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_ACTIVE = <span class=\"string\">'SHOW_ACTIVE'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SHOW_COMPLETED = <span class=\"string\">'SHOW_COMPLETED'</span></div></pre></td></tr></table></figure></p>\n<p>开始写actionCreaetor<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//index.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> types <span class=\"keyword\">from</span> <span class=\"string\">'../constants/ActionTypes'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addItem</span>(<span class=\"params\">text</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.ADD_ITEM, text &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deleteItem</span>(<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.DELETE_ITEM, id &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateItem</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.UPDATE_ITEM, data &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deleteItems</span>(<span class=\"params\">query</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.DELETE_ITEMS, query &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateItems</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">type</span>: types.UPDATE_ITEMS, data &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>reducer<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">//index.js</div><div class=\"line\">import * as types from &apos;../constants/ActionTypes&apos;</div><div class=\"line\">export function addItem(text) &#123;</div><div class=\"line\">  return &#123; type: types.ADD_ITEM, text &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">export function deleteItem(id) &#123;</div><div class=\"line\">  return &#123; type: types.DELETE_ITEM, id &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">export function updateItem(data) &#123;</div><div class=\"line\">  return &#123; type: types.UPDATE_ITEM, data &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">export function deleteItems(query) &#123;</div><div class=\"line\">  return &#123; type: types.DELETE_ITEMS, query &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">export function updateItems(data) &#123;</div><div class=\"line\">  return &#123; type: types.UPDATE_ITEMS, data &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>###</p>\n<p>From <a href=\"https://github.com/kenberkeley/redux-simple-tutorial\">Here</a><br>state是应用的状态，store是state的管理器,唯一的 (state == store.getState())<br>strore包括getState()、 dispatch(action)、 subscribe(listener)、 replaceReducer(nextReducer)<br>action就是普通对象，用于规定数据格式。<br>reducer用来更新state,根据action type修改state，返回新的state。</p>\n"},{"title":"redux应用于React","date":"2016-09-21T16:00:00.000Z","comments":1,"_content":"\n### Redux应用于React  \n\n　　不知道有多少人和我一样，redux的文档看了一遍又一遍，各种教程翻来翻去，还是不知道在自己的React项目中该如何加入redux。  \n　　经过这段时间，总算有些入门的感觉，明白大致的编写流程。  \n　　对于在React项目中使用redux，首先需要理解`展示型组件和容器型组件`。  \n　　简单来说，展示型组件用于对展示页面，数据通过`props`获得，只有容器型组件与redux交道。一般情况下，容器型组件通过redux的`connect`函数获得state，以及action，然后调用展示型组件并通过`props`传递所需要的state和action。展示型组件需要修改state就通过容器型组件传递过来的action调用。  \neg\n```jsx\n// Login.js  Login组件 (此为容器组件)\n\n// 通过connect传递state中的userData和user action\n@connect(\n  ({userData}) => ({userData}),\n  require('ACTION/user').default\n)\nexport default class Login extends Component {\n\trender() {\n\t\treturn (\n        <div className=\"login-content\">\n      \t\t<div className=\"login\">\n            <p className=\"login-close\"><Link to=\"user\">&times;</Link></p>\n            {/* 调用LoginForm组件，并把user action中的login方法通过props传递给LoginForm组件 */}\n            <LoginForm\n              toLogin = { this.props.login }\n            >\n            </LoginForm>\n          </div>\n        </div>\n\t\t\t);\n\t}\n}\n```\n\n```jsx\n// LoginForm.js  LoginForm组件 (此为展示组件)\n\nexport default class LoginForm extends Component {\n  \n  constructor (props) {\n    super(props);\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    let username = this.refs.username.value;\n    let password = this.refs.password.value;\n    // 对输入的处理\n    if(username == '' || password == '') {\n      return alert('请输入用户名和密码');\n    }\n    // 调用redux action来修改state\n    return this.props.toLogin(username, password);\n  }\n\n  render() {\n\t\treturn (\n        <div className=\"login-form\">\n          <from>\n            <input className=\"username-input\" type=\"text\" placeholder=\"用户名\"\n              ref=\"username\"\n            />\n            <input className=\"password-input\" type=\"password\" placeholder=\"密码\"\n              ref=\"password\"\n            />\n            <submit className=\"submit-btn\" onClick={ this.handleClick }>进入头条</submit>\n          </from>\n        </div>\n\t\t\t);\n\t}\n}\n```\n\n#####\n\n关于action, reducer, store的编写，需要明白这个流程：\n\n\t1. dispatch()用于触发action，参数为具体action(actionCreate其实也是产生一个action)。\n\t2. 当有action被触发时，就会去store中查询注册的reducer(通过action.type查找),并执行该reducer返回新的state。\n\n所以我们需要做的：\n\n\t1. 编写reducer，参数为(initstate, action)，(一般样式为switch(action.type))。\n\t2. 合并reducer，主要目的是可以将reducer分成多个编写，更方便管理和理解。\n\t3. 编写store，注册reducer到store中，这里一般都会添加redux的中间件。\n\tps:\n\t应该是最先编写action，包括action type常量定义，可以用于action create和reducer；action create函数；action dispatch函数。函数位置具体怎么分，各有所爱吧。","source":"_posts/redux应用于React.md","raw":"---\ntitle: redux应用于React\ndate: 2016-09-22\ntags: [JavaScript, React, redux]\ncategories: \n- React\ncomments: true\n---\n\n### Redux应用于React  \n\n　　不知道有多少人和我一样，redux的文档看了一遍又一遍，各种教程翻来翻去，还是不知道在自己的React项目中该如何加入redux。  \n　　经过这段时间，总算有些入门的感觉，明白大致的编写流程。  \n　　对于在React项目中使用redux，首先需要理解`展示型组件和容器型组件`。  \n　　简单来说，展示型组件用于对展示页面，数据通过`props`获得，只有容器型组件与redux交道。一般情况下，容器型组件通过redux的`connect`函数获得state，以及action，然后调用展示型组件并通过`props`传递所需要的state和action。展示型组件需要修改state就通过容器型组件传递过来的action调用。  \neg\n```jsx\n// Login.js  Login组件 (此为容器组件)\n\n// 通过connect传递state中的userData和user action\n@connect(\n  ({userData}) => ({userData}),\n  require('ACTION/user').default\n)\nexport default class Login extends Component {\n\trender() {\n\t\treturn (\n        <div className=\"login-content\">\n      \t\t<div className=\"login\">\n            <p className=\"login-close\"><Link to=\"user\">&times;</Link></p>\n            {/* 调用LoginForm组件，并把user action中的login方法通过props传递给LoginForm组件 */}\n            <LoginForm\n              toLogin = { this.props.login }\n            >\n            </LoginForm>\n          </div>\n        </div>\n\t\t\t);\n\t}\n}\n```\n\n```jsx\n// LoginForm.js  LoginForm组件 (此为展示组件)\n\nexport default class LoginForm extends Component {\n  \n  constructor (props) {\n    super(props);\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    let username = this.refs.username.value;\n    let password = this.refs.password.value;\n    // 对输入的处理\n    if(username == '' || password == '') {\n      return alert('请输入用户名和密码');\n    }\n    // 调用redux action来修改state\n    return this.props.toLogin(username, password);\n  }\n\n  render() {\n\t\treturn (\n        <div className=\"login-form\">\n          <from>\n            <input className=\"username-input\" type=\"text\" placeholder=\"用户名\"\n              ref=\"username\"\n            />\n            <input className=\"password-input\" type=\"password\" placeholder=\"密码\"\n              ref=\"password\"\n            />\n            <submit className=\"submit-btn\" onClick={ this.handleClick }>进入头条</submit>\n          </from>\n        </div>\n\t\t\t);\n\t}\n}\n```\n\n#####\n\n关于action, reducer, store的编写，需要明白这个流程：\n\n\t1. dispatch()用于触发action，参数为具体action(actionCreate其实也是产生一个action)。\n\t2. 当有action被触发时，就会去store中查询注册的reducer(通过action.type查找),并执行该reducer返回新的state。\n\n所以我们需要做的：\n\n\t1. 编写reducer，参数为(initstate, action)，(一般样式为switch(action.type))。\n\t2. 合并reducer，主要目的是可以将reducer分成多个编写，更方便管理和理解。\n\t3. 编写store，注册reducer到store中，这里一般都会添加redux的中间件。\n\tps:\n\t应该是最先编写action，包括action type常量定义，可以用于action create和reducer；action create函数；action dispatch函数。函数位置具体怎么分，各有所爱吧。","slug":"redux应用于React","published":1,"updated":"2017-03-22T01:28:58.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8khn000uohfkac3u6asj","content":"<h3 id=\"Redux应用于React\"><a href=\"#Redux应用于React\" class=\"headerlink\" title=\"Redux应用于React\"></a>Redux应用于React</h3><p>　　不知道有多少人和我一样，redux的文档看了一遍又一遍，各种教程翻来翻去，还是不知道在自己的React项目中该如何加入redux。<br>　　经过这段时间，总算有些入门的感觉，明白大致的编写流程。<br>　　对于在React项目中使用redux，首先需要理解<code>展示型组件和容器型组件</code>。<br>　　简单来说，展示型组件用于对展示页面，数据通过<code>props</code>获得，只有容器型组件与redux交道。一般情况下，容器型组件通过redux的<code>connect</code>函数获得state，以及action，然后调用展示型组件并通过<code>props</code>传递所需要的state和action。展示型组件需要修改state就通过容器型组件传递过来的action调用。<br>eg<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Login.js  Login组件 (此为容器组件)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 通过connect传递state中的userData和user action</span></div><div class=\"line\">@connect(</div><div class=\"line\">  <span class=\"function\">(<span class=\"params\">&#123;userData&#125;</span>) =&gt;</span> (&#123;userData&#125;),</div><div class=\"line\">  <span class=\"built_in\">require</span>(<span class=\"string\">'ACTION/user'</span>).default</div><div class=\"line\">)</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Login</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">\trender() &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> (</div><div class=\"line\">        <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"login-content\"</span>&gt;</span></span></div><div class=\"line\">      \t\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"login\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">className</span>=<span class=\"string\">\"login-close\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"user\"</span>&gt;</span>&amp;times;<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">            &#123;/* 调用LoginForm组件，并把user action中的login方法通过props传递给LoginForm组件 */&#125;</div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">LoginForm</span></span></div><div class=\"line\">              <span class=\"attr\">toLogin</span> = <span class=\"string\">&#123;</span> <span class=\"attr\">this.props.login</span> &#125;</div><div class=\"line\">            &gt;</div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">LoginForm</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t\t\t);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// LoginForm.js  LoginForm组件 (此为展示组件)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginForm</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">constructor</span> (props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleClick() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> username = <span class=\"keyword\">this</span>.refs.username.value;</div><div class=\"line\">    <span class=\"keyword\">let</span> password = <span class=\"keyword\">this</span>.refs.password.value;</div><div class=\"line\">    <span class=\"comment\">// 对输入的处理</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(username == <span class=\"string\">''</span> || password == <span class=\"string\">''</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> alert(<span class=\"string\">'请输入用户名和密码'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 调用redux action来修改state</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.toLogin(username, password);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> (</div><div class=\"line\">        &lt;div className=\"login-form\"&gt;</div><div class=\"line\">          &lt;from&gt;</div><div class=\"line\">            &lt;input className=\"username-input\" type=\"text\" placeholder=\"用户名\"</div><div class=\"line\">              ref=\"username\"</div><div class=\"line\">            /&gt;</div><div class=\"line\">            &lt;input className=\"password-input\" type=\"password\" placeholder=\"密码\"</div><div class=\"line\">              ref=\"password\"</div><div class=\"line\">            /&gt;</div><div class=\"line\">            &lt;submit className=\"submit-btn\" onClick=&#123; this.handleClick &#125;&gt;进入头条&lt;/submit&gt;</div><div class=\"line\">          &lt;/from&gt;</div><div class=\"line\">        &lt;/div&gt;</div><div class=\"line\">\t\t\t);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>#####</p>\n<p>关于action, reducer, store的编写，需要明白这个流程：</p>\n<pre><code>1. dispatch()用于触发action，参数为具体action(actionCreate其实也是产生一个action)。\n2. 当有action被触发时，就会去store中查询注册的reducer(通过action.type查找),并执行该reducer返回新的state。\n</code></pre><p>所以我们需要做的：</p>\n<pre><code>1. 编写reducer，参数为(initstate, action)，(一般样式为switch(action.type))。\n2. 合并reducer，主要目的是可以将reducer分成多个编写，更方便管理和理解。\n3. 编写store，注册reducer到store中，这里一般都会添加redux的中间件。\nps:\n应该是最先编写action，包括action type常量定义，可以用于action create和reducer；action create函数；action dispatch函数。函数位置具体怎么分，各有所爱吧。\n</code></pre>","excerpt":"","more":"<h3 id=\"Redux应用于React\"><a href=\"#Redux应用于React\" class=\"headerlink\" title=\"Redux应用于React\"></a>Redux应用于React</h3><p>　　不知道有多少人和我一样，redux的文档看了一遍又一遍，各种教程翻来翻去，还是不知道在自己的React项目中该如何加入redux。<br>　　经过这段时间，总算有些入门的感觉，明白大致的编写流程。<br>　　对于在React项目中使用redux，首先需要理解<code>展示型组件和容器型组件</code>。<br>　　简单来说，展示型组件用于对展示页面，数据通过<code>props</code>获得，只有容器型组件与redux交道。一般情况下，容器型组件通过redux的<code>connect</code>函数获得state，以及action，然后调用展示型组件并通过<code>props</code>传递所需要的state和action。展示型组件需要修改state就通过容器型组件传递过来的action调用。<br>eg<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Login.js  Login组件 (此为容器组件)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 通过connect传递state中的userData和user action</span></div><div class=\"line\">@connect(</div><div class=\"line\">  <span class=\"function\">(<span class=\"params\">&#123;userData&#125;</span>) =&gt;</span> (&#123;userData&#125;),</div><div class=\"line\">  <span class=\"built_in\">require</span>(<span class=\"string\">'ACTION/user'</span>).default</div><div class=\"line\">)</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Login</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">\trender() &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> (</div><div class=\"line\">        <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"login-content\"</span>&gt;</span></div><div class=\"line\">      \t\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"login\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">className</span>=<span class=\"string\">\"login-close\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"user\"</span>&gt;</span>&amp;times;<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">            &#123;/* 调用LoginForm组件，并把user action中的login方法通过props传递给LoginForm组件 */&#125;</div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">LoginForm</span></div><div class=\"line\">              <span class=\"attr\">toLogin</span> = <span class=\"string\">&#123;</span> <span class=\"attr\">this.props.login</span> &#125;</div><div class=\"line\">            &gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">LoginForm</span>&gt;</span></div><div class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">\t\t\t);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// LoginForm.js  LoginForm组件 (此为展示组件)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginForm</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">constructor</span> (props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handleClick() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> username = <span class=\"keyword\">this</span>.refs.username.value;</div><div class=\"line\">    <span class=\"keyword\">let</span> password = <span class=\"keyword\">this</span>.refs.password.value;</div><div class=\"line\">    <span class=\"comment\">// 对输入的处理</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(username == <span class=\"string\">''</span> || password == <span class=\"string\">''</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> alert(<span class=\"string\">'请输入用户名和密码'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 调用redux action来修改state</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.toLogin(username, password);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> (</div><div class=\"line\">        &lt;div className=\"login-form\"&gt;</div><div class=\"line\">          &lt;from&gt;</div><div class=\"line\">            &lt;input className=\"username-input\" type=\"text\" placeholder=\"用户名\"</div><div class=\"line\">              ref=\"username\"</div><div class=\"line\">            /&gt;</div><div class=\"line\">            &lt;input className=\"password-input\" type=\"password\" placeholder=\"密码\"</div><div class=\"line\">              ref=\"password\"</div><div class=\"line\">            /&gt;</div><div class=\"line\">            &lt;submit className=\"submit-btn\" onClick=&#123; this.handleClick &#125;&gt;进入头条&lt;/submit&gt;</div><div class=\"line\">          &lt;/from&gt;</div><div class=\"line\">        &lt;/div&gt;</div><div class=\"line\">\t\t\t);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>#####</p>\n<p>关于action, reducer, store的编写，需要明白这个流程：</p>\n<pre><code>1. dispatch()用于触发action，参数为具体action(actionCreate其实也是产生一个action)。\n2. 当有action被触发时，就会去store中查询注册的reducer(通过action.type查找),并执行该reducer返回新的state。\n</code></pre><p>所以我们需要做的：</p>\n<pre><code>1. 编写reducer，参数为(initstate, action)，(一般样式为switch(action.type))。\n2. 合并reducer，主要目的是可以将reducer分成多个编写，更方便管理和理解。\n3. 编写store，注册reducer到store中，这里一般都会添加redux的中间件。\nps:\n应该是最先编写action，包括action type常量定义，可以用于action create和reducer；action create函数；action dispatch函数。函数位置具体怎么分，各有所爱吧。\n</code></pre>"},{"title":"一次H5页面","date":"2016-08-02T16:00:00.000Z","comments":1,"_content":"\n任务：环球网-2016七夕H5页面  \n环境：swiper插件，gulp及相关常用工具。\n\n---\n\n### 适配\n使用的还是lib-flexible那套解决方案，需要查看的可以点击[这里](https://github.com/amfe/lib-flexible)  \n### 使用swiper\n使用swiper页面的控制以及滑动功能就变得非常容易，可以参见[Swiper中文网](http://www.swiper.com.cn/)，其中添加给类名添加`swiper-slide`即可表示一页。  \n在Swiper实例化中，属性`direction`可以定义横向/竖向滑动，`nextButton`可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在`onSlideChangeStart`中不能够出发`slideTo()`方法。  \nSwiper还有许多其他功能，可以参见[Swiper中文网](http://www.swiper.com.cn/)中API。\n\n### ES6的使用\nES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是`gulp-babel`。\n\n### 目录、git以及gulp相关\n目录和之前的项目目录基本相同。\n```\n.\n├── .eslintrc.json\n├── .gitignore\n├── dist\n│   ├── css\n│   ├── imgs\n│   ├── js\n│   └── libs\n├── gulpfile.js\n├── index.html\n├── node_modules\n├── package.json\n├── psd\n└── src\n    ├── ES6\n    ├── css\n    ├── imgs\n    ├── js\n    ├── libs\n    └── sass\n```\ndist目录存放合并、压缩的代码，用于上线使用。(自动生成)  \nsrc目录存放源文件。  \nnode_modules目录存放用到的node工具。(自动生成)  \npsd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。  \n相比之前增加的文件：\n\n*  .eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看[这里](https://segmentfault.com/a/1190000004468428)。\n*  .gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。\n```\n/node_modules/\n/psd/\n```\n* src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。\n\ngit开始学习使用分支处理bug、添加尝试性功能等。\n\n### 坑是用来爬的\n#### 最经典的坑——this\n在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过`fn.bind(this)`来指向想要的this，在旧版本浏览器下需要使用兼容写法。\n\n#### 省事也被坑——autoprefixer\nautoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是`remove`，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。  \nandriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。\n\n#### 没想到的坑——微信分享\n关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。  \n问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中`mqq.data.setShareInfo`可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。\n\n### 其他\n#### 自定义单选框\n自定义单选框并没有想象中的那么难，除了`<input type=\"radio\">`外，还有个label标签和after伪类。  \n设置css`[type=radio]: display: none;`，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)\n\n#### 文字居中\n要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。\n\n#### 横屏问题\n我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。\n\n### 改进\n需要改进的东西就太多太多了。 \n \n* 最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。\n* 图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。\n* 动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。","source":"_posts/一次H5页面.md","raw":"---\ntitle: 一次H5页面\ndate: 2016-08-03\ntags: [JavaScript, H5]\ncategories: \n- H5\ncomments: true\n---\n\n任务：环球网-2016七夕H5页面  \n环境：swiper插件，gulp及相关常用工具。\n\n---\n\n### 适配\n使用的还是lib-flexible那套解决方案，需要查看的可以点击[这里](https://github.com/amfe/lib-flexible)  \n### 使用swiper\n使用swiper页面的控制以及滑动功能就变得非常容易，可以参见[Swiper中文网](http://www.swiper.com.cn/)，其中添加给类名添加`swiper-slide`即可表示一页。  \n在Swiper实例化中，属性`direction`可以定义横向/竖向滑动，`nextButton`可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在`onSlideChangeStart`中不能够出发`slideTo()`方法。  \nSwiper还有许多其他功能，可以参见[Swiper中文网](http://www.swiper.com.cn/)中API。\n\n### ES6的使用\nES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是`gulp-babel`。\n\n### 目录、git以及gulp相关\n目录和之前的项目目录基本相同。\n```\n.\n├── .eslintrc.json\n├── .gitignore\n├── dist\n│   ├── css\n│   ├── imgs\n│   ├── js\n│   └── libs\n├── gulpfile.js\n├── index.html\n├── node_modules\n├── package.json\n├── psd\n└── src\n    ├── ES6\n    ├── css\n    ├── imgs\n    ├── js\n    ├── libs\n    └── sass\n```\ndist目录存放合并、压缩的代码，用于上线使用。(自动生成)  \nsrc目录存放源文件。  \nnode_modules目录存放用到的node工具。(自动生成)  \npsd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。  \n相比之前增加的文件：\n\n*  .eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看[这里](https://segmentfault.com/a/1190000004468428)。\n*  .gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。\n```\n/node_modules/\n/psd/\n```\n* src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。\n\ngit开始学习使用分支处理bug、添加尝试性功能等。\n\n### 坑是用来爬的\n#### 最经典的坑——this\n在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过`fn.bind(this)`来指向想要的this，在旧版本浏览器下需要使用兼容写法。\n\n#### 省事也被坑——autoprefixer\nautoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是`remove`，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。  \nandriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。\n\n#### 没想到的坑——微信分享\n关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。  \n问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中`mqq.data.setShareInfo`可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。\n\n### 其他\n#### 自定义单选框\n自定义单选框并没有想象中的那么难，除了`<input type=\"radio\">`外，还有个label标签和after伪类。  \n设置css`[type=radio]: display: none;`，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)\n\n#### 文字居中\n要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。\n\n#### 横屏问题\n我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。\n\n### 改进\n需要改进的东西就太多太多了。 \n \n* 最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。\n* 图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。\n* 动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。","slug":"一次H5页面","published":1,"updated":"2017-03-22T01:22:13.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8khr000yohfksud2c94r","content":"<p>任务：环球网-2016七夕H5页面<br>环境：swiper插件，gulp及相关常用工具。</p>\n<hr>\n<h3 id=\"适配\"><a href=\"#适配\" class=\"headerlink\" title=\"适配\"></a>适配</h3><p>使用的还是lib-flexible那套解决方案，需要查看的可以点击<a href=\"https://github.com/amfe/lib-flexible\" target=\"_blank\" rel=\"external\">这里</a>  </p>\n<h3 id=\"使用swiper\"><a href=\"#使用swiper\" class=\"headerlink\" title=\"使用swiper\"></a>使用swiper</h3><p>使用swiper页面的控制以及滑动功能就变得非常容易，可以参见<a href=\"http://www.swiper.com.cn/\" target=\"_blank\" rel=\"external\">Swiper中文网</a>，其中添加给类名添加<code>swiper-slide</code>即可表示一页。<br>在Swiper实例化中，属性<code>direction</code>可以定义横向/竖向滑动，<code>nextButton</code>可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在<code>onSlideChangeStart</code>中不能够出发<code>slideTo()</code>方法。<br>Swiper还有许多其他功能，可以参见<a href=\"http://www.swiper.com.cn/\" target=\"_blank\" rel=\"external\">Swiper中文网</a>中API。</p>\n<h3 id=\"ES6的使用\"><a href=\"#ES6的使用\" class=\"headerlink\" title=\"ES6的使用\"></a>ES6的使用</h3><p>ES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是<code>gulp-babel</code>。</p>\n<h3 id=\"目录、git以及gulp相关\"><a href=\"#目录、git以及gulp相关\" class=\"headerlink\" title=\"目录、git以及gulp相关\"></a>目录、git以及gulp相关</h3><p>目录和之前的项目目录基本相同。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── <span class=\"selector-class\">.eslintrc</span><span class=\"selector-class\">.json</span></div><div class=\"line\">├── <span class=\"selector-class\">.gitignore</span></div><div class=\"line\">├── dist</div><div class=\"line\">│   ├── css</div><div class=\"line\">│   ├── imgs</div><div class=\"line\">│   ├── js</div><div class=\"line\">│   └── libs</div><div class=\"line\">├── gulpfile<span class=\"selector-class\">.js</span></div><div class=\"line\">├── index<span class=\"selector-class\">.html</span></div><div class=\"line\">├── node_modules</div><div class=\"line\">├── package<span class=\"selector-class\">.json</span></div><div class=\"line\">├── psd</div><div class=\"line\">└── src</div><div class=\"line\">    ├── ES6</div><div class=\"line\">    ├── css</div><div class=\"line\">    ├── imgs</div><div class=\"line\">    ├── js</div><div class=\"line\">    ├── libs</div><div class=\"line\">    └── sass</div></pre></td></tr></table></figure></p>\n<p>dist目录存放合并、压缩的代码，用于上线使用。(自动生成)<br>src目录存放源文件。<br>node_modules目录存放用到的node工具。(自动生成)<br>psd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。<br>相比之前增加的文件：</p>\n<ul>\n<li>.eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看<a href=\"https://segmentfault.com/a/1190000004468428\" target=\"_blank\" rel=\"external\">这里</a>。</li>\n<li><p>.gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"regexp\">/node_modules/</span></div><div class=\"line\"><span class=\"regexp\">/psd/</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。</p>\n</li>\n</ul>\n<p>git开始学习使用分支处理bug、添加尝试性功能等。</p>\n<h3 id=\"坑是用来爬的\"><a href=\"#坑是用来爬的\" class=\"headerlink\" title=\"坑是用来爬的\"></a>坑是用来爬的</h3><h4 id=\"最经典的坑——this\"><a href=\"#最经典的坑——this\" class=\"headerlink\" title=\"最经典的坑——this\"></a>最经典的坑——this</h4><p>在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过<code>fn.bind(this)</code>来指向想要的this，在旧版本浏览器下需要使用兼容写法。</p>\n<h4 id=\"省事也被坑——autoprefixer\"><a href=\"#省事也被坑——autoprefixer\" class=\"headerlink\" title=\"省事也被坑——autoprefixer\"></a>省事也被坑——autoprefixer</h4><p>autoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是<code>remove</code>，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。<br>andriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。</p>\n<h4 id=\"没想到的坑——微信分享\"><a href=\"#没想到的坑——微信分享\" class=\"headerlink\" title=\"没想到的坑——微信分享\"></a>没想到的坑——微信分享</h4><p>关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。<br>问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中<code>mqq.data.setShareInfo</code>可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"自定义单选框\"><a href=\"#自定义单选框\" class=\"headerlink\" title=\"自定义单选框\"></a>自定义单选框</h4><p>自定义单选框并没有想象中的那么难，除了<code>&lt;input type=&quot;radio&quot;&gt;</code>外，还有个label标签和after伪类。<br>设置css<code>[type=radio]: display: none;</code>，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)</p>\n<h4 id=\"文字居中\"><a href=\"#文字居中\" class=\"headerlink\" title=\"文字居中\"></a>文字居中</h4><p>要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。</p>\n<h4 id=\"横屏问题\"><a href=\"#横屏问题\" class=\"headerlink\" title=\"横屏问题\"></a>横屏问题</h4><p>我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。</p>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>需要改进的东西就太多太多了。 </p>\n<ul>\n<li>最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。</li>\n<li>图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。</li>\n<li>动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。</li>\n</ul>\n","excerpt":"","more":"<p>任务：环球网-2016七夕H5页面<br>环境：swiper插件，gulp及相关常用工具。</p>\n<hr>\n<h3 id=\"适配\"><a href=\"#适配\" class=\"headerlink\" title=\"适配\"></a>适配</h3><p>使用的还是lib-flexible那套解决方案，需要查看的可以点击<a href=\"https://github.com/amfe/lib-flexible\">这里</a>  </p>\n<h3 id=\"使用swiper\"><a href=\"#使用swiper\" class=\"headerlink\" title=\"使用swiper\"></a>使用swiper</h3><p>使用swiper页面的控制以及滑动功能就变得非常容易，可以参见<a href=\"http://www.swiper.com.cn/\">Swiper中文网</a>，其中添加给类名添加<code>swiper-slide</code>即可表示一页。<br>在Swiper实例化中，属性<code>direction</code>可以定义横向/竖向滑动，<code>nextButton</code>可以定义下一页按钮的选择器。onSlideChangeStart/onSlideChangeEnd事件中，可以定义滑动屏幕触发事件，一个表示页面变化开始，一个表示页面已经变化完成。在<code>onSlideChangeStart</code>中不能够出发<code>slideTo()</code>方法。<br>Swiper还有许多其他功能，可以参见<a href=\"http://www.swiper.com.cn/\">Swiper中文网</a>中API。</p>\n<h3 id=\"ES6的使用\"><a href=\"#ES6的使用\" class=\"headerlink\" title=\"ES6的使用\"></a>ES6的使用</h3><p>ES6对于我这次来说主要使用是Class、let以及箭头函数等，Class和箭头函数应该属于语法糖，可以使得代码更加干净整洁。对于ES6的编译使用的是<code>gulp-babel</code>。</p>\n<h3 id=\"目录、git以及gulp相关\"><a href=\"#目录、git以及gulp相关\" class=\"headerlink\" title=\"目录、git以及gulp相关\"></a>目录、git以及gulp相关</h3><p>目录和之前的项目目录基本相同。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── <span class=\"selector-class\">.eslintrc</span><span class=\"selector-class\">.json</span></div><div class=\"line\">├── <span class=\"selector-class\">.gitignore</span></div><div class=\"line\">├── dist</div><div class=\"line\">│   ├── css</div><div class=\"line\">│   ├── imgs</div><div class=\"line\">│   ├── js</div><div class=\"line\">│   └── libs</div><div class=\"line\">├── gulpfile<span class=\"selector-class\">.js</span></div><div class=\"line\">├── index<span class=\"selector-class\">.html</span></div><div class=\"line\">├── node_modules</div><div class=\"line\">├── package<span class=\"selector-class\">.json</span></div><div class=\"line\">├── psd</div><div class=\"line\">└── src</div><div class=\"line\">    ├── ES6</div><div class=\"line\">    ├── css</div><div class=\"line\">    ├── imgs</div><div class=\"line\">    ├── js</div><div class=\"line\">    ├── libs</div><div class=\"line\">    └── sass</div></pre></td></tr></table></figure></p>\n<p>dist目录存放合并、压缩的代码，用于上线使用。(自动生成)<br>src目录存放源文件。<br>node_modules目录存放用到的node工具。(自动生成)<br>psd目录其实存放的不仅仅是psd文件，还有项目设计的各种文件。<br>相比之前增加的文件：</p>\n<ul>\n<li>.eslintrc.json：这是eslint的配置文件，用于检测代码的错误以及格式，配置项巨多，可以参看<a href=\"https://segmentfault.com/a/1190000004468428\">这里</a>。</li>\n<li><p>.gitignore：之前一直没用这个，很多功能就是一点点发现的，原谅我之前上传的代码。其中的内容就两行。但是还是很重要的，不要像我一样蠢:joy:。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"regexp\">/node_modules/</span></div><div class=\"line\"><span class=\"regexp\">/psd/</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>src/ES6/：存放ES6代码。其实是为了便于学习，先将ES6编译好的代码输出到/src/js/目录下，然后再压缩到/dist/js/目录下。和/src/sass/ /src/css/文件夹一样。</p>\n</li>\n</ul>\n<p>git开始学习使用分支处理bug、添加尝试性功能等。</p>\n<h3 id=\"坑是用来爬的\"><a href=\"#坑是用来爬的\" class=\"headerlink\" title=\"坑是用来爬的\"></a>坑是用来爬的</h3><h4 id=\"最经典的坑——this\"><a href=\"#最经典的坑——this\" class=\"headerlink\" title=\"最经典的坑——this\"></a>最经典的坑——this</h4><p>在使用setTimeout、setInterval调用函数的时候，this的指向会指向window。可以通过<code>fn.bind(this)</code>来指向想要的this，在旧版本浏览器下需要使用兼容写法。</p>\n<h4 id=\"省事也被坑——autoprefixer\"><a href=\"#省事也被坑——autoprefixer\" class=\"headerlink\" title=\"省事也被坑——autoprefixer\"></a>省事也被坑——autoprefixer</h4><p>autoprefixer可以根据配置自动添加浏览器前缀，但是他还有个配置项是<code>remove</code>，默认配置是true，表示会移除不必要的前缀。既然用了autoprefixer，肯定是不会自己再去手动写前缀的，既然是手动写了前缀，那么肯定是autoprefixer没有加上去，而项目中需要兼容的。但是这个默认配置会帮你把手动加上去的前缀移除，然后容许我哭一会:sob:。<br>andriod浏览器中animation以及keyframes需要添加前缀-webkit-，但是autoprefixer没有添加，不知道是不是我配置有问题。</p>\n<h4 id=\"没想到的坑——微信分享\"><a href=\"#没想到的坑——微信分享\" class=\"headerlink\" title=\"没想到的坑——微信分享\"></a>没想到的坑——微信分享</h4><p>关于微信分享的坑，其实很多公司都没有完全解决，应该是因为影响也不是特别大，就没有去研究解决。毕竟这个应该属于腾讯的问题，哪天企鹅一抽风，再调整规则，研究就白做了。<br>问题其实就是微信、QQ应用之间的分享，比如从微信分享到QQ好友或空间，从QQ分享到微信好友或朋友圈，分享标题、描述、图标会存在问题。 通过同时设置微信JS-SDK已经手机QQ中<code>mqq.data.setShareInfo</code>可以实现IOS端正常，但是安卓从微信分享到QQ貌似是有问题的。具体可以看(这里)[]。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"自定义单选框\"><a href=\"#自定义单选框\" class=\"headerlink\" title=\"自定义单选框\"></a>自定义单选框</h4><p>自定义单选框并没有想象中的那么难，除了<code>&lt;input type=&quot;radio&quot;&gt;</code>外，还有个label标签和after伪类。<br>设置css<code>[type=radio]: display: none;</code>，对应label设置为未选中样式，添加after添加选中样式。(ps：最终因为产品经理一句话，又改用了按钮)</p>\n<h4 id=\"文字居中\"><a href=\"#文字居中\" class=\"headerlink\" title=\"文字居中\"></a>文字居中</h4><p>要实现的效果是对话框中文字居中，对话的文字字数不固定，感觉纯粹靠着自己一点一点的调整padding，单位使用的是rem。不知道有没有更好的方法。</p>\n<h4 id=\"横屏问题\"><a href=\"#横屏问题\" class=\"headerlink\" title=\"横屏问题\"></a>横屏问题</h4><p>我承认我偷懒了，这里都没有解决好。因为所做H5页面不太方便适配横屏，想到的最好的解决办法是锁定竖屏，只是最后我也没能找到相关信息，更多应该还是需要看用户。</p>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>需要改进的东西就太多太多了。 </p>\n<ul>\n<li>最基本的，因为用到背景音乐，图片也比较多，应该添加加载页面。</li>\n<li>图片过多，其实有一些图片应该可以使用svg来替代，这样可以减小一部分流量，提高加载速度。</li>\n<li>动效过少，整个给我的感觉就是一大堆图片，自己都看不下去了。</li>\n</ul>\n"},{"title":"一次麻烦的投票","date":"2016-10-30T16:00:00.000Z","comments":1,"_content":"\n刚开始接到任务只是一个将一个之前的页面进行修改，没想到遇到了各种问题。  \n\n### 1. 三角形照片以及遮盖层。\n三角形的实现网上面试题、技术贴也常看到，第一反应就是使用border来实现三角形。使用border来实现三角形还是很方便的。只需要根据三角形的各边给4个border不同的值即可实现。但是这种方法更多的是单色的三角形图标，好像没办法实现三角形照片。只能另找他法。  \n搜索下找到了变换方法，使用的是rotate和skew。需要两层div，先是外层div旋转45度，然后里层div沿X、Y轴倾斜相同度数，就可以生成一个菱形，如果遮住一半即可生成三角形。图片呢，就是放在内层div中，然后在旋转-45度并且倾斜负的里层div旋转度数，使得形成图片正常方形。如下：\n```html\n<div class=\"row\">\n  <div class=\"a\">\n    <div class=\"b\">\n      <img src=\"\" alt=\"\">\n      <div class=\"cover\"></div>\n    </div>\n  </div>\n</div>\n```\n```css\n.a {\n  float: left;\n  transform: rotate(45deg);\n}\n.b {\n  width: 217.1px;\n  height: 217.1px;\n  transform: skew(10deg, 10deg);\n  background: #000;\n}\n```\n.row是用来遮盖菱形上或下半部分形成三角形，img标签和.cover使用绝对定位相对于.row，使得正好将三角形覆盖，.cover中的内容使用margin以及width，使内容正好居中。效果如下：\n<img src=\"images/triangles.png\" alt=\"\">\n\n实现的缺点是IE8即以下不兼容，并且绝对定位因为变换不是特别好调整位置，最后是选择上传图片直接使用三角形图片，IE8以下使用另一套绝对定位，但是遮盖层还是会方形显示。\n\n### 2. 投票功能\n投票系统主要两个麻烦，一个是跨域问题，一个是投票的限制问题。因为投票系统是西安部门进行开发的，是刚开发不久的系统，而且是个问卷系统，并没有充分考虑投票这方面的限制，以及投票成功的反馈。投票的限制前端可以做的应该就是使用localstorage或者cookie来进行一部分限制，更多限制应该还是后端来做支持。跨域问题，GET方法可以使用jsonp很容易解决，但是对于POST就不是特别清晰，我们这边后端做限制的支持，就将投票也改成了GET请求。  \n其实这里的反馈并不怎么好，网速慢的话可能会造成点击没有任何反馈。所以就前端点击，直接投票技术+1，并且投票的心形变成红色，然后请求后端。如果发生错误，提示刷新页面就可以重新投票。","source":"_posts/一次麻烦的投票.md","raw":"---\ntitle: 一次麻烦的投票\ndate: 2016-10-31\ntags: [JavaScript, 项目经验]\ncategories:\n- JavaScript\ncomments: true\n---\n\n刚开始接到任务只是一个将一个之前的页面进行修改，没想到遇到了各种问题。  \n\n### 1. 三角形照片以及遮盖层。\n三角形的实现网上面试题、技术贴也常看到，第一反应就是使用border来实现三角形。使用border来实现三角形还是很方便的。只需要根据三角形的各边给4个border不同的值即可实现。但是这种方法更多的是单色的三角形图标，好像没办法实现三角形照片。只能另找他法。  \n搜索下找到了变换方法，使用的是rotate和skew。需要两层div，先是外层div旋转45度，然后里层div沿X、Y轴倾斜相同度数，就可以生成一个菱形，如果遮住一半即可生成三角形。图片呢，就是放在内层div中，然后在旋转-45度并且倾斜负的里层div旋转度数，使得形成图片正常方形。如下：\n```html\n<div class=\"row\">\n  <div class=\"a\">\n    <div class=\"b\">\n      <img src=\"\" alt=\"\">\n      <div class=\"cover\"></div>\n    </div>\n  </div>\n</div>\n```\n```css\n.a {\n  float: left;\n  transform: rotate(45deg);\n}\n.b {\n  width: 217.1px;\n  height: 217.1px;\n  transform: skew(10deg, 10deg);\n  background: #000;\n}\n```\n.row是用来遮盖菱形上或下半部分形成三角形，img标签和.cover使用绝对定位相对于.row，使得正好将三角形覆盖，.cover中的内容使用margin以及width，使内容正好居中。效果如下：\n<img src=\"images/triangles.png\" alt=\"\">\n\n实现的缺点是IE8即以下不兼容，并且绝对定位因为变换不是特别好调整位置，最后是选择上传图片直接使用三角形图片，IE8以下使用另一套绝对定位，但是遮盖层还是会方形显示。\n\n### 2. 投票功能\n投票系统主要两个麻烦，一个是跨域问题，一个是投票的限制问题。因为投票系统是西安部门进行开发的，是刚开发不久的系统，而且是个问卷系统，并没有充分考虑投票这方面的限制，以及投票成功的反馈。投票的限制前端可以做的应该就是使用localstorage或者cookie来进行一部分限制，更多限制应该还是后端来做支持。跨域问题，GET方法可以使用jsonp很容易解决，但是对于POST就不是特别清晰，我们这边后端做限制的支持，就将投票也改成了GET请求。  \n其实这里的反馈并不怎么好，网速慢的话可能会造成点击没有任何反馈。所以就前端点击，直接投票技术+1，并且投票的心形变成红色，然后请求后端。如果发生错误，提示刷新页面就可以重新投票。","slug":"一次麻烦的投票","published":1,"updated":"2017-03-22T01:22:16.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8khu0011ohfkakfwmjug","content":"<p>刚开始接到任务只是一个将一个之前的页面进行修改，没想到遇到了各种问题。  </p>\n<h3 id=\"1-三角形照片以及遮盖层。\"><a href=\"#1-三角形照片以及遮盖层。\" class=\"headerlink\" title=\"1. 三角形照片以及遮盖层。\"></a>1. 三角形照片以及遮盖层。</h3><p>三角形的实现网上面试题、技术贴也常看到，第一反应就是使用border来实现三角形。使用border来实现三角形还是很方便的。只需要根据三角形的各边给4个border不同的值即可实现。但是这种方法更多的是单色的三角形图标，好像没办法实现三角形照片。只能另找他法。<br>搜索下找到了变换方法，使用的是rotate和skew。需要两层div，先是外层div旋转45度，然后里层div沿X、Y轴倾斜相同度数，就可以生成一个菱形，如果遮住一半即可生成三角形。图片呢，就是放在内层div中，然后在旋转-45度并且倾斜负的里层div旋转度数，使得形成图片正常方形。如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"a\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"b\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cover\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.a</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">float</span>: left;</div><div class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(45deg);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.b</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">217.1px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">217.1px</span>;</div><div class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">skew</span>(10deg, 10deg);</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#000</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>.row是用来遮盖菱形上或下半部分形成三角形，img标签和.cover使用绝对定位相对于.row，使得正好将三角形覆盖，.cover中的内容使用margin以及width，使内容正好居中。效果如下：<br><img src=\"images/triangles.png\" alt=\"\"></p>\n<p>实现的缺点是IE8即以下不兼容，并且绝对定位因为变换不是特别好调整位置，最后是选择上传图片直接使用三角形图片，IE8以下使用另一套绝对定位，但是遮盖层还是会方形显示。</p>\n<h3 id=\"2-投票功能\"><a href=\"#2-投票功能\" class=\"headerlink\" title=\"2. 投票功能\"></a>2. 投票功能</h3><p>投票系统主要两个麻烦，一个是跨域问题，一个是投票的限制问题。因为投票系统是西安部门进行开发的，是刚开发不久的系统，而且是个问卷系统，并没有充分考虑投票这方面的限制，以及投票成功的反馈。投票的限制前端可以做的应该就是使用localstorage或者cookie来进行一部分限制，更多限制应该还是后端来做支持。跨域问题，GET方法可以使用jsonp很容易解决，但是对于POST就不是特别清晰，我们这边后端做限制的支持，就将投票也改成了GET请求。<br>其实这里的反馈并不怎么好，网速慢的话可能会造成点击没有任何反馈。所以就前端点击，直接投票技术+1，并且投票的心形变成红色，然后请求后端。如果发生错误，提示刷新页面就可以重新投票。</p>\n","excerpt":"","more":"<p>刚开始接到任务只是一个将一个之前的页面进行修改，没想到遇到了各种问题。  </p>\n<h3 id=\"1-三角形照片以及遮盖层。\"><a href=\"#1-三角形照片以及遮盖层。\" class=\"headerlink\" title=\"1. 三角形照片以及遮盖层。\"></a>1. 三角形照片以及遮盖层。</h3><p>三角形的实现网上面试题、技术贴也常看到，第一反应就是使用border来实现三角形。使用border来实现三角形还是很方便的。只需要根据三角形的各边给4个border不同的值即可实现。但是这种方法更多的是单色的三角形图标，好像没办法实现三角形照片。只能另找他法。<br>搜索下找到了变换方法，使用的是rotate和skew。需要两层div，先是外层div旋转45度，然后里层div沿X、Y轴倾斜相同度数，就可以生成一个菱形，如果遮住一半即可生成三角形。图片呢，就是放在内层div中，然后在旋转-45度并且倾斜负的里层div旋转度数，使得形成图片正常方形。如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"a\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"b\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cover\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.a</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">float</span>: left;</div><div class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(45deg);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.b</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">217.1px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">217.1px</span>;</div><div class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">skew</span>(10deg, 10deg);</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#000</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>.row是用来遮盖菱形上或下半部分形成三角形，img标签和.cover使用绝对定位相对于.row，使得正好将三角形覆盖，.cover中的内容使用margin以及width，使内容正好居中。效果如下：<br><img src=\"images/triangles.png\" alt=\"\"></p>\n<p>实现的缺点是IE8即以下不兼容，并且绝对定位因为变换不是特别好调整位置，最后是选择上传图片直接使用三角形图片，IE8以下使用另一套绝对定位，但是遮盖层还是会方形显示。</p>\n<h3 id=\"2-投票功能\"><a href=\"#2-投票功能\" class=\"headerlink\" title=\"2. 投票功能\"></a>2. 投票功能</h3><p>投票系统主要两个麻烦，一个是跨域问题，一个是投票的限制问题。因为投票系统是西安部门进行开发的，是刚开发不久的系统，而且是个问卷系统，并没有充分考虑投票这方面的限制，以及投票成功的反馈。投票的限制前端可以做的应该就是使用localstorage或者cookie来进行一部分限制，更多限制应该还是后端来做支持。跨域问题，GET方法可以使用jsonp很容易解决，但是对于POST就不是特别清晰，我们这边后端做限制的支持，就将投票也改成了GET请求。<br>其实这里的反馈并不怎么好，网速慢的话可能会造成点击没有任何反馈。所以就前端点击，直接投票技术+1，并且投票的心形变成红色，然后请求后端。如果发生错误，提示刷新页面就可以重新投票。</p>\n"},{"title":"为gulp添加更多","date":"2016-07-22T16:00:00.000Z","comments":1,"_content":"\n有了之前的gulp经验，使用其他gulp工具就是很简单的工作了。\n\n> ps:\t以下代码前均包含`var gulp = require('gulp')`\n\n> 类似`sass()`表示前面包含`var sass = require('gulp-sass')`\n\n--------------\n\n[gulp-autoprefixer](https://www.npmjs.com/package/gulp-autoprefixer)：应该属于css后处理工具，在编写css完成之后，会根据我们的配置自动按需添加浏览器前缀。\n\n任务事例：\n```javascript\ngulp.task('sass', function() {\n\treturn gulp.src('src/sass/*.scss')\n\t\t\t\t\t.pipe(sass())\n\t\t\t\t\t.pipe(autoprefixer('last 2 versions', 'ios 6', 'android 4'))\t//autoprefixer\n\t\t\t\t\t.pipe(gulp.dest('src/css'))\n\t\t\t\t\t.pipe(cleanCSS())\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//css压缩工具，前面介绍有\n\t\t\t\t\t.pipe(gulp.dest('dist/css'))\n});\n```\n其中`autoprefixer('...','...','...')`为简写形式，其中`last 2 versions`表示兼容所有浏览器最新两个版本。\n完整形式应该为`autoprefixer({ \n\tbrowsers: ['last 2 versions', 'ios 6'],\n\tcascade: true\n})`\n\n***\n\n[gulp-imagemin](https://www.npmjs.com/package/gulp-imagemin):图片压缩工具。\n\n任务事例：\n```javascript\ngulp.task('imageMin', function() {\n\tgulp.src('src/img/*')\n\t\t.pipe(imagemin())\n\t\t.pipe(gulp.dest('dist/img'));\n});\n```\n对于imagemin()进行图片压缩，可以结合使用`gulp-cache`对图片进行缓存。具体用法，我也没研究太懂 :joy:\n\n***\n\n[browser-sync](https://www.npmjs.com/package/browser-sync):属于综合测试的工具，可以实现页面自动刷新、多屏同步操作等功能。\n\n任务实例：\n```javascript\n//首先browser-sync的引用，官方推荐使用create()方法\nvar browserSync = require('browser-sync').create();\n\ngulp.task('serve', ['sass'], function() {\n\tbrowserSync.init({\n\t\tserver: './'\n\t});\n\n\tgulp.watch('src/sass/*.scss', ['sass']);\n\tgulp.watch('*.html').on('change', browserSync.reload);\n});\n```\n其中`server: './'`会将当前目录作为服务器访问地址<br/>\n`gulp.watch('src/sass/*.scss', ['sass'])`会监听*.scss文件，执行`sass`任务，并且实时反应到浏览器上。\n`gulp.watch('*.html').on('change', browserSync.reload)`不同之处在于，会执行reload方法，重新加载页面。\n\n--------\n\n对于工具，我觉得更多的是直接拿过来使用，而不是非要去研究清楚每个API的作用。当然，特别感兴趣的也可以尝试研究工具，甚至是自己动手去制造这些工具。","source":"_posts/为gulp添加更多.md","raw":"---\ntitle: 为gulp添加更多\ndate: 2016-07-23\ntags: [JavaScript, 构建工具, gulp]\ncategories: \n- JavaScript\ncomments: true\n---\n\n有了之前的gulp经验，使用其他gulp工具就是很简单的工作了。\n\n> ps:\t以下代码前均包含`var gulp = require('gulp')`\n\n> 类似`sass()`表示前面包含`var sass = require('gulp-sass')`\n\n--------------\n\n[gulp-autoprefixer](https://www.npmjs.com/package/gulp-autoprefixer)：应该属于css后处理工具，在编写css完成之后，会根据我们的配置自动按需添加浏览器前缀。\n\n任务事例：\n```javascript\ngulp.task('sass', function() {\n\treturn gulp.src('src/sass/*.scss')\n\t\t\t\t\t.pipe(sass())\n\t\t\t\t\t.pipe(autoprefixer('last 2 versions', 'ios 6', 'android 4'))\t//autoprefixer\n\t\t\t\t\t.pipe(gulp.dest('src/css'))\n\t\t\t\t\t.pipe(cleanCSS())\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//css压缩工具，前面介绍有\n\t\t\t\t\t.pipe(gulp.dest('dist/css'))\n});\n```\n其中`autoprefixer('...','...','...')`为简写形式，其中`last 2 versions`表示兼容所有浏览器最新两个版本。\n完整形式应该为`autoprefixer({ \n\tbrowsers: ['last 2 versions', 'ios 6'],\n\tcascade: true\n})`\n\n***\n\n[gulp-imagemin](https://www.npmjs.com/package/gulp-imagemin):图片压缩工具。\n\n任务事例：\n```javascript\ngulp.task('imageMin', function() {\n\tgulp.src('src/img/*')\n\t\t.pipe(imagemin())\n\t\t.pipe(gulp.dest('dist/img'));\n});\n```\n对于imagemin()进行图片压缩，可以结合使用`gulp-cache`对图片进行缓存。具体用法，我也没研究太懂 :joy:\n\n***\n\n[browser-sync](https://www.npmjs.com/package/browser-sync):属于综合测试的工具，可以实现页面自动刷新、多屏同步操作等功能。\n\n任务实例：\n```javascript\n//首先browser-sync的引用，官方推荐使用create()方法\nvar browserSync = require('browser-sync').create();\n\ngulp.task('serve', ['sass'], function() {\n\tbrowserSync.init({\n\t\tserver: './'\n\t});\n\n\tgulp.watch('src/sass/*.scss', ['sass']);\n\tgulp.watch('*.html').on('change', browserSync.reload);\n});\n```\n其中`server: './'`会将当前目录作为服务器访问地址<br/>\n`gulp.watch('src/sass/*.scss', ['sass'])`会监听*.scss文件，执行`sass`任务，并且实时反应到浏览器上。\n`gulp.watch('*.html').on('change', browserSync.reload)`不同之处在于，会执行reload方法，重新加载页面。\n\n--------\n\n对于工具，我觉得更多的是直接拿过来使用，而不是非要去研究清楚每个API的作用。当然，特别感兴趣的也可以尝试研究工具，甚至是自己动手去制造这些工具。","slug":"为gulp添加更多","published":1,"updated":"2017-03-22T01:22:11.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8khy0015ohfknp5mivwm","content":"<p>有了之前的gulp经验，使用其他gulp工具就是很简单的工作了。</p>\n<blockquote>\n<p>ps:    以下代码前均包含<code>var gulp = require(&#39;gulp&#39;)</code></p>\n<p>类似<code>sass()</code>表示前面包含<code>var sass = require(&#39;gulp-sass&#39;)</code></p>\n</blockquote>\n<hr>\n<p><a href=\"https://www.npmjs.com/package/gulp-autoprefixer\" target=\"_blank\" rel=\"external\">gulp-autoprefixer</a>：应该属于css后处理工具，在编写css完成之后，会根据我们的配置自动按需添加浏览器前缀。</p>\n<p>任务事例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(<span class=\"string\">'sass'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'src/sass/*.scss'</span>)</div><div class=\"line\">\t\t\t\t\t.pipe(sass())</div><div class=\"line\">\t\t\t\t\t.pipe(autoprefixer(<span class=\"string\">'last 2 versions'</span>, <span class=\"string\">'ios 6'</span>, <span class=\"string\">'android 4'</span>))\t<span class=\"comment\">//autoprefixer</span></div><div class=\"line\">\t\t\t\t\t.pipe(gulp.dest(<span class=\"string\">'src/css'</span>))</div><div class=\"line\">\t\t\t\t\t.pipe(cleanCSS())\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//css压缩工具，前面介绍有</span></div><div class=\"line\">\t\t\t\t\t.pipe(gulp.dest(<span class=\"string\">'dist/css'</span>))</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>其中<code>autoprefixer(&#39;...&#39;,&#39;...&#39;,&#39;...&#39;)</code>为简写形式，其中<code>last 2 versions</code>表示兼容所有浏览器最新两个版本。<br>完整形式应该为<code>autoprefixer({ \n    browsers: [&#39;last 2 versions&#39;, &#39;ios 6&#39;],\n    cascade: true\n})</code></p>\n<hr>\n<p><a href=\"https://www.npmjs.com/package/gulp-imagemin\" target=\"_blank\" rel=\"external\">gulp-imagemin</a>:图片压缩工具。</p>\n<p>任务事例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(<span class=\"string\">'imageMin'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tgulp.src(<span class=\"string\">'src/img/*'</span>)</div><div class=\"line\">\t\t.pipe(imagemin())</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/img'</span>));</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>对于imagemin()进行图片压缩，可以结合使用<code>gulp-cache</code>对图片进行缓存。具体用法，我也没研究太懂 :joy:</p>\n<hr>\n<p><a href=\"https://www.npmjs.com/package/browser-sync\" target=\"_blank\" rel=\"external\">browser-sync</a>:属于综合测试的工具，可以实现页面自动刷新、多屏同步操作等功能。</p>\n<p>任务实例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//首先browser-sync的引用，官方推荐使用create()方法</span></div><div class=\"line\"><span class=\"keyword\">var</span> browserSync = <span class=\"built_in\">require</span>(<span class=\"string\">'browser-sync'</span>).create();</div><div class=\"line\"></div><div class=\"line\">gulp.task(<span class=\"string\">'serve'</span>, [<span class=\"string\">'sass'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tbrowserSync.init(&#123;</div><div class=\"line\">\t\t<span class=\"attr\">server</span>: <span class=\"string\">'./'</span></div><div class=\"line\">\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\tgulp.watch(<span class=\"string\">'src/sass/*.scss'</span>, [<span class=\"string\">'sass'</span>]);</div><div class=\"line\">\tgulp.watch(<span class=\"string\">'*.html'</span>).on(<span class=\"string\">'change'</span>, browserSync.reload);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>其中<code>server: &#39;./&#39;</code>会将当前目录作为服务器访问地址<br><br><code>gulp.watch(&#39;src/sass/*.scss&#39;, [&#39;sass&#39;])</code>会监听<em>.scss文件，执行<code>sass</code>任务，并且实时反应到浏览器上。<br>`gulp.watch(‘</em>.html’).on(‘change’, browserSync.reload)`不同之处在于，会执行reload方法，重新加载页面。</p>\n<hr>\n<p>对于工具，我觉得更多的是直接拿过来使用，而不是非要去研究清楚每个API的作用。当然，特别感兴趣的也可以尝试研究工具，甚至是自己动手去制造这些工具。</p>\n","excerpt":"","more":"<p>有了之前的gulp经验，使用其他gulp工具就是很简单的工作了。</p>\n<blockquote>\n<p>ps:    以下代码前均包含<code>var gulp = require(&#39;gulp&#39;)</code></p>\n<p>类似<code>sass()</code>表示前面包含<code>var sass = require(&#39;gulp-sass&#39;)</code></p>\n</blockquote>\n<hr>\n<p><a href=\"https://www.npmjs.com/package/gulp-autoprefixer\">gulp-autoprefixer</a>：应该属于css后处理工具，在编写css完成之后，会根据我们的配置自动按需添加浏览器前缀。</p>\n<p>任务事例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(<span class=\"string\">'sass'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'src/sass/*.scss'</span>)</div><div class=\"line\">\t\t\t\t\t.pipe(sass())</div><div class=\"line\">\t\t\t\t\t.pipe(autoprefixer(<span class=\"string\">'last 2 versions'</span>, <span class=\"string\">'ios 6'</span>, <span class=\"string\">'android 4'</span>))\t<span class=\"comment\">//autoprefixer</span></div><div class=\"line\">\t\t\t\t\t.pipe(gulp.dest(<span class=\"string\">'src/css'</span>))</div><div class=\"line\">\t\t\t\t\t.pipe(cleanCSS())\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//css压缩工具，前面介绍有</span></div><div class=\"line\">\t\t\t\t\t.pipe(gulp.dest(<span class=\"string\">'dist/css'</span>))</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>其中<code>autoprefixer(&#39;...&#39;,&#39;...&#39;,&#39;...&#39;)</code>为简写形式，其中<code>last 2 versions</code>表示兼容所有浏览器最新两个版本。<br>完整形式应该为<code>autoprefixer({ \n    browsers: [&#39;last 2 versions&#39;, &#39;ios 6&#39;],\n    cascade: true\n})</code></p>\n<hr>\n<p><a href=\"https://www.npmjs.com/package/gulp-imagemin\">gulp-imagemin</a>:图片压缩工具。</p>\n<p>任务事例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(<span class=\"string\">'imageMin'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tgulp.src(<span class=\"string\">'src/img/*'</span>)</div><div class=\"line\">\t\t.pipe(imagemin())</div><div class=\"line\">\t\t.pipe(gulp.dest(<span class=\"string\">'dist/img'</span>));</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>对于imagemin()进行图片压缩，可以结合使用<code>gulp-cache</code>对图片进行缓存。具体用法，我也没研究太懂 :joy:</p>\n<hr>\n<p><a href=\"https://www.npmjs.com/package/browser-sync\">browser-sync</a>:属于综合测试的工具，可以实现页面自动刷新、多屏同步操作等功能。</p>\n<p>任务实例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//首先browser-sync的引用，官方推荐使用create()方法</span></div><div class=\"line\"><span class=\"keyword\">var</span> browserSync = <span class=\"built_in\">require</span>(<span class=\"string\">'browser-sync'</span>).create();</div><div class=\"line\"></div><div class=\"line\">gulp.task(<span class=\"string\">'serve'</span>, [<span class=\"string\">'sass'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tbrowserSync.init(&#123;</div><div class=\"line\">\t\t<span class=\"attr\">server</span>: <span class=\"string\">'./'</span></div><div class=\"line\">\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\tgulp.watch(<span class=\"string\">'src/sass/*.scss'</span>, [<span class=\"string\">'sass'</span>]);</div><div class=\"line\">\tgulp.watch(<span class=\"string\">'*.html'</span>).on(<span class=\"string\">'change'</span>, browserSync.reload);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>其中<code>server: &#39;./&#39;</code>会将当前目录作为服务器访问地址<br/><br><code>gulp.watch(&#39;src/sass/*.scss&#39;, [&#39;sass&#39;])</code>会监听<em>.scss文件，执行<code>sass</code>任务，并且实时反应到浏览器上。<br>`gulp.watch(‘</em>.html’).on(‘change’, browserSync.reload)`不同之处在于，会执行reload方法，重新加载页面。</p>\n<hr>\n<p>对于工具，我觉得更多的是直接拿过来使用，而不是非要去研究清楚每个API的作用。当然，特别感兴趣的也可以尝试研究工具，甚至是自己动手去制造这些工具。</p>\n"},{"title":"今天的面试","date":"2016-06-13T14:04:00.000Z","comments":1,"_content":"　　英语教育方面公司，笔试+面试，题目类型主要包括JS基础、git操作、Linux基础。\n　　首先就把题目虐了一遍，全英文题目，幸好只是简单的output之类勉强能够理解题目内容。\n　　API不熟悉：考察了reduce、for of,这两个函数完全没用过，对于for of我只知道for in。NaN不熟悉，<!--more-->typeof NaN当时蒙逼的我竟然回答个NaN，typeof结果只有string、number、boolean、object、function、undefined，白记了。最最最蒙逼的是，`console.log(function(){} && null)`这个竟然不是考察类型转换的，感觉就像是被前面的一大堆==和===带跑了，好吧，我承认还是自己的基础问题。之后的angular就不说了，我那入门水平真不够看的。\n　　git和linux的考察就不是我能够掌控得了的了，考察了git分支的合并，git中移除某个项目不再管理。linux考察了权限，vim的基本操作。git平时都是一个人写写，提交一下，linux更是自从大二考试结束后就没再接触，哎~只能是自己的叹息。\n　　总结下来，基础方面是有些差，JS那些基础问题应该都明白的，和自己有些浮躁有关。期间几个问题挺尴尬的，一个是问到了英语水平，一个是问我JS方面的书读过几本，细细想来，好像一本完整的都没有。git和linux的问题也许情有可原，JS就是一个大问题了。","source":"_posts/今天的面试.md","raw":"---\ntitle: 今天的面试\ndate: 2016-06-13 22:04\ntags: [面试, JavaScript]\ncategories: \n- 杂记\ncomments: true\n---\n　　英语教育方面公司，笔试+面试，题目类型主要包括JS基础、git操作、Linux基础。\n　　首先就把题目虐了一遍，全英文题目，幸好只是简单的output之类勉强能够理解题目内容。\n　　API不熟悉：考察了reduce、for of,这两个函数完全没用过，对于for of我只知道for in。NaN不熟悉，<!--more-->typeof NaN当时蒙逼的我竟然回答个NaN，typeof结果只有string、number、boolean、object、function、undefined，白记了。最最最蒙逼的是，`console.log(function(){} && null)`这个竟然不是考察类型转换的，感觉就像是被前面的一大堆==和===带跑了，好吧，我承认还是自己的基础问题。之后的angular就不说了，我那入门水平真不够看的。\n　　git和linux的考察就不是我能够掌控得了的了，考察了git分支的合并，git中移除某个项目不再管理。linux考察了权限，vim的基本操作。git平时都是一个人写写，提交一下，linux更是自从大二考试结束后就没再接触，哎~只能是自己的叹息。\n　　总结下来，基础方面是有些差，JS那些基础问题应该都明白的，和自己有些浮躁有关。期间几个问题挺尴尬的，一个是问到了英语水平，一个是问我JS方面的书读过几本，细细想来，好像一本完整的都没有。git和linux的问题也许情有可原，JS就是一个大问题了。","slug":"今天的面试","published":1,"updated":"2017-03-22T01:22:07.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8ki10019ohfk1fphozmq","content":"<p>　　英语教育方面公司，笔试+面试，题目类型主要包括JS基础、git操作、Linux基础。<br>　　首先就把题目虐了一遍，全英文题目，幸好只是简单的output之类勉强能够理解题目内容。<br>　　API不熟悉：考察了reduce、for of,这两个函数完全没用过，对于for of我只知道for in。NaN不熟悉，<a id=\"more\"></a>typeof NaN当时蒙逼的我竟然回答个NaN，typeof结果只有string、number、boolean、object、function、undefined，白记了。最最最蒙逼的是，<code>console.log(function(){} &amp;&amp; null)</code>这个竟然不是考察类型转换的，感觉就像是被前面的一大堆==和===带跑了，好吧，我承认还是自己的基础问题。之后的angular就不说了，我那入门水平真不够看的。<br>　　git和linux的考察就不是我能够掌控得了的了，考察了git分支的合并，git中移除某个项目不再管理。linux考察了权限，vim的基本操作。git平时都是一个人写写，提交一下，linux更是自从大二考试结束后就没再接触，哎~只能是自己的叹息。<br>　　总结下来，基础方面是有些差，JS那些基础问题应该都明白的，和自己有些浮躁有关。期间几个问题挺尴尬的，一个是问到了英语水平，一个是问我JS方面的书读过几本，细细想来，好像一本完整的都没有。git和linux的问题也许情有可原，JS就是一个大问题了。</p>\n","excerpt":"<p>　　英语教育方面公司，笔试+面试，题目类型主要包括JS基础、git操作、Linux基础。<br>　　首先就把题目虐了一遍，全英文题目，幸好只是简单的output之类勉强能够理解题目内容。<br>　　API不熟悉：考察了reduce、for of,这两个函数完全没用过，对于for of我只知道for in。NaN不熟悉，","more":"typeof NaN当时蒙逼的我竟然回答个NaN，typeof结果只有string、number、boolean、object、function、undefined，白记了。最最最蒙逼的是，<code>console.log(function(){} &amp;&amp; null)</code>这个竟然不是考察类型转换的，感觉就像是被前面的一大堆==和===带跑了，好吧，我承认还是自己的基础问题。之后的angular就不说了，我那入门水平真不够看的。<br>　　git和linux的考察就不是我能够掌控得了的了，考察了git分支的合并，git中移除某个项目不再管理。linux考察了权限，vim的基本操作。git平时都是一个人写写，提交一下，linux更是自从大二考试结束后就没再接触，哎~只能是自己的叹息。<br>　　总结下来，基础方面是有些差，JS那些基础问题应该都明白的，和自己有些浮躁有关。期间几个问题挺尴尬的，一个是问到了英语水平，一个是问我JS方面的书读过几本，细细想来，好像一本完整的都没有。git和linux的问题也许情有可原，JS就是一个大问题了。</p>"},{"title":"从零开始搭建React(1)","date":"2016-11-12T16:00:00.000Z","comments":1,"_content":"\n学习React几乎绕不开Webpack，就像使用Java需要搭建环境、规划目录结构、写各种配置文件一样，这里我们也要搭建这样的一个脚手架。当然，这里只是我的简单总结，并不是什么最佳实践，只是一步步去理解这个搭建过程。  \n目录结构开始只是简单的`myapp/src`，首先肯定是安装react、react-dom、webpack，webpack官网是安装在全局的。[参见官网](http://webpack.github.io/docs/tutorials/getting-started/#welcome)  \n这时候就可以开始写webpack配置文件，在编写之前，可以安装eslint来规范代码，这里的配置文件我是写在`myapp/src/config/webpack.config.js`，最基本的样子如下（可以在官网找到各配置项表示，这里使用的是node API形式）：\n```javascript\n// webpack.config.js\nvar path = require('path')\nvar webpack = require('webpack')\n\nvar src = path.resolve(__dirname, '../../src')  // 源码目录\nvar build = path.resolve(__dirname, '../../dist')   // 编译目录\n\nmodule.exports = {\n  entry: {\n    app: path.join(src, 'app.js')\n  },\n  output: {\n    filename: '[name].js',\n    path: build,\n    publicPath: '/static/'\n  },\n  resolve: {\n    extensions: ['', '.js']\n  },\n  module: {\n    loaders: [{\n      test: /\\.js$/,\n      include: src,\n      loader: 'babel'\n    }, {\n      test: /\\.scss$/,\n      loaders: ['style', 'css', 'sass']\n    }]\n  }\n}\n```\n\n接下来就是根据loaders安装各种webpack-loader，以后随着项目的需要，这里肯定还会添加更多的webpack-loader，安装方式就是`npm install --save-dev babel-loader style-loader css-loader sass-loader`。然后，创建`myapp/src/app.js`文件用于测试我们的环境。执行`webpack --config src/config/webpack.config.js`，会发现报错`can't find module 'babel-core'`，那么就按照提示，安装babel-core，一定要学会看提示/报错信息。  \n再次执行`webpack --config src/config/webpack.config.js`(以下简称执行webpack)应该会生成`myapp/dist/app.js`文件，里面应该是只有一段webpackBootstrap以及一段空函数function(module, exports)。  \n在`src/app.js`中编写代码用于环境测试：\n```javascript\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\nReactDOM.render(\n    <h1>Hello React</h1>,\n    document.getElementById('app')\n  )\n```\n再次执行`webpack --config src/config/webpack.config.js`，发现报错Unexpected token在<h1\\>位置，显然是babel不能识别jsx格式，我们并没有配置babel的转换规则。创建`myapp/.babelrc`，一般的基础配置是，具体规则[参见官网](http://babeljs.io/docs/plugins/)。\n```json\n{\n  \"presets\": [\"es2015\", \"react\", \"stage-0\"]\n}\n```\n安装这些preset，再次执行webpack，生成编译后的文件。创建html文件：\n```html\n<!-- 我这里的路径是myapp/src/index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title></title>\n</head>\n<body>\n  <div id=\"app\"></div>\n  <script type=\"text/javascript\" src=\"../dist/app.js\"></script>\n</body>\n</html>\n```\n用浏览器打开该文件，则能看到Hello React。  \n然后测试sass文件怎么样，创建`myapp/src/app.scss`\n```sass\nh1 {\n  background: red;\n}\n```\n在`myapp/src/app.js`中引入该scss文件`import './app.scss'`  \n执行webpack，可能会报错can't find module node-sass，再次安装此模块，执行webpack刷新页面，应该会看到Hello React背景色变成红色。\n\n至此，一个最简单的webpack打包React的环境完成。虽然这个环境可以使用，但是没有好好利用webpack，也就没有提高一点我们的工作效率。","source":"_posts/从零搭建React(1).md","raw":"---\ntitle: 从零开始搭建React(1)\ndate: 2016-11-13\ntags: [JavaScript, React, Webpack]\ncategories: \n- React\ncomments: true\n---\n\n学习React几乎绕不开Webpack，就像使用Java需要搭建环境、规划目录结构、写各种配置文件一样，这里我们也要搭建这样的一个脚手架。当然，这里只是我的简单总结，并不是什么最佳实践，只是一步步去理解这个搭建过程。  \n目录结构开始只是简单的`myapp/src`，首先肯定是安装react、react-dom、webpack，webpack官网是安装在全局的。[参见官网](http://webpack.github.io/docs/tutorials/getting-started/#welcome)  \n这时候就可以开始写webpack配置文件，在编写之前，可以安装eslint来规范代码，这里的配置文件我是写在`myapp/src/config/webpack.config.js`，最基本的样子如下（可以在官网找到各配置项表示，这里使用的是node API形式）：\n```javascript\n// webpack.config.js\nvar path = require('path')\nvar webpack = require('webpack')\n\nvar src = path.resolve(__dirname, '../../src')  // 源码目录\nvar build = path.resolve(__dirname, '../../dist')   // 编译目录\n\nmodule.exports = {\n  entry: {\n    app: path.join(src, 'app.js')\n  },\n  output: {\n    filename: '[name].js',\n    path: build,\n    publicPath: '/static/'\n  },\n  resolve: {\n    extensions: ['', '.js']\n  },\n  module: {\n    loaders: [{\n      test: /\\.js$/,\n      include: src,\n      loader: 'babel'\n    }, {\n      test: /\\.scss$/,\n      loaders: ['style', 'css', 'sass']\n    }]\n  }\n}\n```\n\n接下来就是根据loaders安装各种webpack-loader，以后随着项目的需要，这里肯定还会添加更多的webpack-loader，安装方式就是`npm install --save-dev babel-loader style-loader css-loader sass-loader`。然后，创建`myapp/src/app.js`文件用于测试我们的环境。执行`webpack --config src/config/webpack.config.js`，会发现报错`can't find module 'babel-core'`，那么就按照提示，安装babel-core，一定要学会看提示/报错信息。  \n再次执行`webpack --config src/config/webpack.config.js`(以下简称执行webpack)应该会生成`myapp/dist/app.js`文件，里面应该是只有一段webpackBootstrap以及一段空函数function(module, exports)。  \n在`src/app.js`中编写代码用于环境测试：\n```javascript\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\nReactDOM.render(\n    <h1>Hello React</h1>,\n    document.getElementById('app')\n  )\n```\n再次执行`webpack --config src/config/webpack.config.js`，发现报错Unexpected token在<h1\\>位置，显然是babel不能识别jsx格式，我们并没有配置babel的转换规则。创建`myapp/.babelrc`，一般的基础配置是，具体规则[参见官网](http://babeljs.io/docs/plugins/)。\n```json\n{\n  \"presets\": [\"es2015\", \"react\", \"stage-0\"]\n}\n```\n安装这些preset，再次执行webpack，生成编译后的文件。创建html文件：\n```html\n<!-- 我这里的路径是myapp/src/index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title></title>\n</head>\n<body>\n  <div id=\"app\"></div>\n  <script type=\"text/javascript\" src=\"../dist/app.js\"></script>\n</body>\n</html>\n```\n用浏览器打开该文件，则能看到Hello React。  \n然后测试sass文件怎么样，创建`myapp/src/app.scss`\n```sass\nh1 {\n  background: red;\n}\n```\n在`myapp/src/app.js`中引入该scss文件`import './app.scss'`  \n执行webpack，可能会报错can't find module node-sass，再次安装此模块，执行webpack刷新页面，应该会看到Hello React背景色变成红色。\n\n至此，一个最简单的webpack打包React的环境完成。虽然这个环境可以使用，但是没有好好利用webpack，也就没有提高一点我们的工作效率。","slug":"从零搭建React(1)","published":1,"updated":"2017-03-22T01:21:49.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8ki4001dohfkmntmv314","content":"<p>学习React几乎绕不开Webpack，就像使用Java需要搭建环境、规划目录结构、写各种配置文件一样，这里我们也要搭建这样的一个脚手架。当然，这里只是我的简单总结，并不是什么最佳实践，只是一步步去理解这个搭建过程。<br>目录结构开始只是简单的<code>myapp/src</code>，首先肯定是安装react、react-dom、webpack，webpack官网是安装在全局的。<a href=\"http://webpack.github.io/docs/tutorials/getting-started/#welcome\" target=\"_blank\" rel=\"external\">参见官网</a><br>这时候就可以开始写webpack配置文件，在编写之前，可以安装eslint来规范代码，这里的配置文件我是写在<code>myapp/src/config/webpack.config.js</code>，最基本的样子如下（可以在官网找到各配置项表示，这里使用的是node API形式）：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// webpack.config.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> src = path.resolve(__dirname, <span class=\"string\">'../../src'</span>)  <span class=\"comment\">// 源码目录</span></div><div class=\"line\"><span class=\"keyword\">var</span> build = path.resolve(__dirname, <span class=\"string\">'../../dist'</span>)   <span class=\"comment\">// 编译目录</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"attr\">entry</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">app</span>: path.join(src, <span class=\"string\">'app.js'</span>)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">output</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">'[name].js'</span>,</div><div class=\"line\">    <span class=\"attr\">path</span>: build,</div><div class=\"line\">    <span class=\"attr\">publicPath</span>: <span class=\"string\">'/static/'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">resolve</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">extensions</span>: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>]</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">module</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">loaders</span>: [&#123;</div><div class=\"line\">      <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>,</div><div class=\"line\">      <span class=\"attr\">include</span>: src,</div><div class=\"line\">      <span class=\"attr\">loader</span>: <span class=\"string\">'babel'</span></div><div class=\"line\">    &#125;, &#123;</div><div class=\"line\">      <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.scss$/</span>,</div><div class=\"line\">      <span class=\"attr\">loaders</span>: [<span class=\"string\">'style'</span>, <span class=\"string\">'css'</span>, <span class=\"string\">'sass'</span>]</div><div class=\"line\">    &#125;]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接下来就是根据loaders安装各种webpack-loader，以后随着项目的需要，这里肯定还会添加更多的webpack-loader，安装方式就是<code>npm install --save-dev babel-loader style-loader css-loader sass-loader</code>。然后，创建<code>myapp/src/app.js</code>文件用于测试我们的环境。执行<code>webpack --config src/config/webpack.config.js</code>，会发现报错<code>can&#39;t find module &#39;babel-core&#39;</code>，那么就按照提示，安装babel-core，一定要学会看提示/报错信息。<br>再次执行<code>webpack --config src/config/webpack.config.js</code>(以下简称执行webpack)应该会生成<code>myapp/dist/app.js</code>文件，里面应该是只有一段webpackBootstrap以及一段空函数function(module, exports)。<br>在<code>src/app.js</code>中编写代码用于环境测试：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></div><div class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello React<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>,</div><div class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>)</div><div class=\"line\">  )</div></pre></td></tr></table></figure></p>\n<p>再次执行<code>webpack --config src/config/webpack.config.js</code>，发现报错Unexpected token在<h1\\>位置，显然是babel不能识别jsx格式，我们并没有配置babel的转换规则。创建<code>myapp/.babelrc</code>，一般的基础配置是，具体规则<a href=\"http://babeljs.io/docs/plugins/\" target=\"_blank\" rel=\"external\">参见官网</a>。<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"presets\"</span>: [<span class=\"string\">\"es2015\"</span>, <span class=\"string\">\"react\"</span>, <span class=\"string\">\"stage-0\"</span>]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></h1\\></p>\n<p>安装这些preset，再次执行webpack，生成编译后的文件。创建html文件：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 我这里的路径是myapp/src/index.html --&gt;</span></div><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../dist/app.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>用浏览器打开该文件，则能看到Hello React。<br>然后测试sass文件怎么样，创建<code>myapp/src/app.scss</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">h1 &#123;</div><div class=\"line\">  background: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在<code>myapp/src/app.js</code>中引入该scss文件<code>import &#39;./app.scss&#39;</code><br>执行webpack，可能会报错can’t find module node-sass，再次安装此模块，执行webpack刷新页面，应该会看到Hello React背景色变成红色。</p>\n<p>至此，一个最简单的webpack打包React的环境完成。虽然这个环境可以使用，但是没有好好利用webpack，也就没有提高一点我们的工作效率。</p>\n","excerpt":"","more":"<p>学习React几乎绕不开Webpack，就像使用Java需要搭建环境、规划目录结构、写各种配置文件一样，这里我们也要搭建这样的一个脚手架。当然，这里只是我的简单总结，并不是什么最佳实践，只是一步步去理解这个搭建过程。<br>目录结构开始只是简单的<code>myapp/src</code>，首先肯定是安装react、react-dom、webpack，webpack官网是安装在全局的。<a href=\"http://webpack.github.io/docs/tutorials/getting-started/#welcome\">参见官网</a><br>这时候就可以开始写webpack配置文件，在编写之前，可以安装eslint来规范代码，这里的配置文件我是写在<code>myapp/src/config/webpack.config.js</code>，最基本的样子如下（可以在官网找到各配置项表示，这里使用的是node API形式）：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// webpack.config.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> src = path.resolve(__dirname, <span class=\"string\">'../../src'</span>)  <span class=\"comment\">// 源码目录</span></div><div class=\"line\"><span class=\"keyword\">var</span> build = path.resolve(__dirname, <span class=\"string\">'../../dist'</span>)   <span class=\"comment\">// 编译目录</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"attr\">entry</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">app</span>: path.join(src, <span class=\"string\">'app.js'</span>)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">output</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">'[name].js'</span>,</div><div class=\"line\">    <span class=\"attr\">path</span>: build,</div><div class=\"line\">    <span class=\"attr\">publicPath</span>: <span class=\"string\">'/static/'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">resolve</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">extensions</span>: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>]</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">module</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">loaders</span>: [&#123;</div><div class=\"line\">      <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>,</div><div class=\"line\">      <span class=\"attr\">include</span>: src,</div><div class=\"line\">      <span class=\"attr\">loader</span>: <span class=\"string\">'babel'</span></div><div class=\"line\">    &#125;, &#123;</div><div class=\"line\">      <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.scss$/</span>,</div><div class=\"line\">      <span class=\"attr\">loaders</span>: [<span class=\"string\">'style'</span>, <span class=\"string\">'css'</span>, <span class=\"string\">'sass'</span>]</div><div class=\"line\">    &#125;]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接下来就是根据loaders安装各种webpack-loader，以后随着项目的需要，这里肯定还会添加更多的webpack-loader，安装方式就是<code>npm install --save-dev babel-loader style-loader css-loader sass-loader</code>。然后，创建<code>myapp/src/app.js</code>文件用于测试我们的环境。执行<code>webpack --config src/config/webpack.config.js</code>，会发现报错<code>can&#39;t find module &#39;babel-core&#39;</code>，那么就按照提示，安装babel-core，一定要学会看提示/报错信息。<br>再次执行<code>webpack --config src/config/webpack.config.js</code>(以下简称执行webpack)应该会生成<code>myapp/dist/app.js</code>文件，里面应该是只有一段webpackBootstrap以及一段空函数function(module, exports)。<br>在<code>src/app.js</code>中编写代码用于环境测试：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></div><div class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello React<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>,</div><div class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>)</div><div class=\"line\">  )</div></pre></td></tr></table></figure></p>\n<p>再次执行<code>webpack --config src/config/webpack.config.js</code>，发现报错Unexpected token在<h1\\>位置，显然是babel不能识别jsx格式，我们并没有配置babel的转换规则。创建<code>myapp/.babelrc</code>，一般的基础配置是，具体规则<a href=\"http://babeljs.io/docs/plugins/\">参见官网</a>。<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"presets\"</span>: [<span class=\"string\">\"es2015\"</span>, <span class=\"string\">\"react\"</span>, <span class=\"string\">\"stage-0\"</span>]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>安装这些preset，再次执行webpack，生成编译后的文件。创建html文件：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 我这里的路径是myapp/src/index.html --&gt;</span></div><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"../dist/app.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>用浏览器打开该文件，则能看到Hello React。<br>然后测试sass文件怎么样，创建<code>myapp/src/app.scss</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">h1 &#123;</div><div class=\"line\">  background: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在<code>myapp/src/app.js</code>中引入该scss文件<code>import &#39;./app.scss&#39;</code><br>执行webpack，可能会报错can’t find module node-sass，再次安装此模块，执行webpack刷新页面，应该会看到Hello React背景色变成红色。</p>\n<p>至此，一个最简单的webpack打包React的环境完成。虽然这个环境可以使用，但是没有好好利用webpack，也就没有提高一点我们的工作效率。</p>\n"},{"title":"从零开始搭建React(2)","date":"2016-11-13T16:00:00.000Z","comments":1,"_content":"\n提高开发效率，我们发现前面用的最多的就是`webpack --config ***`，然后去刷新页面。解决此问题，可以使用[react-hot-loader](https://github.com/gaearon/react-hot-loader)，这应该也是我们使用github的原因，在这里我们可以找到解决各种问题的办法。  \n查看其中使用方法（看不懂英文就用翻译一句一句看呗，其实我也是这么看过来的），会发现这一句These steps are covered by [the walkthrough](http://gaearon.github.io/react-hot-loader/getstarted/)（这里应该是1版本的写法）。  \n根据这里的步骤，先是安装react-hot-loader，然后是server.js，提供有事例：\n```javascript\n// 我的路径 myapp/src/config/server.js\nvar path = require('path')\nvar webpack = require('webpack')\nvar express = require('express')\nvar config = require('./webpack.config')\n\nvar app = express()\nvar compiler = webpack(config)\n\napp.use(require('webpack-dev-middleware')(compiler, {\n  publicPath: config.output.publicPath\n}))\n\napp.use(require('webpack-hot-middleware')(compiler))\n\napp.get('*', function (req, res) {\n  res.sendFile(path.join(__dirname, '../index.html'))\n})\n\napp.listen(3000, function (err) {\n  if (err) {\n    return console.error(err)\n  }\n\n  console.log('Listening at http://localhost:3000/')\n})\n```\n需要安装express，另外需要修改`res.sendFile(path.join(__dirname, '../index.html'))`这里的路径，还有端口。  \n接着修改webpack的配置文件，在入口配置项前面添加，\n```javascript\nentry: {\n  app: [\n  'webpack-dev-server/client?http://0.0.0.0:3000', // WebpackDevServer host and port\n  'webpack/hot/only-dev-server', // \"only\" prevents reload on syntax errors\n  path.join(src, 'app.js')\n  ]\n}\n```\n这个应该是1版本的写法，而我这里安装的是3版本，导致页面会多次刷新。下面是3版本，具体参看[事例](https://github.com/gaearon/react-hot-boilerplate/tree/next)\n```javascript\nentry: {\n    app: [\n      'react-hot-loader/patch',\n      'webpack-hot-middleware/client',\n      path.join(src, 'app.js')\n    ]\n  },\n```\n接着是在oader中添加react-hot，按照官网是将react-hot添加在babel前面即可\n```javascript\nloaders: [{\n  test: /\\.js$/,\n  include: src,\n  loaders: ['react-hot', 'babel']\n}]\n```\n但是在我这里报错了，报错提示还算明显，大致就是将react-hot-loader/babel添加到babel的plugins中，于是修改`myapp/.babelrc`解决。同样是1和3的区别\n```json\n{\n  \"presets\": [\"es2015\", \"react\", \"stage-0\"],\n  \"plugins\": [\"react-hot-loader/babel\"]\n}\n```\n最后一步，是webpack中添加plugins\n```javascript\nplugins: [\n  new webpack.HotModuleReplacementPlugin()\n]\n```\n1版本到这里就结束了，3版本是这样的\n```javascript\n// myapp/src/app.js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport { AppContainer } from 'react-hot-loader'\nimport Hello from './Hello'\nimport './app.scss'\n\nReactDOM.render(\n    <AppContainer>\n      <Hello />\n    </AppContainer>,\n    document.getElementById('app')\n  )\n\nif (module.hot) {\n  module.hot.accept('./Hello', () => {\n    // If you use Webpack 2 in ES modules mode, you can\n    // use <App /> here rather than require() a <NextApp />.\n    const NextApp = require('./Hello').default\n    ReactDOM.render(\n      <AppContainer>\n         <NextApp />\n      </AppContainer>,\n      document.getElementById('app')\n    )\n  })\n}\n```\n```javascript\n// myapp/src/Hello.js\nimport React from 'react'\nexport default function Layout () {\n  return (\n    <div>\n      <h1>Hello, world!!</h1>\n    </div>\n  )\n}\n```\n这里有个小坑，改变app.js文件中的内容并不会刷新，需要手动刷新页面。\n\n启动就是`node src/config/server.js`，可以将其写入到package.json文件中`\"script\": {\"start\": \"node src/config/server.js\"}`\n\n最后遇到一个小坑，在HTML文件引用入口文件中，地址应该是webpack配置中的`output.publicPath/[name].js`，如`<script src=\"/static/app.js\"></script>`。引用不到，或者路径错误会将html文件作为js文件引入，报错。  \n至此，在之后的编写中就不需要一遍又一遍的`webpack --config ****`\n\n------------------\n11.18补充\n\n分离打包：  \n在入口文件中添加要分离的模块：(这里将react和react-dom打包到vendor中)\n```javascript\nentry: {\n    app: [\n      'react-hot-loader/patch',\n      'webpack-hot-middleware/client',\n      path.join(src, 'index.js')\n    ],\n+    // 打包分离\n+    vendor: [\n+      'react',\n+      'react-dom'\n+    ]\n  },\n```\n增加CommonsChunkPlugin插件：\n```javascript\n  plugins: [\n+    // 分离打包\n+    new webpack.optimize.CommonsChunkPlugin({\n+      names: ['vendor']\n+    }),\n    // 热加载\n    new webpack.HotModuleReplacementPlugin()\n  ]\n```\n分离打包后，两个app.js和vendor.js都需要引入。","source":"_posts/从零搭建React(2).md","raw":"---\ntitle: 从零开始搭建React(2)\ndate: 2016-11-14\ntags: [JavaScript, React, Webpack]\ncategories: \n- React\ncomments: true\n---\n\n提高开发效率，我们发现前面用的最多的就是`webpack --config ***`，然后去刷新页面。解决此问题，可以使用[react-hot-loader](https://github.com/gaearon/react-hot-loader)，这应该也是我们使用github的原因，在这里我们可以找到解决各种问题的办法。  \n查看其中使用方法（看不懂英文就用翻译一句一句看呗，其实我也是这么看过来的），会发现这一句These steps are covered by [the walkthrough](http://gaearon.github.io/react-hot-loader/getstarted/)（这里应该是1版本的写法）。  \n根据这里的步骤，先是安装react-hot-loader，然后是server.js，提供有事例：\n```javascript\n// 我的路径 myapp/src/config/server.js\nvar path = require('path')\nvar webpack = require('webpack')\nvar express = require('express')\nvar config = require('./webpack.config')\n\nvar app = express()\nvar compiler = webpack(config)\n\napp.use(require('webpack-dev-middleware')(compiler, {\n  publicPath: config.output.publicPath\n}))\n\napp.use(require('webpack-hot-middleware')(compiler))\n\napp.get('*', function (req, res) {\n  res.sendFile(path.join(__dirname, '../index.html'))\n})\n\napp.listen(3000, function (err) {\n  if (err) {\n    return console.error(err)\n  }\n\n  console.log('Listening at http://localhost:3000/')\n})\n```\n需要安装express，另外需要修改`res.sendFile(path.join(__dirname, '../index.html'))`这里的路径，还有端口。  \n接着修改webpack的配置文件，在入口配置项前面添加，\n```javascript\nentry: {\n  app: [\n  'webpack-dev-server/client?http://0.0.0.0:3000', // WebpackDevServer host and port\n  'webpack/hot/only-dev-server', // \"only\" prevents reload on syntax errors\n  path.join(src, 'app.js')\n  ]\n}\n```\n这个应该是1版本的写法，而我这里安装的是3版本，导致页面会多次刷新。下面是3版本，具体参看[事例](https://github.com/gaearon/react-hot-boilerplate/tree/next)\n```javascript\nentry: {\n    app: [\n      'react-hot-loader/patch',\n      'webpack-hot-middleware/client',\n      path.join(src, 'app.js')\n    ]\n  },\n```\n接着是在oader中添加react-hot，按照官网是将react-hot添加在babel前面即可\n```javascript\nloaders: [{\n  test: /\\.js$/,\n  include: src,\n  loaders: ['react-hot', 'babel']\n}]\n```\n但是在我这里报错了，报错提示还算明显，大致就是将react-hot-loader/babel添加到babel的plugins中，于是修改`myapp/.babelrc`解决。同样是1和3的区别\n```json\n{\n  \"presets\": [\"es2015\", \"react\", \"stage-0\"],\n  \"plugins\": [\"react-hot-loader/babel\"]\n}\n```\n最后一步，是webpack中添加plugins\n```javascript\nplugins: [\n  new webpack.HotModuleReplacementPlugin()\n]\n```\n1版本到这里就结束了，3版本是这样的\n```javascript\n// myapp/src/app.js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport { AppContainer } from 'react-hot-loader'\nimport Hello from './Hello'\nimport './app.scss'\n\nReactDOM.render(\n    <AppContainer>\n      <Hello />\n    </AppContainer>,\n    document.getElementById('app')\n  )\n\nif (module.hot) {\n  module.hot.accept('./Hello', () => {\n    // If you use Webpack 2 in ES modules mode, you can\n    // use <App /> here rather than require() a <NextApp />.\n    const NextApp = require('./Hello').default\n    ReactDOM.render(\n      <AppContainer>\n         <NextApp />\n      </AppContainer>,\n      document.getElementById('app')\n    )\n  })\n}\n```\n```javascript\n// myapp/src/Hello.js\nimport React from 'react'\nexport default function Layout () {\n  return (\n    <div>\n      <h1>Hello, world!!</h1>\n    </div>\n  )\n}\n```\n这里有个小坑，改变app.js文件中的内容并不会刷新，需要手动刷新页面。\n\n启动就是`node src/config/server.js`，可以将其写入到package.json文件中`\"script\": {\"start\": \"node src/config/server.js\"}`\n\n最后遇到一个小坑，在HTML文件引用入口文件中，地址应该是webpack配置中的`output.publicPath/[name].js`，如`<script src=\"/static/app.js\"></script>`。引用不到，或者路径错误会将html文件作为js文件引入，报错。  \n至此，在之后的编写中就不需要一遍又一遍的`webpack --config ****`\n\n------------------\n11.18补充\n\n分离打包：  \n在入口文件中添加要分离的模块：(这里将react和react-dom打包到vendor中)\n```javascript\nentry: {\n    app: [\n      'react-hot-loader/patch',\n      'webpack-hot-middleware/client',\n      path.join(src, 'index.js')\n    ],\n+    // 打包分离\n+    vendor: [\n+      'react',\n+      'react-dom'\n+    ]\n  },\n```\n增加CommonsChunkPlugin插件：\n```javascript\n  plugins: [\n+    // 分离打包\n+    new webpack.optimize.CommonsChunkPlugin({\n+      names: ['vendor']\n+    }),\n    // 热加载\n    new webpack.HotModuleReplacementPlugin()\n  ]\n```\n分离打包后，两个app.js和vendor.js都需要引入。","slug":"从零搭建React(2)","published":1,"updated":"2017-03-22T01:22:44.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8ki7001hohfknrtv1oia","content":"<p>提高开发效率，我们发现前面用的最多的就是<code>webpack --config ***</code>，然后去刷新页面。解决此问题，可以使用<a href=\"https://github.com/gaearon/react-hot-loader\" target=\"_blank\" rel=\"external\">react-hot-loader</a>，这应该也是我们使用github的原因，在这里我们可以找到解决各种问题的办法。<br>查看其中使用方法（看不懂英文就用翻译一句一句看呗，其实我也是这么看过来的），会发现这一句These steps are covered by <a href=\"http://gaearon.github.io/react-hot-loader/getstarted/\" target=\"_blank\" rel=\"external\">the walkthrough</a>（这里应该是1版本的写法）。<br>根据这里的步骤，先是安装react-hot-loader，然后是server.js，提供有事例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 我的路径 myapp/src/config/server.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.config'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> app = express()</div><div class=\"line\"><span class=\"keyword\">var</span> compiler = webpack(config)</div><div class=\"line\"></div><div class=\"line\">app.use(<span class=\"built_in\">require</span>(<span class=\"string\">'webpack-dev-middleware'</span>)(compiler, &#123;</div><div class=\"line\">  <span class=\"attr\">publicPath</span>: config.output.publicPath</div><div class=\"line\">&#125;))</div><div class=\"line\"></div><div class=\"line\">app.use(<span class=\"built_in\">require</span>(<span class=\"string\">'webpack-hot-middleware'</span>)(compiler))</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'*'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">  res.sendFile(path.join(__dirname, <span class=\"string\">'../index.html'</span>))</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.error(err)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Listening at http://localhost:3000/'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>需要安装express，另外需要修改<code>res.sendFile(path.join(__dirname, &#39;../index.html&#39;))</code>这里的路径，还有端口。<br>接着修改webpack的配置文件，在入口配置项前面添加，<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">entry: &#123;</div><div class=\"line\">  <span class=\"attr\">app</span>: [</div><div class=\"line\">  <span class=\"string\">'webpack-dev-server/client?http://0.0.0.0:3000'</span>, <span class=\"comment\">// WebpackDevServer host and port</span></div><div class=\"line\">  <span class=\"string\">'webpack/hot/only-dev-server'</span>, <span class=\"comment\">// \"only\" prevents reload on syntax errors</span></div><div class=\"line\">  path.join(src, <span class=\"string\">'app.js'</span>)</div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个应该是1版本的写法，而我这里安装的是3版本，导致页面会多次刷新。下面是3版本，具体参看<a href=\"https://github.com/gaearon/react-hot-boilerplate/tree/next\" target=\"_blank\" rel=\"external\">事例</a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">entry: &#123;</div><div class=\"line\">    <span class=\"attr\">app</span>: [</div><div class=\"line\">      <span class=\"string\">'react-hot-loader/patch'</span>,</div><div class=\"line\">      <span class=\"string\">'webpack-hot-middleware/client'</span>,</div><div class=\"line\">      path.join(src, <span class=\"string\">'app.js'</span>)</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>接着是在oader中添加react-hot，按照官网是将react-hot添加在babel前面即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">loaders: [&#123;</div><div class=\"line\">  <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>,</div><div class=\"line\">  <span class=\"attr\">include</span>: src,</div><div class=\"line\">  <span class=\"attr\">loaders</span>: [<span class=\"string\">'react-hot'</span>, <span class=\"string\">'babel'</span>]</div><div class=\"line\">&#125;]</div></pre></td></tr></table></figure></p>\n<p>但是在我这里报错了，报错提示还算明显，大致就是将react-hot-loader/babel添加到babel的plugins中，于是修改<code>myapp/.babelrc</code>解决。同样是1和3的区别<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"presets\"</span>: [<span class=\"string\">\"es2015\"</span>, <span class=\"string\">\"react\"</span>, <span class=\"string\">\"stage-0\"</span>],</div><div class=\"line\">  <span class=\"attr\">\"plugins\"</span>: [<span class=\"string\">\"react-hot-loader/babel\"</span>]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后一步，是webpack中添加plugins<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">plugins: [</div><div class=\"line\">  <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>1版本到这里就结束了，3版本是这样的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// myapp/src/app.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></div><div class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; AppContainer &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-hot-loader'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'./Hello'</span></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./app.scss'</span></div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">AppContainer</span>&gt;</span></span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">Hello</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">AppContainer</span>&gt;</span>,</div><div class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>)</div><div class=\"line\">  )</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.hot) &#123;</div><div class=\"line\">  <span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">'./Hello'</span>, () =&gt; &#123;</div><div class=\"line\">    <span class=\"comment\">// If you use Webpack 2 in ES modules mode, you can</span></div><div class=\"line\">    <span class=\"comment\">// use &lt;App /&gt; here rather than require() a &lt;NextApp /&gt;.</span></div><div class=\"line\">    <span class=\"keyword\">const</span> NextApp = <span class=\"built_in\">require</span>(<span class=\"string\">'./Hello'</span>).default</div><div class=\"line\">    ReactDOM.render(</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">AppContainer</span>&gt;</span></span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">NextApp</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">AppContainer</span>&gt;</span>,</div><div class=\"line\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>)</div><div class=\"line\">    )</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// myapp/src/Hello.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Layout</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  )</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里有个小坑，改变app.js文件中的内容并不会刷新，需要手动刷新页面。</p>\n<p>启动就是<code>node src/config/server.js</code>，可以将其写入到package.json文件中<code>&quot;script&quot;: {&quot;start&quot;: &quot;node src/config/server.js&quot;}</code></p>\n<p>最后遇到一个小坑，在HTML文件引用入口文件中，地址应该是webpack配置中的<code>output.publicPath/[name].js</code>，如<code>&lt;script src=&quot;/static/app.js&quot;&gt;&lt;/script&gt;</code>。引用不到，或者路径错误会将html文件作为js文件引入，报错。<br>至此，在之后的编写中就不需要一遍又一遍的<code>webpack --config ****</code></p>\n<hr>\n<p>11.18补充</p>\n<p>分离打包：<br>在入口文件中添加要分离的模块：(这里将react和react-dom打包到vendor中)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">entry: &#123;</div><div class=\"line\">    <span class=\"attr\">app</span>: [</div><div class=\"line\">      <span class=\"string\">'react-hot-loader/patch'</span>,</div><div class=\"line\">      <span class=\"string\">'webpack-hot-middleware/client'</span>,</div><div class=\"line\">      path.join(src, <span class=\"string\">'index.js'</span>)</div><div class=\"line\">    ],</div><div class=\"line\">+    <span class=\"comment\">// 打包分离</span></div><div class=\"line\">+    vendor: [</div><div class=\"line\">+      <span class=\"string\">'react'</span>,</div><div class=\"line\">+      <span class=\"string\">'react-dom'</span></div><div class=\"line\">+    ]</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>增加CommonsChunkPlugin插件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">  plugins: [</div><div class=\"line\">+    <span class=\"comment\">// 分离打包</span></div><div class=\"line\">+    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class=\"line\">+      names: [<span class=\"string\">'vendor'</span>]</div><div class=\"line\">+    &#125;),</div><div class=\"line\">    <span class=\"comment\">// 热加载</span></div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</div><div class=\"line\">  ]</div></pre></td></tr></table></figure></p>\n<p>分离打包后，两个app.js和vendor.js都需要引入。</p>\n","excerpt":"","more":"<p>提高开发效率，我们发现前面用的最多的就是<code>webpack --config ***</code>，然后去刷新页面。解决此问题，可以使用<a href=\"https://github.com/gaearon/react-hot-loader\">react-hot-loader</a>，这应该也是我们使用github的原因，在这里我们可以找到解决各种问题的办法。<br>查看其中使用方法（看不懂英文就用翻译一句一句看呗，其实我也是这么看过来的），会发现这一句These steps are covered by <a href=\"http://gaearon.github.io/react-hot-loader/getstarted/\">the walkthrough</a>（这里应该是1版本的写法）。<br>根据这里的步骤，先是安装react-hot-loader，然后是server.js，提供有事例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 我的路径 myapp/src/config/server.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.config'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> app = express()</div><div class=\"line\"><span class=\"keyword\">var</span> compiler = webpack(config)</div><div class=\"line\"></div><div class=\"line\">app.use(<span class=\"built_in\">require</span>(<span class=\"string\">'webpack-dev-middleware'</span>)(compiler, &#123;</div><div class=\"line\">  <span class=\"attr\">publicPath</span>: config.output.publicPath</div><div class=\"line\">&#125;))</div><div class=\"line\"></div><div class=\"line\">app.use(<span class=\"built_in\">require</span>(<span class=\"string\">'webpack-hot-middleware'</span>)(compiler))</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'*'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">  res.sendFile(path.join(__dirname, <span class=\"string\">'../index.html'</span>))</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.error(err)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Listening at http://localhost:3000/'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>需要安装express，另外需要修改<code>res.sendFile(path.join(__dirname, &#39;../index.html&#39;))</code>这里的路径，还有端口。<br>接着修改webpack的配置文件，在入口配置项前面添加，<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">entry: &#123;</div><div class=\"line\">  <span class=\"attr\">app</span>: [</div><div class=\"line\">  <span class=\"string\">'webpack-dev-server/client?http://0.0.0.0:3000'</span>, <span class=\"comment\">// WebpackDevServer host and port</span></div><div class=\"line\">  <span class=\"string\">'webpack/hot/only-dev-server'</span>, <span class=\"comment\">// \"only\" prevents reload on syntax errors</span></div><div class=\"line\">  path.join(src, <span class=\"string\">'app.js'</span>)</div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个应该是1版本的写法，而我这里安装的是3版本，导致页面会多次刷新。下面是3版本，具体参看<a href=\"https://github.com/gaearon/react-hot-boilerplate/tree/next\">事例</a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">entry: &#123;</div><div class=\"line\">    <span class=\"attr\">app</span>: [</div><div class=\"line\">      <span class=\"string\">'react-hot-loader/patch'</span>,</div><div class=\"line\">      <span class=\"string\">'webpack-hot-middleware/client'</span>,</div><div class=\"line\">      path.join(src, <span class=\"string\">'app.js'</span>)</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>接着是在oader中添加react-hot，按照官网是将react-hot添加在babel前面即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">loaders: [&#123;</div><div class=\"line\">  <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>,</div><div class=\"line\">  <span class=\"attr\">include</span>: src,</div><div class=\"line\">  <span class=\"attr\">loaders</span>: [<span class=\"string\">'react-hot'</span>, <span class=\"string\">'babel'</span>]</div><div class=\"line\">&#125;]</div></pre></td></tr></table></figure></p>\n<p>但是在我这里报错了，报错提示还算明显，大致就是将react-hot-loader/babel添加到babel的plugins中，于是修改<code>myapp/.babelrc</code>解决。同样是1和3的区别<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"presets\"</span>: [<span class=\"string\">\"es2015\"</span>, <span class=\"string\">\"react\"</span>, <span class=\"string\">\"stage-0\"</span>],</div><div class=\"line\">  <span class=\"attr\">\"plugins\"</span>: [<span class=\"string\">\"react-hot-loader/babel\"</span>]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后一步，是webpack中添加plugins<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">plugins: [</div><div class=\"line\">  <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>1版本到这里就结束了，3版本是这样的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// myapp/src/app.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></div><div class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; AppContainer &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-hot-loader'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'./Hello'</span></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./app.scss'</span></div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">AppContainer</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">Hello</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">AppContainer</span>&gt;</span></span>,</div><div class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>)</div><div class=\"line\">  )</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.hot) &#123;</div><div class=\"line\">  <span class=\"built_in\">module</span>.hot.accept(<span class=\"string\">'./Hello'</span>, () =&gt; &#123;</div><div class=\"line\">    <span class=\"comment\">// If you use Webpack 2 in ES modules mode, you can</span></div><div class=\"line\">    <span class=\"comment\">// use &lt;App /&gt; here rather than require() a &lt;NextApp /&gt;.</span></div><div class=\"line\">    <span class=\"keyword\">const</span> NextApp = <span class=\"built_in\">require</span>(<span class=\"string\">'./Hello'</span>).default</div><div class=\"line\">    ReactDOM.render(</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">AppContainer</span>&gt;</span></div><div class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">NextApp</span> /&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">AppContainer</span>&gt;</span></span>,</div><div class=\"line\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>)</div><div class=\"line\">    )</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// myapp/src/Hello.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Layout</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world!!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">  )</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里有个小坑，改变app.js文件中的内容并不会刷新，需要手动刷新页面。</p>\n<p>启动就是<code>node src/config/server.js</code>，可以将其写入到package.json文件中<code>&quot;script&quot;: {&quot;start&quot;: &quot;node src/config/server.js&quot;}</code></p>\n<p>最后遇到一个小坑，在HTML文件引用入口文件中，地址应该是webpack配置中的<code>output.publicPath/[name].js</code>，如<code>&lt;script src=&quot;/static/app.js&quot;&gt;&lt;/script&gt;</code>。引用不到，或者路径错误会将html文件作为js文件引入，报错。<br>至此，在之后的编写中就不需要一遍又一遍的<code>webpack --config ****</code></p>\n<hr>\n<p>11.18补充</p>\n<p>分离打包：<br>在入口文件中添加要分离的模块：(这里将react和react-dom打包到vendor中)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">entry: &#123;</div><div class=\"line\">    <span class=\"attr\">app</span>: [</div><div class=\"line\">      <span class=\"string\">'react-hot-loader/patch'</span>,</div><div class=\"line\">      <span class=\"string\">'webpack-hot-middleware/client'</span>,</div><div class=\"line\">      path.join(src, <span class=\"string\">'index.js'</span>)</div><div class=\"line\">    ],</div><div class=\"line\">+    <span class=\"comment\">// 打包分离</span></div><div class=\"line\">+    vendor: [</div><div class=\"line\">+      <span class=\"string\">'react'</span>,</div><div class=\"line\">+      <span class=\"string\">'react-dom'</span></div><div class=\"line\">+    ]</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>增加CommonsChunkPlugin插件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">  plugins: [</div><div class=\"line\">+    <span class=\"comment\">// 分离打包</span></div><div class=\"line\">+    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class=\"line\">+      names: [<span class=\"string\">'vendor'</span>]</div><div class=\"line\">+    &#125;),</div><div class=\"line\">    <span class=\"comment\">// 热加载</span></div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</div><div class=\"line\">  ]</div></pre></td></tr></table></figure></p>\n<p>分离打包后，两个app.js和vendor.js都需要引入。</p>\n"},{"title":"从零开始搭建React(3)","date":"2016-11-15T16:00:00.000Z","comments":1,"_content":"\n相信学习React的都是有过一定了解的，React页面都是一个个组件构成的，所以写React也就是写一个个组件的过程。  \n目前，从写法上来说React组件主要有两种写法，一种是函数式(Functional)组件，一种是继承类(Class)组件：\n```javascript\n// Functional\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>\n}\n// ES6下更多情况会写成这样，其实就是一段返回一段jsx的函数\nconst Welcome = (props) => {\n  return (\n    <h1>Hello, {props.name}</h1>\n  )\n}\nexport default Welcome\n\n// Class\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n// ES6下一般为方便导入加入下面\nexport default Welcom\n```\n按照React组件的功能可以分为有状态组件和无状态组件。无状态组件一般使用函数式组件即可。  \n我的建议是，如果不清楚是用哪一种写法去编写组件，可以先使用函数式组件。在编写过程中如若发现需要使用state或者组件生命周期，再将此组件改成继承类组件。下面是一个比较完整的继承类组件架子：\n```javascript\nclass MyComponent extends Component {\n    // 构造函数\n  constructor (props) {\n    super(props)\n    // 设置state\n    this.state = {\n      ...\n    }\n    // 定义 eventHandler\n    this.handleClick = this.handleClick.bind(this)\n  }\n\n  // 生命周期方法\n  componentWillMount () {}\n  componentDidMount () {}\n  componentWillReceiveProps () {}\n  componentWillUpdate () {}\n  componentWillUnmount () {}\n\n  // handlers\n  handleClick() {\n    this.setState({\n      ...\n    })\n  }\n\n  render() {\n    // 这里是组件的内容\n    return (\n        <div onClick={this.handleClick}>\n        </div>\n      )\n  }\n}\n\nMyComponent.defaultProps = {}\nMyComponent.propTypes = {}\n\nexport default MyComponent\n```\n    需要注意点：\n      无论哪种写法，return中必须被一个标签包裹，这是jsx语法要求的。\n      函数式组件也可以设置defaultProps和propTypes。\n      函数式组件中不能访问this。\n      可以声明变量值为jsx，如：let a = <div></div>","source":"_posts/从零搭建React(3).md","raw":"---\ntitle: 从零开始搭建React(3)\ndate: 2016-11-16\ntags: [JavaScript, React, Webpack]\ncategories: \n- React\ncomments: true\n---\n\n相信学习React的都是有过一定了解的，React页面都是一个个组件构成的，所以写React也就是写一个个组件的过程。  \n目前，从写法上来说React组件主要有两种写法，一种是函数式(Functional)组件，一种是继承类(Class)组件：\n```javascript\n// Functional\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>\n}\n// ES6下更多情况会写成这样，其实就是一段返回一段jsx的函数\nconst Welcome = (props) => {\n  return (\n    <h1>Hello, {props.name}</h1>\n  )\n}\nexport default Welcome\n\n// Class\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n// ES6下一般为方便导入加入下面\nexport default Welcom\n```\n按照React组件的功能可以分为有状态组件和无状态组件。无状态组件一般使用函数式组件即可。  \n我的建议是，如果不清楚是用哪一种写法去编写组件，可以先使用函数式组件。在编写过程中如若发现需要使用state或者组件生命周期，再将此组件改成继承类组件。下面是一个比较完整的继承类组件架子：\n```javascript\nclass MyComponent extends Component {\n    // 构造函数\n  constructor (props) {\n    super(props)\n    // 设置state\n    this.state = {\n      ...\n    }\n    // 定义 eventHandler\n    this.handleClick = this.handleClick.bind(this)\n  }\n\n  // 生命周期方法\n  componentWillMount () {}\n  componentDidMount () {}\n  componentWillReceiveProps () {}\n  componentWillUpdate () {}\n  componentWillUnmount () {}\n\n  // handlers\n  handleClick() {\n    this.setState({\n      ...\n    })\n  }\n\n  render() {\n    // 这里是组件的内容\n    return (\n        <div onClick={this.handleClick}>\n        </div>\n      )\n  }\n}\n\nMyComponent.defaultProps = {}\nMyComponent.propTypes = {}\n\nexport default MyComponent\n```\n    需要注意点：\n      无论哪种写法，return中必须被一个标签包裹，这是jsx语法要求的。\n      函数式组件也可以设置defaultProps和propTypes。\n      函数式组件中不能访问this。\n      可以声明变量值为jsx，如：let a = <div></div>","slug":"从零搭建React(3)","published":1,"updated":"2017-03-22T01:23:23.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8ki8001kohfkbr8qr3rt","content":"<p>相信学习React的都是有过一定了解的，React页面都是一个个组件构成的，所以写React也就是写一个个组件的过程。<br>目前，从写法上来说React组件主要有两种写法，一种是函数式(Functional)组件，一种是继承类(Class)组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Functional</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// ES6下更多情况会写成这样，其实就是一段返回一段jsx的函数</span></div><div class=\"line\"><span class=\"keyword\">const</span> Welcome = <span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">  )</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Welcome</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Class</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Welcome</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// ES6下一般为方便导入加入下面</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Welcom</div></pre></td></tr></table></figure></p>\n<p>按照React组件的功能可以分为有状态组件和无状态组件。无状态组件一般使用函数式组件即可。<br>我的建议是，如果不清楚是用哪一种写法去编写组件，可以先使用函数式组件。在编写过程中如若发现需要使用state或者组件生命周期，再将此组件改成继承类组件。下面是一个比较完整的继承类组件架子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 构造函数</span></div><div class=\"line\">  <span class=\"keyword\">constructor</span> (props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props)</div><div class=\"line\">    <span class=\"comment\">// 设置state</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 定义 eventHandler</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 生命周期方法</span></div><div class=\"line\">  componentWillMount () &#123;&#125;</div><div class=\"line\">  componentDidMount () &#123;&#125;</div><div class=\"line\">  componentWillReceiveProps () &#123;&#125;</div><div class=\"line\">  componentWillUpdate () &#123;&#125;</div><div class=\"line\">  componentWillUnmount () &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// handlers</span></div><div class=\"line\">  handleClick() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"comment\">// 这里是组件的内容</span></div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">        <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handleClick&#125;</span>&gt;</span></span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">MyComponent.defaultProps = &#123;&#125;</div><div class=\"line\">MyComponent.propTypes = &#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> MyComponent</div></pre></td></tr></table></figure></p>\n<pre><code>需要注意点：\n  无论哪种写法，return中必须被一个标签包裹，这是jsx语法要求的。\n  函数式组件也可以设置defaultProps和propTypes。\n  函数式组件中不能访问this。\n  可以声明变量值为jsx，如：let a = &lt;div&gt;&lt;/div&gt;\n</code></pre>","excerpt":"","more":"<p>相信学习React的都是有过一定了解的，React页面都是一个个组件构成的，所以写React也就是写一个个组件的过程。<br>目前，从写法上来说React组件主要有两种写法，一种是函数式(Functional)组件，一种是继承类(Class)组件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Functional</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// ES6下更多情况会写成这样，其实就是一段返回一段jsx的函数</span></div><div class=\"line\"><span class=\"keyword\">const</span> Welcome = <span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">  )</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Welcome</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Class</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Welcome</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// ES6下一般为方便导入加入下面</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Welcom</div></pre></td></tr></table></figure></p>\n<p>按照React组件的功能可以分为有状态组件和无状态组件。无状态组件一般使用函数式组件即可。<br>我的建议是，如果不清楚是用哪一种写法去编写组件，可以先使用函数式组件。在编写过程中如若发现需要使用state或者组件生命周期，再将此组件改成继承类组件。下面是一个比较完整的继承类组件架子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 构造函数</span></div><div class=\"line\">  <span class=\"keyword\">constructor</span> (props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props)</div><div class=\"line\">    <span class=\"comment\">// 设置state</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 定义 eventHandler</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 生命周期方法</span></div><div class=\"line\">  componentWillMount () &#123;&#125;</div><div class=\"line\">  componentDidMount () &#123;&#125;</div><div class=\"line\">  componentWillReceiveProps () &#123;&#125;</div><div class=\"line\">  componentWillUpdate () &#123;&#125;</div><div class=\"line\">  componentWillUnmount () &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// handlers</span></div><div class=\"line\">  handleClick() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"comment\">// 这里是组件的内容</span></div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">        <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handleClick&#125;</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">      )</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">MyComponent.defaultProps = &#123;&#125;</div><div class=\"line\">MyComponent.propTypes = &#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> MyComponent</div></pre></td></tr></table></figure></p>\n<pre><code>需要注意点：\n  无论哪种写法，return中必须被一个标签包裹，这是jsx语法要求的。\n  函数式组件也可以设置defaultProps和propTypes。\n  函数式组件中不能访问this。\n  可以声明变量值为jsx，如：let a = &lt;div&gt;&lt;/div&gt;\n</code></pre>"},{"title":"函数节流","date":"2016-07-27T16:00:00.000Z","comments":1,"_content":"\n[From](http://imweb.io/topic/577aa790ea7bb9b760c7adc3)\n\n函数节流：常用于onresize,scroll,mousemove,mousehover等连续触发的事件(隔断时间触发一次)。\n\n方法：\n\n\teg.\n```javascript \n\t\twindow.onscroll = function() {\n\t\t\tconsole.log('scoll滑动');\n\t\t\tthrottle(count);\n\t\t};\n\n\t\tfunction count() {\n\t\t\tconsole.log('函数调用');\n\t\t}\n\n\t\tfunction throttle(method, context) {\n\t\t\t// 如果连续触发就会方法会被清除，所以只会执行最后一次\n\t\t\tclearTimeout(method.tId);\n\t\t\tmethod.tId = setTimeout(function() {\n\t\t\t\tmethod.call(context);\n\t\t\t}, 300);\n\t\t}\n\n\t// eg.\n\t\tvar time = +new Date(); // 隐式转换，相当于new Date().getTime()\n\t\tfunction count() {\n\t\t\tconsole.log('函数调用：' + (+new Date() - time));\n\t\t}\n\n\n\t\t// 到达mustRun毫秒一定执行\n\t\tvar throttle = function(fn, delay, mustRun) {\n\t\t\tvar timer = null,\n\t\t\t\t\tprevious = null;\n\n\t\t\treturn function() {\n\t\t\t\tvar now = +new Date(),\n\t\t\t\t\t\tcontext = this,\n\t\t\t\t\t\targs = arguments;\n\t\t\t\t// 闭包，只有在第一次执行时，previous==null，会被赋值为now\n\t\t\t\tif(!previous) previous = now;\n\t\t\t\tvar remaining = now - previous;\n\t\t\t\tif(mustRun && remaining >= mustRun){\n\t\t\t\t\tfn.apply(context, args);\n\t\t\t\t\tprevious = now;\n\t\t\t\t} else {\n\t\t\t\t\tcleaerTimeout(timer);\n\t\t\t\t\ttimer = setTimeout(function() {\n\t\t\t\t\t\tfn.apply(context, args);\n\t\t\t\t\t}, delay);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\twindow.onscroll = throttle(count, 500, 1000);\n```","source":"_posts/函数节流.md","raw":"---\ntitle: 函数节流\ndate: 2016-07-28\ntags: JavaScript\ncategories: \n- JavaScript\ncomments: true\n---\n\n[From](http://imweb.io/topic/577aa790ea7bb9b760c7adc3)\n\n函数节流：常用于onresize,scroll,mousemove,mousehover等连续触发的事件(隔断时间触发一次)。\n\n方法：\n\n\teg.\n```javascript \n\t\twindow.onscroll = function() {\n\t\t\tconsole.log('scoll滑动');\n\t\t\tthrottle(count);\n\t\t};\n\n\t\tfunction count() {\n\t\t\tconsole.log('函数调用');\n\t\t}\n\n\t\tfunction throttle(method, context) {\n\t\t\t// 如果连续触发就会方法会被清除，所以只会执行最后一次\n\t\t\tclearTimeout(method.tId);\n\t\t\tmethod.tId = setTimeout(function() {\n\t\t\t\tmethod.call(context);\n\t\t\t}, 300);\n\t\t}\n\n\t// eg.\n\t\tvar time = +new Date(); // 隐式转换，相当于new Date().getTime()\n\t\tfunction count() {\n\t\t\tconsole.log('函数调用：' + (+new Date() - time));\n\t\t}\n\n\n\t\t// 到达mustRun毫秒一定执行\n\t\tvar throttle = function(fn, delay, mustRun) {\n\t\t\tvar timer = null,\n\t\t\t\t\tprevious = null;\n\n\t\t\treturn function() {\n\t\t\t\tvar now = +new Date(),\n\t\t\t\t\t\tcontext = this,\n\t\t\t\t\t\targs = arguments;\n\t\t\t\t// 闭包，只有在第一次执行时，previous==null，会被赋值为now\n\t\t\t\tif(!previous) previous = now;\n\t\t\t\tvar remaining = now - previous;\n\t\t\t\tif(mustRun && remaining >= mustRun){\n\t\t\t\t\tfn.apply(context, args);\n\t\t\t\t\tprevious = now;\n\t\t\t\t} else {\n\t\t\t\t\tcleaerTimeout(timer);\n\t\t\t\t\ttimer = setTimeout(function() {\n\t\t\t\t\t\tfn.apply(context, args);\n\t\t\t\t\t}, delay);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\twindow.onscroll = throttle(count, 500, 1000);\n```","slug":"函数节流","published":1,"updated":"2017-03-22T01:23:41.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8kia001oohfkwu8m9mwt","content":"<p><a href=\"http://imweb.io/topic/577aa790ea7bb9b760c7adc3\" target=\"_blank\" rel=\"external\">From</a></p>\n<p>函数节流：常用于onresize,scroll,mousemove,mousehover等连续触发的事件(隔断时间触发一次)。</p>\n<p>方法：</p>\n<pre><code>eg.\n</code></pre><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t<span class=\"built_in\">window</span>.onscroll = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'scoll滑动'</span>);</div><div class=\"line\">\t\tthrottle(count);</div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'函数调用'</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">method, context</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 如果连续触发就会方法会被清除，所以只会执行最后一次</span></div><div class=\"line\">\t\tclearTimeout(method.tId);</div><div class=\"line\">\t\tmethod.tId = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\tmethod.call(context);</div><div class=\"line\">\t\t&#125;, <span class=\"number\">300</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// eg.</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> time = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); <span class=\"comment\">// 隐式转换，相当于new Date().getTime()</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'函数调用：'</span> + (+<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - time));</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 到达mustRun毫秒一定执行</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn, delay, mustRun</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>,</div><div class=\"line\">\t\t\t\tprevious = <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</div><div class=\"line\">\t\t\t\t\tcontext = <span class=\"keyword\">this</span>,</div><div class=\"line\">\t\t\t\t\targs = <span class=\"built_in\">arguments</span>;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 闭包，只有在第一次执行时，previous==null，会被赋值为now</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!previous) previous = now;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> remaining = now - previous;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(mustRun &amp;&amp; remaining &gt;= mustRun)&#123;</div><div class=\"line\">\t\t\t\tfn.apply(context, args);</div><div class=\"line\">\t\t\t\tprevious = now;</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\tcleaerTimeout(timer);</div><div class=\"line\">\t\t\t\ttimer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\tfn.apply(context, args);</div><div class=\"line\">\t\t\t\t&#125;, delay);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"built_in\">window</span>.onscroll = throttle(count, <span class=\"number\">500</span>, <span class=\"number\">1000</span>);</div></pre></td></tr></table></figure>","excerpt":"","more":"<p><a href=\"http://imweb.io/topic/577aa790ea7bb9b760c7adc3\">From</a></p>\n<p>函数节流：常用于onresize,scroll,mousemove,mousehover等连续触发的事件(隔断时间触发一次)。</p>\n<p>方法：</p>\n<pre><code>eg.\n</code></pre><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t<span class=\"built_in\">window</span>.onscroll = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'scoll滑动'</span>);</div><div class=\"line\">\t\tthrottle(count);</div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'函数调用'</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">method, context</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 如果连续触发就会方法会被清除，所以只会执行最后一次</span></div><div class=\"line\">\t\tclearTimeout(method.tId);</div><div class=\"line\">\t\tmethod.tId = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\tmethod.call(context);</div><div class=\"line\">\t\t&#125;, <span class=\"number\">300</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// eg.</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> time = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); <span class=\"comment\">// 隐式转换，相当于new Date().getTime()</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'函数调用：'</span> + (+<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - time));</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 到达mustRun毫秒一定执行</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn, delay, mustRun</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>,</div><div class=\"line\">\t\t\t\tprevious = <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</div><div class=\"line\">\t\t\t\t\tcontext = <span class=\"keyword\">this</span>,</div><div class=\"line\">\t\t\t\t\targs = <span class=\"built_in\">arguments</span>;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 闭包，只有在第一次执行时，previous==null，会被赋值为now</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!previous) previous = now;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> remaining = now - previous;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(mustRun &amp;&amp; remaining &gt;= mustRun)&#123;</div><div class=\"line\">\t\t\t\tfn.apply(context, args);</div><div class=\"line\">\t\t\t\tprevious = now;</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t\tcleaerTimeout(timer);</div><div class=\"line\">\t\t\t\ttimer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\tfn.apply(context, args);</div><div class=\"line\">\t\t\t\t&#125;, delay);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"built_in\">window</span>.onscroll = throttle(count, <span class=\"number\">500</span>, <span class=\"number\">1000</span>);</div></pre></td></tr></table></figure>"},{"title":"利用Github+Hexo搭建博客过程","date":"2016-06-09T14:11:35.000Z","comments":1,"_content":"\n　　有阵子没有静下心来做点什么了，希望通过博客，可以让自己多静下心来做些东西，学习下技术，记录一下过程。\n　　因为最近一直在学习和使用Github，希望通过Github来建立自己的博客，并且还能刷下自己Github上提交的贡献-.-\n　　总得过程还是比较容易的，因为自己有使用Github，电脑上也安装配置有nodejs，也看过markdown的一些语法，所以搭建起来，实现基本功能并没有花费多少时间。\n　　第一步，安装nodejs和Git。\n　　第二步，安装Hexo,和其他的包一样，通过`npm install-g hexo`来安装。<!--more-->\n　　第三步，创建一个用于存放Hexo的文件夹，在该文件夹目录下执行hexo init。\n　　第四步，执行`hexo g`(等同于`hexo generate`)生成静态页面，执行`hexo s`(等同于`hexo server`)启动本地服务进行预览，这样浏览器里可以输入`http://localhost:4000`进行访问。我第一次访问的时候，因为4000端口被占用，页面打不开，关闭占用端口后，正常。\n　　第五步，配置博客。在Hexo目录配置文件_config.yml中可以配置诸如标题、副标题、作者、语言、主题、部署等等配置。\n　　第六步，配置主题。搜索Hexo主题会有很多，并且都有使用说明。一般流程就是通过git clone复制到自己的目录下，在Hexo目录下的_config.yml文件中配置`theme`属性，之后就是主题配置文件(位于themes/*/_config.yml)进行个性化配置。\n  \n　　之后，就是把博客放到Github上去了。\n　　首先是在个人GIthub上建立新的仓库，仓库名为`username.github.io`，比如我的Github帐号是[PFanz](http://github.com/PFanz),仓库名就是`PFanz.github.io`。\n　　在Hexo配置文件_config.yml中配置`deploy`中各项，比如：\n```\ndeploy:\n  type: git\n  repo: https://github.com/PFanz/PFanz.github.io.git\n  branch: master\n```\n　　然后执行命令`npm install hexo-deployer-git --save`，便可以通过`username.github.io`访问到该博客。\n　　写博客可以通过命令`hexo new\"titleName\"`，在Hexo目录下`source/_posts`新建文件titleName.md，也可以自己手动建立。手动建立的话，需要自己加入头\n```\n---\ntitle: titleName\ndate: 2016-06-09 22:11:35\ntags: 标签\ncategories: \n- 分类名称\n---\n  ```\n  \n　　每次部署按一下三步\n```\nhexo clean\nhexo g\nhexo d\n```\n  \n  \n\n---\n　　虽然说基本功能已经搭建，感觉还有不少地方值得去探索，以实现更个性化，更漂亮的博客。","source":"_posts/利用Github+Hexo搭建博客过程.md","raw":"---\ntitle: 利用Github+Hexo搭建博客过程\ndate: 2016-06-09 22:11:35\ntags: [Hexo, 搭建博客]\ncategories: \n- 杂记\ncomments: true\n---\n\n　　有阵子没有静下心来做点什么了，希望通过博客，可以让自己多静下心来做些东西，学习下技术，记录一下过程。\n　　因为最近一直在学习和使用Github，希望通过Github来建立自己的博客，并且还能刷下自己Github上提交的贡献-.-\n　　总得过程还是比较容易的，因为自己有使用Github，电脑上也安装配置有nodejs，也看过markdown的一些语法，所以搭建起来，实现基本功能并没有花费多少时间。\n　　第一步，安装nodejs和Git。\n　　第二步，安装Hexo,和其他的包一样，通过`npm install-g hexo`来安装。<!--more-->\n　　第三步，创建一个用于存放Hexo的文件夹，在该文件夹目录下执行hexo init。\n　　第四步，执行`hexo g`(等同于`hexo generate`)生成静态页面，执行`hexo s`(等同于`hexo server`)启动本地服务进行预览，这样浏览器里可以输入`http://localhost:4000`进行访问。我第一次访问的时候，因为4000端口被占用，页面打不开，关闭占用端口后，正常。\n　　第五步，配置博客。在Hexo目录配置文件_config.yml中可以配置诸如标题、副标题、作者、语言、主题、部署等等配置。\n　　第六步，配置主题。搜索Hexo主题会有很多，并且都有使用说明。一般流程就是通过git clone复制到自己的目录下，在Hexo目录下的_config.yml文件中配置`theme`属性，之后就是主题配置文件(位于themes/*/_config.yml)进行个性化配置。\n  \n　　之后，就是把博客放到Github上去了。\n　　首先是在个人GIthub上建立新的仓库，仓库名为`username.github.io`，比如我的Github帐号是[PFanz](http://github.com/PFanz),仓库名就是`PFanz.github.io`。\n　　在Hexo配置文件_config.yml中配置`deploy`中各项，比如：\n```\ndeploy:\n  type: git\n  repo: https://github.com/PFanz/PFanz.github.io.git\n  branch: master\n```\n　　然后执行命令`npm install hexo-deployer-git --save`，便可以通过`username.github.io`访问到该博客。\n　　写博客可以通过命令`hexo new\"titleName\"`，在Hexo目录下`source/_posts`新建文件titleName.md，也可以自己手动建立。手动建立的话，需要自己加入头\n```\n---\ntitle: titleName\ndate: 2016-06-09 22:11:35\ntags: 标签\ncategories: \n- 分类名称\n---\n  ```\n  \n　　每次部署按一下三步\n```\nhexo clean\nhexo g\nhexo d\n```\n  \n  \n\n---\n　　虽然说基本功能已经搭建，感觉还有不少地方值得去探索，以实现更个性化，更漂亮的博客。","slug":"利用Github+Hexo搭建博客过程","published":1,"updated":"2017-03-22T01:23:56.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8kid001rohfkdch4cmzv","content":"<p>　　有阵子没有静下心来做点什么了，希望通过博客，可以让自己多静下心来做些东西，学习下技术，记录一下过程。<br>　　因为最近一直在学习和使用Github，希望通过Github来建立自己的博客，并且还能刷下自己Github上提交的贡献-.-<br>　　总得过程还是比较容易的，因为自己有使用Github，电脑上也安装配置有nodejs，也看过markdown的一些语法，所以搭建起来，实现基本功能并没有花费多少时间。<br>　　第一步，安装nodejs和Git。<br>　　第二步，安装Hexo,和其他的包一样，通过<code>npm install-g hexo</code>来安装。<a id=\"more\"></a><br>　　第三步，创建一个用于存放Hexo的文件夹，在该文件夹目录下执行hexo init。<br>　　第四步，执行<code>hexo g</code>(等同于<code>hexo generate</code>)生成静态页面，执行<code>hexo s</code>(等同于<code>hexo server</code>)启动本地服务进行预览，这样浏览器里可以输入<code>http://localhost:4000</code>进行访问。我第一次访问的时候，因为4000端口被占用，页面打不开，关闭占用端口后，正常。<br>　　第五步，配置博客。在Hexo目录配置文件_config.yml中可以配置诸如标题、副标题、作者、语言、主题、部署等等配置。<br>　　第六步，配置主题。搜索Hexo主题会有很多，并且都有使用说明。一般流程就是通过git clone复制到自己的目录下，在Hexo目录下的_config.yml文件中配置<code>theme</code>属性，之后就是主题配置文件(位于themes/*/_config.yml)进行个性化配置。</p>\n<p>　　之后，就是把博客放到Github上去了。<br>　　首先是在个人GIthub上建立新的仓库，仓库名为<code>username.github.io</code>，比如我的Github帐号是<a href=\"http://github.com/PFanz\" target=\"_blank\" rel=\"external\">PFanz</a>,仓库名就是<code>PFanz.github.io</code>。<br>　　在Hexo配置文件_config.yml中配置<code>deploy</code>中各项，比如：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">deploy</span>:</div><div class=\"line\">  <span class=\"attribute\">type</span>: git</div><div class=\"line\">  <span class=\"attribute\">repo</span>: <span class=\"attribute\">https</span>:<span class=\"comment\">//github.com/PFanz/PFanz.github.io.git</span></div><div class=\"line\">  <span class=\"attribute\">branch</span>: master</div></pre></td></tr></table></figure></p>\n<p>　　然后执行命令<code>npm install hexo-deployer-git --save</code>，便可以通过<code>username.github.io</code>访问到该博客。<br>　　写博客可以通过命令<code>hexo new&quot;titleName&quot;</code>，在Hexo目录下<code>source/_posts</code>新建文件titleName.md，也可以自己手动建立。手动建立的话，需要自己加入头<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">---</span></div><div class=\"line\"><span class=\"attr\">title:</span> titleName</div><div class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2016</span><span class=\"bullet\">-06</span><span class=\"bullet\">-09</span> <span class=\"number\">22</span>:<span class=\"number\">11</span>:<span class=\"number\">35</span></div><div class=\"line\"><span class=\"attr\">tags:</span> 标签</div><div class=\"line\"><span class=\"attr\">categories:</span> </div><div class=\"line\"><span class=\"bullet\">-</span> 分类名称</div><div class=\"line\"><span class=\"meta\">---</span></div></pre></td></tr></table></figure></p>\n<p>　　每次部署按一下三步<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">hexo clean</span></div><div class=\"line\">hexo g</div><div class=\"line\">hexo d</div></pre></td></tr></table></figure></p>\n<hr>\n<p>　　虽然说基本功能已经搭建，感觉还有不少地方值得去探索，以实现更个性化，更漂亮的博客。</p>\n","excerpt":"<p>　　有阵子没有静下心来做点什么了，希望通过博客，可以让自己多静下心来做些东西，学习下技术，记录一下过程。<br>　　因为最近一直在学习和使用Github，希望通过Github来建立自己的博客，并且还能刷下自己Github上提交的贡献-.-<br>　　总得过程还是比较容易的，因为自己有使用Github，电脑上也安装配置有nodejs，也看过markdown的一些语法，所以搭建起来，实现基本功能并没有花费多少时间。<br>　　第一步，安装nodejs和Git。<br>　　第二步，安装Hexo,和其他的包一样，通过<code>npm install-g hexo</code>来安装。","more":"<br>　　第三步，创建一个用于存放Hexo的文件夹，在该文件夹目录下执行hexo init。<br>　　第四步，执行<code>hexo g</code>(等同于<code>hexo generate</code>)生成静态页面，执行<code>hexo s</code>(等同于<code>hexo server</code>)启动本地服务进行预览，这样浏览器里可以输入<code>http://localhost:4000</code>进行访问。我第一次访问的时候，因为4000端口被占用，页面打不开，关闭占用端口后，正常。<br>　　第五步，配置博客。在Hexo目录配置文件_config.yml中可以配置诸如标题、副标题、作者、语言、主题、部署等等配置。<br>　　第六步，配置主题。搜索Hexo主题会有很多，并且都有使用说明。一般流程就是通过git clone复制到自己的目录下，在Hexo目录下的_config.yml文件中配置<code>theme</code>属性，之后就是主题配置文件(位于themes/*/_config.yml)进行个性化配置。</p>\n<p>　　之后，就是把博客放到Github上去了。<br>　　首先是在个人GIthub上建立新的仓库，仓库名为<code>username.github.io</code>，比如我的Github帐号是<a href=\"http://github.com/PFanz\">PFanz</a>,仓库名就是<code>PFanz.github.io</code>。<br>　　在Hexo配置文件_config.yml中配置<code>deploy</code>中各项，比如：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">deploy</span>:</div><div class=\"line\">  <span class=\"attribute\">type</span>: git</div><div class=\"line\">  <span class=\"attribute\">repo</span>: <span class=\"attribute\">https</span>:<span class=\"comment\">//github.com/PFanz/PFanz.github.io.git</span></div><div class=\"line\">  <span class=\"attribute\">branch</span>: master</div></pre></td></tr></table></figure></p>\n<p>　　然后执行命令<code>npm install hexo-deployer-git --save</code>，便可以通过<code>username.github.io</code>访问到该博客。<br>　　写博客可以通过命令<code>hexo new&quot;titleName&quot;</code>，在Hexo目录下<code>source/_posts</code>新建文件titleName.md，也可以自己手动建立。手动建立的话，需要自己加入头<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">---</span></div><div class=\"line\"><span class=\"attr\">title:</span> titleName</div><div class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2016</span><span class=\"bullet\">-06</span><span class=\"bullet\">-09</span> <span class=\"number\">22</span>:<span class=\"number\">11</span>:<span class=\"number\">35</span></div><div class=\"line\"><span class=\"attr\">tags:</span> 标签</div><div class=\"line\"><span class=\"attr\">categories:</span> </div><div class=\"line\"><span class=\"bullet\">-</span> 分类名称</div><div class=\"line\"><span class=\"meta\">---</span></div></pre></td></tr></table></figure></p>\n<p>　　每次部署按一下三步<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">hexo clean</div><div class=\"line\">hexo g</div><div class=\"line\">hexo d</span></div></pre></td></tr></table></figure></p>\n<hr>\n<p>　　虽然说基本功能已经搭建，感觉还有不少地方值得去探索，以实现更个性化，更漂亮的博客。</p>"},{"title":"前端技术栈","date":"2016-10-08T16:00:00.000Z","comments":1,"_content":"\n浏览器环境IE6~8 IE9+ Chrome Firefox Safari Opera Edge\t\t\t\t持续学习\n\nHTTP协议URI Cache Session Cookie Request Response\t\t\t\t\t持续学习\n\nHTMLW3C HTML4.01 HTML5 DOM 语义化\t\t\t\t\t\t\t\t\t\t\t\t\t持续学习\n\nCSSCSS1~3 选择器 盒模型 Flex 媒体检测 响应式 渲染引擎\t\t\t\t\t媒体检测，响应式，渲染引擎\n\nJavaScriptEcmaScript3~5~6 Lexical-scope prototype-chain AJAX js引擎\n\n编辑器Emacs Vim WebStorm Atom Sublime-Text\t\t\t\t\t\t\t\t\t学习WebStorm\n\n发布部署合并 压缩 单元测试 Node.js Grunt Gulp Yeoman Phantom JSLint\n\n框架类库jQuery Zepto UnderScore Backbone Knockout React AngularJS\n\n模块管理CommonJS Webpack\n\nUI框架BootStrap SemanticUI jQueryUI Foundation\n\n推送技术WebSocket 轮询 长连接\n\n跨域技术iframe JSONP CORS\n\n数据可视化D3 Echarts HighCharts Canvas\n\n异步编程Promise $.Deferred Generator\n\nCSS预处理器LESS SASS Stylus\n\n客户端模板Handlebars Haml Jade Mustache\n\n相关语言CoffeeScript TypeScript Dart WebAssembly\n\nWebApp/PCReact-native ionic\n\n环境：nodejs (Node.js)\n包管理：npm (https://www.npmjs.com/)\n框架：react/vue (A JavaScript library for building user interfaces, vue.js)\n架构：redux (rackt/redux · GitHub)\n打包：webpack (webpack module bundler)\n构建：gulp (gulp.js - the streaming build system)\n编译：babel (Babel 路 The compiler for writing next generation JavaScript)\n合并请求：htmlone (https://www.npmjs.com/package/gulp-htmlone)\n\t预处理器：sass (Sass: Syntactically Awesome Style Sheets)\n\t后处理器：postCSS (postcss/postcss · GitHub)\n\t自动前缀：autoprefixer (postcss/autoprefixer · GitHub)\n\t适配方案：lib-flexible&px2rem (amfe/lib-flexible · GitHubhttps://www.npmjs.com/package/postcss-px2rem)\n框架调试工具：vue-devtools/react-devtools(https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpdhttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)\n开发服务器：这个随便，主要是配合hot-loader：(gaearon/react-hot-loader · GitHubvuejs/vue-hot-reload-api · GitHub) \n\n浏览器\n渲染引擎、JavaScript引擎\nHTML/JavaScript/CSS三支柱\n编辑器\n编译任务\n编译工具\n打包、调试、质量\n测试\nJS基础类库\nJS类库\nUI框架\nCSS预处理器\n模板\n现代化\n安全/模式\n中间语言\n跨平台解决方案","source":"_posts/前端技术栈.md","raw":"---\ntitle: 前端技术栈\ndate: 2016-10-09\ntags: [前端, 汇总]\ncategories: \n- 杂记\ncomments: true\n---\n\n浏览器环境IE6~8 IE9+ Chrome Firefox Safari Opera Edge\t\t\t\t持续学习\n\nHTTP协议URI Cache Session Cookie Request Response\t\t\t\t\t持续学习\n\nHTMLW3C HTML4.01 HTML5 DOM 语义化\t\t\t\t\t\t\t\t\t\t\t\t\t持续学习\n\nCSSCSS1~3 选择器 盒模型 Flex 媒体检测 响应式 渲染引擎\t\t\t\t\t媒体检测，响应式，渲染引擎\n\nJavaScriptEcmaScript3~5~6 Lexical-scope prototype-chain AJAX js引擎\n\n编辑器Emacs Vim WebStorm Atom Sublime-Text\t\t\t\t\t\t\t\t\t学习WebStorm\n\n发布部署合并 压缩 单元测试 Node.js Grunt Gulp Yeoman Phantom JSLint\n\n框架类库jQuery Zepto UnderScore Backbone Knockout React AngularJS\n\n模块管理CommonJS Webpack\n\nUI框架BootStrap SemanticUI jQueryUI Foundation\n\n推送技术WebSocket 轮询 长连接\n\n跨域技术iframe JSONP CORS\n\n数据可视化D3 Echarts HighCharts Canvas\n\n异步编程Promise $.Deferred Generator\n\nCSS预处理器LESS SASS Stylus\n\n客户端模板Handlebars Haml Jade Mustache\n\n相关语言CoffeeScript TypeScript Dart WebAssembly\n\nWebApp/PCReact-native ionic\n\n环境：nodejs (Node.js)\n包管理：npm (https://www.npmjs.com/)\n框架：react/vue (A JavaScript library for building user interfaces, vue.js)\n架构：redux (rackt/redux · GitHub)\n打包：webpack (webpack module bundler)\n构建：gulp (gulp.js - the streaming build system)\n编译：babel (Babel 路 The compiler for writing next generation JavaScript)\n合并请求：htmlone (https://www.npmjs.com/package/gulp-htmlone)\n\t预处理器：sass (Sass: Syntactically Awesome Style Sheets)\n\t后处理器：postCSS (postcss/postcss · GitHub)\n\t自动前缀：autoprefixer (postcss/autoprefixer · GitHub)\n\t适配方案：lib-flexible&px2rem (amfe/lib-flexible · GitHubhttps://www.npmjs.com/package/postcss-px2rem)\n框架调试工具：vue-devtools/react-devtools(https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpdhttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)\n开发服务器：这个随便，主要是配合hot-loader：(gaearon/react-hot-loader · GitHubvuejs/vue-hot-reload-api · GitHub) \n\n浏览器\n渲染引擎、JavaScript引擎\nHTML/JavaScript/CSS三支柱\n编辑器\n编译任务\n编译工具\n打包、调试、质量\n测试\nJS基础类库\nJS类库\nUI框架\nCSS预处理器\n模板\n现代化\n安全/模式\n中间语言\n跨平台解决方案","slug":"前端技术栈","published":1,"updated":"2017-02-16T06:42:44.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8kig001vohfklocaaje1","content":"<p>浏览器环境IE6~8 IE9+ Chrome Firefox Safari Opera Edge                持续学习</p>\n<p>HTTP协议URI Cache Session Cookie Request Response                    持续学习</p>\n<p>HTMLW3C HTML4.01 HTML5 DOM 语义化                                                    持续学习</p>\n<p>CSSCSS1~3 选择器 盒模型 Flex 媒体检测 响应式 渲染引擎                    媒体检测，响应式，渲染引擎</p>\n<p>JavaScriptEcmaScript3~5~6 Lexical-scope prototype-chain AJAX js引擎</p>\n<p>编辑器Emacs Vim WebStorm Atom Sublime-Text                                    学习WebStorm</p>\n<p>发布部署合并 压缩 单元测试 Node.js Grunt Gulp Yeoman Phantom JSLint</p>\n<p>框架类库jQuery Zepto UnderScore Backbone Knockout React AngularJS</p>\n<p>模块管理CommonJS Webpack</p>\n<p>UI框架BootStrap SemanticUI jQueryUI Foundation</p>\n<p>推送技术WebSocket 轮询 长连接</p>\n<p>跨域技术iframe JSONP CORS</p>\n<p>数据可视化D3 Echarts HighCharts Canvas</p>\n<p>异步编程Promise $.Deferred Generator</p>\n<p>CSS预处理器LESS SASS Stylus</p>\n<p>客户端模板Handlebars Haml Jade Mustache</p>\n<p>相关语言CoffeeScript TypeScript Dart WebAssembly</p>\n<p>WebApp/PCReact-native ionic</p>\n<p>环境：nodejs (Node.js)<br>包管理：npm (<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/</a>)<br>框架：react/vue (A JavaScript library for building user interfaces, vue.js)<br>架构：redux (rackt/redux · GitHub)<br>打包：webpack (webpack module bundler)<br>构建：gulp (gulp.js - the streaming build system)<br>编译：babel (Babel 路 The compiler for writing next generation JavaScript)<br>合并请求：htmlone (<a href=\"https://www.npmjs.com/package/gulp-htmlone\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/package/gulp-htmlone</a>)<br>    预处理器：sass (Sass: Syntactically Awesome Style Sheets)<br>    后处理器：postCSS (postcss/postcss · GitHub)<br>    自动前缀：autoprefixer (postcss/autoprefixer · GitHub)<br>    适配方案：lib-flexible&amp;px2rem (amfe/lib-flexible · GitHub<a href=\"https://www.npmjs.com/package/postcss-px2rem\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/package/postcss-px2rem</a>)<br>框架调试工具：vue-devtools/react-devtools(<a href=\"https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpdhttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi\" target=\"_blank\" rel=\"external\">https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpdhttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi</a>)<br>开发服务器：这个随便，主要是配合hot-loader：(gaearon/react-hot-loader · GitHubvuejs/vue-hot-reload-api · GitHub) </p>\n<p>浏览器<br>渲染引擎、JavaScript引擎<br>HTML/JavaScript/CSS三支柱<br>编辑器<br>编译任务<br>编译工具<br>打包、调试、质量<br>测试<br>JS基础类库<br>JS类库<br>UI框架<br>CSS预处理器<br>模板<br>现代化<br>安全/模式<br>中间语言<br>跨平台解决方案</p>\n","excerpt":"","more":"<p>浏览器环境IE6~8 IE9+ Chrome Firefox Safari Opera Edge                持续学习</p>\n<p>HTTP协议URI Cache Session Cookie Request Response                    持续学习</p>\n<p>HTMLW3C HTML4.01 HTML5 DOM 语义化                                                    持续学习</p>\n<p>CSSCSS1~3 选择器 盒模型 Flex 媒体检测 响应式 渲染引擎                    媒体检测，响应式，渲染引擎</p>\n<p>JavaScriptEcmaScript3~5~6 Lexical-scope prototype-chain AJAX js引擎</p>\n<p>编辑器Emacs Vim WebStorm Atom Sublime-Text                                    学习WebStorm</p>\n<p>发布部署合并 压缩 单元测试 Node.js Grunt Gulp Yeoman Phantom JSLint</p>\n<p>框架类库jQuery Zepto UnderScore Backbone Knockout React AngularJS</p>\n<p>模块管理CommonJS Webpack</p>\n<p>UI框架BootStrap SemanticUI jQueryUI Foundation</p>\n<p>推送技术WebSocket 轮询 长连接</p>\n<p>跨域技术iframe JSONP CORS</p>\n<p>数据可视化D3 Echarts HighCharts Canvas</p>\n<p>异步编程Promise $.Deferred Generator</p>\n<p>CSS预处理器LESS SASS Stylus</p>\n<p>客户端模板Handlebars Haml Jade Mustache</p>\n<p>相关语言CoffeeScript TypeScript Dart WebAssembly</p>\n<p>WebApp/PCReact-native ionic</p>\n<p>环境：nodejs (Node.js)<br>包管理：npm (<a href=\"https://www.npmjs.com/\">https://www.npmjs.com/</a>)<br>框架：react/vue (A JavaScript library for building user interfaces, vue.js)<br>架构：redux (rackt/redux · GitHub)<br>打包：webpack (webpack module bundler)<br>构建：gulp (gulp.js - the streaming build system)<br>编译：babel (Babel 路 The compiler for writing next generation JavaScript)<br>合并请求：htmlone (<a href=\"https://www.npmjs.com/package/gulp-htmlone\">https://www.npmjs.com/package/gulp-htmlone</a>)<br>    预处理器：sass (Sass: Syntactically Awesome Style Sheets)<br>    后处理器：postCSS (postcss/postcss · GitHub)<br>    自动前缀：autoprefixer (postcss/autoprefixer · GitHub)<br>    适配方案：lib-flexible&amp;px2rem (amfe/lib-flexible · GitHub<a href=\"https://www.npmjs.com/package/postcss-px2rem\">https://www.npmjs.com/package/postcss-px2rem</a>)<br>框架调试工具：vue-devtools/react-devtools(<a href=\"https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpdhttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi\">https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpdhttps://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi</a>)<br>开发服务器：这个随便，主要是配合hot-loader：(gaearon/react-hot-loader · GitHubvuejs/vue-hot-reload-api · GitHub) </p>\n<p>浏览器<br>渲染引擎、JavaScript引擎<br>HTML/JavaScript/CSS三支柱<br>编辑器<br>编译任务<br>编译工具<br>打包、调试、质量<br>测试<br>JS基础类库<br>JS类库<br>UI框架<br>CSS预处理器<br>模板<br>现代化<br>安全/模式<br>中间语言<br>跨平台解决方案</p>\n"},{"title":"微信分享绝对是个坑","date":"2016-08-07T16:00:00.000Z","comments":1,"_content":"\n没想到碰到的第一个大坑竟然是这种问题，原以为一个微信分享，不就是看着微信开发者文档，然后写几个配置参数就可以完成的么？就算开发者文档比较麻烦，像这种常用的功能不是应该公司早就封装好，拿来配置几个参数搞定的事情么！\n\n-----\n\n### 0.先上结论吧\n目前我发现的比较好的解决办法是使用官方的(分享组件)[http://open.mobile.qq.com/api/component/share],但是安卓下微信分享手机QQ方向会有问题。微信分享QQ方向，标题使用的是title标签，描述是链接地址，图标使用的是页面第一个img标签内容(尺寸应该是大于等于300*300)。所以可以使用`div display:none;`包含img标签。  \n\tps:应该是微信API有问题，以后可能会被修复。\n\n### 1.公司封装\n在我项目开始不久前，另一个前端根据新的微信JS-SDK封装了分享方法，正好拿过来使用。使用还是挺方便的，只需要在引入插件前面定义全局对象即可。\n```javascript\nvar weChatShare = {\n\t\t\t\"title\" : '分享标题',    // 分享标题,建议主标题一行 18个字符以内 \n\t\t\t\"desc\"  : '分享描述',    // 分享描述，建议描述最多两行 36个字符以内 \n\t\t\t\"img\"   : '分享图标url', // 分享图标,200*200\n\t\t}\n```\n结果发现只有标题和描述，图标没有出来。手机QQ分享微信标题、描述、图片都没有出来。只能放弃。\n\n后来查看代码，封装的挺基本的，一个生成随机字符串作为生成签名的函数，一个ajax请求根据随机字符串、链接从后台获取签名(签名获取后台方法可以参看微信JS-SDK)，然后就是通过配置调用微信JS-SDK了。只是因为微信调用中配置`imgUrl`写错成了`img`导致图片没有出来。而手机QQ因为这些是微信的接口，手机QQ分享当然出不来了。当然，这都是后来再回头看的，项目期间时间紧，就一直在赶着找现成的方法。\n\n### 2.微信旧的API\n就是WeixinJSBridge这个对象，应该是已经不再推荐使用，但是还是可以生效的。因为是旧的嘛，我也没有太去了解。代码也就不贴了，直接忽略掉吧。  \n结果就是图片出来了，但是微信分享QQ以及QQ分享微信还是不够正常。\n\n### 3.找正常项目\n自己公司的基本上是找不到所谓正常的项目了，只能找其他公司的页面了。看了一遍，严格意义上的正常好像没有，不是QQ分享没有，就是微信分享QQ图片有问题，然后在滴滴的分享代码里找到这么一句`if(mqq !== undefined)`。然后顺着发现了`mqq.data.setShareInfo`。通过搜索这个方法名，发现了[腾讯移动WEB开发平台](http://open.mobile.qq.com/api/mqq/index)。好吧，承认自己蠢，QQ分享当然是应该找QQ的API，微信的API当然不管用了。\n\n### 4.分享组件\n期间又经过了自己的一系列的尝试，不停的add、commit、push，最终无意间发现了[这个](http://open.mobile.qq.com/api/component/share)，竟然有封装好的组件，但是[腾讯移动WEB开发平台](http://open.mobile.qq.com/api/mqq/index)中的手机QQ下没有，微信下没有，竟然是藏在首页的热门API标签下的分享中，这里写的API不应该就是API吗，为什么是组件？我怎么知道这里的『API』会和文档中的API不同呢？  \n使用该组件后，IOS上一切正常，安卓下微信分享QQ无效。\n\n### 5.图片隐藏法\n如果没有调用API，分享的时候会选取页面中第一个img标签中的图片作为图标，所以可以是用`div display:none;`包含图标地址img标签使用。经测试，不要使用太小的图片，200 * 200的图片，微信分享会无法显示，会跳过继续寻找下一个图片作为图标。没有测试太多，300 * 300的应该是比较合适的尺寸。","source":"_posts/微信分享绝对是个坑.md","raw":"---\ntitle: 微信分享绝对是个坑\ndate: 2016-08-08\ntags: [JavaScript, H5, 微信分享]\ncategories: \n- H5\ncomments: true\n---\n\n没想到碰到的第一个大坑竟然是这种问题，原以为一个微信分享，不就是看着微信开发者文档，然后写几个配置参数就可以完成的么？就算开发者文档比较麻烦，像这种常用的功能不是应该公司早就封装好，拿来配置几个参数搞定的事情么！\n\n-----\n\n### 0.先上结论吧\n目前我发现的比较好的解决办法是使用官方的(分享组件)[http://open.mobile.qq.com/api/component/share],但是安卓下微信分享手机QQ方向会有问题。微信分享QQ方向，标题使用的是title标签，描述是链接地址，图标使用的是页面第一个img标签内容(尺寸应该是大于等于300*300)。所以可以使用`div display:none;`包含img标签。  \n\tps:应该是微信API有问题，以后可能会被修复。\n\n### 1.公司封装\n在我项目开始不久前，另一个前端根据新的微信JS-SDK封装了分享方法，正好拿过来使用。使用还是挺方便的，只需要在引入插件前面定义全局对象即可。\n```javascript\nvar weChatShare = {\n\t\t\t\"title\" : '分享标题',    // 分享标题,建议主标题一行 18个字符以内 \n\t\t\t\"desc\"  : '分享描述',    // 分享描述，建议描述最多两行 36个字符以内 \n\t\t\t\"img\"   : '分享图标url', // 分享图标,200*200\n\t\t}\n```\n结果发现只有标题和描述，图标没有出来。手机QQ分享微信标题、描述、图片都没有出来。只能放弃。\n\n后来查看代码，封装的挺基本的，一个生成随机字符串作为生成签名的函数，一个ajax请求根据随机字符串、链接从后台获取签名(签名获取后台方法可以参看微信JS-SDK)，然后就是通过配置调用微信JS-SDK了。只是因为微信调用中配置`imgUrl`写错成了`img`导致图片没有出来。而手机QQ因为这些是微信的接口，手机QQ分享当然出不来了。当然，这都是后来再回头看的，项目期间时间紧，就一直在赶着找现成的方法。\n\n### 2.微信旧的API\n就是WeixinJSBridge这个对象，应该是已经不再推荐使用，但是还是可以生效的。因为是旧的嘛，我也没有太去了解。代码也就不贴了，直接忽略掉吧。  \n结果就是图片出来了，但是微信分享QQ以及QQ分享微信还是不够正常。\n\n### 3.找正常项目\n自己公司的基本上是找不到所谓正常的项目了，只能找其他公司的页面了。看了一遍，严格意义上的正常好像没有，不是QQ分享没有，就是微信分享QQ图片有问题，然后在滴滴的分享代码里找到这么一句`if(mqq !== undefined)`。然后顺着发现了`mqq.data.setShareInfo`。通过搜索这个方法名，发现了[腾讯移动WEB开发平台](http://open.mobile.qq.com/api/mqq/index)。好吧，承认自己蠢，QQ分享当然是应该找QQ的API，微信的API当然不管用了。\n\n### 4.分享组件\n期间又经过了自己的一系列的尝试，不停的add、commit、push，最终无意间发现了[这个](http://open.mobile.qq.com/api/component/share)，竟然有封装好的组件，但是[腾讯移动WEB开发平台](http://open.mobile.qq.com/api/mqq/index)中的手机QQ下没有，微信下没有，竟然是藏在首页的热门API标签下的分享中，这里写的API不应该就是API吗，为什么是组件？我怎么知道这里的『API』会和文档中的API不同呢？  \n使用该组件后，IOS上一切正常，安卓下微信分享QQ无效。\n\n### 5.图片隐藏法\n如果没有调用API，分享的时候会选取页面中第一个img标签中的图片作为图标，所以可以是用`div display:none;`包含图标地址img标签使用。经测试，不要使用太小的图片，200 * 200的图片，微信分享会无法显示，会跳过继续寻找下一个图片作为图标。没有测试太多，300 * 300的应该是比较合适的尺寸。","slug":"微信分享绝对是个坑","published":1,"updated":"2017-03-22T01:24:33.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8kih001yohfkmvk7gu1l","content":"<p>没想到碰到的第一个大坑竟然是这种问题，原以为一个微信分享，不就是看着微信开发者文档，然后写几个配置参数就可以完成的么？就算开发者文档比较麻烦，像这种常用的功能不是应该公司早就封装好，拿来配置几个参数搞定的事情么！</p>\n<hr>\n<h3 id=\"0-先上结论吧\"><a href=\"#0-先上结论吧\" class=\"headerlink\" title=\"0.先上结论吧\"></a>0.先上结论吧</h3><p>目前我发现的比较好的解决办法是使用官方的(分享组件)[<a href=\"http://open.mobile.qq.com/api/component/share],但是安卓下微信分享手机QQ方向会有问题。微信分享QQ方向，标题使用的是title标签，描述是链接地址，图标使用的是页面第一个img标签内容(尺寸应该是大于等于300*300)。所以可以使用`div\" target=\"_blank\" rel=\"external\">http://open.mobile.qq.com/api/component/share],但是安卓下微信分享手机QQ方向会有问题。微信分享QQ方向，标题使用的是title标签，描述是链接地址，图标使用的是页面第一个img标签内容(尺寸应该是大于等于300*300)。所以可以使用`div</a> display:none;`包含img标签。<br>    ps:应该是微信API有问题，以后可能会被修复。</p>\n<h3 id=\"1-公司封装\"><a href=\"#1-公司封装\" class=\"headerlink\" title=\"1.公司封装\"></a>1.公司封装</h3><p>在我项目开始不久前，另一个前端根据新的微信JS-SDK封装了分享方法，正好拿过来使用。使用还是挺方便的，只需要在引入插件前面定义全局对象即可。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> weChatShare = &#123;</div><div class=\"line\">\t\t\t<span class=\"string\">\"title\"</span> : <span class=\"string\">'分享标题'</span>,    <span class=\"comment\">// 分享标题,建议主标题一行 18个字符以内 </span></div><div class=\"line\">\t\t\t<span class=\"string\">\"desc\"</span>  : <span class=\"string\">'分享描述'</span>,    <span class=\"comment\">// 分享描述，建议描述最多两行 36个字符以内 </span></div><div class=\"line\">\t\t\t<span class=\"string\">\"img\"</span>   : <span class=\"string\">'分享图标url'</span>, <span class=\"comment\">// 分享图标,200*200</span></div><div class=\"line\">\t\t&#125;</div></pre></td></tr></table></figure></p>\n<p>结果发现只有标题和描述，图标没有出来。手机QQ分享微信标题、描述、图片都没有出来。只能放弃。</p>\n<p>后来查看代码，封装的挺基本的，一个生成随机字符串作为生成签名的函数，一个ajax请求根据随机字符串、链接从后台获取签名(签名获取后台方法可以参看微信JS-SDK)，然后就是通过配置调用微信JS-SDK了。只是因为微信调用中配置<code>imgUrl</code>写错成了<code>img</code>导致图片没有出来。而手机QQ因为这些是微信的接口，手机QQ分享当然出不来了。当然，这都是后来再回头看的，项目期间时间紧，就一直在赶着找现成的方法。</p>\n<h3 id=\"2-微信旧的API\"><a href=\"#2-微信旧的API\" class=\"headerlink\" title=\"2.微信旧的API\"></a>2.微信旧的API</h3><p>就是WeixinJSBridge这个对象，应该是已经不再推荐使用，但是还是可以生效的。因为是旧的嘛，我也没有太去了解。代码也就不贴了，直接忽略掉吧。<br>结果就是图片出来了，但是微信分享QQ以及QQ分享微信还是不够正常。</p>\n<h3 id=\"3-找正常项目\"><a href=\"#3-找正常项目\" class=\"headerlink\" title=\"3.找正常项目\"></a>3.找正常项目</h3><p>自己公司的基本上是找不到所谓正常的项目了，只能找其他公司的页面了。看了一遍，严格意义上的正常好像没有，不是QQ分享没有，就是微信分享QQ图片有问题，然后在滴滴的分享代码里找到这么一句<code>if(mqq !== undefined)</code>。然后顺着发现了<code>mqq.data.setShareInfo</code>。通过搜索这个方法名，发现了<a href=\"http://open.mobile.qq.com/api/mqq/index\" target=\"_blank\" rel=\"external\">腾讯移动WEB开发平台</a>。好吧，承认自己蠢，QQ分享当然是应该找QQ的API，微信的API当然不管用了。</p>\n<h3 id=\"4-分享组件\"><a href=\"#4-分享组件\" class=\"headerlink\" title=\"4.分享组件\"></a>4.分享组件</h3><p>期间又经过了自己的一系列的尝试，不停的add、commit、push，最终无意间发现了<a href=\"http://open.mobile.qq.com/api/component/share\" target=\"_blank\" rel=\"external\">这个</a>，竟然有封装好的组件，但是<a href=\"http://open.mobile.qq.com/api/mqq/index\" target=\"_blank\" rel=\"external\">腾讯移动WEB开发平台</a>中的手机QQ下没有，微信下没有，竟然是藏在首页的热门API标签下的分享中，这里写的API不应该就是API吗，为什么是组件？我怎么知道这里的『API』会和文档中的API不同呢？<br>使用该组件后，IOS上一切正常，安卓下微信分享QQ无效。</p>\n<h3 id=\"5-图片隐藏法\"><a href=\"#5-图片隐藏法\" class=\"headerlink\" title=\"5.图片隐藏法\"></a>5.图片隐藏法</h3><p>如果没有调用API，分享的时候会选取页面中第一个img标签中的图片作为图标，所以可以是用<code>div display:none;</code>包含图标地址img标签使用。经测试，不要使用太小的图片，200 <em> 200的图片，微信分享会无法显示，会跳过继续寻找下一个图片作为图标。没有测试太多，300 </em> 300的应该是比较合适的尺寸。</p>\n","excerpt":"","more":"<p>没想到碰到的第一个大坑竟然是这种问题，原以为一个微信分享，不就是看着微信开发者文档，然后写几个配置参数就可以完成的么？就算开发者文档比较麻烦，像这种常用的功能不是应该公司早就封装好，拿来配置几个参数搞定的事情么！</p>\n<hr>\n<h3 id=\"0-先上结论吧\"><a href=\"#0-先上结论吧\" class=\"headerlink\" title=\"0.先上结论吧\"></a>0.先上结论吧</h3><p>目前我发现的比较好的解决办法是使用官方的(分享组件)[<a href=\"http://open.mobile.qq.com/api/component/share],但是安卓下微信分享手机QQ方向会有问题。微信分享QQ方向，标题使用的是title标签，描述是链接地址，图标使用的是页面第一个img标签内容(尺寸应该是大于等于300*300)。所以可以使用`div\">http://open.mobile.qq.com/api/component/share],但是安卓下微信分享手机QQ方向会有问题。微信分享QQ方向，标题使用的是title标签，描述是链接地址，图标使用的是页面第一个img标签内容(尺寸应该是大于等于300*300)。所以可以使用`div</a> display:none;`包含img标签。<br>    ps:应该是微信API有问题，以后可能会被修复。</p>\n<h3 id=\"1-公司封装\"><a href=\"#1-公司封装\" class=\"headerlink\" title=\"1.公司封装\"></a>1.公司封装</h3><p>在我项目开始不久前，另一个前端根据新的微信JS-SDK封装了分享方法，正好拿过来使用。使用还是挺方便的，只需要在引入插件前面定义全局对象即可。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> weChatShare = &#123;</div><div class=\"line\">\t\t\t<span class=\"string\">\"title\"</span> : <span class=\"string\">'分享标题'</span>,    <span class=\"comment\">// 分享标题,建议主标题一行 18个字符以内 </span></div><div class=\"line\">\t\t\t<span class=\"string\">\"desc\"</span>  : <span class=\"string\">'分享描述'</span>,    <span class=\"comment\">// 分享描述，建议描述最多两行 36个字符以内 </span></div><div class=\"line\">\t\t\t<span class=\"string\">\"img\"</span>   : <span class=\"string\">'分享图标url'</span>, <span class=\"comment\">// 分享图标,200*200</span></div><div class=\"line\">\t\t&#125;</div></pre></td></tr></table></figure></p>\n<p>结果发现只有标题和描述，图标没有出来。手机QQ分享微信标题、描述、图片都没有出来。只能放弃。</p>\n<p>后来查看代码，封装的挺基本的，一个生成随机字符串作为生成签名的函数，一个ajax请求根据随机字符串、链接从后台获取签名(签名获取后台方法可以参看微信JS-SDK)，然后就是通过配置调用微信JS-SDK了。只是因为微信调用中配置<code>imgUrl</code>写错成了<code>img</code>导致图片没有出来。而手机QQ因为这些是微信的接口，手机QQ分享当然出不来了。当然，这都是后来再回头看的，项目期间时间紧，就一直在赶着找现成的方法。</p>\n<h3 id=\"2-微信旧的API\"><a href=\"#2-微信旧的API\" class=\"headerlink\" title=\"2.微信旧的API\"></a>2.微信旧的API</h3><p>就是WeixinJSBridge这个对象，应该是已经不再推荐使用，但是还是可以生效的。因为是旧的嘛，我也没有太去了解。代码也就不贴了，直接忽略掉吧。<br>结果就是图片出来了，但是微信分享QQ以及QQ分享微信还是不够正常。</p>\n<h3 id=\"3-找正常项目\"><a href=\"#3-找正常项目\" class=\"headerlink\" title=\"3.找正常项目\"></a>3.找正常项目</h3><p>自己公司的基本上是找不到所谓正常的项目了，只能找其他公司的页面了。看了一遍，严格意义上的正常好像没有，不是QQ分享没有，就是微信分享QQ图片有问题，然后在滴滴的分享代码里找到这么一句<code>if(mqq !== undefined)</code>。然后顺着发现了<code>mqq.data.setShareInfo</code>。通过搜索这个方法名，发现了<a href=\"http://open.mobile.qq.com/api/mqq/index\">腾讯移动WEB开发平台</a>。好吧，承认自己蠢，QQ分享当然是应该找QQ的API，微信的API当然不管用了。</p>\n<h3 id=\"4-分享组件\"><a href=\"#4-分享组件\" class=\"headerlink\" title=\"4.分享组件\"></a>4.分享组件</h3><p>期间又经过了自己的一系列的尝试，不停的add、commit、push，最终无意间发现了<a href=\"http://open.mobile.qq.com/api/component/share\">这个</a>，竟然有封装好的组件，但是<a href=\"http://open.mobile.qq.com/api/mqq/index\">腾讯移动WEB开发平台</a>中的手机QQ下没有，微信下没有，竟然是藏在首页的热门API标签下的分享中，这里写的API不应该就是API吗，为什么是组件？我怎么知道这里的『API』会和文档中的API不同呢？<br>使用该组件后，IOS上一切正常，安卓下微信分享QQ无效。</p>\n<h3 id=\"5-图片隐藏法\"><a href=\"#5-图片隐藏法\" class=\"headerlink\" title=\"5.图片隐藏法\"></a>5.图片隐藏法</h3><p>如果没有调用API，分享的时候会选取页面中第一个img标签中的图片作为图标，所以可以是用<code>div display:none;</code>包含图标地址img标签使用。经测试，不要使用太小的图片，200 <em> 200的图片，微信分享会无法显示，会跳过继续寻找下一个图片作为图标。没有测试太多，300 </em> 300的应该是比较合适的尺寸。</p>\n"},{"title":"我的第一个Hexo博客","date":"2016-06-09T14:11:35.000Z","_content":"\n  希望自己以后能在这个博客里，留下自己成长的点滴，不管之后会获得什么样的工作，不管以后时间是怎样。\n","source":"_posts/我的首个Hexo博客.md","raw":"---\ntitle: 我的第一个Hexo博客\ndate: 2016-06-09 22:11:35\ntags: \ncategories: \n- 杂记\n---\n\n  希望自己以后能在这个博客里，留下自己成长的点滴，不管之后会获得什么样的工作，不管以后时间是怎样。\n","slug":"我的首个Hexo博客","published":1,"updated":"2017-02-16T06:42:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1eq8kik0022ohfkk52ersum","content":"<p>  希望自己以后能在这个博客里，留下自己成长的点滴，不管之后会获得什么样的工作，不管以后时间是怎样。</p>\n","excerpt":"","more":"<p>  希望自己以后能在这个博客里，留下自己成长的点滴，不管之后会获得什么样的工作，不管以后时间是怎样。</p>\n"},{"title":"批量移动QQ邮箱文件夹","date":"2017-03-13T16:00:00.000Z","comments":1,"_content":"\n在使用QQ企业邮箱中，设置了错误的收件规则，导致收件箱所有邮件移动到了自定义文件夹中。手动去移回这些邮件，没有找到响应的批量处理，一次只能移动一页，这样下来有170+页，是个麻烦事。\n\n第一个想到的方法是查看API，发现每次移动调用的参数是这样的\n```\n&location=mail_list\n\n&mailid=ZC0513-BHmnKHGM8D_6qBtDH4Lae7f\n&mailid=ZL0513-ss~T6rNM2RbTpRZO~VGRf7f\n... ...\n&mailid=ZL0514-l~qc1YzCN_g_zX4mtbd3B7f\n\n&mailaction=mail_move\n\n&destfolderid=1\n\n&t=mail_mgr2\n\n&resp_charset=UTF8\n\n&ef=js\n\n&sid=-IELu_LevHO0lyR8,2\n```\n试着调用一次，发现失败了。为了节约时间，采用了模拟点击的方法来实现批量移动。\n\n我们要实现的功能挺简单的，点击全选按钮，触发移动到里面的收件箱按钮。  \nQQ邮箱网页版是多个iframe嵌套实现的，也正是因为这样的iframe嵌套结构，使我们能够在邮件再次加载的时候我们的js代码还存在环境中，(这样是不是意味着对某个网页进行批量操作时，操作如果会刷新页面，可以使用iframe嵌套来创造程序运行的环境呢？)我们用的到主要是邮件这个ifame。  \niframe的操作主要包括一个top，一个parent。每个iframe相当于一个window对象，通过iframe的name可以访问响应的iframe。在chrome浏览器的console中是可以切换当前代码在哪个iframe下执行的。![iframe](./images/iframe.png)  \n我们需要操作iframe位于mainFrame中，如果将执行代码放在mainFrame中\n```JavaScript\nfunction move () {\n    window.getTop().selectAll(true,document);getTop().checkAll('mailid',document);\n    document.querySelectorAll('#selmContainer')[1].querySelector('.txtflow').click()\n    document.querySelector('[title=' + folder + ']').click()\n  }\n```\n这样在每次移动邮件后，mainFrame重新加载，move函数就会丢失，我们无法使用循环来实现。所以可以将执行代码放在top中，所有的window、document都需要指定为mainFrame下的window和document。\n```JavaScript\n\nfunction moveMail (folder, pages) {\n  function move () {\n    mainFrame.window.getTop().selectAll(true,mainFrame.document);getTop().checkAll('mailid',mainFrame.document);\n    mainFrame.document.querySelectorAll('#selmContainer')[1].querySelector('.txtflow').click()\n    mainFrame.document.querySelector('[title=' + folder + ']').click()\n  }\n\n  for(var i = 0; i < pages; i++) {\n    setTimeout(move, (i + 1) * 3000);\n  }\n}\n```\nps:  mainFrame.window === mainFrame","source":"_posts/批量移动QQ邮箱文件夹.md","raw":"---\ntitle: 批量移动QQ邮箱文件夹\ndate: 2017-03-14\ntags: JavaScript \ncategories: \n- JavaScript\ncomments: true\n---\n\n在使用QQ企业邮箱中，设置了错误的收件规则，导致收件箱所有邮件移动到了自定义文件夹中。手动去移回这些邮件，没有找到响应的批量处理，一次只能移动一页，这样下来有170+页，是个麻烦事。\n\n第一个想到的方法是查看API，发现每次移动调用的参数是这样的\n```\n&location=mail_list\n\n&mailid=ZC0513-BHmnKHGM8D_6qBtDH4Lae7f\n&mailid=ZL0513-ss~T6rNM2RbTpRZO~VGRf7f\n... ...\n&mailid=ZL0514-l~qc1YzCN_g_zX4mtbd3B7f\n\n&mailaction=mail_move\n\n&destfolderid=1\n\n&t=mail_mgr2\n\n&resp_charset=UTF8\n\n&ef=js\n\n&sid=-IELu_LevHO0lyR8,2\n```\n试着调用一次，发现失败了。为了节约时间，采用了模拟点击的方法来实现批量移动。\n\n我们要实现的功能挺简单的，点击全选按钮，触发移动到里面的收件箱按钮。  \nQQ邮箱网页版是多个iframe嵌套实现的，也正是因为这样的iframe嵌套结构，使我们能够在邮件再次加载的时候我们的js代码还存在环境中，(这样是不是意味着对某个网页进行批量操作时，操作如果会刷新页面，可以使用iframe嵌套来创造程序运行的环境呢？)我们用的到主要是邮件这个ifame。  \niframe的操作主要包括一个top，一个parent。每个iframe相当于一个window对象，通过iframe的name可以访问响应的iframe。在chrome浏览器的console中是可以切换当前代码在哪个iframe下执行的。![iframe](./images/iframe.png)  \n我们需要操作iframe位于mainFrame中，如果将执行代码放在mainFrame中\n```JavaScript\nfunction move () {\n    window.getTop().selectAll(true,document);getTop().checkAll('mailid',document);\n    document.querySelectorAll('#selmContainer')[1].querySelector('.txtflow').click()\n    document.querySelector('[title=' + folder + ']').click()\n  }\n```\n这样在每次移动邮件后，mainFrame重新加载，move函数就会丢失，我们无法使用循环来实现。所以可以将执行代码放在top中，所有的window、document都需要指定为mainFrame下的window和document。\n```JavaScript\n\nfunction moveMail (folder, pages) {\n  function move () {\n    mainFrame.window.getTop().selectAll(true,mainFrame.document);getTop().checkAll('mailid',mainFrame.document);\n    mainFrame.document.querySelectorAll('#selmContainer')[1].querySelector('.txtflow').click()\n    mainFrame.document.querySelector('[title=' + folder + ']').click()\n  }\n\n  for(var i = 0; i < pages; i++) {\n    setTimeout(move, (i + 1) * 3000);\n  }\n}\n```\nps:  mainFrame.window === mainFrame","slug":"批量移动QQ邮箱文件夹","published":1,"updated":"2017-03-14T02:55:35.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8kil0025ohfkv5zcza5j","content":"<p>在使用QQ企业邮箱中，设置了错误的收件规则，导致收件箱所有邮件移动到了自定义文件夹中。手动去移回这些邮件，没有找到响应的批量处理，一次只能移动一页，这样下来有170+页，是个麻烦事。</p>\n<p>第一个想到的方法是查看API，发现每次移动调用的参数是这样的<br><figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">&amp;location</span>=mail_list</div><div class=\"line\"></div><div class=\"line\"><span class=\"variable\">&amp;mailid</span>=ZC0513-BHmnKHGM8D_6qBtDH4Lae7f</div><div class=\"line\"><span class=\"variable\">&amp;mailid</span>=ZL0513-ss~T6rNM2RbTpRZO~VGRf7f</div><div class=\"line\">... ...</div><div class=\"line\"><span class=\"variable\">&amp;mailid</span>=ZL0514-l~qc1YzCN_g_zX4mtbd3B7f</div><div class=\"line\"></div><div class=\"line\"><span class=\"variable\">&amp;mailaction</span>=mail_move</div><div class=\"line\"></div><div class=\"line\"><span class=\"variable\">&amp;destfolderid</span>=<span class=\"number\">1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"variable\">&amp;t</span>=mail_mgr2</div><div class=\"line\"></div><div class=\"line\"><span class=\"variable\">&amp;resp_charset</span>=UTF8</div><div class=\"line\"></div><div class=\"line\"><span class=\"variable\">&amp;ef</span>=js</div><div class=\"line\"></div><div class=\"line\"><span class=\"variable\">&amp;sid</span>=-IELu_LevHO0lyR8,<span class=\"number\">2</span></div></pre></td></tr></table></figure></p>\n<p>试着调用一次，发现失败了。为了节约时间，采用了模拟点击的方法来实现批量移动。</p>\n<p>我们要实现的功能挺简单的，点击全选按钮，触发移动到里面的收件箱按钮。<br>QQ邮箱网页版是多个iframe嵌套实现的，也正是因为这样的iframe嵌套结构，使我们能够在邮件再次加载的时候我们的js代码还存在环境中，(这样是不是意味着对某个网页进行批量操作时，操作如果会刷新页面，可以使用iframe嵌套来创造程序运行的环境呢？)我们用的到主要是邮件这个ifame。<br>iframe的操作主要包括一个top，一个parent。每个iframe相当于一个window对象，通过iframe的name可以访问响应的iframe。在chrome浏览器的console中是可以切换当前代码在哪个iframe下执行的。<img src=\"./images/iframe.png\" alt=\"iframe\"><br>我们需要操作iframe位于mainFrame中，如果将执行代码放在mainFrame中<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">move</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">window</span>.getTop().selectAll(<span class=\"literal\">true</span>,<span class=\"built_in\">document</span>);getTop().checkAll(<span class=\"string\">'mailid'</span>,<span class=\"built_in\">document</span>);</div><div class=\"line\">    <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'#selmContainer'</span>)[<span class=\"number\">1</span>].querySelector(<span class=\"string\">'.txtflow'</span>).click()</div><div class=\"line\">    <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'[title='</span> + folder + <span class=\"string\">']'</span>).click()</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>这样在每次移动邮件后，mainFrame重新加载，move函数就会丢失，我们无法使用循环来实现。所以可以将执行代码放在top中，所有的window、document都需要指定为mainFrame下的window和document。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">moveMail</span> (<span class=\"params\">folder, pages</span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">move</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    mainFrame.window.getTop().selectAll(<span class=\"literal\">true</span>,mainFrame.document);getTop().checkAll(<span class=\"string\">'mailid'</span>,mainFrame.document);</div><div class=\"line\">    mainFrame.document.querySelectorAll(<span class=\"string\">'#selmContainer'</span>)[<span class=\"number\">1</span>].querySelector(<span class=\"string\">'.txtflow'</span>).click()</div><div class=\"line\">    mainFrame.document.querySelector(<span class=\"string\">'[title='</span> + folder + <span class=\"string\">']'</span>).click()</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; pages; i++) &#123;</div><div class=\"line\">    setTimeout(move, (i + <span class=\"number\">1</span>) * <span class=\"number\">3000</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>ps:  mainFrame.window === mainFrame</p>\n","excerpt":"","more":"<p>在使用QQ企业邮箱中，设置了错误的收件规则，导致收件箱所有邮件移动到了自定义文件夹中。手动去移回这些邮件，没有找到响应的批量处理，一次只能移动一页，这样下来有170+页，是个麻烦事。</p>\n<p>第一个想到的方法是查看API，发现每次移动调用的参数是这样的<br><figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">&amp;location</span>=mail_list</div><div class=\"line\"></div><div class=\"line\"><span class=\"variable\">&amp;mailid</span>=ZC0513-BHmnKHGM8D_6qBtDH4Lae7f</div><div class=\"line\"><span class=\"variable\">&amp;mailid</span>=ZL0513-ss~T6rNM2RbTpRZO~VGRf7f</div><div class=\"line\">... ...</div><div class=\"line\"><span class=\"variable\">&amp;mailid</span>=ZL0514-l~qc1YzCN_g_zX4mtbd3B7f</div><div class=\"line\"></div><div class=\"line\"><span class=\"variable\">&amp;mailaction</span>=mail_move</div><div class=\"line\"></div><div class=\"line\"><span class=\"variable\">&amp;destfolderid</span>=<span class=\"number\">1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"variable\">&amp;t</span>=mail_mgr2</div><div class=\"line\"></div><div class=\"line\"><span class=\"variable\">&amp;resp_charset</span>=UTF8</div><div class=\"line\"></div><div class=\"line\"><span class=\"variable\">&amp;ef</span>=js</div><div class=\"line\"></div><div class=\"line\"><span class=\"variable\">&amp;sid</span>=-IELu_LevHO0lyR8,<span class=\"number\">2</span></div></pre></td></tr></table></figure></p>\n<p>试着调用一次，发现失败了。为了节约时间，采用了模拟点击的方法来实现批量移动。</p>\n<p>我们要实现的功能挺简单的，点击全选按钮，触发移动到里面的收件箱按钮。<br>QQ邮箱网页版是多个iframe嵌套实现的，也正是因为这样的iframe嵌套结构，使我们能够在邮件再次加载的时候我们的js代码还存在环境中，(这样是不是意味着对某个网页进行批量操作时，操作如果会刷新页面，可以使用iframe嵌套来创造程序运行的环境呢？)我们用的到主要是邮件这个ifame。<br>iframe的操作主要包括一个top，一个parent。每个iframe相当于一个window对象，通过iframe的name可以访问响应的iframe。在chrome浏览器的console中是可以切换当前代码在哪个iframe下执行的。<img src=\"./images/iframe.png\" alt=\"iframe\"><br>我们需要操作iframe位于mainFrame中，如果将执行代码放在mainFrame中<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">move</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">window</span>.getTop().selectAll(<span class=\"literal\">true</span>,<span class=\"built_in\">document</span>);getTop().checkAll(<span class=\"string\">'mailid'</span>,<span class=\"built_in\">document</span>);</div><div class=\"line\">    <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'#selmContainer'</span>)[<span class=\"number\">1</span>].querySelector(<span class=\"string\">'.txtflow'</span>).click()</div><div class=\"line\">    <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'[title='</span> + folder + <span class=\"string\">']'</span>).click()</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>这样在每次移动邮件后，mainFrame重新加载，move函数就会丢失，我们无法使用循环来实现。所以可以将执行代码放在top中，所有的window、document都需要指定为mainFrame下的window和document。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">moveMail</span> (<span class=\"params\">folder, pages</span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">move</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    mainFrame.window.getTop().selectAll(<span class=\"literal\">true</span>,mainFrame.document);getTop().checkAll(<span class=\"string\">'mailid'</span>,mainFrame.document);</div><div class=\"line\">    mainFrame.document.querySelectorAll(<span class=\"string\">'#selmContainer'</span>)[<span class=\"number\">1</span>].querySelector(<span class=\"string\">'.txtflow'</span>).click()</div><div class=\"line\">    mainFrame.document.querySelector(<span class=\"string\">'[title='</span> + folder + <span class=\"string\">']'</span>).click()</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; pages; i++) &#123;</div><div class=\"line\">    setTimeout(move, (i + <span class=\"number\">1</span>) * <span class=\"number\">3000</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>ps:  mainFrame.window === mainFrame</p>\n"},{"title":"起点大事件H5学习","date":"2016-08-09T16:00:00.000Z","comments":1,"_content":"\n[起点大事记 - 515粉丝节](http://m.qidian.com/ploy/20160515/qd/mockup/index.html)\n\n##### 0. js整体代码\n通过自执行函数返回两个对象，Common对象主要包含通用的分享代码，QDHISTORY对象(项目逻辑方法)包含页面主要逻辑，诸如init、loading、pagePlay、musicPlay、events(绑定事件)、JS动画等等。在页面</body>前引入后，标签script中调用。\n\n##### 1. 打开页面，第一个就是碰到的就是自动跳转。  \n代码很简单，只是对屏幕宽度的判断，大于600就显示静态页二维码。\n```javascript\nif(document.documentElement.clientWidth > 600) {\n  location.replace('pc.html');\n}\n```\n\n##### 2. 加载页面\n进度条，css中30s增加width动画。js中监听load事件，load事件完成后通过对进度条添加class实现width:100%过渡，修改加载标志。如果30s内加载标志还是未加载，则提示用户，并修改加载标志为失败，及时后面加载完成也不再触发load事件。  \n预加载，其实也是延迟加载。页面中img标签src属性保存在data-src中，这样就不会下载该图片，之后根据一定条件出发函数将data-src中属性写到src中。可以通过`new Image().src='图片地址'`提前下载图片。\n\n##### 3. 使用svg sprite && 使用canva\nsvg和canva虽然已经很久了，但是大量使用的貌似还不是特别多，使用svg和canva可以减少图片的使用，而且更容易添加动画，局限性主要是颜色上的限制。\n\n##### 4. css动画\ncss动画会在元素display:none和display:block的时候重新开始。一大堆令人眼花的动画，确实需要深厚的功力才能掌握。\n\n##### 5. 还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的[博客](http://www.zhangxinxu.com/wordpress/2016/06/canvas-star-noise-smoke/)吧。\n\n------\n\nps：自己能够写出来吗？ 应该是不行，即使照着临摹，动画的难度感觉也是很大，更别提烟雾、噪点等这些效果了。","source":"_posts/起点H5分析.md","raw":"---\ntitle: 起点大事件H5学习\ndate: 2016-08-10\ntags: [JavaScript, H5]\ncategories: \n- H5\ncomments: true\n---\n\n[起点大事记 - 515粉丝节](http://m.qidian.com/ploy/20160515/qd/mockup/index.html)\n\n##### 0. js整体代码\n通过自执行函数返回两个对象，Common对象主要包含通用的分享代码，QDHISTORY对象(项目逻辑方法)包含页面主要逻辑，诸如init、loading、pagePlay、musicPlay、events(绑定事件)、JS动画等等。在页面</body>前引入后，标签script中调用。\n\n##### 1. 打开页面，第一个就是碰到的就是自动跳转。  \n代码很简单，只是对屏幕宽度的判断，大于600就显示静态页二维码。\n```javascript\nif(document.documentElement.clientWidth > 600) {\n  location.replace('pc.html');\n}\n```\n\n##### 2. 加载页面\n进度条，css中30s增加width动画。js中监听load事件，load事件完成后通过对进度条添加class实现width:100%过渡，修改加载标志。如果30s内加载标志还是未加载，则提示用户，并修改加载标志为失败，及时后面加载完成也不再触发load事件。  \n预加载，其实也是延迟加载。页面中img标签src属性保存在data-src中，这样就不会下载该图片，之后根据一定条件出发函数将data-src中属性写到src中。可以通过`new Image().src='图片地址'`提前下载图片。\n\n##### 3. 使用svg sprite && 使用canva\nsvg和canva虽然已经很久了，但是大量使用的貌似还不是特别多，使用svg和canva可以减少图片的使用，而且更容易添加动画，局限性主要是颜色上的限制。\n\n##### 4. css动画\ncss动画会在元素display:none和display:block的时候重新开始。一大堆令人眼花的动画，确实需要深厚的功力才能掌握。\n\n##### 5. 还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的[博客](http://www.zhangxinxu.com/wordpress/2016/06/canvas-star-noise-smoke/)吧。\n\n------\n\nps：自己能够写出来吗？ 应该是不行，即使照着临摹，动画的难度感觉也是很大，更别提烟雾、噪点等这些效果了。","slug":"起点H5分析","published":1,"updated":"2017-03-22T01:25:06.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8kin0028ohfkbtrb122i","content":"<p><a href=\"http://m.qidian.com/ploy/20160515/qd/mockup/index.html\" target=\"_blank\" rel=\"external\">起点大事记 - 515粉丝节</a></p>\n<h5 id=\"0-js整体代码\"><a href=\"#0-js整体代码\" class=\"headerlink\" title=\"0. js整体代码\"></a>0. js整体代码</h5><p>通过自执行函数返回两个对象，Common对象主要包含通用的分享代码，QDHISTORY对象(项目逻辑方法)包含页面主要逻辑，诸如init、loading、pagePlay、musicPlay、events(绑定事件)、JS动画等等。在页面前引入后，标签script中调用。</p>\n<h5 id=\"1-打开页面，第一个就是碰到的就是自动跳转。\"><a href=\"#1-打开页面，第一个就是碰到的就是自动跳转。\" class=\"headerlink\" title=\"1. 打开页面，第一个就是碰到的就是自动跳转。\"></a>1. 打开页面，第一个就是碰到的就是自动跳转。</h5><p>代码很简单，只是对屏幕宽度的判断，大于600就显示静态页二维码。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">document</span>.documentElement.clientWidth &gt; <span class=\"number\">600</span>) &#123;</div><div class=\"line\">  location.replace(<span class=\"string\">'pc.html'</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"2-加载页面\"><a href=\"#2-加载页面\" class=\"headerlink\" title=\"2. 加载页面\"></a>2. 加载页面</h5><p>进度条，css中30s增加width动画。js中监听load事件，load事件完成后通过对进度条添加class实现width:100%过渡，修改加载标志。如果30s内加载标志还是未加载，则提示用户，并修改加载标志为失败，及时后面加载完成也不再触发load事件。<br>预加载，其实也是延迟加载。页面中img标签src属性保存在data-src中，这样就不会下载该图片，之后根据一定条件出发函数将data-src中属性写到src中。可以通过<code>new Image().src=&#39;图片地址&#39;</code>提前下载图片。</p>\n<h5 id=\"3-使用svg-sprite-amp-amp-使用canva\"><a href=\"#3-使用svg-sprite-amp-amp-使用canva\" class=\"headerlink\" title=\"3. 使用svg sprite &amp;&amp; 使用canva\"></a>3. 使用svg sprite &amp;&amp; 使用canva</h5><p>svg和canva虽然已经很久了，但是大量使用的貌似还不是特别多，使用svg和canva可以减少图片的使用，而且更容易添加动画，局限性主要是颜色上的限制。</p>\n<h5 id=\"4-css动画\"><a href=\"#4-css动画\" class=\"headerlink\" title=\"4. css动画\"></a>4. css动画</h5><p>css动画会在元素display:none和display:block的时候重新开始。一大堆令人眼花的动画，确实需要深厚的功力才能掌握。</p>\n<h5 id=\"5-还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的博客吧。\"><a href=\"#5-还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的博客吧。\" class=\"headerlink\" title=\"5. 还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的博客吧。\"></a>5. 还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的<a href=\"http://www.zhangxinxu.com/wordpress/2016/06/canvas-star-noise-smoke/\" target=\"_blank\" rel=\"external\">博客</a>吧。</h5><hr>\n<p>ps：自己能够写出来吗？ 应该是不行，即使照着临摹，动画的难度感觉也是很大，更别提烟雾、噪点等这些效果了。</p>\n","excerpt":"","more":"<p><a href=\"http://m.qidian.com/ploy/20160515/qd/mockup/index.html\">起点大事记 - 515粉丝节</a></p>\n<h5 id=\"0-js整体代码\"><a href=\"#0-js整体代码\" class=\"headerlink\" title=\"0. js整体代码\"></a>0. js整体代码</h5><p>通过自执行函数返回两个对象，Common对象主要包含通用的分享代码，QDHISTORY对象(项目逻辑方法)包含页面主要逻辑，诸如init、loading、pagePlay、musicPlay、events(绑定事件)、JS动画等等。在页面</body>前引入后，标签script中调用。</p>\n<h5 id=\"1-打开页面，第一个就是碰到的就是自动跳转。\"><a href=\"#1-打开页面，第一个就是碰到的就是自动跳转。\" class=\"headerlink\" title=\"1. 打开页面，第一个就是碰到的就是自动跳转。\"></a>1. 打开页面，第一个就是碰到的就是自动跳转。</h5><p>代码很简单，只是对屏幕宽度的判断，大于600就显示静态页二维码。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">document</span>.documentElement.clientWidth &gt; <span class=\"number\">600</span>) &#123;</div><div class=\"line\">  location.replace(<span class=\"string\">'pc.html'</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"2-加载页面\"><a href=\"#2-加载页面\" class=\"headerlink\" title=\"2. 加载页面\"></a>2. 加载页面</h5><p>进度条，css中30s增加width动画。js中监听load事件，load事件完成后通过对进度条添加class实现width:100%过渡，修改加载标志。如果30s内加载标志还是未加载，则提示用户，并修改加载标志为失败，及时后面加载完成也不再触发load事件。<br>预加载，其实也是延迟加载。页面中img标签src属性保存在data-src中，这样就不会下载该图片，之后根据一定条件出发函数将data-src中属性写到src中。可以通过<code>new Image().src=&#39;图片地址&#39;</code>提前下载图片。</p>\n<h5 id=\"3-使用svg-sprite-amp-amp-使用canva\"><a href=\"#3-使用svg-sprite-amp-amp-使用canva\" class=\"headerlink\" title=\"3. 使用svg sprite &amp;&amp; 使用canva\"></a>3. 使用svg sprite &amp;&amp; 使用canva</h5><p>svg和canva虽然已经很久了，但是大量使用的貌似还不是特别多，使用svg和canva可以减少图片的使用，而且更容易添加动画，局限性主要是颜色上的限制。</p>\n<h5 id=\"4-css动画\"><a href=\"#4-css动画\" class=\"headerlink\" title=\"4. css动画\"></a>4. css动画</h5><p>css动画会在元素display:none和display:block的时候重新开始。一大堆令人眼花的动画，确实需要深厚的功力才能掌握。</p>\n<h5 id=\"5-还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的博客吧。\"><a href=\"#5-还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的博客吧。\" class=\"headerlink\" title=\"5. 还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的博客吧。\"></a>5. 还有一些其他的烟雾效果、背景噪点效果，这些详细的移步大神的<a href=\"http://www.zhangxinxu.com/wordpress/2016/06/canvas-star-noise-smoke/\">博客</a>吧。</h5><hr>\n<p>ps：自己能够写出来吗？ 应该是不行，即使照着临摹，动画的难度感觉也是很大，更别提烟雾、噪点等这些效果了。</p>\n"},{"title":"面向对象的javascript(继承)","date":"2016-06-21T12:33:00.000Z","comments":1,"_content":"　　继承就是从已有的类(对象)派生出新的类(对象)，新的类(对象)会拥有父类的所有属性和方法，并可以添加或修改属性和方法。\n\n--------------------\n\n### 1.类式继承(prototype模式)\n```javascript\n// 父类\nfunction SupClass() {\n\tthis.superValue = true;\n}\nSuperClass.prototype = {\n\tgetSuperValue = function() {\n\t\treturn this.superValue;\n\t}\n};\n// 子类\nfunction SubClass() {\n\tthis.subValue = false;\n}\n// 通过原型链实现继承\nSubClass.prototype = new SuperClass();\n// 修正constructor的指向\nSubClass.prototype.contructor = SubClass;\n// 子类添加公有方法\nSubClass.prototype.getSubValue = function() {}\n```\n将父类实例赋值给子类的prototype，子类就能通过原型链来访问到父类中的属性以及方法。缺点是因为子类是通过原型链继承父类的，所以多个实例化的子类中包含的父类属性和方法其实是一份，其中一个修改，其他会受到影响。另外是实例化无法传递参数。\n\n### 2.构造函数继承\n```javascript\n// 父类\nfunction SupClass(id) {\n\tthis.superValue = true;\n\tthis.id = id;\n}\nSuperClass.prototype = {\n\tgetSuperValue = function() {\n\t\treturn this.superValue;\n\t}\n};\n// 子类\nfunction SubClass(id, name) {\n\tSupClass.call(this, id);\n\tthis.name = name;\n}\n```\n通过call或apply函数修改父类中的this指向，可以实现参数的传递。缺点是只能继承构造函数中的属性(即this指向的属性和方法)，原型链得不到继承。\n\n### 3.组合继承\n```javascript\n// 父类\nfunction SupClass(id) {\n\tthis.superValue = true;\n\tthis.id = id;\n}\nSuperClass.prototype = {\n\tgetSuperValue = function() {\n\t\treturn this.superValue;\n\t}\n};\n// 子类\nfunction SubClass(id, name) {\n\t// 继承构造函数中的属性和方法\n\tSupClass.call(this, id);\n\tthis.name = name;\n}\n// 继承所有属性和方法\nSubClass.prototype = new SuperClass();\nSubClass.prototype.contructor = SubClass;\n```\n结合了类式继承和构造函数继承的优点，去除了两者的缺点。唯一的缺点就是在子类中执行了SupClass()，在子类原型中又执行了SupClass()。\n\n### 4.直接继承prototype\n```javascript\n// 同上\n... ...\n// 继承原型中的属性和方法\nSubClass.prototype = SuperClass.prototype;\nSubClass.prototype.contructor = SubClass;\n```\n既然在子类中构造函数的属性和方法已经被继承了，所以子类的原型中只需要继承父类的原型。缺点是SubClass.prototype和SupClass.prototype指向同一对象，修改会互相影响。\n\n### 5.利用空对象继承prototype\n```javascript\n// 同上\n... ...\n// 在空对象中复制一份父类的原型\nvar O = function(){};\nO.prototype = SuperClass.prototype;\n// 继承原型中的属性和方法\nSubClass.prototype = new O();\nSubClass.prototype.contructor = SubClass;\n```\n基于3.的修改，执行两次SupClass()消耗资源，执行空对象，消耗资源就会大大减少。\n\n### 6.拷贝继承\n拷贝就是将父类的属性和方法拷贝到子类中，拷贝可以是浅拷贝和深拷贝。拷贝可以实现多继承。\n\n----------------\n　　　　-------来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢","source":"_posts/面向对象的javascript(继承).md","raw":"---\ntitle: 面向对象的javascript(继承)\ndate: 2016-06-21 20:33\ntags: [JavaScript, 面向对象]\ncategories: \n- JavaScript\ncomments: true\n---\n　　继承就是从已有的类(对象)派生出新的类(对象)，新的类(对象)会拥有父类的所有属性和方法，并可以添加或修改属性和方法。\n\n--------------------\n\n### 1.类式继承(prototype模式)\n```javascript\n// 父类\nfunction SupClass() {\n\tthis.superValue = true;\n}\nSuperClass.prototype = {\n\tgetSuperValue = function() {\n\t\treturn this.superValue;\n\t}\n};\n// 子类\nfunction SubClass() {\n\tthis.subValue = false;\n}\n// 通过原型链实现继承\nSubClass.prototype = new SuperClass();\n// 修正constructor的指向\nSubClass.prototype.contructor = SubClass;\n// 子类添加公有方法\nSubClass.prototype.getSubValue = function() {}\n```\n将父类实例赋值给子类的prototype，子类就能通过原型链来访问到父类中的属性以及方法。缺点是因为子类是通过原型链继承父类的，所以多个实例化的子类中包含的父类属性和方法其实是一份，其中一个修改，其他会受到影响。另外是实例化无法传递参数。\n\n### 2.构造函数继承\n```javascript\n// 父类\nfunction SupClass(id) {\n\tthis.superValue = true;\n\tthis.id = id;\n}\nSuperClass.prototype = {\n\tgetSuperValue = function() {\n\t\treturn this.superValue;\n\t}\n};\n// 子类\nfunction SubClass(id, name) {\n\tSupClass.call(this, id);\n\tthis.name = name;\n}\n```\n通过call或apply函数修改父类中的this指向，可以实现参数的传递。缺点是只能继承构造函数中的属性(即this指向的属性和方法)，原型链得不到继承。\n\n### 3.组合继承\n```javascript\n// 父类\nfunction SupClass(id) {\n\tthis.superValue = true;\n\tthis.id = id;\n}\nSuperClass.prototype = {\n\tgetSuperValue = function() {\n\t\treturn this.superValue;\n\t}\n};\n// 子类\nfunction SubClass(id, name) {\n\t// 继承构造函数中的属性和方法\n\tSupClass.call(this, id);\n\tthis.name = name;\n}\n// 继承所有属性和方法\nSubClass.prototype = new SuperClass();\nSubClass.prototype.contructor = SubClass;\n```\n结合了类式继承和构造函数继承的优点，去除了两者的缺点。唯一的缺点就是在子类中执行了SupClass()，在子类原型中又执行了SupClass()。\n\n### 4.直接继承prototype\n```javascript\n// 同上\n... ...\n// 继承原型中的属性和方法\nSubClass.prototype = SuperClass.prototype;\nSubClass.prototype.contructor = SubClass;\n```\n既然在子类中构造函数的属性和方法已经被继承了，所以子类的原型中只需要继承父类的原型。缺点是SubClass.prototype和SupClass.prototype指向同一对象，修改会互相影响。\n\n### 5.利用空对象继承prototype\n```javascript\n// 同上\n... ...\n// 在空对象中复制一份父类的原型\nvar O = function(){};\nO.prototype = SuperClass.prototype;\n// 继承原型中的属性和方法\nSubClass.prototype = new O();\nSubClass.prototype.contructor = SubClass;\n```\n基于3.的修改，执行两次SupClass()消耗资源，执行空对象，消耗资源就会大大减少。\n\n### 6.拷贝继承\n拷贝就是将父类的属性和方法拷贝到子类中，拷贝可以是浅拷贝和深拷贝。拷贝可以实现多继承。\n\n----------------\n　　　　-------来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢","slug":"面向对象的javascript(继承)","published":1,"updated":"2017-03-22T01:25:14.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8kip002cohfk4ckumupy","content":"<p>　　继承就是从已有的类(对象)派生出新的类(对象)，新的类(对象)会拥有父类的所有属性和方法，并可以添加或修改属性和方法。</p>\n<hr>\n<h3 id=\"1-类式继承-prototype模式\"><a href=\"#1-类式继承-prototype模式\" class=\"headerlink\" title=\"1.类式继承(prototype模式)\"></a>1.类式继承(prototype模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 父类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupClass</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.superValue = <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">SuperClass.prototype = &#123;</div><div class=\"line\">\tgetSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.superValue;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 子类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.subValue = <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 通过原型链实现继承</span></div><div class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> SuperClass();</div><div class=\"line\"><span class=\"comment\">// 修正constructor的指向</span></div><div class=\"line\">SubClass.prototype.contructor = SubClass;</div><div class=\"line\"><span class=\"comment\">// 子类添加公有方法</span></div><div class=\"line\">SubClass.prototype.getSubValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>将父类实例赋值给子类的prototype，子类就能通过原型链来访问到父类中的属性以及方法。缺点是因为子类是通过原型链继承父类的，所以多个实例化的子类中包含的父类属性和方法其实是一份，其中一个修改，其他会受到影响。另外是实例化无法传递参数。</p>\n<h3 id=\"2-构造函数继承\"><a href=\"#2-构造函数继承\" class=\"headerlink\" title=\"2.构造函数继承\"></a>2.构造函数继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 父类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupClass</span>(<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.superValue = <span class=\"literal\">true</span>;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">&#125;</div><div class=\"line\">SuperClass.prototype = &#123;</div><div class=\"line\">\tgetSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.superValue;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 子类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">id, name</span>) </span>&#123;</div><div class=\"line\">\tSupClass.call(<span class=\"keyword\">this</span>, id);</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过call或apply函数修改父类中的this指向，可以实现参数的传递。缺点是只能继承构造函数中的属性(即this指向的属性和方法)，原型链得不到继承。</p>\n<h3 id=\"3-组合继承\"><a href=\"#3-组合继承\" class=\"headerlink\" title=\"3.组合继承\"></a>3.组合继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 父类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupClass</span>(<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.superValue = <span class=\"literal\">true</span>;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">&#125;</div><div class=\"line\">SuperClass.prototype = &#123;</div><div class=\"line\">\tgetSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.superValue;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 子类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">id, name</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 继承构造函数中的属性和方法</span></div><div class=\"line\">\tSupClass.call(<span class=\"keyword\">this</span>, id);</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 继承所有属性和方法</span></div><div class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> SuperClass();</div><div class=\"line\">SubClass.prototype.contructor = SubClass;</div></pre></td></tr></table></figure>\n<p>结合了类式继承和构造函数继承的优点，去除了两者的缺点。唯一的缺点就是在子类中执行了SupClass()，在子类原型中又执行了SupClass()。</p>\n<h3 id=\"4-直接继承prototype\"><a href=\"#4-直接继承prototype\" class=\"headerlink\" title=\"4.直接继承prototype\"></a>4.直接继承prototype</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 同上</span></div><div class=\"line\">... ...</div><div class=\"line\"><span class=\"comment\">// 继承原型中的属性和方法</span></div><div class=\"line\">SubClass.prototype = SuperClass.prototype;</div><div class=\"line\">SubClass.prototype.contructor = SubClass;</div></pre></td></tr></table></figure>\n<p>既然在子类中构造函数的属性和方法已经被继承了，所以子类的原型中只需要继承父类的原型。缺点是SubClass.prototype和SupClass.prototype指向同一对象，修改会互相影响。</p>\n<h3 id=\"5-利用空对象继承prototype\"><a href=\"#5-利用空对象继承prototype\" class=\"headerlink\" title=\"5.利用空对象继承prototype\"></a>5.利用空对象继承prototype</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 同上</span></div><div class=\"line\">... ...</div><div class=\"line\"><span class=\"comment\">// 在空对象中复制一份父类的原型</span></div><div class=\"line\"><span class=\"keyword\">var</span> O = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">O.prototype = SuperClass.prototype;</div><div class=\"line\"><span class=\"comment\">// 继承原型中的属性和方法</span></div><div class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> O();</div><div class=\"line\">SubClass.prototype.contructor = SubClass;</div></pre></td></tr></table></figure>\n<p>基于3.的修改，执行两次SupClass()消耗资源，执行空对象，消耗资源就会大大减少。</p>\n<h3 id=\"6-拷贝继承\"><a href=\"#6-拷贝继承\" class=\"headerlink\" title=\"6.拷贝继承\"></a>6.拷贝继承</h3><p>拷贝就是将父类的属性和方法拷贝到子类中，拷贝可以是浅拷贝和深拷贝。拷贝可以实现多继承。</p>\n<hr>\n<p>　　　　——-来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢</p>\n","excerpt":"","more":"<p>　　继承就是从已有的类(对象)派生出新的类(对象)，新的类(对象)会拥有父类的所有属性和方法，并可以添加或修改属性和方法。</p>\n<hr>\n<h3 id=\"1-类式继承-prototype模式\"><a href=\"#1-类式继承-prototype模式\" class=\"headerlink\" title=\"1.类式继承(prototype模式)\"></a>1.类式继承(prototype模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 父类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupClass</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.superValue = <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">SuperClass.prototype = &#123;</div><div class=\"line\">\tgetSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.superValue;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 子类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.subValue = <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 通过原型链实现继承</span></div><div class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> SuperClass();</div><div class=\"line\"><span class=\"comment\">// 修正constructor的指向</span></div><div class=\"line\">SubClass.prototype.contructor = SubClass;</div><div class=\"line\"><span class=\"comment\">// 子类添加公有方法</span></div><div class=\"line\">SubClass.prototype.getSubValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>将父类实例赋值给子类的prototype，子类就能通过原型链来访问到父类中的属性以及方法。缺点是因为子类是通过原型链继承父类的，所以多个实例化的子类中包含的父类属性和方法其实是一份，其中一个修改，其他会受到影响。另外是实例化无法传递参数。</p>\n<h3 id=\"2-构造函数继承\"><a href=\"#2-构造函数继承\" class=\"headerlink\" title=\"2.构造函数继承\"></a>2.构造函数继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 父类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupClass</span>(<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.superValue = <span class=\"literal\">true</span>;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">&#125;</div><div class=\"line\">SuperClass.prototype = &#123;</div><div class=\"line\">\tgetSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.superValue;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 子类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">id, name</span>) </span>&#123;</div><div class=\"line\">\tSupClass.call(<span class=\"keyword\">this</span>, id);</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过call或apply函数修改父类中的this指向，可以实现参数的传递。缺点是只能继承构造函数中的属性(即this指向的属性和方法)，原型链得不到继承。</p>\n<h3 id=\"3-组合继承\"><a href=\"#3-组合继承\" class=\"headerlink\" title=\"3.组合继承\"></a>3.组合继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 父类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupClass</span>(<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.superValue = <span class=\"literal\">true</span>;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">&#125;</div><div class=\"line\">SuperClass.prototype = &#123;</div><div class=\"line\">\tgetSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.superValue;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 子类</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">id, name</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 继承构造函数中的属性和方法</span></div><div class=\"line\">\tSupClass.call(<span class=\"keyword\">this</span>, id);</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 继承所有属性和方法</span></div><div class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> SuperClass();</div><div class=\"line\">SubClass.prototype.contructor = SubClass;</div></pre></td></tr></table></figure>\n<p>结合了类式继承和构造函数继承的优点，去除了两者的缺点。唯一的缺点就是在子类中执行了SupClass()，在子类原型中又执行了SupClass()。</p>\n<h3 id=\"4-直接继承prototype\"><a href=\"#4-直接继承prototype\" class=\"headerlink\" title=\"4.直接继承prototype\"></a>4.直接继承prototype</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 同上</span></div><div class=\"line\">... ...</div><div class=\"line\"><span class=\"comment\">// 继承原型中的属性和方法</span></div><div class=\"line\">SubClass.prototype = SuperClass.prototype;</div><div class=\"line\">SubClass.prototype.contructor = SubClass;</div></pre></td></tr></table></figure>\n<p>既然在子类中构造函数的属性和方法已经被继承了，所以子类的原型中只需要继承父类的原型。缺点是SubClass.prototype和SupClass.prototype指向同一对象，修改会互相影响。</p>\n<h3 id=\"5-利用空对象继承prototype\"><a href=\"#5-利用空对象继承prototype\" class=\"headerlink\" title=\"5.利用空对象继承prototype\"></a>5.利用空对象继承prototype</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 同上</span></div><div class=\"line\">... ...</div><div class=\"line\"><span class=\"comment\">// 在空对象中复制一份父类的原型</span></div><div class=\"line\"><span class=\"keyword\">var</span> O = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">O.prototype = SuperClass.prototype;</div><div class=\"line\"><span class=\"comment\">// 继承原型中的属性和方法</span></div><div class=\"line\">SubClass.prototype = <span class=\"keyword\">new</span> O();</div><div class=\"line\">SubClass.prototype.contructor = SubClass;</div></pre></td></tr></table></figure>\n<p>基于3.的修改，执行两次SupClass()消耗资源，执行空对象，消耗资源就会大大减少。</p>\n<h3 id=\"6-拷贝继承\"><a href=\"#6-拷贝继承\" class=\"headerlink\" title=\"6.拷贝继承\"></a>6.拷贝继承</h3><p>拷贝就是将父类的属性和方法拷贝到子类中，拷贝可以是浅拷贝和深拷贝。拷贝可以实现多继承。</p>\n<hr>\n<p>　　　　——-来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢</p>\n"},{"title":"面向对象的JavaScript(封装)","date":"2016-06-17T12:23:00.000Z","comments":1,"_content":"\n　　面向对象的基本特征：封装、继承、多态。\n　　封装就是把对象的属性和方法结合成在一些，也可以隐藏对象的属性和实现细节，所以封装后的对象一般有私有属性、私有方法、公有属性、公有方法等。\n\n--------------------\n\n### 1.最初的javascript代码是这样的\n```javascript\nfunction checkName() {\n\t\n}\nfunction checkEmail() {\n\t\n}\nfunction checkPassword() {\n\t\n}\n```\n调用时候，直接使用函数名checkName()。这样编写相当于创建多个全局变量：checkName、checkEmail、checkPassword。\n\n### 2.使用对象封装(原始模式)\n```javascript\nvar CheckObject = {\n\tcheckName: function() {\n\n\t},\n\tcheckEmail: function() {\n\n\t},\n\tcheckPassword: function() {\n\n\t}\n};\n```\n调用时，通过对象名调用，CheckObject.checkName()。缺点是只能够通过CheckObject使用，不能生成新的实例。\n\n### 3.返回新的对象(原始模式改进)\n```javascript\nvar CheckObject = function() {\n\treturn {\n\t\tcheckName: function() {\n\n\t\t},\n\t\tcheckEmail: function() {\n\n\t\t},\n\t\tcheckPassword: function() {\n\n\t\t}\n\t}\n};\n```\n调用方式\n```javascript\nvar a = CheckObject();\na.checkName();\n```\n每次调用CHeckObject都会产生新的对象，这样每个人在使用的时候互相之间不会影响，但是新生成的实例与实例之间没有关联，与CheckObject也没有关联。\n\n### 4.new操作符，能将方法中this指向新的实例(构造函数模式)\n```javascript\nvar CheckObject = function() {\n\tthis.checkName = function() {\n\n\t};\n\tthis.checkEmail = function() {\n\n\t};\n\tthis.checkPassword = function() {\n\n\t};\n};\n```\n调用方式\n```javascript\nvar a = new CheckObject();\na.checkName();\n```\n所有通过new生成的实例对象，都包含constructor属性，这个属性都会指向CheckObject。`a.constructor == CHeckObject`每个新生成的实例中都会包含checkName、checkEmail、checkPassword方法，这些方法都是相同的，可以通过原型链保存在prototype属性中，这样这些方法就只会存储一遍。\n\tps: new首先会创建一个空的对象。然后将新对象的_proto_指向调用函数的prototype属性。 最后将调用函数中的所有this指向新对象。\n\n### 5.利用prototype节省内存(prototype模式)\n```javascript\nvar CheckObject = function() {\n\t\n};\nCheckObject.prototype = {\n\tcheckName: function() {\n\n\t\treturn this;  //链式使用\n\t},\n\tcheckEmail: function() {\n\n\t\treturn this; //链式使用\n\t}，\n\tcheckPassword: function() {\n\n\t\treturn this; //链式使用\n\t}\n};\n```\n调用方法与4.相同。\n\n### 6.更像一个类\n```javascript\nvar Book = function(id, name, price) {\n\t// 私有属性  (外界不能直接访问、调用)\n\tvar num = 0;\n\t// 私有方法\n\tfunction checkId() {}\n\t// 对象公有属性  (对象可以访问、调用)\n\tthis.id = id;\n\t// 特权方法  (对象可以访问、调用，并且操作私有属性、方法)\n\tthis.getName = function() {};\n\tthis.setName = function() {};\n\tthis.getPrice = function() {};\n\tthis.setPrice = function() {};\n};\n// 类静态公有属性  (类可以访问、调用)\nBook.isChinese = true;\n// 类静态公有方法\nBook.resetTime = function() {};\nBook.prototype = {\n\t// 静态公有属性  (对象可以访问、调用，并且只保存一份)\n\tisJSBook: false,\n\t// 静态公有方法\n\tdisplay: function() {}\n};\n```\n\n### 7.利用闭包来实现\n```javascript\nvar Book = (function() {\n\t// 静态私有\n\tvar bookNum = 0;\n\tfunction checkBook() {};\n\t// 创建类\n\tfunction _book(id, name, price) {\n\t\t// 私有\n\t\tvar name,price;\n\t\tfunction checkID(){}\n\t\tthis.sayNum = function() {\n\t\t\tconsole.log(bookNum);\n\t\t};\n\t\tthis.setNum = function(number) {\n\t\t\tbookNum = number;\n\t\t};\n\t\t// 公有\n\t\tthis.id = id;\n\t\t// 特权方法\n\t\tthis.getName = function(){};\n\t\tthis.setName = function(){};\n\t\tthis.getPrice = function(){};\n\t\tthis.setPrice = function(){};\n\t}\n\t_book.prototype = {\n\t\t// 静态公有\n\t\tisJSBook: true,\n\t\tdisplay: function(){}\n\t};\n\treturn _book;\n})();\n```\n\tps: 静态私有变量只存在一份，如果通过创建类中的特权方法修改静态私有变量，所有对象实例中的此静态私有变量都会改变。(闭包)\n\t在6.中通过特权方法修改私有变量，其他对象中的私有变量，不会改变。\n\t这个，怎么理解呢？回头还需要研究下。\n\n### 8.创建对象的安全模式\n在创建实例对象的时候，如果没有使用new操作符，会造成this指向的是全局环境，在浏览器中也就是window对象。为了避免这种情况，可以使用instanceof来检测。\n```javascript\nvar Book = function(id, name, price) {\n\tif(this instanceof Book) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.price = price;\n\t} else  {\n\t\treturn new Book(id, name, price);\n\t}\n}\n```\n----------------\n　　　　-------来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢","source":"_posts/面向对象的javascript.md","raw":"---\ntitle: 面向对象的JavaScript(封装)\ndate: 2016-06-17 20:23\ntags: [JavaScript, 面向对象]\ncategories: \n- JavaScript\ncomments: true\n---\n\n　　面向对象的基本特征：封装、继承、多态。\n　　封装就是把对象的属性和方法结合成在一些，也可以隐藏对象的属性和实现细节，所以封装后的对象一般有私有属性、私有方法、公有属性、公有方法等。\n\n--------------------\n\n### 1.最初的javascript代码是这样的\n```javascript\nfunction checkName() {\n\t\n}\nfunction checkEmail() {\n\t\n}\nfunction checkPassword() {\n\t\n}\n```\n调用时候，直接使用函数名checkName()。这样编写相当于创建多个全局变量：checkName、checkEmail、checkPassword。\n\n### 2.使用对象封装(原始模式)\n```javascript\nvar CheckObject = {\n\tcheckName: function() {\n\n\t},\n\tcheckEmail: function() {\n\n\t},\n\tcheckPassword: function() {\n\n\t}\n};\n```\n调用时，通过对象名调用，CheckObject.checkName()。缺点是只能够通过CheckObject使用，不能生成新的实例。\n\n### 3.返回新的对象(原始模式改进)\n```javascript\nvar CheckObject = function() {\n\treturn {\n\t\tcheckName: function() {\n\n\t\t},\n\t\tcheckEmail: function() {\n\n\t\t},\n\t\tcheckPassword: function() {\n\n\t\t}\n\t}\n};\n```\n调用方式\n```javascript\nvar a = CheckObject();\na.checkName();\n```\n每次调用CHeckObject都会产生新的对象，这样每个人在使用的时候互相之间不会影响，但是新生成的实例与实例之间没有关联，与CheckObject也没有关联。\n\n### 4.new操作符，能将方法中this指向新的实例(构造函数模式)\n```javascript\nvar CheckObject = function() {\n\tthis.checkName = function() {\n\n\t};\n\tthis.checkEmail = function() {\n\n\t};\n\tthis.checkPassword = function() {\n\n\t};\n};\n```\n调用方式\n```javascript\nvar a = new CheckObject();\na.checkName();\n```\n所有通过new生成的实例对象，都包含constructor属性，这个属性都会指向CheckObject。`a.constructor == CHeckObject`每个新生成的实例中都会包含checkName、checkEmail、checkPassword方法，这些方法都是相同的，可以通过原型链保存在prototype属性中，这样这些方法就只会存储一遍。\n\tps: new首先会创建一个空的对象。然后将新对象的_proto_指向调用函数的prototype属性。 最后将调用函数中的所有this指向新对象。\n\n### 5.利用prototype节省内存(prototype模式)\n```javascript\nvar CheckObject = function() {\n\t\n};\nCheckObject.prototype = {\n\tcheckName: function() {\n\n\t\treturn this;  //链式使用\n\t},\n\tcheckEmail: function() {\n\n\t\treturn this; //链式使用\n\t}，\n\tcheckPassword: function() {\n\n\t\treturn this; //链式使用\n\t}\n};\n```\n调用方法与4.相同。\n\n### 6.更像一个类\n```javascript\nvar Book = function(id, name, price) {\n\t// 私有属性  (外界不能直接访问、调用)\n\tvar num = 0;\n\t// 私有方法\n\tfunction checkId() {}\n\t// 对象公有属性  (对象可以访问、调用)\n\tthis.id = id;\n\t// 特权方法  (对象可以访问、调用，并且操作私有属性、方法)\n\tthis.getName = function() {};\n\tthis.setName = function() {};\n\tthis.getPrice = function() {};\n\tthis.setPrice = function() {};\n};\n// 类静态公有属性  (类可以访问、调用)\nBook.isChinese = true;\n// 类静态公有方法\nBook.resetTime = function() {};\nBook.prototype = {\n\t// 静态公有属性  (对象可以访问、调用，并且只保存一份)\n\tisJSBook: false,\n\t// 静态公有方法\n\tdisplay: function() {}\n};\n```\n\n### 7.利用闭包来实现\n```javascript\nvar Book = (function() {\n\t// 静态私有\n\tvar bookNum = 0;\n\tfunction checkBook() {};\n\t// 创建类\n\tfunction _book(id, name, price) {\n\t\t// 私有\n\t\tvar name,price;\n\t\tfunction checkID(){}\n\t\tthis.sayNum = function() {\n\t\t\tconsole.log(bookNum);\n\t\t};\n\t\tthis.setNum = function(number) {\n\t\t\tbookNum = number;\n\t\t};\n\t\t// 公有\n\t\tthis.id = id;\n\t\t// 特权方法\n\t\tthis.getName = function(){};\n\t\tthis.setName = function(){};\n\t\tthis.getPrice = function(){};\n\t\tthis.setPrice = function(){};\n\t}\n\t_book.prototype = {\n\t\t// 静态公有\n\t\tisJSBook: true,\n\t\tdisplay: function(){}\n\t};\n\treturn _book;\n})();\n```\n\tps: 静态私有变量只存在一份，如果通过创建类中的特权方法修改静态私有变量，所有对象实例中的此静态私有变量都会改变。(闭包)\n\t在6.中通过特权方法修改私有变量，其他对象中的私有变量，不会改变。\n\t这个，怎么理解呢？回头还需要研究下。\n\n### 8.创建对象的安全模式\n在创建实例对象的时候，如果没有使用new操作符，会造成this指向的是全局环境，在浏览器中也就是window对象。为了避免这种情况，可以使用instanceof来检测。\n```javascript\nvar Book = function(id, name, price) {\n\tif(this instanceof Book) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.price = price;\n\t} else  {\n\t\treturn new Book(id, name, price);\n\t}\n}\n```\n----------------\n　　　　-------来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢","slug":"面向对象的javascript","published":1,"updated":"2017-03-22T01:26:01.000Z","layout":"post","photos":[],"link":"","_id":"cj1eq8kir002fohfk9tqki5b4","content":"<p>　　面向对象的基本特征：封装、继承、多态。<br>　　封装就是把对象的属性和方法结合成在一些，也可以隐藏对象的属性和实现细节，所以封装后的对象一般有私有属性、私有方法、公有属性、公有方法等。</p>\n<hr>\n<h3 id=\"1-最初的javascript代码是这样的\"><a href=\"#1-最初的javascript代码是这样的\" class=\"headerlink\" title=\"1.最初的javascript代码是这样的\"></a>1.最初的javascript代码是这样的</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkName</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkEmail</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkPassword</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用时候，直接使用函数名checkName()。这样编写相当于创建多个全局变量：checkName、checkEmail、checkPassword。</p>\n<h3 id=\"2-使用对象封装-原始模式\"><a href=\"#2-使用对象封装-原始模式\" class=\"headerlink\" title=\"2.使用对象封装(原始模式)\"></a>2.使用对象封装(原始模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = &#123;</div><div class=\"line\">\t<span class=\"attr\">checkName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">checkEmail</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">checkPassword</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>调用时，通过对象名调用，CheckObject.checkName()。缺点是只能够通过CheckObject使用，不能生成新的实例。</p>\n<h3 id=\"3-返回新的对象-原始模式改进\"><a href=\"#3-返回新的对象-原始模式改进\" class=\"headerlink\" title=\"3.返回新的对象(原始模式改进)\"></a>3.返回新的对象(原始模式改进)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t<span class=\"attr\">checkName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">checkEmail</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">checkPassword</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>调用方式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = CheckObject();</div><div class=\"line\">a.checkName();</div></pre></td></tr></table></figure></p>\n<p>每次调用CHeckObject都会产生新的对象，这样每个人在使用的时候互相之间不会影响，但是新生成的实例与实例之间没有关联，与CheckObject也没有关联。</p>\n<h3 id=\"4-new操作符，能将方法中this指向新的实例-构造函数模式\"><a href=\"#4-new操作符，能将方法中this指向新的实例-构造函数模式\" class=\"headerlink\" title=\"4.new操作符，能将方法中this指向新的实例(构造函数模式)\"></a>4.new操作符，能将方法中this指向新的实例(构造函数模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.checkName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.checkEmail = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.checkPassword = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>调用方式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> CheckObject();</div><div class=\"line\">a.checkName();</div></pre></td></tr></table></figure></p>\n<p>所有通过new生成的实例对象，都包含constructor属性，这个属性都会指向CheckObject。<code>a.constructor == CHeckObject</code>每个新生成的实例中都会包含checkName、checkEmail、checkPassword方法，这些方法都是相同的，可以通过原型链保存在prototype属性中，这样这些方法就只会存储一遍。<br>    ps: new首先会创建一个空的对象。然后将新对象的<em>proto</em>指向调用函数的prototype属性。 最后将调用函数中的所有this指向新对象。</p>\n<h3 id=\"5-利用prototype节省内存-prototype模式\"><a href=\"#5-利用prototype节省内存-prototype模式\" class=\"headerlink\" title=\"5.利用prototype节省内存(prototype模式)\"></a>5.利用prototype节省内存(prototype模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;;</div><div class=\"line\">CheckObject.prototype = &#123;</div><div class=\"line\">\t<span class=\"attr\">checkName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  <span class=\"comment\">//链式使用</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">checkEmail</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; <span class=\"comment\">//链式使用</span></div><div class=\"line\">\t&#125;，</div><div class=\"line\">\tcheckPassword: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; <span class=\"comment\">//链式使用</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>调用方法与4.相同。</p>\n<h3 id=\"6-更像一个类\"><a href=\"#6-更像一个类\" class=\"headerlink\" title=\"6.更像一个类\"></a>6.更像一个类</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Book = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, name, price</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 私有属性  (外界不能直接访问、调用)</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> num = <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"comment\">// 私有方法</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkId</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">\t<span class=\"comment\">// 对象公有属性  (对象可以访问、调用)</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">\t<span class=\"comment\">// 特权方法  (对象可以访问、调用，并且操作私有属性、方法)</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.getPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.setPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 类静态公有属性  (类可以访问、调用)</span></div><div class=\"line\">Book.isChinese = <span class=\"literal\">true</span>;</div><div class=\"line\"><span class=\"comment\">// 类静态公有方法</span></div><div class=\"line\">Book.resetTime = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">Book.prototype = &#123;</div><div class=\"line\">\t<span class=\"comment\">// 静态公有属性  (对象可以访问、调用，并且只保存一份)</span></div><div class=\"line\">\tisJSBook: <span class=\"literal\">false</span>,</div><div class=\"line\">\t<span class=\"comment\">// 静态公有方法</span></div><div class=\"line\">\tdisplay: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"7-利用闭包来实现\"><a href=\"#7-利用闭包来实现\" class=\"headerlink\" title=\"7.利用闭包来实现\"></a>7.利用闭包来实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Book = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 静态私有</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> bookNum = <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkBook</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">\t<span class=\"comment\">// 创建类</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_book</span>(<span class=\"params\">id, name, price</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 私有</span></div><div class=\"line\">\t\t<span class=\"keyword\">var</span> name,price;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkID</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.sayNum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(bookNum);</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.setNum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">number</span>) </span>&#123;</div><div class=\"line\">\t\t\tbookNum = number;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\t<span class=\"comment\">// 公有</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">\t\t<span class=\"comment\">// 特权方法</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.getPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.setPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t_book.prototype = &#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 静态公有</span></div><div class=\"line\">\t\tisJSBook: <span class=\"literal\">true</span>,</div><div class=\"line\">\t\t<span class=\"attr\">display</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">return</span> _book;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<pre><code>ps: 静态私有变量只存在一份，如果通过创建类中的特权方法修改静态私有变量，所有对象实例中的此静态私有变量都会改变。(闭包)\n在6.中通过特权方法修改私有变量，其他对象中的私有变量，不会改变。\n这个，怎么理解呢？回头还需要研究下。\n</code></pre><h3 id=\"8-创建对象的安全模式\"><a href=\"#8-创建对象的安全模式\" class=\"headerlink\" title=\"8.创建对象的安全模式\"></a>8.创建对象的安全模式</h3><p>在创建实例对象的时候，如果没有使用new操作符，会造成this指向的是全局环境，在浏览器中也就是window对象。为了避免这种情况，可以使用instanceof来检测。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Book = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, name, price</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> Book) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.price = price;</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span>  &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Book(id, name, price);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<p>　　　　——-来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢</p>\n","excerpt":"","more":"<p>　　面向对象的基本特征：封装、继承、多态。<br>　　封装就是把对象的属性和方法结合成在一些，也可以隐藏对象的属性和实现细节，所以封装后的对象一般有私有属性、私有方法、公有属性、公有方法等。</p>\n<hr>\n<h3 id=\"1-最初的javascript代码是这样的\"><a href=\"#1-最初的javascript代码是这样的\" class=\"headerlink\" title=\"1.最初的javascript代码是这样的\"></a>1.最初的javascript代码是这样的</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkName</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkEmail</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkPassword</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用时候，直接使用函数名checkName()。这样编写相当于创建多个全局变量：checkName、checkEmail、checkPassword。</p>\n<h3 id=\"2-使用对象封装-原始模式\"><a href=\"#2-使用对象封装-原始模式\" class=\"headerlink\" title=\"2.使用对象封装(原始模式)\"></a>2.使用对象封装(原始模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = &#123;</div><div class=\"line\">\t<span class=\"attr\">checkName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">checkEmail</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">checkPassword</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>调用时，通过对象名调用，CheckObject.checkName()。缺点是只能够通过CheckObject使用，不能生成新的实例。</p>\n<h3 id=\"3-返回新的对象-原始模式改进\"><a href=\"#3-返回新的对象-原始模式改进\" class=\"headerlink\" title=\"3.返回新的对象(原始模式改进)\"></a>3.返回新的对象(原始模式改进)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t<span class=\"attr\">checkName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">checkEmail</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">checkPassword</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>调用方式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = CheckObject();</div><div class=\"line\">a.checkName();</div></pre></td></tr></table></figure></p>\n<p>每次调用CHeckObject都会产生新的对象，这样每个人在使用的时候互相之间不会影响，但是新生成的实例与实例之间没有关联，与CheckObject也没有关联。</p>\n<h3 id=\"4-new操作符，能将方法中this指向新的实例-构造函数模式\"><a href=\"#4-new操作符，能将方法中this指向新的实例-构造函数模式\" class=\"headerlink\" title=\"4.new操作符，能将方法中this指向新的实例(构造函数模式)\"></a>4.new操作符，能将方法中this指向新的实例(构造函数模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.checkName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.checkEmail = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.checkPassword = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>调用方式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> CheckObject();</div><div class=\"line\">a.checkName();</div></pre></td></tr></table></figure></p>\n<p>所有通过new生成的实例对象，都包含constructor属性，这个属性都会指向CheckObject。<code>a.constructor == CHeckObject</code>每个新生成的实例中都会包含checkName、checkEmail、checkPassword方法，这些方法都是相同的，可以通过原型链保存在prototype属性中，这样这些方法就只会存储一遍。<br>    ps: new首先会创建一个空的对象。然后将新对象的<em>proto</em>指向调用函数的prototype属性。 最后将调用函数中的所有this指向新对象。</p>\n<h3 id=\"5-利用prototype节省内存-prototype模式\"><a href=\"#5-利用prototype节省内存-prototype模式\" class=\"headerlink\" title=\"5.利用prototype节省内存(prototype模式)\"></a>5.利用prototype节省内存(prototype模式)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;;</div><div class=\"line\">CheckObject.prototype = &#123;</div><div class=\"line\">\t<span class=\"attr\">checkName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  <span class=\"comment\">//链式使用</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"attr\">checkEmail</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; <span class=\"comment\">//链式使用</span></div><div class=\"line\">\t&#125;，</div><div class=\"line\">\tcheckPassword: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; <span class=\"comment\">//链式使用</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>调用方法与4.相同。</p>\n<h3 id=\"6-更像一个类\"><a href=\"#6-更像一个类\" class=\"headerlink\" title=\"6.更像一个类\"></a>6.更像一个类</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Book = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, name, price</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 私有属性  (外界不能直接访问、调用)</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> num = <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"comment\">// 私有方法</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkId</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">\t<span class=\"comment\">// 对象公有属性  (对象可以访问、调用)</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">\t<span class=\"comment\">// 特权方法  (对象可以访问、调用，并且操作私有属性、方法)</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.getPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.setPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 类静态公有属性  (类可以访问、调用)</span></div><div class=\"line\">Book.isChinese = <span class=\"literal\">true</span>;</div><div class=\"line\"><span class=\"comment\">// 类静态公有方法</span></div><div class=\"line\">Book.resetTime = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">Book.prototype = &#123;</div><div class=\"line\">\t<span class=\"comment\">// 静态公有属性  (对象可以访问、调用，并且只保存一份)</span></div><div class=\"line\">\tisJSBook: <span class=\"literal\">false</span>,</div><div class=\"line\">\t<span class=\"comment\">// 静态公有方法</span></div><div class=\"line\">\tdisplay: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"7-利用闭包来实现\"><a href=\"#7-利用闭包来实现\" class=\"headerlink\" title=\"7.利用闭包来实现\"></a>7.利用闭包来实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Book = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 静态私有</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> bookNum = <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkBook</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">\t<span class=\"comment\">// 创建类</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_book</span>(<span class=\"params\">id, name, price</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 私有</span></div><div class=\"line\">\t\t<span class=\"keyword\">var</span> name,price;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkID</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.sayNum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(bookNum);</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.setNum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">number</span>) </span>&#123;</div><div class=\"line\">\t\t\tbookNum = number;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\t<span class=\"comment\">// 公有</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">\t\t<span class=\"comment\">// 特权方法</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.getPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.setPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t_book.prototype = &#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 静态公有</span></div><div class=\"line\">\t\tisJSBook: <span class=\"literal\">true</span>,</div><div class=\"line\">\t\t<span class=\"attr\">display</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">return</span> _book;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<pre><code>ps: 静态私有变量只存在一份，如果通过创建类中的特权方法修改静态私有变量，所有对象实例中的此静态私有变量都会改变。(闭包)\n在6.中通过特权方法修改私有变量，其他对象中的私有变量，不会改变。\n这个，怎么理解呢？回头还需要研究下。\n</code></pre><h3 id=\"8-创建对象的安全模式\"><a href=\"#8-创建对象的安全模式\" class=\"headerlink\" title=\"8.创建对象的安全模式\"></a>8.创建对象的安全模式</h3><p>在创建实例对象的时候，如果没有使用new操作符，会造成this指向的是全局环境，在浏览器中也就是window对象。为了避免这种情况，可以使用instanceof来检测。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Book = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, name, price</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> Book) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.price = price;</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span>  &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Book(id, name, price);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<p>　　　　——-来自 张容铭《Javascript设计模式》 和 阮一峰 《Javascript面向对象编程》感谢</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj1eq8kgn0000ohfks93i2k4r","category_id":"cj1eq8kgv0002ohfksluzhyfo","_id":"cj1eq8kh9000bohfkhncryl8t"},{"post_id":"cj1eq8kgs0001ohfk6r4xqlm9","category_id":"cj1eq8kh50007ohfk36rm3x3w","_id":"cj1eq8khf000hohfk1rotg8tq"},{"post_id":"cj1eq8khc000eohfki4ss30r3","category_id":"cj1eq8kh50007ohfk36rm3x3w","_id":"cj1eq8khj000lohfkncc9ug73"},{"post_id":"cj1eq8kgz0003ohfkwlaug7pa","category_id":"cj1eq8khb000dohfkjvp9un7y","_id":"cj1eq8khl000pohfk6i1ra13f"},{"post_id":"cj1eq8khh000johfkjmrb7r96","category_id":"cj1eq8kh50007ohfk36rm3x3w","_id":"cj1eq8khn000tohfkpltwsd7l"},{"post_id":"cj1eq8kh20005ohfkrmgw7sy4","category_id":"cj1eq8kh50007ohfk36rm3x3w","_id":"cj1eq8khq000wohfk7mse7whd"},{"post_id":"cj1eq8khj000mohfkmzcpx4pa","category_id":"cj1eq8kh50007ohfk36rm3x3w","_id":"cj1eq8khu0010ohfkkr91eygp"},{"post_id":"cj1eq8khl000qohfko1nutmpv","category_id":"cj1eq8khk000oohfkqg70u7t1","_id":"cj1eq8khw0013ohfkt0wabe49"},{"post_id":"cj1eq8kh40006ohfks9j0ns1x","category_id":"cj1eq8khk000oohfkqg70u7t1","_id":"cj1eq8ki10018ohfk4lh6izfi"},{"post_id":"cj1eq8khn000uohfkac3u6asj","category_id":"cj1eq8khk000oohfkqg70u7t1","_id":"cj1eq8ki3001bohfkva2evf9i"},{"post_id":"cj1eq8khr000yohfksud2c94r","category_id":"cj1eq8khb000dohfkjvp9un7y","_id":"cj1eq8ki6001gohfkc5q10c2r"},{"post_id":"cj1eq8kh50008ohfkkprrbvwj","category_id":"cj1eq8khk000oohfkqg70u7t1","_id":"cj1eq8ki8001johfkx5zslnvq"},{"post_id":"cj1eq8khu0011ohfkakfwmjug","category_id":"cj1eq8kh50007ohfk36rm3x3w","_id":"cj1eq8ki9001nohfk7mpuh227"},{"post_id":"cj1eq8khy0015ohfknp5mivwm","category_id":"cj1eq8kh50007ohfk36rm3x3w","_id":"cj1eq8kid001qohfkgfk73cak"},{"post_id":"cj1eq8kh9000cohfkvbc6vciq","category_id":"cj1eq8khk000oohfkqg70u7t1","_id":"cj1eq8kif001uohfkldl8ssv7"},{"post_id":"cj1eq8ki10019ohfk1fphozmq","category_id":"cj1eq8kgv0002ohfksluzhyfo","_id":"cj1eq8kih001xohfkclbt3q79"},{"post_id":"cj1eq8ki4001dohfkmntmv314","category_id":"cj1eq8khk000oohfkqg70u7t1","_id":"cj1eq8kij0020ohfk1se8y9q2"},{"post_id":"cj1eq8khe000gohfkuk2kdkyp","category_id":"cj1eq8khk000oohfkqg70u7t1","_id":"cj1eq8kil0024ohfk2syzt3sk"},{"post_id":"cj1eq8ki7001hohfknrtv1oia","category_id":"cj1eq8khk000oohfkqg70u7t1","_id":"cj1eq8kin0027ohfkjawpa6xl"},{"post_id":"cj1eq8ki8001kohfkbr8qr3rt","category_id":"cj1eq8khk000oohfkqg70u7t1","_id":"cj1eq8kip002bohfkzr38un89"},{"post_id":"cj1eq8kia001oohfkwu8m9mwt","category_id":"cj1eq8kh50007ohfk36rm3x3w","_id":"cj1eq8kir002eohfksuqbgzmx"},{"post_id":"cj1eq8kid001rohfkdch4cmzv","category_id":"cj1eq8kgv0002ohfksluzhyfo","_id":"cj1eq8kit002iohfk6eu1ed1y"},{"post_id":"cj1eq8kig001vohfklocaaje1","category_id":"cj1eq8kgv0002ohfksluzhyfo","_id":"cj1eq8kit002kohfkce8ap549"},{"post_id":"cj1eq8kih001yohfkmvk7gu1l","category_id":"cj1eq8khb000dohfkjvp9un7y","_id":"cj1eq8kiu002nohfkdcwiz2h9"},{"post_id":"cj1eq8kik0022ohfkk52ersum","category_id":"cj1eq8kgv0002ohfksluzhyfo","_id":"cj1eq8kiu002pohfkngn7ss0y"},{"post_id":"cj1eq8kil0025ohfkv5zcza5j","category_id":"cj1eq8kh50007ohfk36rm3x3w","_id":"cj1eq8kiu002sohfkx8enf0ps"},{"post_id":"cj1eq8kin0028ohfkbtrb122i","category_id":"cj1eq8khb000dohfkjvp9un7y","_id":"cj1eq8kiv002uohfkcffvtq1k"},{"post_id":"cj1eq8kip002cohfk4ckumupy","category_id":"cj1eq8kh50007ohfk36rm3x3w","_id":"cj1eq8kiv002wohfkszp7gve8"},{"post_id":"cj1eq8kir002fohfk9tqki5b4","category_id":"cj1eq8kh50007ohfk36rm3x3w","_id":"cj1eq8kiv002zohfkyu87ovag"}],"PostTag":[{"post_id":"cj1eq8kgs0001ohfk6r4xqlm9","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kh8000aohfkgewh5kt2"},{"post_id":"cj1eq8kgz0003ohfkwlaug7pa","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8khk000nohfkzmbs40bk"},{"post_id":"cj1eq8kgz0003ohfkwlaug7pa","tag_id":"cj1eq8khd000fohfk8e68uldo","_id":"cj1eq8khm000rohfkq0md81eb"},{"post_id":"cj1eq8kh20005ohfkrmgw7sy4","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kho000vohfkn2u10l0r"},{"post_id":"cj1eq8kh40006ohfks9j0ns1x","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8khw0012ohfkai5o4fln"},{"post_id":"cj1eq8kh40006ohfks9j0ns1x","tag_id":"cj1eq8khn000sohfk7perrukx","_id":"cj1eq8khz0016ohfk978aox3k"},{"post_id":"cj1eq8khr000yohfksud2c94r","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8ki2001aohfkb6ugp50n"},{"post_id":"cj1eq8khr000yohfksud2c94r","tag_id":"cj1eq8khd000fohfk8e68uldo","_id":"cj1eq8ki6001eohfkopwcgzak"},{"post_id":"cj1eq8kh50008ohfkkprrbvwj","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8ki8001iohfkaa692t01"},{"post_id":"cj1eq8kh50008ohfkkprrbvwj","tag_id":"cj1eq8khn000sohfk7perrukx","_id":"cj1eq8ki9001lohfkb9ega6o9"},{"post_id":"cj1eq8kh9000cohfkvbc6vciq","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kid001pohfka5srh9u8"},{"post_id":"cj1eq8kh9000cohfkvbc6vciq","tag_id":"cj1eq8khn000sohfk7perrukx","_id":"cj1eq8kie001sohfkk2ubjnzi"},{"post_id":"cj1eq8khc000eohfki4ss30r3","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kih001wohfkw8b0g41m"},{"post_id":"cj1eq8khc000eohfki4ss30r3","tag_id":"cj1eq8khn000sohfk7perrukx","_id":"cj1eq8kij001zohfkh1yoezze"},{"post_id":"cj1eq8kia001oohfkwu8m9mwt","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kil0023ohfkdc7j034b"},{"post_id":"cj1eq8khe000gohfkuk2kdkyp","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kim0026ohfkzi07tkzs"},{"post_id":"cj1eq8khe000gohfkuk2kdkyp","tag_id":"cj1eq8khn000sohfk7perrukx","_id":"cj1eq8kip002aohfkosj8nwgn"},{"post_id":"cj1eq8khh000johfkjmrb7r96","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kir002dohfkqhk6jfsi"},{"post_id":"cj1eq8khh000johfkjmrb7r96","tag_id":"cj1eq8kie001tohfkempiovpg","_id":"cj1eq8kis002hohfkqu5o6x1q"},{"post_id":"cj1eq8kil0025ohfkv5zcza5j","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kit002johfk8kbyn7n8"},{"post_id":"cj1eq8kin0028ohfkbtrb122i","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kiu002mohfkuclbm9z1"},{"post_id":"cj1eq8kin0028ohfkbtrb122i","tag_id":"cj1eq8khd000fohfk8e68uldo","_id":"cj1eq8kiu002oohfk9n7ofgtc"},{"post_id":"cj1eq8khj000mohfkmzcpx4pa","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kiu002qohfkiz2vxbx3"},{"post_id":"cj1eq8khj000mohfkmzcpx4pa","tag_id":"cj1eq8kij0021ohfk99z8r1jy","_id":"cj1eq8kiv002tohfkbxyshoeb"},{"post_id":"cj1eq8khj000mohfkmzcpx4pa","tag_id":"cj1eq8kip0029ohfkesupgzi9","_id":"cj1eq8kiv002vohfkso9w624t"},{"post_id":"cj1eq8khl000qohfko1nutmpv","tag_id":"cj1eq8khn000sohfk7perrukx","_id":"cj1eq8kiv002yohfk00t2h6ww"},{"post_id":"cj1eq8khl000qohfko1nutmpv","tag_id":"cj1eq8kiu002lohfkvvmcqnfg","_id":"cj1eq8kiv0030ohfkrvicqjum"},{"post_id":"cj1eq8khn000uohfkac3u6asj","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kiw0032ohfku7hb10i6"},{"post_id":"cj1eq8khn000uohfkac3u6asj","tag_id":"cj1eq8khn000sohfk7perrukx","_id":"cj1eq8kiw0033ohfk5uhh1o52"},{"post_id":"cj1eq8khn000uohfkac3u6asj","tag_id":"cj1eq8kiu002rohfkklvamfiy","_id":"cj1eq8kix0035ohfk9n8zfvun"},{"post_id":"cj1eq8khu0011ohfkakfwmjug","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kix0036ohfkvp549jd1"},{"post_id":"cj1eq8khu0011ohfkakfwmjug","tag_id":"cj1eq8kiv002xohfkb25irmhg","_id":"cj1eq8kix0038ohfkifg46ij1"},{"post_id":"cj1eq8khy0015ohfknp5mivwm","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kix0039ohfkjss01whs"},{"post_id":"cj1eq8khy0015ohfknp5mivwm","tag_id":"cj1eq8kip0029ohfkesupgzi9","_id":"cj1eq8kiy003bohfkv75g1r65"},{"post_id":"cj1eq8khy0015ohfknp5mivwm","tag_id":"cj1eq8kij0021ohfk99z8r1jy","_id":"cj1eq8kiy003cohfkxt900tpw"},{"post_id":"cj1eq8ki10019ohfk1fphozmq","tag_id":"cj1eq8kix0037ohfkt17vfx8g","_id":"cj1eq8kiy003dohfkrvc9oga2"},{"post_id":"cj1eq8ki10019ohfk1fphozmq","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kiz003fohfkzo4ck1b4"},{"post_id":"cj1eq8ki4001dohfkmntmv314","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kiz003gohfku1gakuyu"},{"post_id":"cj1eq8ki4001dohfkmntmv314","tag_id":"cj1eq8khn000sohfk7perrukx","_id":"cj1eq8kj0003iohfk3jm062ke"},{"post_id":"cj1eq8ki4001dohfkmntmv314","tag_id":"cj1eq8kix003aohfk44mkli1z","_id":"cj1eq8kj0003johfki7jmd5sj"},{"post_id":"cj1eq8ki7001hohfknrtv1oia","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kj0003lohfkbr2i1p19"},{"post_id":"cj1eq8ki7001hohfknrtv1oia","tag_id":"cj1eq8khn000sohfk7perrukx","_id":"cj1eq8kj0003mohfkujubgbtt"},{"post_id":"cj1eq8ki7001hohfknrtv1oia","tag_id":"cj1eq8kix003aohfk44mkli1z","_id":"cj1eq8kj2003oohfkx4o0zi96"},{"post_id":"cj1eq8ki8001kohfkbr8qr3rt","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kj2003pohfkb66qur53"},{"post_id":"cj1eq8ki8001kohfkbr8qr3rt","tag_id":"cj1eq8khn000sohfk7perrukx","_id":"cj1eq8kj4003rohfkpugmkhnk"},{"post_id":"cj1eq8ki8001kohfkbr8qr3rt","tag_id":"cj1eq8kix003aohfk44mkli1z","_id":"cj1eq8kj4003sohfkoxfg6zwr"},{"post_id":"cj1eq8kid001rohfkdch4cmzv","tag_id":"cj1eq8kj0003kohfkxxgn27w7","_id":"cj1eq8kj4003uohfkw8ne7vve"},{"post_id":"cj1eq8kid001rohfkdch4cmzv","tag_id":"cj1eq8kj1003nohfknyzp5st9","_id":"cj1eq8kj5003vohfkcftaoiuk"},{"post_id":"cj1eq8kig001vohfklocaaje1","tag_id":"cj1eq8kj2003qohfkk5x3nmzd","_id":"cj1eq8kj5003xohfkubpnp3uy"},{"post_id":"cj1eq8kig001vohfklocaaje1","tag_id":"cj1eq8kj4003tohfk9221kdxr","_id":"cj1eq8kj6003yohfkdeewbkcs"},{"post_id":"cj1eq8kih001yohfkmvk7gu1l","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kj60040ohfkg526ty30"},{"post_id":"cj1eq8kih001yohfkmvk7gu1l","tag_id":"cj1eq8khd000fohfk8e68uldo","_id":"cj1eq8kj60041ohfkiubuuf8s"},{"post_id":"cj1eq8kih001yohfkmvk7gu1l","tag_id":"cj1eq8kj5003wohfkx4v07xmk","_id":"cj1eq8kj70043ohfkc5g2bvds"},{"post_id":"cj1eq8kip002cohfk4ckumupy","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kj70044ohfkpnt51p7a"},{"post_id":"cj1eq8kip002cohfk4ckumupy","tag_id":"cj1eq8kj6003zohfkcnaxljxk","_id":"cj1eq8kj70045ohfkdl0jl3tz"},{"post_id":"cj1eq8kir002fohfk9tqki5b4","tag_id":"cj1eq8kh10004ohfk8djd3vk7","_id":"cj1eq8kj70046ohfkaa6g5arb"},{"post_id":"cj1eq8kir002fohfk9tqki5b4","tag_id":"cj1eq8kj6003zohfkcnaxljxk","_id":"cj1eq8kj70047ohfk5vbmdzzi"}],"Tag":[{"name":"JavaScript","_id":"cj1eq8kh10004ohfk8djd3vk7"},{"name":"H5","_id":"cj1eq8khd000fohfk8e68uldo"},{"name":"React","_id":"cj1eq8khn000sohfk7perrukx"},{"name":"移动Web","_id":"cj1eq8kie001tohfkempiovpg"},{"name":"gulp","_id":"cj1eq8kij0021ohfk99z8r1jy"},{"name":"构建工具","_id":"cj1eq8kip0029ohfkesupgzi9"},{"name":"Redux","_id":"cj1eq8kiu002lohfkvvmcqnfg"},{"name":"redux","_id":"cj1eq8kiu002rohfkklvamfiy"},{"name":"项目经验","_id":"cj1eq8kiv002xohfkb25irmhg"},{"name":"面试","_id":"cj1eq8kix0037ohfkt17vfx8g"},{"name":"Webpack","_id":"cj1eq8kix003aohfk44mkli1z"},{"name":"Hexo","_id":"cj1eq8kj0003kohfkxxgn27w7"},{"name":"搭建博客","_id":"cj1eq8kj1003nohfknyzp5st9"},{"name":"前端","_id":"cj1eq8kj2003qohfkk5x3nmzd"},{"name":"汇总","_id":"cj1eq8kj4003tohfk9221kdxr"},{"name":"微信分享","_id":"cj1eq8kj5003wohfkx4v07xmk"},{"name":"面向对象","_id":"cj1eq8kj6003zohfkcnaxljxk"}]}}